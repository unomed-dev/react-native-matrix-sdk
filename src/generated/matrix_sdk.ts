// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './matrix_sdk-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterBool,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * A set of common power levels required for various operations within a room,
 * that can be applied as a single operation. When updating these
 * settings, any levels that are `None` will remain unchanged.
 */
export type RoomPowerLevelChanges = {
  /**
   * The level required to ban a user.
   */
  ban: /*i64*/ bigint | undefined;
  /**
   * The level required to invite a user.
   */
  invite: /*i64*/ bigint | undefined;
  /**
   * The level required to kick a user.
   */
  kick: /*i64*/ bigint | undefined;
  /**
   * The level required to redact an event.
   */
  redact: /*i64*/ bigint | undefined;
  /**
   * The default level required to send message events.
   */
  eventsDefault: /*i64*/ bigint | undefined;
  /**
   * The default level required to send state events.
   */
  stateDefault: /*i64*/ bigint | undefined;
  /**
   * The default power level for every user in the room.
   */
  usersDefault: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's name.
   */
  roomName: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's avatar.
   */
  roomAvatar: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's topic.
   */
  roomTopic: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link RoomPowerLevelChanges} record objects.
 */
export const RoomPowerLevelChanges = (() => {
  const defaults = () => ({
    ban: undefined,
    invite: undefined,
    kick: undefined,
    redact: undefined,
    eventsDefault: undefined,
    stateDefault: undefined,
    usersDefault: undefined,
    roomName: undefined,
    roomAvatar: undefined,
    roomTopic: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      RoomPowerLevelChanges,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPowerLevelChanges}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomPowerLevelChanges}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPowerLevelChanges>,
  });
})();

const FfiConverterTypeRoomPowerLevelChanges = (() => {
  type TypeName = RoomPowerLevelChanges;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ban: FfiConverterOptionalInt64.read(from),
        invite: FfiConverterOptionalInt64.read(from),
        kick: FfiConverterOptionalInt64.read(from),
        redact: FfiConverterOptionalInt64.read(from),
        eventsDefault: FfiConverterOptionalInt64.read(from),
        stateDefault: FfiConverterOptionalInt64.read(from),
        usersDefault: FfiConverterOptionalInt64.read(from),
        roomName: FfiConverterOptionalInt64.read(from),
        roomAvatar: FfiConverterOptionalInt64.read(from),
        roomTopic: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt64.write(value.ban, into);
      FfiConverterOptionalInt64.write(value.invite, into);
      FfiConverterOptionalInt64.write(value.kick, into);
      FfiConverterOptionalInt64.write(value.redact, into);
      FfiConverterOptionalInt64.write(value.eventsDefault, into);
      FfiConverterOptionalInt64.write(value.stateDefault, into);
      FfiConverterOptionalInt64.write(value.usersDefault, into);
      FfiConverterOptionalInt64.write(value.roomName, into);
      FfiConverterOptionalInt64.write(value.roomAvatar, into);
      FfiConverterOptionalInt64.write(value.roomTopic, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt64.allocationSize(value.ban) +
        FfiConverterOptionalInt64.allocationSize(value.invite) +
        FfiConverterOptionalInt64.allocationSize(value.kick) +
        FfiConverterOptionalInt64.allocationSize(value.redact) +
        FfiConverterOptionalInt64.allocationSize(value.eventsDefault) +
        FfiConverterOptionalInt64.allocationSize(value.stateDefault) +
        FfiConverterOptionalInt64.allocationSize(value.usersDefault) +
        FfiConverterOptionalInt64.allocationSize(value.roomName) +
        FfiConverterOptionalInt64.allocationSize(value.roomAvatar) +
        FfiConverterOptionalInt64.allocationSize(value.roomTopic)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Information about the server vendor obtained from the federation API.
 */
export type ServerVendorInfo = {
  /**
   * The server name.
   */
  serverName: string;
  /**
   * The server version.
   */
  version: string;
};

/**
 * Generated factory for {@link ServerVendorInfo} record objects.
 */
export const ServerVendorInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ServerVendorInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ServerVendorInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ServerVendorInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ServerVendorInfo>,
  });
})();

const FfiConverterTypeServerVendorInfo = (() => {
  type TypeName = ServerVendorInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        serverName: FfiConverterString.read(from),
        version: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.serverName, into);
      FfiConverterString.write(value.version, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.serverName) +
        FfiConverterString.allocationSize(value.version)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Properties to create a new virtual Element Call widget.
 */
export type VirtualElementCallWidgetOptions = {
  /**
   * The url to the app.
   *
   * E.g. <https://call.element.io>, <https://call.element.dev>, <https://call.element.dev/room>
   */
  elementCallUrl: string;
  /**
   * The widget id.
   */
  widgetId: string;
  /**
   * The url that is used as the target for the PostMessages sent
   * by the widget (to the client).
   *
   * For a web app client this is the client url. In case of using other
   * platforms the client most likely is setup up to listen to
   * postmessages in the same webview the widget is hosted. In this case
   * the `parent_url` is set to the url of the webview with the widget. Be
   * aware that this means that the widget will receive its own postmessage
   * messages. The `matrix-widget-api` (js) ignores those so this works but
   * it might break custom implementations.
   *
   * Defaults to `element_call_url` for the non-iframe (dedicated webview)
   * usecase.
   */
  parentUrl: string | undefined;
  /**
   * Whether the branding header of Element call should be shown or if a
   * mobile header navbar should be render.
   *
   * Default: [`HeaderStyle::Standard`]
   */
  header: HeaderStyle | undefined;
  /**
   * Whether the branding header of Element call should be hidden.
   *
   * Default: `true`
   */
  hideHeader: boolean | undefined;
  /**
   * If set, the lobby will be skipped and the widget will join the
   * call on the `io.element.join` action.
   *
   * Default: `false`
   */
  preload: boolean | undefined;
  /**
   * The font scale which will be used inside element call.
   *
   * Default: `1`
   */
  fontScale: /*f64*/ number | undefined;
  /**
   * Whether element call should prompt the user to open in the browser or
   * the app.
   *
   * Default: `false`
   */
  appPrompt: boolean | undefined;
  /**
   * Make it not possible to get to the calls list in the webview.
   *
   * Default: `true`
   */
  confineToRoom: boolean | undefined;
  /**
   * The font to use, to adapt to the system font.
   */
  font: string | undefined;
  /**
   * The encryption system to use.
   *
   * Use `EncryptionSystem::Unencrypted` to disable encryption.
   */
  encryption: EncryptionSystem;
  /**
   * The intent of showing the call.
   * If the user wants to start a call or join an existing one.
   * Controls if the lobby is skipped or not.
   */
  intent: Intent | undefined;
  /**
   * Do not show the screenshare button.
   */
  hideScreensharing: boolean;
  /**
   * Can be used to pass a PostHog id to element call.
   */
  posthogUserId: string | undefined;
  /**
   * The host of the posthog api.
   * This is only used by the embedded package of Element Call.
   */
  posthogApiHost: string | undefined;
  /**
   * The key for the posthog api.
   * This is only used by the embedded package of Element Call.
   */
  posthogApiKey: string | undefined;
  /**
   * The url to use for submitting rageshakes.
   * This is only used by the embedded package of Element Call.
   */
  rageshakeSubmitUrl: string | undefined;
  /**
   * Sentry [DSN](https://docs.sentry.io/concepts/key-terms/dsn-explainer/)
   * This is only used by the embedded package of Element Call.
   */
  sentryDsn: string | undefined;
  /**
   * Sentry [environment](https://docs.sentry.io/concepts/key-terms/key-terms/)
   * This is only used by the embedded package of Element Call.
   */
  sentryEnvironment: string | undefined;
  /**
   * - `false`: the webview shows a a list of devices injected by the
   * client. (used on ios & android)
   */
  controlledMediaDevices: boolean;
  /**
   * Whether and what type of notification Element Call should send, when
   * starting a call.
   */
  sendNotificationType: NotificationType | undefined;
};

/**
 * Generated factory for {@link VirtualElementCallWidgetOptions} record objects.
 */
export const VirtualElementCallWidgetOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      VirtualElementCallWidgetOptions,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VirtualElementCallWidgetOptions}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VirtualElementCallWidgetOptions}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<VirtualElementCallWidgetOptions>,
  });
})();

const FfiConverterTypeVirtualElementCallWidgetOptions = (() => {
  type TypeName = VirtualElementCallWidgetOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        elementCallUrl: FfiConverterString.read(from),
        widgetId: FfiConverterString.read(from),
        parentUrl: FfiConverterOptionalString.read(from),
        header: FfiConverterOptionalTypeHeaderStyle.read(from),
        hideHeader: FfiConverterOptionalBool.read(from),
        preload: FfiConverterOptionalBool.read(from),
        fontScale: FfiConverterOptionalFloat64.read(from),
        appPrompt: FfiConverterOptionalBool.read(from),
        confineToRoom: FfiConverterOptionalBool.read(from),
        font: FfiConverterOptionalString.read(from),
        encryption: FfiConverterTypeEncryptionSystem.read(from),
        intent: FfiConverterOptionalTypeIntent.read(from),
        hideScreensharing: FfiConverterBool.read(from),
        posthogUserId: FfiConverterOptionalString.read(from),
        posthogApiHost: FfiConverterOptionalString.read(from),
        posthogApiKey: FfiConverterOptionalString.read(from),
        rageshakeSubmitUrl: FfiConverterOptionalString.read(from),
        sentryDsn: FfiConverterOptionalString.read(from),
        sentryEnvironment: FfiConverterOptionalString.read(from),
        controlledMediaDevices: FfiConverterBool.read(from),
        sendNotificationType:
          FfiConverterOptionalTypeNotificationType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.elementCallUrl, into);
      FfiConverterString.write(value.widgetId, into);
      FfiConverterOptionalString.write(value.parentUrl, into);
      FfiConverterOptionalTypeHeaderStyle.write(value.header, into);
      FfiConverterOptionalBool.write(value.hideHeader, into);
      FfiConverterOptionalBool.write(value.preload, into);
      FfiConverterOptionalFloat64.write(value.fontScale, into);
      FfiConverterOptionalBool.write(value.appPrompt, into);
      FfiConverterOptionalBool.write(value.confineToRoom, into);
      FfiConverterOptionalString.write(value.font, into);
      FfiConverterTypeEncryptionSystem.write(value.encryption, into);
      FfiConverterOptionalTypeIntent.write(value.intent, into);
      FfiConverterBool.write(value.hideScreensharing, into);
      FfiConverterOptionalString.write(value.posthogUserId, into);
      FfiConverterOptionalString.write(value.posthogApiHost, into);
      FfiConverterOptionalString.write(value.posthogApiKey, into);
      FfiConverterOptionalString.write(value.rageshakeSubmitUrl, into);
      FfiConverterOptionalString.write(value.sentryDsn, into);
      FfiConverterOptionalString.write(value.sentryEnvironment, into);
      FfiConverterBool.write(value.controlledMediaDevices, into);
      FfiConverterOptionalTypeNotificationType.write(
        value.sendNotificationType,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.elementCallUrl) +
        FfiConverterString.allocationSize(value.widgetId) +
        FfiConverterOptionalString.allocationSize(value.parentUrl) +
        FfiConverterOptionalTypeHeaderStyle.allocationSize(value.header) +
        FfiConverterOptionalBool.allocationSize(value.hideHeader) +
        FfiConverterOptionalBool.allocationSize(value.preload) +
        FfiConverterOptionalFloat64.allocationSize(value.fontScale) +
        FfiConverterOptionalBool.allocationSize(value.appPrompt) +
        FfiConverterOptionalBool.allocationSize(value.confineToRoom) +
        FfiConverterOptionalString.allocationSize(value.font) +
        FfiConverterTypeEncryptionSystem.allocationSize(value.encryption) +
        FfiConverterOptionalTypeIntent.allocationSize(value.intent) +
        FfiConverterBool.allocationSize(value.hideScreensharing) +
        FfiConverterOptionalString.allocationSize(value.posthogUserId) +
        FfiConverterOptionalString.allocationSize(value.posthogApiHost) +
        FfiConverterOptionalString.allocationSize(value.posthogApiKey) +
        FfiConverterOptionalString.allocationSize(value.rageshakeSubmitUrl) +
        FfiConverterOptionalString.allocationSize(value.sentryDsn) +
        FfiConverterOptionalString.allocationSize(value.sentryEnvironment) +
        FfiConverterBool.allocationSize(value.controlledMediaDevices) +
        FfiConverterOptionalTypeNotificationType.allocationSize(
          value.sendNotificationType
        )
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

/**
 * Settings for end-to-end encryption features.
 */
export enum BackupDownloadStrategy {
  /**
   * Automatically download all room keys from the backup when the backup
   * recovery key has been received. The backup recovery key can be received
   * in two ways:
   *
   * 1. Received as a `m.secret.send` to-device event, after a successful
   * interactive verification.
   * 2. Imported from secret storage (4S) using the
   * [`SecretStore::import_secrets()`] method.
   *
   * [`SecretStore::import_secrets()`]: crate::encryption::secret_storage::SecretStore::import_secrets
   */
  OneShot,
  /**
   * Attempt to download a single room key if an event fails to be decrypted.
   */
  AfterDecryptionFailure,
  /**
   * Don't download any room keys automatically. The user can manually
   * download room keys using the [`Backups::download_room_key()`] methods.
   *
   * This is the default option.
   */
  Manual,
}

const FfiConverterTypeBackupDownloadStrategy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupDownloadStrategy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BackupDownloadStrategy.OneShot;
        case 2:
          return BackupDownloadStrategy.AfterDecryptionFailure;
        case 3:
          return BackupDownloadStrategy.Manual;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BackupDownloadStrategy.OneShot:
          return ordinalConverter.write(1, into);
        case BackupDownloadStrategy.AfterDecryptionFailure:
          return ordinalConverter.write(2, into);
        case BackupDownloadStrategy.Manual:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: EncryptionSystem
export enum EncryptionSystem_Tags {
  Unencrypted = 'Unencrypted',
  PerParticipantKeys = 'PerParticipantKeys',
  SharedSecret = 'SharedSecret',
}
/**
 * Defines if a call is encrypted and which encryption system should be used.
 *
 * This controls the url parameters: `perParticipantE2EE`, `password`.
 */
export const EncryptionSystem = (() => {
  type Unencrypted__interface = {
    tag: EncryptionSystem_Tags.Unencrypted;
  };

  /**
   * Equivalent to the element call url parameter: `perParticipantE2EE=false`
   * and no password.
   */
  class Unencrypted_ extends UniffiEnum implements Unencrypted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptionSystem';
    readonly tag = EncryptionSystem_Tags.Unencrypted;
    constructor() {
      super('EncryptionSystem', 'Unencrypted');
    }

    static new(): Unencrypted_ {
      return new Unencrypted_();
    }

    static instanceOf(obj: any): obj is Unencrypted_ {
      return obj.tag === EncryptionSystem_Tags.Unencrypted;
    }
  }

  type PerParticipantKeys__interface = {
    tag: EncryptionSystem_Tags.PerParticipantKeys;
  };

  /**
   * Equivalent to the element call url parameters:
   * `perParticipantE2EE=true`
   */
  class PerParticipantKeys_
    extends UniffiEnum
    implements PerParticipantKeys__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptionSystem';
    readonly tag = EncryptionSystem_Tags.PerParticipantKeys;
    constructor() {
      super('EncryptionSystem', 'PerParticipantKeys');
    }

    static new(): PerParticipantKeys_ {
      return new PerParticipantKeys_();
    }

    static instanceOf(obj: any): obj is PerParticipantKeys_ {
      return obj.tag === EncryptionSystem_Tags.PerParticipantKeys;
    }
  }

  type SharedSecret__interface = {
    tag: EncryptionSystem_Tags.SharedSecret;
    inner: Readonly<{ secret: string }>;
  };

  /**
   * Equivalent to the element call url parameters:
   * `password={secret}`
   */
  class SharedSecret_ extends UniffiEnum implements SharedSecret__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptionSystem';
    readonly tag = EncryptionSystem_Tags.SharedSecret;
    readonly inner: Readonly<{ secret: string }>;
    constructor(inner: {
      /**
       * The secret/password which is used in the url.
       */ secret: string;
    }) {
      super('EncryptionSystem', 'SharedSecret');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The secret/password which is used in the url.
       */ secret: string;
    }): SharedSecret_ {
      return new SharedSecret_(inner);
    }

    static instanceOf(obj: any): obj is SharedSecret_ {
      return obj.tag === EncryptionSystem_Tags.SharedSecret;
    }
  }

  function instanceOf(obj: any): obj is EncryptionSystem {
    return obj[uniffiTypeNameSymbol] === 'EncryptionSystem';
  }

  return Object.freeze({
    instanceOf,
    Unencrypted: Unencrypted_,
    PerParticipantKeys: PerParticipantKeys_,
    SharedSecret: SharedSecret_,
  });
})();

/**
 * Defines if a call is encrypted and which encryption system should be used.
 *
 * This controls the url parameters: `perParticipantE2EE`, `password`.
 */

export type EncryptionSystem = InstanceType<
  (typeof EncryptionSystem)[keyof Omit<typeof EncryptionSystem, 'instanceOf'>]
>;

// FfiConverter for enum EncryptionSystem
const FfiConverterTypeEncryptionSystem = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EncryptionSystem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EncryptionSystem.Unencrypted();
        case 2:
          return new EncryptionSystem.PerParticipantKeys();
        case 3:
          return new EncryptionSystem.SharedSecret({
            secret: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EncryptionSystem_Tags.Unencrypted: {
          ordinalConverter.write(1, into);
          return;
        }
        case EncryptionSystem_Tags.PerParticipantKeys: {
          ordinalConverter.write(2, into);
          return;
        }
        case EncryptionSystem_Tags.SharedSecret: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.secret, into);
          return;
        }
        default:
          // Throwing from here means that EncryptionSystem_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EncryptionSystem_Tags.Unencrypted: {
          return ordinalConverter.allocationSize(1);
        }
        case EncryptionSystem_Tags.PerParticipantKeys: {
          return ordinalConverter.allocationSize(2);
        }
        case EncryptionSystem_Tags.SharedSecret: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.secret);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Defines how (if) element-call renders a header.
 */
export enum HeaderStyle {
  /**
   * The normal header with branding.
   */
  Standard,
  /**
   * Render a header with a back button (useful on mobile platforms).
   */
  AppBar,
  /**
   * No Header (useful for webapps).
   */
  None,
}

const FfiConverterTypeHeaderStyle = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = HeaderStyle;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return HeaderStyle.Standard;
        case 2:
          return HeaderStyle.AppBar;
        case 3:
          return HeaderStyle.None;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case HeaderStyle.Standard:
          return ordinalConverter.write(1, into);
        case HeaderStyle.AppBar:
          return ordinalConverter.write(2, into);
        case HeaderStyle.None:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Defines the intent of showing the call.
 *
 * This controls whether to show or skip the lobby.
 */
export enum Intent {
  /**
   * The user wants to start a call.
   */
  StartCall,
  /**
   * The user wants to join an existing call.
   */
  JoinExisting,
}

const FfiConverterTypeIntent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Intent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Intent.StartCall;
        case 2:
          return Intent.JoinExisting;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Intent.StartCall:
          return ordinalConverter.write(1, into);
        case Intent.JoinExisting:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Types of call notifications.
 */
export enum NotificationType {
  /**
   * The receiving client should display a visual notification.
   */
  Notification,
  /**
   * The receiving client should ring with an audible sound.
   */
  Ring,
}

const FfiConverterTypeNotificationType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotificationType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return NotificationType.Notification;
        case 2:
          return NotificationType.Ring;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case NotificationType.Notification:
          return ordinalConverter.write(1, into);
        case NotificationType.Ring:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Current state of a [`Paginator`].
 */
export enum PaginatorState {
  /**
   * The initial state of the paginator.
   */
  Initial,
  /**
   * The paginator is fetching the target initial event.
   */
  FetchingTargetEvent,
  /**
   * The target initial event could be found, zero or more paginations have
   * happened since then, and the paginator is at rest now.
   */
  Idle,
  /**
   * The paginator is… paginating one direction or another.
   */
  Paginating,
}

const FfiConverterTypePaginatorState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaginatorState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaginatorState.Initial;
        case 2:
          return PaginatorState.FetchingTargetEvent;
        case 3:
          return PaginatorState.Idle;
        case 4:
          return PaginatorState.Paginating;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaginatorState.Initial:
          return ordinalConverter.write(1, into);
        case PaginatorState.FetchingTargetEvent:
          return ordinalConverter.write(2, into);
        case PaginatorState.Idle:
          return ordinalConverter.write(3, into);
        case PaginatorState.Paginating:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: QrCodeLoginError
export enum QrCodeLoginError_Tags {
  OAuth = 'OAuth',
  LoginFailure = 'LoginFailure',
  UnexpectedMessage = 'UnexpectedMessage',
  SecureChannel = 'SecureChannel',
  CrossProcessRefreshLock = 'CrossProcessRefreshLock',
  UserIdDiscovery = 'UserIdDiscovery',
  SessionTokens = 'SessionTokens',
  DeviceKeyUpload = 'DeviceKeyUpload',
  SecretImport = 'SecretImport',
}
/**
 * The error type for failures while trying to log in a new device using a QR
 * code.
 */
export const QrCodeLoginError = (() => {
  /**
   * An error happened while we were communicating with the OAuth 2.0
   * authorization server.
   */
  class OAuth extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = QrCodeLoginError_Tags.OAuth;

    constructor(message: string) {
      super('QrCodeLoginError', 'OAuth', message);
    }

    static instanceOf(e: any): e is OAuth {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  /**
   * The other device has signaled to us that the login has failed.
   */
  class LoginFailure extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = QrCodeLoginError_Tags.LoginFailure;

    constructor(message: string) {
      super('QrCodeLoginError', 'LoginFailure', message);
    }

    static instanceOf(e: any): e is LoginFailure {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  /**
   * An unexpected message was received from the other device.
   */
  class UnexpectedMessage extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = QrCodeLoginError_Tags.UnexpectedMessage;

    constructor(message: string) {
      super('QrCodeLoginError', 'UnexpectedMessage', message);
    }

    static instanceOf(e: any): e is UnexpectedMessage {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  /**
   * An error happened while exchanging messages with the other device.
   */
  class SecureChannel extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = QrCodeLoginError_Tags.SecureChannel;

    constructor(message: string) {
      super('QrCodeLoginError', 'SecureChannel', message);
    }

    static instanceOf(e: any): e is SecureChannel {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  /**
   * The cross-process refresh lock failed to be initialized.
   */
  class CrossProcessRefreshLock extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = QrCodeLoginError_Tags.CrossProcessRefreshLock;

    constructor(message: string) {
      super('QrCodeLoginError', 'CrossProcessRefreshLock', message);
    }

    static instanceOf(e: any): e is CrossProcessRefreshLock {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  /**
   * An error happened while we were trying to discover our user and device
   * ID, after we have acquired an access token from the OAuth 2.0
   * authorization server.
   */
  class UserIdDiscovery extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = QrCodeLoginError_Tags.UserIdDiscovery;

    constructor(message: string) {
      super('QrCodeLoginError', 'UserIdDiscovery', message);
    }

    static instanceOf(e: any): e is UserIdDiscovery {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  /**
   * We failed to set the session tokens after we figured out our device and
   * user IDs.
   */
  class SessionTokens extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = QrCodeLoginError_Tags.SessionTokens;

    constructor(message: string) {
      super('QrCodeLoginError', 'SessionTokens', message);
    }

    static instanceOf(e: any): e is SessionTokens {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  /**
   * The device keys failed to be uploaded after we successfully logged in.
   */
  class DeviceKeyUpload extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = QrCodeLoginError_Tags.DeviceKeyUpload;

    constructor(message: string) {
      super('QrCodeLoginError', 'DeviceKeyUpload', message);
    }

    static instanceOf(e: any): e is DeviceKeyUpload {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  /**
   * The secrets bundle we received from the existing device failed to be
   * imported.
   */
  class SecretImport extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = QrCodeLoginError_Tags.SecretImport;

    constructor(message: string) {
      super('QrCodeLoginError', 'SecretImport', message);
    }

    static instanceOf(e: any): e is SecretImport {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is QrCodeLoginError {
    return (e as any)[uniffiTypeNameSymbol] === 'QrCodeLoginError';
  }
  return {
    OAuth,
    LoginFailure,
    UnexpectedMessage,
    SecureChannel,
    CrossProcessRefreshLock,
    UserIdDiscovery,
    SessionTokens,
    DeviceKeyUpload,
    SecretImport,
    instanceOf,
  };
})();

// Union type for QrCodeLoginError error type.

/**
 * The error type for failures while trying to log in a new device using a QR
 * code.
 */

export type QrCodeLoginError = InstanceType<
  (typeof QrCodeLoginError)[keyof Omit<typeof QrCodeLoginError, 'instanceOf'>]
>;

const FfiConverterTypeQRCodeLoginError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = QrCodeLoginError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new QrCodeLoginError.OAuth(FfiConverterString.read(from));

        case 2:
          return new QrCodeLoginError.LoginFailure(
            FfiConverterString.read(from)
          );

        case 3:
          return new QrCodeLoginError.UnexpectedMessage(
            FfiConverterString.read(from)
          );

        case 4:
          return new QrCodeLoginError.SecureChannel(
            FfiConverterString.read(from)
          );

        case 5:
          return new QrCodeLoginError.CrossProcessRefreshLock(
            FfiConverterString.read(from)
          );

        case 6:
          return new QrCodeLoginError.UserIdDiscovery(
            FfiConverterString.read(from)
          );

        case 7:
          return new QrCodeLoginError.SessionTokens(
            FfiConverterString.read(from)
          );

        case 8:
          return new QrCodeLoginError.DeviceKeyUpload(
            FfiConverterString.read(from)
          );

        case 9:
          return new QrCodeLoginError.SecretImport(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

/**
 * The role of a member in a room.
 */
export enum RoomMemberRole {
  /**
   * The member is a creator.
   *
   * A creator has an infinite power level and cannot be demoted, so this
   * role is immutable. A room can have several creators.
   *
   * It is available in room versions where
   * `explicitly_privilege_room_creators` in [`AuthorizationRules`] is set to
   * `true`.
   *
   * [`AuthorizationRules`]: ruma::room_version_rules::AuthorizationRules
   */
  Creator,
  /**
   * The member is an administrator.
   */
  Administrator,
  /**
   * The member is a moderator.
   */
  Moderator,
  /**
   * The member is a regular user.
   */
  User,
}

const FfiConverterTypeRoomMemberRole = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomMemberRole;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomMemberRole.Creator;
        case 2:
          return RoomMemberRole.Administrator;
        case 3:
          return RoomMemberRole.Moderator;
        case 4:
          return RoomMemberRole.User;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomMemberRole.Creator:
          return ordinalConverter.write(1, into);
        case RoomMemberRole.Administrator:
          return ordinalConverter.write(2, into);
        case RoomMemberRole.Moderator:
          return ordinalConverter.write(3, into);
        case RoomMemberRole.User:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomPaginationStatus
export enum RoomPaginationStatus_Tags {
  Idle = 'Idle',
  Paginating = 'Paginating',
}
/**
 * Status for the back-pagination on a room event cache.
 */
export const RoomPaginationStatus = (() => {
  type Idle__interface = {
    tag: RoomPaginationStatus_Tags.Idle;
    inner: Readonly<{ hitTimelineStart: boolean }>;
  };

  /**
   * No back-pagination is happening right now.
   */
  class Idle_ extends UniffiEnum implements Idle__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomPaginationStatus';
    readonly tag = RoomPaginationStatus_Tags.Idle;
    readonly inner: Readonly<{ hitTimelineStart: boolean }>;
    constructor(inner: {
      /**
       * Have we hit the start of the timeline, i.e. back-paginating wouldn't
       * have any effect?
       */ hitTimelineStart: boolean;
    }) {
      super('RoomPaginationStatus', 'Idle');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Have we hit the start of the timeline, i.e. back-paginating wouldn't
       * have any effect?
       */ hitTimelineStart: boolean;
    }): Idle_ {
      return new Idle_(inner);
    }

    static instanceOf(obj: any): obj is Idle_ {
      return obj.tag === RoomPaginationStatus_Tags.Idle;
    }
  }

  type Paginating__interface = {
    tag: RoomPaginationStatus_Tags.Paginating;
  };

  /**
   * Back-pagination is already running in the background.
   */
  class Paginating_ extends UniffiEnum implements Paginating__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomPaginationStatus';
    readonly tag = RoomPaginationStatus_Tags.Paginating;
    constructor() {
      super('RoomPaginationStatus', 'Paginating');
    }

    static new(): Paginating_ {
      return new Paginating_();
    }

    static instanceOf(obj: any): obj is Paginating_ {
      return obj.tag === RoomPaginationStatus_Tags.Paginating;
    }
  }

  function instanceOf(obj: any): obj is RoomPaginationStatus {
    return obj[uniffiTypeNameSymbol] === 'RoomPaginationStatus';
  }

  return Object.freeze({
    instanceOf,
    Idle: Idle_,
    Paginating: Paginating_,
  });
})();

/**
 * Status for the back-pagination on a room event cache.
 */

export type RoomPaginationStatus = InstanceType<
  (typeof RoomPaginationStatus)[keyof Omit<
    typeof RoomPaginationStatus,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomPaginationStatus
const FfiConverterTypeRoomPaginationStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomPaginationStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomPaginationStatus.Idle({
            hitTimelineStart: FfiConverterBool.read(from),
          });
        case 2:
          return new RoomPaginationStatus.Paginating();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomPaginationStatus_Tags.Idle: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.hitTimelineStart, into);
          return;
        }
        case RoomPaginationStatus_Tags.Paginating: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that RoomPaginationStatus_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomPaginationStatus_Tags.Idle: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterBool.allocationSize(inner.hitTimelineStart);
          return size;
        }
        case RoomPaginationStatus_Tags.Paginating: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * The data needed to perform authorization using OAuth 2.0.
 */
export interface OAuthAuthorizationDataInterface {
  /**
   * The login URL to use for authorization.
   */
  loginUrl(): string;
}

/**
 * The data needed to perform authorization using OAuth 2.0.
 */
export class OAuthAuthorizationData
  extends UniffiAbstractObject
  implements OAuthAuthorizationDataInterface
{
  readonly [uniffiTypeNameSymbol] = 'OAuthAuthorizationData';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeOAuthAuthorizationDataObjectFactory.bless(pointer);
  }

  /**
   * The login URL to use for authorization.
   */
  public loginUrl(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_fn_method_oauthauthorizationdata_login_url(
            uniffiTypeOAuthAuthorizationDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeOAuthAuthorizationDataObjectFactory.pointer(this);
      uniffiTypeOAuthAuthorizationDataObjectFactory.freePointer(pointer);
      uniffiTypeOAuthAuthorizationDataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is OAuthAuthorizationData {
    return uniffiTypeOAuthAuthorizationDataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeOAuthAuthorizationDataObjectFactory: UniffiObjectFactory<OAuthAuthorizationDataInterface> =
  (() => {
    return {
      create(
        pointer: UnsafeMutableRawPointer
      ): OAuthAuthorizationDataInterface {
        const instance = Object.create(OAuthAuthorizationData.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'OAuthAuthorizationData';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_oauthauthorizationdata_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: OAuthAuthorizationDataInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(
        obj: OAuthAuthorizationDataInterface
      ): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_matrix_sdk_fn_clone_oauthauthorizationdata(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_matrix_sdk_fn_free_oauthauthorizationdata(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is OAuthAuthorizationDataInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'OAuthAuthorizationData'
        );
      },
    };
  })();
// FfiConverter for OAuthAuthorizationDataInterface
const FfiConverterTypeOAuthAuthorizationData = new FfiConverterObject(
  uniffiTypeOAuthAuthorizationDataObjectFactory
);

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(
  FfiConverterFloat64
);

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for HeaderStyle | undefined
const FfiConverterOptionalTypeHeaderStyle = new FfiConverterOptional(
  FfiConverterTypeHeaderStyle
);

// FfiConverter for Intent | undefined
const FfiConverterOptionalTypeIntent = new FfiConverterOptional(
  FfiConverterTypeIntent
);

// FfiConverter for NotificationType | undefined
const FfiConverterOptionalTypeNotificationType = new FfiConverterOptional(
  FfiConverterTypeNotificationType
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_matrix_sdk_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_checksum_method_oauthauthorizationdata_login_url() !==
    25566
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_checksum_method_oauthauthorizationdata_login_url'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBackupDownloadStrategy,
    FfiConverterTypeEncryptionSystem,
    FfiConverterTypeHeaderStyle,
    FfiConverterTypeIntent,
    FfiConverterTypeNotificationType,
    FfiConverterTypeOAuthAuthorizationData,
    FfiConverterTypePaginatorState,
    FfiConverterTypeQRCodeLoginError,
    FfiConverterTypeRoomMemberRole,
    FfiConverterTypeRoomPaginationStatus,
    FfiConverterTypeRoomPowerLevelChanges,
    FfiConverterTypeServerVendorInfo,
    FfiConverterTypeVirtualElementCallWidgetOptions,
  },
});
