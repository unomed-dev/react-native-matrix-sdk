// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFutureFree,
  type UniffiCallbackInterfaceFree,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './matrix_sdk-ffi';
import {
  type FfiConverter,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiError,
  UniffiInternalError,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  rustCall,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.

const uniffiIsDebug = process.env.uniffiIsDebug !== 'production' || false;
// Public interface members begin here.

/**
 * A set of common power levels required for various operations within a room,
 * that can be applied as a single operation. When updating these
 * settings, any levels that are `None` will remain unchanged.
 */
export type RoomPowerLevelChanges = {
  /**
   * The level required to ban a user.
   */
  ban: /*i64*/ bigint | undefined;
  /**
   * The level required to invite a user.
   */
  invite: /*i64*/ bigint | undefined;
  /**
   * The level required to kick a user.
   */
  kick: /*i64*/ bigint | undefined;
  /**
   * The level required to redact an event.
   */
  redact: /*i64*/ bigint | undefined;
  /**
   * The default level required to send message events.
   */
  eventsDefault: /*i64*/ bigint | undefined;
  /**
   * The default level required to send state events.
   */
  stateDefault: /*i64*/ bigint | undefined;
  /**
   * The default power level for every user in the room.
   */
  usersDefault: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's name.
   */
  roomName: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's avatar.
   */
  roomAvatar: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's topic.
   */
  roomTopic: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link RoomPowerLevelChanges} record objects.
 */
export const RoomPowerLevelChanges = (() => {
  const defaults = () => ({
    ban: undefined,
    invite: undefined,
    kick: undefined,
    redact: undefined,
    eventsDefault: undefined,
    stateDefault: undefined,
    usersDefault: undefined,
    roomName: undefined,
    roomAvatar: undefined,
    roomTopic: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      RoomPowerLevelChanges,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPowerLevelChanges}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomPowerLevelChanges}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPowerLevelChanges>,
  });
})();

const FfiConverterTypeRoomPowerLevelChanges = (() => {
  type TypeName = RoomPowerLevelChanges;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ban: FfiConverterOptionalInt64.read(from),
        invite: FfiConverterOptionalInt64.read(from),
        kick: FfiConverterOptionalInt64.read(from),
        redact: FfiConverterOptionalInt64.read(from),
        eventsDefault: FfiConverterOptionalInt64.read(from),
        stateDefault: FfiConverterOptionalInt64.read(from),
        usersDefault: FfiConverterOptionalInt64.read(from),
        roomName: FfiConverterOptionalInt64.read(from),
        roomAvatar: FfiConverterOptionalInt64.read(from),
        roomTopic: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt64.write(value.ban, into);
      FfiConverterOptionalInt64.write(value.invite, into);
      FfiConverterOptionalInt64.write(value.kick, into);
      FfiConverterOptionalInt64.write(value.redact, into);
      FfiConverterOptionalInt64.write(value.eventsDefault, into);
      FfiConverterOptionalInt64.write(value.stateDefault, into);
      FfiConverterOptionalInt64.write(value.usersDefault, into);
      FfiConverterOptionalInt64.write(value.roomName, into);
      FfiConverterOptionalInt64.write(value.roomAvatar, into);
      FfiConverterOptionalInt64.write(value.roomTopic, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt64.allocationSize(value.ban) +
        FfiConverterOptionalInt64.allocationSize(value.invite) +
        FfiConverterOptionalInt64.allocationSize(value.kick) +
        FfiConverterOptionalInt64.allocationSize(value.redact) +
        FfiConverterOptionalInt64.allocationSize(value.eventsDefault) +
        FfiConverterOptionalInt64.allocationSize(value.stateDefault) +
        FfiConverterOptionalInt64.allocationSize(value.usersDefault) +
        FfiConverterOptionalInt64.allocationSize(value.roomName) +
        FfiConverterOptionalInt64.allocationSize(value.roomAvatar) +
        FfiConverterOptionalInt64.allocationSize(value.roomTopic)
      );
    }
  }
  return new FFIConverter();
})();

const stringToArrayBuffer = (s: string): ArrayBuffer =>
  rustCall((status) =>
    nativeModule().uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)
  );

const arrayBufferToString = (ab: ArrayBuffer): string =>
  rustCall((status) =>
    nativeModule().uniffi_internal_fn_func_ffi__arraybuffer_to_string(
      ab,
      status
    )
  );

const stringByteLength = (s: string): number =>
  rustCall((status) =>
    nativeModule().uniffi_internal_fn_func_ffi__string_to_byte_length(s, status)
  );

const FfiConverterString = (() => {
  const lengthConverter = FfiConverterInt32;
  type TypeName = string;
  class FFIConverter implements FfiConverter<ArrayBuffer, TypeName> {
    lift(value: ArrayBuffer): TypeName {
      return arrayBufferToString(value);
    }
    lower(value: TypeName): ArrayBuffer {
      return stringToArrayBuffer(value);
    }
    read(from: RustBuffer): TypeName {
      const length = lengthConverter.read(from);
      const bytes = from.readBytes(length);
      return arrayBufferToString(bytes);
    }
    write(value: TypeName, into: RustBuffer): void {
      const buffer = stringToArrayBuffer(value);
      const numBytes = buffer.byteLength;
      lengthConverter.write(numBytes, into);
      into.writeBytes(buffer);
    }
    allocationSize(value: TypeName): number {
      return lengthConverter.allocationSize(0) + stringByteLength(value);
    }
  }

  return new FFIConverter();
})();

/**
 * Settings for end-to-end encryption features.
 */
export enum BackupDownloadStrategy {
  /**
   * Automatically download all room keys from the backup when the backup
   * recovery key has been received. The backup recovery key can be received
   * in two ways:
   *
   * 1. Received as a `m.secret.send` to-device event, after a successful
   * interactive verification.
   * 2. Imported from secret storage (4S) using the
   * [`SecretStore::import_secrets()`] method.
   *
   * [`SecretStore::import_secrets()`]: crate::encryption::secret_storage::SecretStore::import_secrets
   */
  OneShot,
  /**
   * Attempt to download a single room key if an event fails to be decrypted.
   */
  AfterDecryptionFailure,
  /**
   * Don't download any room keys automatically. The user can manually
   * download room keys using the [`Backups::download_room_key()`] methods.
   *
   * This is the default option.
   */
  Manual,
}

const FfiConverterTypeBackupDownloadStrategy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupDownloadStrategy;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BackupDownloadStrategy.OneShot;
        case 2:
          return BackupDownloadStrategy.AfterDecryptionFailure;
        case 3:
          return BackupDownloadStrategy.Manual;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BackupDownloadStrategy.OneShot:
          return ordinalConverter.write(1, into);
        case BackupDownloadStrategy.AfterDecryptionFailure:
          return ordinalConverter.write(2, into);
        case BackupDownloadStrategy.Manual:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Current state of a [`Paginator`].
 */
export enum PaginatorState {
  /**
   * The initial state of the paginator.
   */
  Initial,
  /**
   * The paginator is fetching the target initial event.
   */
  FetchingTargetEvent,
  /**
   * The target initial event could be found, zero or more paginations have
   * happened since then, and the paginator is at rest now.
   */
  Idle,
  /**
   * The paginator isâ€¦ paginating one direction or another.
   */
  Paginating,
}

const FfiConverterTypePaginatorState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaginatorState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaginatorState.Initial;
        case 2:
          return PaginatorState.FetchingTargetEvent;
        case 3:
          return PaginatorState.Idle;
        case 4:
          return PaginatorState.Paginating;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaginatorState.Initial:
          return ordinalConverter.write(1, into);
        case PaginatorState.FetchingTargetEvent:
          return ordinalConverter.write(2, into);
        case PaginatorState.Idle:
          return ordinalConverter.write(3, into);
        case PaginatorState.Paginating:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: QrCodeLoginError
export enum QrCodeLoginError_Tags {
  Oidc = 'Oidc',
  LoginFailure = 'LoginFailure',
  UnexpectedMessage = 'UnexpectedMessage',
  SecureChannel = 'SecureChannel',
  CrossProcessRefreshLock = 'CrossProcessRefreshLock',
  UserIdDiscovery = 'UserIdDiscovery',
  SessionTokens = 'SessionTokens',
  DeviceKeyUpload = 'DeviceKeyUpload',
  SecretImport = 'SecretImport',
}
/**
 * The error type for failures while trying to log in a new device using a QR
 * code.
 */
export const QrCodeLoginError = (() => {
  /**
   * An error happened while we were communicating with the OIDC provider.
   */
  class Oidc extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = QrCodeLoginError_Tags.Oidc;

    constructor(message: string) {
      super('QrCodeLoginError', 'Oidc', message);
    }

    static instanceOf(e: any): e is Oidc {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  /**
   * The other device has signaled to us that the login has failed.
   */
  class LoginFailure extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = QrCodeLoginError_Tags.LoginFailure;

    constructor(message: string) {
      super('QrCodeLoginError', 'LoginFailure', message);
    }

    static instanceOf(e: any): e is LoginFailure {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  /**
   * An unexpected message was received from the other device.
   */
  class UnexpectedMessage extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = QrCodeLoginError_Tags.UnexpectedMessage;

    constructor(message: string) {
      super('QrCodeLoginError', 'UnexpectedMessage', message);
    }

    static instanceOf(e: any): e is UnexpectedMessage {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  /**
   * An error happened while exchanging messages with the other device.
   */
  class SecureChannel extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = QrCodeLoginError_Tags.SecureChannel;

    constructor(message: string) {
      super('QrCodeLoginError', 'SecureChannel', message);
    }

    static instanceOf(e: any): e is SecureChannel {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  /**
   * The cross-process refresh lock failed to be initialized.
   */
  class CrossProcessRefreshLock extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = QrCodeLoginError_Tags.CrossProcessRefreshLock;

    constructor(message: string) {
      super('QrCodeLoginError', 'CrossProcessRefreshLock', message);
    }

    static instanceOf(e: any): e is CrossProcessRefreshLock {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  /**
   * An error happened while we were trying to discover our user and device
   * ID, after we have acquired an access token from the OIDC provider.
   */
  class UserIdDiscovery extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = QrCodeLoginError_Tags.UserIdDiscovery;

    constructor(message: string) {
      super('QrCodeLoginError', 'UserIdDiscovery', message);
    }

    static instanceOf(e: any): e is UserIdDiscovery {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  /**
   * We failed to set the session tokens after we figured out our device and
   * user IDs.
   */
  class SessionTokens extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = QrCodeLoginError_Tags.SessionTokens;

    constructor(message: string) {
      super('QrCodeLoginError', 'SessionTokens', message);
    }

    static instanceOf(e: any): e is SessionTokens {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  /**
   * The device keys failed to be uploaded after we successfully logged in.
   */
  class DeviceKeyUpload extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = QrCodeLoginError_Tags.DeviceKeyUpload;

    constructor(message: string) {
      super('QrCodeLoginError', 'DeviceKeyUpload', message);
    }

    static instanceOf(e: any): e is DeviceKeyUpload {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  /**
   * The secrets bundle we received from the existing device failed to be
   * imported.
   */
  class SecretImport extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = QrCodeLoginError_Tags.SecretImport;

    constructor(message: string) {
      super('QrCodeLoginError', 'SecretImport', message);
    }

    static instanceOf(e: any): e is SecretImport {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is QrCodeLoginError {
    return (e as any)[uniffiTypeNameSymbol] === 'QrCodeLoginError';
  }
  return {
    Oidc,
    LoginFailure,
    UnexpectedMessage,
    SecureChannel,
    CrossProcessRefreshLock,
    UserIdDiscovery,
    SessionTokens,
    DeviceKeyUpload,
    SecretImport,
    instanceOf,
  };
})();

// Union type for QrCodeLoginError error type.

/**
 * The error type for failures while trying to log in a new device using a QR
 * code.
 */

export type QrCodeLoginError = InstanceType<
  (typeof QrCodeLoginError)[keyof Omit<typeof QrCodeLoginError, 'instanceOf'>]
>;

const FfiConverterTypeQRCodeLoginError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = QrCodeLoginError;
  class FfiConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new QrCodeLoginError.Oidc(FfiConverterString.read(from));

        case 2:
          return new QrCodeLoginError.LoginFailure(
            FfiConverterString.read(from)
          );

        case 3:
          return new QrCodeLoginError.UnexpectedMessage(
            FfiConverterString.read(from)
          );

        case 4:
          return new QrCodeLoginError.SecureChannel(
            FfiConverterString.read(from)
          );

        case 5:
          return new QrCodeLoginError.CrossProcessRefreshLock(
            FfiConverterString.read(from)
          );

        case 6:
          return new QrCodeLoginError.UserIdDiscovery(
            FfiConverterString.read(from)
          );

        case 7:
          return new QrCodeLoginError.SessionTokens(
            FfiConverterString.read(from)
          );

        case 8:
          return new QrCodeLoginError.DeviceKeyUpload(
            FfiConverterString.read(from)
          );

        case 9:
          return new QrCodeLoginError.SecretImport(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

/**
 * The role of a member in a room.
 */
export enum RoomMemberRole {
  /**
   * The member is an administrator.
   */
  Administrator,
  /**
   * The member is a moderator.
   */
  Moderator,
  /**
   * The member is a regular user.
   */
  User,
}

const FfiConverterTypeRoomMemberRole = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomMemberRole;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomMemberRole.Administrator;
        case 2:
          return RoomMemberRole.Moderator;
        case 3:
          return RoomMemberRole.User;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomMemberRole.Administrator:
          return ordinalConverter.write(1, into);
        case RoomMemberRole.Moderator:
          return ordinalConverter.write(2, into);
        case RoomMemberRole.User:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The data needed to perform authorization using OpenID Connect.
 */
export interface OidcAuthorizationDataInterface {
  /**
   * The login URL to use for authorization.
   */
  loginUrl(): string;
}

/**
 * The data needed to perform authorization using OpenID Connect.
 */
export class OidcAuthorizationData
  extends UniffiAbstractObject
  implements OidcAuthorizationDataInterface
{
  readonly [uniffiTypeNameSymbol] = 'OidcAuthorizationData';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeOidcAuthorizationDataObjectFactory.bless(pointer);
  }

  /**
   * The login URL to use for authorization.
   */
  public loginUrl(): string {
    return FfiConverterString.lift(
      rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_matrix_sdk_fn_method_oidcauthorizationdata_login_url(
            uniffiTypeOidcAuthorizationDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    if ((this as any)[destructorGuardSymbol]) {
      const pointer =
        uniffiTypeOidcAuthorizationDataObjectFactory.pointer(this);
      uniffiTypeOidcAuthorizationDataObjectFactory.freePointer(pointer);
      this[destructorGuardSymbol].markDestroyed();
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is OidcAuthorizationData {
    return uniffiTypeOidcAuthorizationDataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeOidcAuthorizationDataObjectFactory: UniffiObjectFactory<OidcAuthorizationDataInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): OidcAuthorizationDataInterface {
      const instance = Object.create(OidcAuthorizationData.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'OidcAuthorizationData';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return rustCall(
        /*caller:*/ (status) =>
          nativeModule().uniffi_internal_fn_method_oidcauthorizationdata_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    pointer(obj: OidcAuthorizationDataInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: OidcAuthorizationDataInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_matrix_sdk_fn_clone_oidcauthorizationdata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_matrix_sdk_fn_free_oidcauthorizationdata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is OidcAuthorizationDataInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'OidcAuthorizationData'
      );
    },
  };
// FfiConverter for OidcAuthorizationDataInterface
const FfiConverterTypeOidcAuthorizationData = new FfiConverterObject(
  uniffiTypeOidcAuthorizationDataObjectFactory
);

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 26;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ffi_matrix_sdk_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().uniffi_matrix_sdk_checksum_method_oidcauthorizationdata_login_url() !==
    59213
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_checksum_method_oidcauthorizationdata_login_url'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBackupDownloadStrategy,
    FfiConverterTypeOidcAuthorizationData,
    FfiConverterTypePaginatorState,
    FfiConverterTypeRoomMemberRole,
    FfiConverterTypeRoomPowerLevelChanges,
  },
});
