// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './matrix_sdk-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * A set of common power levels required for various operations within a room,
 * that can be applied as a single operation. When updating these
 * settings, any levels that are `None` will remain unchanged.
 */
export type RoomPowerLevelChanges = {
  /**
   * The level required to ban a user.
   */
  ban: /*i64*/ bigint | undefined;
  /**
   * The level required to invite a user.
   */
  invite: /*i64*/ bigint | undefined;
  /**
   * The level required to kick a user.
   */
  kick: /*i64*/ bigint | undefined;
  /**
   * The level required to redact an event.
   */
  redact: /*i64*/ bigint | undefined;
  /**
   * The default level required to send message events.
   */
  eventsDefault: /*i64*/ bigint | undefined;
  /**
   * The default level required to send state events.
   */
  stateDefault: /*i64*/ bigint | undefined;
  /**
   * The default power level for every user in the room.
   */
  usersDefault: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's name.
   */
  roomName: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's avatar.
   */
  roomAvatar: /*i64*/ bigint | undefined;
  /**
   * The level required to change the room's topic.
   */
  roomTopic: /*i64*/ bigint | undefined;
};

/**
 * Generated factory for {@link RoomPowerLevelChanges} record objects.
 */
export const RoomPowerLevelChanges = (() => {
  const defaults = () => ({
    ban: undefined,
    invite: undefined,
    kick: undefined,
    redact: undefined,
    eventsDefault: undefined,
    stateDefault: undefined,
    usersDefault: undefined,
    roomName: undefined,
    roomAvatar: undefined,
    roomTopic: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      RoomPowerLevelChanges,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPowerLevelChanges}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomPowerLevelChanges}, with defaults specified
     * in Rust, in the {@link matrix_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPowerLevelChanges>,
  });
})();

const FfiConverterTypeRoomPowerLevelChanges = (() => {
  type TypeName = RoomPowerLevelChanges;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ban: FfiConverterOptionalInt64.read(from),
        invite: FfiConverterOptionalInt64.read(from),
        kick: FfiConverterOptionalInt64.read(from),
        redact: FfiConverterOptionalInt64.read(from),
        eventsDefault: FfiConverterOptionalInt64.read(from),
        stateDefault: FfiConverterOptionalInt64.read(from),
        usersDefault: FfiConverterOptionalInt64.read(from),
        roomName: FfiConverterOptionalInt64.read(from),
        roomAvatar: FfiConverterOptionalInt64.read(from),
        roomTopic: FfiConverterOptionalInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt64.write(value.ban, into);
      FfiConverterOptionalInt64.write(value.invite, into);
      FfiConverterOptionalInt64.write(value.kick, into);
      FfiConverterOptionalInt64.write(value.redact, into);
      FfiConverterOptionalInt64.write(value.eventsDefault, into);
      FfiConverterOptionalInt64.write(value.stateDefault, into);
      FfiConverterOptionalInt64.write(value.usersDefault, into);
      FfiConverterOptionalInt64.write(value.roomName, into);
      FfiConverterOptionalInt64.write(value.roomAvatar, into);
      FfiConverterOptionalInt64.write(value.roomTopic, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt64.allocationSize(value.ban) +
        FfiConverterOptionalInt64.allocationSize(value.invite) +
        FfiConverterOptionalInt64.allocationSize(value.kick) +
        FfiConverterOptionalInt64.allocationSize(value.redact) +
        FfiConverterOptionalInt64.allocationSize(value.eventsDefault) +
        FfiConverterOptionalInt64.allocationSize(value.stateDefault) +
        FfiConverterOptionalInt64.allocationSize(value.usersDefault) +
        FfiConverterOptionalInt64.allocationSize(value.roomName) +
        FfiConverterOptionalInt64.allocationSize(value.roomAvatar) +
        FfiConverterOptionalInt64.allocationSize(value.roomTopic)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

/**
 * Settings for end-to-end encryption features.
 */
export enum BackupDownloadStrategy {
  /**
   * Automatically download all room keys from the backup when the backup
   * recovery key has been received. The backup recovery key can be received
   * in two ways:
   *
   * 1. Received as a `m.secret.send` to-device event, after a successful
   * interactive verification.
   * 2. Imported from secret storage (4S) using the
   * [`SecretStore::import_secrets()`] method.
   *
   * [`SecretStore::import_secrets()`]: crate::encryption::secret_storage::SecretStore::import_secrets
   */
  OneShot,
  /**
   * Attempt to download a single room key if an event fails to be decrypted.
   */
  AfterDecryptionFailure,
  /**
   * Don't download any room keys automatically. The user can manually
   * download room keys using the [`Backups::download_room_key()`] methods.
   *
   * This is the default option.
   */
  Manual,
}

const FfiConverterTypeBackupDownloadStrategy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupDownloadStrategy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BackupDownloadStrategy.OneShot;
        case 2:
          return BackupDownloadStrategy.AfterDecryptionFailure;
        case 3:
          return BackupDownloadStrategy.Manual;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BackupDownloadStrategy.OneShot:
          return ordinalConverter.write(1, into);
        case BackupDownloadStrategy.AfterDecryptionFailure:
          return ordinalConverter.write(2, into);
        case BackupDownloadStrategy.Manual:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Current state of a [`Paginator`].
 */
export enum PaginatorState {
  /**
   * The initial state of the paginator.
   */
  Initial,
  /**
   * The paginator is fetching the target initial event.
   */
  FetchingTargetEvent,
  /**
   * The target initial event could be found, zero or more paginations have
   * happened since then, and the paginator is at rest now.
   */
  Idle,
  /**
   * The paginator isâ€¦ paginating one direction or another.
   */
  Paginating,
}

const FfiConverterTypePaginatorState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaginatorState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaginatorState.Initial;
        case 2:
          return PaginatorState.FetchingTargetEvent;
        case 3:
          return PaginatorState.Idle;
        case 4:
          return PaginatorState.Paginating;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaginatorState.Initial:
          return ordinalConverter.write(1, into);
        case PaginatorState.FetchingTargetEvent:
          return ordinalConverter.write(2, into);
        case PaginatorState.Idle:
          return ordinalConverter.write(3, into);
        case PaginatorState.Paginating:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: QrCodeLoginError
export enum QrCodeLoginError_Tags {
  OAuth = 'OAuth',
  LoginFailure = 'LoginFailure',
  UnexpectedMessage = 'UnexpectedMessage',
  SecureChannel = 'SecureChannel',
  CrossProcessRefreshLock = 'CrossProcessRefreshLock',
  UserIdDiscovery = 'UserIdDiscovery',
  SessionTokens = 'SessionTokens',
  DeviceKeyUpload = 'DeviceKeyUpload',
  SecretImport = 'SecretImport',
}
/**
 * The error type for failures while trying to log in a new device using a QR
 * code.
 */
export const QrCodeLoginError = (() => {
  /**
   * An error happened while we were communicating with the OAuth 2.0
   * authorization server.
   */
  class OAuth extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = QrCodeLoginError_Tags.OAuth;

    constructor(message: string) {
      super('QrCodeLoginError', 'OAuth', message);
    }

    static instanceOf(e: any): e is OAuth {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  /**
   * The other device has signaled to us that the login has failed.
   */
  class LoginFailure extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = QrCodeLoginError_Tags.LoginFailure;

    constructor(message: string) {
      super('QrCodeLoginError', 'LoginFailure', message);
    }

    static instanceOf(e: any): e is LoginFailure {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  /**
   * An unexpected message was received from the other device.
   */
  class UnexpectedMessage extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = QrCodeLoginError_Tags.UnexpectedMessage;

    constructor(message: string) {
      super('QrCodeLoginError', 'UnexpectedMessage', message);
    }

    static instanceOf(e: any): e is UnexpectedMessage {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  /**
   * An error happened while exchanging messages with the other device.
   */
  class SecureChannel extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = QrCodeLoginError_Tags.SecureChannel;

    constructor(message: string) {
      super('QrCodeLoginError', 'SecureChannel', message);
    }

    static instanceOf(e: any): e is SecureChannel {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  /**
   * The cross-process refresh lock failed to be initialized.
   */
  class CrossProcessRefreshLock extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = QrCodeLoginError_Tags.CrossProcessRefreshLock;

    constructor(message: string) {
      super('QrCodeLoginError', 'CrossProcessRefreshLock', message);
    }

    static instanceOf(e: any): e is CrossProcessRefreshLock {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  /**
   * An error happened while we were trying to discover our user and device
   * ID, after we have acquired an access token from the OAuth 2.0
   * authorization server.
   */
  class UserIdDiscovery extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = QrCodeLoginError_Tags.UserIdDiscovery;

    constructor(message: string) {
      super('QrCodeLoginError', 'UserIdDiscovery', message);
    }

    static instanceOf(e: any): e is UserIdDiscovery {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  /**
   * We failed to set the session tokens after we figured out our device and
   * user IDs.
   */
  class SessionTokens extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = QrCodeLoginError_Tags.SessionTokens;

    constructor(message: string) {
      super('QrCodeLoginError', 'SessionTokens', message);
    }

    static instanceOf(e: any): e is SessionTokens {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  /**
   * The device keys failed to be uploaded after we successfully logged in.
   */
  class DeviceKeyUpload extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = QrCodeLoginError_Tags.DeviceKeyUpload;

    constructor(message: string) {
      super('QrCodeLoginError', 'DeviceKeyUpload', message);
    }

    static instanceOf(e: any): e is DeviceKeyUpload {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  /**
   * The secrets bundle we received from the existing device failed to be
   * imported.
   */
  class SecretImport extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeLoginError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = QrCodeLoginError_Tags.SecretImport;

    constructor(message: string) {
      super('QrCodeLoginError', 'SecretImport', message);
    }

    static instanceOf(e: any): e is SecretImport {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is QrCodeLoginError {
    return (e as any)[uniffiTypeNameSymbol] === 'QrCodeLoginError';
  }
  return {
    OAuth,
    LoginFailure,
    UnexpectedMessage,
    SecureChannel,
    CrossProcessRefreshLock,
    UserIdDiscovery,
    SessionTokens,
    DeviceKeyUpload,
    SecretImport,
    instanceOf,
  };
})();

// Union type for QrCodeLoginError error type.

/**
 * The error type for failures while trying to log in a new device using a QR
 * code.
 */

export type QrCodeLoginError = InstanceType<
  (typeof QrCodeLoginError)[keyof Omit<typeof QrCodeLoginError, 'instanceOf'>]
>;

const FfiConverterTypeQRCodeLoginError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = QrCodeLoginError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new QrCodeLoginError.OAuth(FfiConverterString.read(from));

        case 2:
          return new QrCodeLoginError.LoginFailure(
            FfiConverterString.read(from)
          );

        case 3:
          return new QrCodeLoginError.UnexpectedMessage(
            FfiConverterString.read(from)
          );

        case 4:
          return new QrCodeLoginError.SecureChannel(
            FfiConverterString.read(from)
          );

        case 5:
          return new QrCodeLoginError.CrossProcessRefreshLock(
            FfiConverterString.read(from)
          );

        case 6:
          return new QrCodeLoginError.UserIdDiscovery(
            FfiConverterString.read(from)
          );

        case 7:
          return new QrCodeLoginError.SessionTokens(
            FfiConverterString.read(from)
          );

        case 8:
          return new QrCodeLoginError.DeviceKeyUpload(
            FfiConverterString.read(from)
          );

        case 9:
          return new QrCodeLoginError.SecretImport(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

/**
 * The role of a member in a room.
 */
export enum RoomMemberRole {
  /**
   * The member is an administrator.
   */
  Administrator,
  /**
   * The member is a moderator.
   */
  Moderator,
  /**
   * The member is a regular user.
   */
  User,
}

const FfiConverterTypeRoomMemberRole = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomMemberRole;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomMemberRole.Administrator;
        case 2:
          return RoomMemberRole.Moderator;
        case 3:
          return RoomMemberRole.User;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomMemberRole.Administrator:
          return ordinalConverter.write(1, into);
        case RoomMemberRole.Moderator:
          return ordinalConverter.write(2, into);
        case RoomMemberRole.User:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomPaginationStatus
export enum RoomPaginationStatus_Tags {
  Idle = 'Idle',
  Paginating = 'Paginating',
}
/**
 * Status for the back-pagination on a room event cache.
 */
export const RoomPaginationStatus = (() => {
  type Idle__interface = {
    tag: RoomPaginationStatus_Tags.Idle;
    inner: Readonly<{ hitTimelineStart: boolean }>;
  };

  /**
   * No back-pagination is happening right now.
   */
  class Idle_ extends UniffiEnum implements Idle__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomPaginationStatus';
    readonly tag = RoomPaginationStatus_Tags.Idle;
    readonly inner: Readonly<{ hitTimelineStart: boolean }>;
    constructor(inner: {
      /**
       * Have we hit the start of the timeline, i.e. back-paginating wouldn't
       * have any effect?
       */ hitTimelineStart: boolean;
    }) {
      super('RoomPaginationStatus', 'Idle');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Have we hit the start of the timeline, i.e. back-paginating wouldn't
       * have any effect?
       */ hitTimelineStart: boolean;
    }): Idle_ {
      return new Idle_(inner);
    }

    static instanceOf(obj: any): obj is Idle_ {
      return obj.tag === RoomPaginationStatus_Tags.Idle;
    }
  }

  type Paginating__interface = {
    tag: RoomPaginationStatus_Tags.Paginating;
  };

  /**
   * Back-pagination is already running in the background.
   */
  class Paginating_ extends UniffiEnum implements Paginating__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomPaginationStatus';
    readonly tag = RoomPaginationStatus_Tags.Paginating;
    constructor() {
      super('RoomPaginationStatus', 'Paginating');
    }

    static new(): Paginating_ {
      return new Paginating_();
    }

    static instanceOf(obj: any): obj is Paginating_ {
      return obj.tag === RoomPaginationStatus_Tags.Paginating;
    }
  }

  function instanceOf(obj: any): obj is RoomPaginationStatus {
    return obj[uniffiTypeNameSymbol] === 'RoomPaginationStatus';
  }

  return Object.freeze({
    instanceOf,
    Idle: Idle_,
    Paginating: Paginating_,
  });
})();

/**
 * Status for the back-pagination on a room event cache.
 */

export type RoomPaginationStatus = InstanceType<
  (typeof RoomPaginationStatus)[keyof Omit<
    typeof RoomPaginationStatus,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomPaginationStatus
const FfiConverterTypeRoomPaginationStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomPaginationStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomPaginationStatus.Idle({
            hitTimelineStart: FfiConverterBool.read(from),
          });
        case 2:
          return new RoomPaginationStatus.Paginating();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomPaginationStatus_Tags.Idle: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.hitTimelineStart, into);
          return;
        }
        case RoomPaginationStatus_Tags.Paginating: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that RoomPaginationStatus_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomPaginationStatus_Tags.Idle: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterBool.allocationSize(inner.hitTimelineStart);
          return size;
        }
        case RoomPaginationStatus_Tags.Paginating: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * The data needed to perform authorization using OAuth 2.0.
 */
export interface OAuthAuthorizationDataInterface {
  /**
   * The login URL to use for authorization.
   */
  loginUrl(): string;
}

/**
 * The data needed to perform authorization using OAuth 2.0.
 */
export class OAuthAuthorizationData
  extends UniffiAbstractObject
  implements OAuthAuthorizationDataInterface
{
  readonly [uniffiTypeNameSymbol] = 'OAuthAuthorizationData';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeOAuthAuthorizationDataObjectFactory.bless(pointer);
  }

  /**
   * The login URL to use for authorization.
   */
  public loginUrl(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_fn_method_oauthauthorizationdata_login_url(
            uniffiTypeOAuthAuthorizationDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeOAuthAuthorizationDataObjectFactory.pointer(this);
      uniffiTypeOAuthAuthorizationDataObjectFactory.freePointer(pointer);
      uniffiTypeOAuthAuthorizationDataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is OAuthAuthorizationData {
    return uniffiTypeOAuthAuthorizationDataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeOAuthAuthorizationDataObjectFactory: UniffiObjectFactory<OAuthAuthorizationDataInterface> =
  (() => {
    return {
      create(
        pointer: UnsafeMutableRawPointer
      ): OAuthAuthorizationDataInterface {
        const instance = Object.create(OAuthAuthorizationData.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'OAuthAuthorizationData';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_oauthauthorizationdata_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: OAuthAuthorizationDataInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(
        obj: OAuthAuthorizationDataInterface
      ): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_matrix_sdk_fn_clone_oauthauthorizationdata(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_matrix_sdk_fn_free_oauthauthorizationdata(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is OAuthAuthorizationDataInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'OAuthAuthorizationData'
        );
      },
    };
  })();
// FfiConverter for OAuthAuthorizationDataInterface
const FfiConverterTypeOAuthAuthorizationData = new FfiConverterObject(
  uniffiTypeOAuthAuthorizationDataObjectFactory
);

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_matrix_sdk_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_checksum_method_oauthauthorizationdata_login_url() !==
    25566
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_checksum_method_oauthauthorizationdata_login_url'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBackupDownloadStrategy,
    FfiConverterTypeOAuthAuthorizationData,
    FfiConverterTypePaginatorState,
    FfiConverterTypeRoomMemberRole,
    FfiConverterTypeRoomPaginationStatus,
    FfiConverterTypeRoomPowerLevelChanges,
  },
});
