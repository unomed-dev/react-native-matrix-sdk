// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceBackupStateListener,
  type UniffiVTableCallbackInterfaceBackupSteadyStateListener,
  type UniffiVTableCallbackInterfaceClientDelegate,
  type UniffiVTableCallbackInterfaceClientSessionDelegate,
  type UniffiVTableCallbackInterfaceEnableRecoveryProgressListener,
  type UniffiVTableCallbackInterfaceIdentityStatusChangeListener,
  type UniffiVTableCallbackInterfaceIgnoredUsersListener,
  type UniffiVTableCallbackInterfaceKnockRequestsListener,
  type UniffiVTableCallbackInterfaceNotificationSettingsDelegate,
  type UniffiVTableCallbackInterfacePaginationStatusListener,
  type UniffiVTableCallbackInterfaceProgressWatcher,
  type UniffiVTableCallbackInterfaceQrLoginProgressListener,
  type UniffiVTableCallbackInterfaceRecoveryStateListener,
  type UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener,
  type UniffiVTableCallbackInterfaceRoomInfoListener,
  type UniffiVTableCallbackInterfaceRoomListEntriesListener,
  type UniffiVTableCallbackInterfaceRoomListLoadingStateListener,
  type UniffiVTableCallbackInterfaceRoomListServiceStateListener,
  type UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener,
  type UniffiVTableCallbackInterfaceSendQueueRoomErrorListener,
  type UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate,
  type UniffiVTableCallbackInterfaceSyncServiceStateObserver,
  type UniffiVTableCallbackInterfaceTimelineListener,
  type UniffiVTableCallbackInterfaceTypingNotificationsListener,
  type UniffiVTableCallbackInterfaceUnableToDecryptDelegate,
  type UniffiVTableCallbackInterfaceVerificationStateListener,
  type UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider,
} from './matrix_sdk_ffi-ffi';
import {
  type OidcAuthorizationDataInterface,
  type RoomPowerLevelChanges,
  BackupDownloadStrategy,
  RoomMemberRole,
} from './matrix_sdk';
import { ShieldStateCode } from './matrix_sdk_common';
import {
  CollectStrategy,
  IdentityState,
  TrustRequirement,
  UtdCause,
} from './matrix_sdk_crypto';
import {
  EventItemOrigin,
  LiveBackPaginationStatus,
  RoomPinnedEventsChange,
} from './matrix_sdk_ui';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiDuration,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterDuration,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt64,
  FfiConverterUInt8,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCall,
  uniffiTraitInterfaceCallWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
import uniffiMatrixSdkModule from './matrix_sdk';
import uniffiMatrixSdkCommonModule from './matrix_sdk_common';
import uniffiMatrixSdkCryptoModule from './matrix_sdk_crypto';
import uniffiMatrixSdkUiModule from './matrix_sdk_ui';
const {
  FfiConverterTypeBackupDownloadStrategy,
  FfiConverterTypeOidcAuthorizationData,
  FfiConverterTypeRoomMemberRole,
  FfiConverterTypeRoomPowerLevelChanges,
} = uniffiMatrixSdkModule.converters;
const { FfiConverterTypeShieldStateCode } =
  uniffiMatrixSdkCommonModule.converters;
const {
  FfiConverterTypeCollectStrategy,
  FfiConverterTypeIdentityState,
  FfiConverterTypeTrustRequirement,
  FfiConverterTypeUtdCause,
} = uniffiMatrixSdkCryptoModule.converters;
const {
  FfiConverterTypeEventItemOrigin,
  FfiConverterTypeLiveBackPaginationStatus,
  FfiConverterTypeRoomPinnedEventsChange,
} = uniffiMatrixSdkUiModule.converters;
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Creates a [`RoomMessageEventContentWithoutRelation`] given a
 * [`MessageContent`] value.
 */
export function contentWithoutRelationFromMessage(
  message: MessageContent
): RoomMessageEventContentWithoutRelationInterface /*throws*/ {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(
          FfiConverterTypeMessageContent.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Create a caption edit.
 *
 * If no `formatted_caption` is provided, then it's assumed the `caption`
 * represents valid Markdown that can be used as the formatted caption.
 */
export function createCaptionEdit(
  caption: string | undefined,
  formattedCaption: FormattedBody | undefined
): EditedContent {
  return FfiConverterTypeEditedContent.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(
          FfiConverterOptionalString.lower(caption),
          FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function genTransactionId(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Create the actual url that can be used to setup the WebView or IFrame
 * that contains the widget.
 *
 * # Arguments
 * * `widget_settings` - The widget settings to generate the url for.
 * * `room` - A matrix room which is used to query the logged in username
 * * `props` - Properties from the client that can be used by a widget to adapt
 * to the client. e.g. language, font-scale...
 */
export async function generateWebviewUrl(
  widgetSettings: WidgetSettings,
  room: RoomInterface,
  props: ClientProperties,
  asyncOpts_?: { signal: AbortSignal }
): Promise<string> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(
          FfiConverterTypeWidgetSettings.lower(widgetSettings),
          FfiConverterTypeRoom.lower(room),
          FfiConverterTypeClientProperties.lower(props)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeParseError.lift.bind(
        FfiConverterTypeParseError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * The Capabilities required to run a element call widget.
 *
 * This is intended to be used in combination with: `acquire_capabilities` of
 * the `CapabilitiesProvider`.
 *
 * `acquire_capabilities` can simply return the `WidgetCapabilities` from this
 * function. Even if there are non intersecting permissions to what the widget
 * requested.
 *
 * Editing and extending the capabilities from this function is also possible,
 * but should only be done as temporal workarounds until this function is
 * adjusted
 */
export function getElementCallRequiredPermissions(
  ownUserId: string,
  ownDeviceId: string
): WidgetCapabilities {
  return FfiConverterTypeWidgetCapabilities.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(
          FfiConverterString.lower(ownUserId),
          FfiConverterString.lower(ownDeviceId),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Verifies the passed `String` matches the expected room alias format:
 *
 * This means it's lowercase, with no whitespace chars, has a single leading
 * `#` char and a single `:` separator between the local and domain parts, and
 * the local part only contains characters that can't be percent encoded.
 */
export function isRoomAliasFormatValid(alias: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(
          FfiConverterString.lower(alias),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Log an event.
 *
 * The target should be something like a module path, and can be referenced in
 * the filter string given to `setup_tracing`. `level` and `target` for a
 * callsite are fixed at the first `log_event` call for that callsite and can
 * not be changed afterwards, i.e. the level and target passed for second and
 * following `log_event`s with the same callsite will be ignored.
 *
 * This function leaks a little bit of memory for each unique (file + line +
 * level + target) it is called with. Please make sure that the number of
 * different combinations of those parameters this can be called with is
 * constant in the final executable.
 */
export function logEvent(
  file: string,
  line: /*u32*/ number | undefined,
  level: LogLevel,
  target: string,
  message: string
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_log_event(
        FfiConverterString.lower(file),
        FfiConverterOptionalUInt32.lower(line),
        FfiConverterTypeLogLevel.lower(level),
        FfiConverterString.lower(target),
        FfiConverterString.lower(message),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
/**
 * Helper function to parse a string into a ElementWellKnown struct
 */
export function makeElementWellKnown(
  string: string
): ElementWellKnown /*throws*/ {
  return FfiConverterTypeElementWellKnown.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_make_element_well_known(
          FfiConverterString.lower(string),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function makeWidgetDriver(
  settings: WidgetSettings
): WidgetDriverAndHandle /*throws*/ {
  return FfiConverterTypeWidgetDriverAndHandle.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeParseError.lift.bind(
        FfiConverterTypeParseError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(
          FfiConverterTypeWidgetSettings.lower(settings),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generates a `matrix.to` permalink to the given room alias.
 */
export function matrixToRoomAliasPermalink(
  roomAlias: string
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(
          FfiConverterString.lower(roomAlias),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generates a `matrix.to` permalink to the given userID.
 */
export function matrixToUserPermalink(userId: string): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(
          FfiConverterString.lower(userId),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentFromHtml(
  body: string,
  htmlBody: string
): RoomMessageEventContentWithoutRelationInterface {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(
          FfiConverterString.lower(body),
          FfiConverterString.lower(htmlBody),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentFromHtmlAsEmote(
  body: string,
  htmlBody: string
): RoomMessageEventContentWithoutRelationInterface {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(
          FfiConverterString.lower(body),
          FfiConverterString.lower(htmlBody),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentFromMarkdown(
  md: string
): RoomMessageEventContentWithoutRelationInterface {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
          FfiConverterString.lower(md),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentFromMarkdownAsEmote(
  md: string
): RoomMessageEventContentWithoutRelationInterface {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(
          FfiConverterString.lower(md),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentNew(
  msgtype: MessageType
): RoomMessageEventContentWithoutRelationInterface /*throws*/ {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(
          FfiConverterTypeMessageType.lower(msgtype),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * `WidgetSettings` are usually created from a state event.
 * (currently unimplemented)
 *
 * In some cases the client wants to create custom `WidgetSettings`
 * for specific rooms based on other conditions.
 * This function returns a `WidgetSettings` object which can be used
 * to setup a widget using `run_client_widget_api`
 * and to generate the correct url for the widget.
 *
 * # Arguments
 *
 * * `props` - A struct containing the configuration parameters for a element
 * call widget.
 */
export function newVirtualElementCallWidget(
  props: VirtualElementCallWidgetOptions
): WidgetSettings /*throws*/ {
  return FfiConverterTypeWidgetSettings.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeParseError.lift.bind(
        FfiConverterTypeParseError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(
          FfiConverterTypeVirtualElementCallWidgetOptions.lower(props),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Parse a matrix entity from a given URI, be it either
 * a `matrix.to` link or a `matrix:` URI
 */
export function parseMatrixEntityFrom(uri: string): MatrixEntity | undefined {
  return FfiConverterOptionalTypeMatrixEntity.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(
          FfiConverterString.lower(uri),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Transforms a Room's display name into a valid room alias name.
 */
export function roomAliasNameFromRoomDisplayName(roomName: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(
          FfiConverterString.lower(roomName),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function sdkGitSha(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function setupTracing(config: TracingConfiguration): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_setup_tracing(
        FfiConverterTypeTracingConfiguration.lower(config),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
export function suggestedPowerLevelForRole(
  role: RoomMemberRole
): /*i64*/ bigint {
  return FfiConverterInt64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(
          FfiConverterTypeRoomMemberRole.lower(role),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function suggestedRoleForPowerLevel(
  powerLevel: /*i64*/ bigint
): RoomMemberRole {
  return FfiConverterTypeRoomMemberRole.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(
          FfiConverterInt64.lower(powerLevel),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

export interface BackupStateListener {
  onUpdate(status: BackupState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBackupStateListener: {
  vtable: UniffiVTableCallbackInterfaceBackupStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeBackupStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(FfiConverterTypeBackupState.lift(status));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // BackupStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeBackupStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(
      uniffiCallbackInterfaceBackupStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeBackupStateListener =
  new FfiConverterCallback<BackupStateListener>();

export interface BackupSteadyStateListener {
  onUpdate(status: BackupUploadState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBackupSteadyStateListener: {
  vtable: UniffiVTableCallbackInterfaceBackupSteadyStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeBackupSteadyStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeBackupUploadState.lift(status)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // BackupSteadyStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeBackupSteadyStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(
      uniffiCallbackInterfaceBackupSteadyStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeBackupSteadyStateListener =
  new FfiConverterCallback<BackupSteadyStateListener>();

export interface ClientDelegate {
  didReceiveAuthError(isSoftLogout: boolean): void;
  didRefreshTokens(): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceClientDelegate: {
  vtable: UniffiVTableCallbackInterfaceClientDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    didReceiveAuthError: (uniffiHandle: bigint, isSoftLogout: number) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeClientDelegate.lift(uniffiHandle);
        return jsCallback.didReceiveAuthError(
          FfiConverterBool.lift(isSoftLogout)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didRefreshTokens: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeClientDelegate.lift(uniffiHandle);
        return jsCallback.didRefreshTokens();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // ClientDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeClientDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(
      uniffiCallbackInterfaceClientDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeClientDelegate =
  new FfiConverterCallback<ClientDelegate>();

export interface ClientSessionDelegate {
  retrieveSessionFromKeychain(userId: string) /*throws*/ : Session;
  saveSessionInKeychain(session: Session): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceClientSessionDelegate: {
  vtable: UniffiVTableCallbackInterfaceClientSessionDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    retrieveSessionFromKeychain: (uniffiHandle: bigint, userId: Uint8Array) => {
      const uniffiMakeCall = (): Session => {
        const jsCallback =
          FfiConverterTypeClientSessionDelegate.lift(uniffiHandle);
        return jsCallback.retrieveSessionFromKeychain(
          FfiConverterString.lift(userId)
        );
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterTypeSession.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ClientError.instanceOf,
        /*lowerError:*/ FfiConverterTypeClientError.lower.bind(
          FfiConverterTypeClientError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    saveSessionInKeychain: (uniffiHandle: bigint, session: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeClientSessionDelegate.lift(uniffiHandle);
        return jsCallback.saveSessionInKeychain(
          FfiConverterTypeSession.lift(session)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // ClientSessionDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeClientSessionDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(
      uniffiCallbackInterfaceClientSessionDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeClientSessionDelegate =
  new FfiConverterCallback<ClientSessionDelegate>();

export interface EnableRecoveryProgressListener {
  onUpdate(status: EnableRecoveryProgress): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEnableRecoveryProgressListener: {
  vtable: UniffiVTableCallbackInterfaceEnableRecoveryProgressListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeEnableRecoveryProgressListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeEnableRecoveryProgress.lift(status)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // EnableRecoveryProgressListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeEnableRecoveryProgressListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(
      uniffiCallbackInterfaceEnableRecoveryProgressListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeEnableRecoveryProgressListener =
  new FfiConverterCallback<EnableRecoveryProgressListener>();

export interface IdentityStatusChangeListener {
  call(identityStatusChange: Array<IdentityStatusChange>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceIdentityStatusChangeListener: {
  vtable: UniffiVTableCallbackInterfaceIdentityStatusChangeListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, identityStatusChange: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeIdentityStatusChangeListener.lift(uniffiHandle);
        return jsCallback.call(
          FfiConverterArrayTypeIdentityStatusChange.lift(identityStatusChange)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // IdentityStatusChangeListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeIdentityStatusChangeListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(
      uniffiCallbackInterfaceIdentityStatusChangeListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeIdentityStatusChangeListener =
  new FfiConverterCallback<IdentityStatusChangeListener>();

export interface IgnoredUsersListener {
  call(ignoredUserIds: Array<string>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceIgnoredUsersListener: {
  vtable: UniffiVTableCallbackInterfaceIgnoredUsersListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, ignoredUserIds: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeIgnoredUsersListener.lift(uniffiHandle);
        return jsCallback.call(FfiConverterArrayString.lift(ignoredUserIds));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // IgnoredUsersListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeIgnoredUsersListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(
      uniffiCallbackInterfaceIgnoredUsersListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeIgnoredUsersListener =
  new FfiConverterCallback<IgnoredUsersListener>();

/**
 * A listener for receiving new requests to a join a room.
 */
export interface KnockRequestsListener {
  call(joinRequests: Array<KnockRequest>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceKnockRequestsListener: {
  vtable: UniffiVTableCallbackInterfaceKnockRequestsListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, joinRequests: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeKnockRequestsListener.lift(uniffiHandle);
        return jsCallback.call(
          FfiConverterArrayTypeKnockRequest.lift(joinRequests)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // KnockRequestsListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeKnockRequestsListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(
      uniffiCallbackInterfaceKnockRequestsListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeKnockRequestsListener =
  new FfiConverterCallback<KnockRequestsListener>();

/**
 * Delegate to notify of changes in push rules
 */
export interface NotificationSettingsDelegate {
  settingsDidChange(): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceNotificationSettingsDelegate: {
  vtable: UniffiVTableCallbackInterfaceNotificationSettingsDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    settingsDidChange: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeNotificationSettingsDelegate.lift(uniffiHandle);
        return jsCallback.settingsDidChange();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // NotificationSettingsDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeNotificationSettingsDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(
      uniffiCallbackInterfaceNotificationSettingsDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeNotificationSettingsDelegate =
  new FfiConverterCallback<NotificationSettingsDelegate>();

export interface PaginationStatusListener {
  onUpdate(status: LiveBackPaginationStatus): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePaginationStatusListener: {
  vtable: UniffiVTableCallbackInterfacePaginationStatusListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypePaginationStatusListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeLiveBackPaginationStatus.lift(status)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // PaginationStatusListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypePaginationStatusListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(
      uniffiCallbackInterfacePaginationStatusListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypePaginationStatusListener =
  new FfiConverterCallback<PaginationStatusListener>();

export interface ProgressWatcher {
  transmissionProgress(progress: TransmissionProgress): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceProgressWatcher: {
  vtable: UniffiVTableCallbackInterfaceProgressWatcher;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    transmissionProgress: (uniffiHandle: bigint, progress: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeProgressWatcher.lift(uniffiHandle);
        return jsCallback.transmissionProgress(
          FfiConverterTypeTransmissionProgress.lift(progress)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // ProgressWatcher: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeProgressWatcher.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(
      uniffiCallbackInterfaceProgressWatcher.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeProgressWatcher =
  new FfiConverterCallback<ProgressWatcher>();

export interface QrLoginProgressListener {
  onUpdate(state: QrLoginProgress): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceQrLoginProgressListener: {
  vtable: UniffiVTableCallbackInterfaceQrLoginProgressListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, state: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeQrLoginProgressListener.lift(uniffiHandle);
        return jsCallback.onUpdate(FfiConverterTypeQrLoginProgress.lift(state));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // QrLoginProgressListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeQrLoginProgressListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(
      uniffiCallbackInterfaceQrLoginProgressListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeQrLoginProgressListener =
  new FfiConverterCallback<QrLoginProgressListener>();

export interface RecoveryStateListener {
  onUpdate(status: RecoveryState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRecoveryStateListener: {
  vtable: UniffiVTableCallbackInterfaceRecoveryStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRecoveryStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(FfiConverterTypeRecoveryState.lift(status));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RecoveryStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRecoveryStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(
      uniffiCallbackInterfaceRecoveryStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRecoveryStateListener =
  new FfiConverterCallback<RecoveryStateListener>();

export interface RoomDirectorySearchEntriesListener {
  onUpdate(roomEntriesUpdate: Array<RoomDirectorySearchEntryUpdate>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomDirectorySearchEntriesListener: {
  vtable: UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, roomEntriesUpdate: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomDirectorySearchEntriesListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterArrayTypeRoomDirectorySearchEntryUpdate.lift(
            roomEntriesUpdate
          )
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomDirectorySearchEntriesListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomDirectorySearchEntriesListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(
      uniffiCallbackInterfaceRoomDirectorySearchEntriesListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomDirectorySearchEntriesListener =
  new FfiConverterCallback<RoomDirectorySearchEntriesListener>();

export interface RoomInfoListener {
  call(roomInfo: RoomInfo): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomInfoListener: {
  vtable: UniffiVTableCallbackInterfaceRoomInfoListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, roomInfo: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeRoomInfoListener.lift(uniffiHandle);
        return jsCallback.call(FfiConverterTypeRoomInfo.lift(roomInfo));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomInfoListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomInfoListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(
      uniffiCallbackInterfaceRoomInfoListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomInfoListener =
  new FfiConverterCallback<RoomInfoListener>();

export interface RoomListEntriesListener {
  onUpdate(roomEntriesUpdate: Array<RoomListEntriesUpdate>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListEntriesListener: {
  vtable: UniffiVTableCallbackInterfaceRoomListEntriesListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, roomEntriesUpdate: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomListEntriesListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterArrayTypeRoomListEntriesUpdate.lift(roomEntriesUpdate)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomListEntriesListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomListEntriesListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(
      uniffiCallbackInterfaceRoomListEntriesListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListEntriesListener =
  new FfiConverterCallback<RoomListEntriesListener>();

export interface RoomListLoadingStateListener {
  onUpdate(state: RoomListLoadingState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListLoadingStateListener: {
  vtable: UniffiVTableCallbackInterfaceRoomListLoadingStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, state: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomListLoadingStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeRoomListLoadingState.lift(state)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomListLoadingStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomListLoadingStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(
      uniffiCallbackInterfaceRoomListLoadingStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListLoadingStateListener =
  new FfiConverterCallback<RoomListLoadingStateListener>();

export interface RoomListServiceStateListener {
  onUpdate(state: RoomListServiceState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListServiceStateListener: {
  vtable: UniffiVTableCallbackInterfaceRoomListServiceStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, state: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomListServiceStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeRoomListServiceState.lift(state)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomListServiceStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomListServiceStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(
      uniffiCallbackInterfaceRoomListServiceStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListServiceStateListener =
  new FfiConverterCallback<RoomListServiceStateListener>();

export interface RoomListServiceSyncIndicatorListener {
  onUpdate(syncIndicator: RoomListServiceSyncIndicator): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener: {
  vtable: UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, syncIndicator: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomListServiceSyncIndicatorListener.lift(
            uniffiHandle
          );
        return jsCallback.onUpdate(
          FfiConverterTypeRoomListServiceSyncIndicator.lift(syncIndicator)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomListServiceSyncIndicatorListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomListServiceSyncIndicatorListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(
      uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListServiceSyncIndicatorListener =
  new FfiConverterCallback<RoomListServiceSyncIndicatorListener>();

/**
 * A listener to the global (client-wide) error reporter of the send queue.
 */
export interface SendQueueRoomErrorListener {
  /**
   * Called every time the send queue has ran into an error for a given room,
   * which will disable the send queue for that particular room.
   */
  onError(roomId: string, error: ClientError): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSendQueueRoomErrorListener: {
  vtable: UniffiVTableCallbackInterfaceSendQueueRoomErrorListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onError: (uniffiHandle: bigint, roomId: Uint8Array, error: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSendQueueRoomErrorListener.lift(uniffiHandle);
        return jsCallback.onError(
          FfiConverterString.lift(roomId),
          FfiConverterTypeClientError.lift(error)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // SendQueueRoomErrorListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeSendQueueRoomErrorListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(
      uniffiCallbackInterfaceSendQueueRoomErrorListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeSendQueueRoomErrorListener =
  new FfiConverterCallback<SendQueueRoomErrorListener>();

export interface SessionVerificationControllerDelegate {
  didReceiveVerificationRequest(
    details: SessionVerificationRequestDetails
  ): void;
  didAcceptVerificationRequest(): void;
  didStartSasVerification(): void;
  didReceiveVerificationData(data: SessionVerificationData): void;
  didFail(): void;
  didCancel(): void;
  didFinish(): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSessionVerificationControllerDelegate: {
  vtable: UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    didReceiveVerificationRequest: (
      uniffiHandle: bigint,
      details: Uint8Array
    ) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didReceiveVerificationRequest(
          FfiConverterTypeSessionVerificationRequestDetails.lift(details)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didAcceptVerificationRequest: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didAcceptVerificationRequest();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didStartSasVerification: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didStartSasVerification();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didReceiveVerificationData: (uniffiHandle: bigint, data: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didReceiveVerificationData(
          FfiConverterTypeSessionVerificationData.lift(data)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didFail: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didFail();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didCancel: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didCancel();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didFinish: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didFinish();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // SessionVerificationControllerDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeSessionVerificationControllerDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(
      uniffiCallbackInterfaceSessionVerificationControllerDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeSessionVerificationControllerDelegate =
  new FfiConverterCallback<SessionVerificationControllerDelegate>();

export interface SyncServiceStateObserver {
  onUpdate(state: SyncServiceState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSyncServiceStateObserver: {
  vtable: UniffiVTableCallbackInterfaceSyncServiceStateObserver;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, state: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSyncServiceStateObserver.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeSyncServiceState.lift(state)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // SyncServiceStateObserver: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeSyncServiceStateObserver.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(
      uniffiCallbackInterfaceSyncServiceStateObserver.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeSyncServiceStateObserver =
  new FfiConverterCallback<SyncServiceStateObserver>();

export interface TimelineListener {
  onUpdate(diff: Array<TimelineDiffInterface>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceTimelineListener: {
  vtable: UniffiVTableCallbackInterfaceTimelineListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, diff: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeTimelineListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterArrayTypeTimelineDiff.lift(diff)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // TimelineListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeTimelineListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(
      uniffiCallbackInterfaceTimelineListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeTimelineListener =
  new FfiConverterCallback<TimelineListener>();

export interface TypingNotificationsListener {
  call(typingUserIds: Array<string>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceTypingNotificationsListener: {
  vtable: UniffiVTableCallbackInterfaceTypingNotificationsListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, typingUserIds: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeTypingNotificationsListener.lift(uniffiHandle);
        return jsCallback.call(FfiConverterArrayString.lift(typingUserIds));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // TypingNotificationsListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeTypingNotificationsListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(
      uniffiCallbackInterfaceTypingNotificationsListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeTypingNotificationsListener =
  new FfiConverterCallback<TypingNotificationsListener>();

export interface UnableToDecryptDelegate {
  onUtd(info: UnableToDecryptInfo): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceUnableToDecryptDelegate: {
  vtable: UniffiVTableCallbackInterfaceUnableToDecryptDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUtd: (uniffiHandle: bigint, info: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeUnableToDecryptDelegate.lift(uniffiHandle);
        return jsCallback.onUtd(FfiConverterTypeUnableToDecryptInfo.lift(info));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // UnableToDecryptDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeUnableToDecryptDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(
      uniffiCallbackInterfaceUnableToDecryptDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeUnableToDecryptDelegate =
  new FfiConverterCallback<UnableToDecryptDelegate>();

export interface VerificationStateListener {
  onUpdate(status: VerificationState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceVerificationStateListener: {
  vtable: UniffiVTableCallbackInterfaceVerificationStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeVerificationStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeVerificationState.lift(status)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // VerificationStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeVerificationStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(
      uniffiCallbackInterfaceVerificationStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeVerificationStateListener =
  new FfiConverterCallback<VerificationStateListener>();

export interface WidgetCapabilitiesProvider {
  acquireCapabilities(capabilities: WidgetCapabilities): WidgetCapabilities;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceWidgetCapabilitiesProvider: {
  vtable: UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    acquireCapabilities: (uniffiHandle: bigint, capabilities: Uint8Array) => {
      const uniffiMakeCall = (): WidgetCapabilities => {
        const jsCallback =
          FfiConverterTypeWidgetCapabilitiesProvider.lift(uniffiHandle);
        return jsCallback.acquireCapabilities(
          FfiConverterTypeWidgetCapabilities.lift(capabilities)
        );
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterTypeWidgetCapabilities.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // WidgetCapabilitiesProvider: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeWidgetCapabilitiesProvider.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(
      uniffiCallbackInterfaceWidgetCapabilitiesProvider.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeWidgetCapabilitiesProvider =
  new FfiConverterCallback<WidgetCapabilitiesProvider>();

export type AudioInfo = {
  duration: UniffiDuration | undefined;
  size: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
};

/**
 * Generated factory for {@link AudioInfo} record objects.
 */
export const AudioInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<AudioInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AudioInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AudioInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AudioInfo>,
  });
})();

const FfiConverterTypeAudioInfo = (() => {
  type TypeName = AudioInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        duration: FfiConverterOptionalDuration.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalDuration.write(value.duration, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalString.write(value.mimetype, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalDuration.allocationSize(value.duration) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalString.allocationSize(value.mimetype)
      );
    }
  }
  return new FFIConverter();
})();

export type AudioMessageContent = {
  /**
   * The computed filename, for use in a client.
   */
  filename: string;
  caption: string | undefined;
  formattedCaption: FormattedBody | undefined;
  source: MediaSourceInterface;
  info: AudioInfo | undefined;
  audio: UnstableAudioDetailsContent | undefined;
  voice: UnstableVoiceContent | undefined;
};

/**
 * Generated factory for {@link AudioMessageContent} record objects.
 */
export const AudioMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<AudioMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AudioMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AudioMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AudioMessageContent>,
  });
})();

const FfiConverterTypeAudioMessageContent = (() => {
  type TypeName = AudioMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filename: FfiConverterString.read(from),
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeAudioInfo.read(from),
        audio: FfiConverterOptionalTypeUnstableAudioDetailsContent.read(from),
        voice: FfiConverterOptionalTypeUnstableVoiceContent.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filename, into);
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeAudioInfo.write(value.info, into);
      FfiConverterOptionalTypeUnstableAudioDetailsContent.write(
        value.audio,
        into
      );
      FfiConverterOptionalTypeUnstableVoiceContent.write(value.voice, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filename) +
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeAudioInfo.allocationSize(value.info) +
        FfiConverterOptionalTypeUnstableAudioDetailsContent.allocationSize(
          value.audio
        ) +
        FfiConverterOptionalTypeUnstableVoiceContent.allocationSize(value.voice)
      );
    }
  }
  return new FFIConverter();
})();

export type AuthDataPasswordDetails = {
  /**
   * One of the user's identifiers.
   */
  identifier: string;
  /**
   * The plaintext password.
   */
  password: string;
};

/**
 * Generated factory for {@link AuthDataPasswordDetails} record objects.
 */
export const AuthDataPasswordDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      AuthDataPasswordDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AuthDataPasswordDetails}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AuthDataPasswordDetails}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<AuthDataPasswordDetails>,
  });
})();

const FfiConverterTypeAuthDataPasswordDetails = (() => {
  type TypeName = AuthDataPasswordDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        identifier: FfiConverterString.read(from),
        password: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.identifier, into);
      FfiConverterString.write(value.password, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.identifier) +
        FfiConverterString.allocationSize(value.password)
      );
    }
  }
  return new FFIConverter();
})();

export type ClientProperties = {
  /**
   * The client_id provides the widget with the option to behave differently
   * for different clients. e.g org.example.ios.
   */
  clientId: string;
  /**
   * The language tag the client is set to e.g. en-us. (Undefined and invalid
   * becomes: `en-US`)
   */
  languageTag: string | undefined;
  /**
   * A string describing the theme (dark, light) or org.example.dark.
   * (default: `light`)
   */
  theme: string | undefined;
};

/**
 * Generated factory for {@link ClientProperties} record objects.
 */
export const ClientProperties = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ClientProperties, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClientProperties}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ClientProperties}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClientProperties>,
  });
})();

const FfiConverterTypeClientProperties = (() => {
  type TypeName = ClientProperties;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        clientId: FfiConverterString.read(from),
        languageTag: FfiConverterOptionalString.read(from),
        theme: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.clientId, into);
      FfiConverterOptionalString.write(value.languageTag, into);
      FfiConverterOptionalString.write(value.theme, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.clientId) +
        FfiConverterOptionalString.allocationSize(value.languageTag) +
        FfiConverterOptionalString.allocationSize(value.theme)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Current draft of the composer for the room.
 */
export type ComposerDraft = {
  /**
   * The draft content in plain text.
   */
  plainText: string;
  /**
   * If the message is formatted in HTML, the HTML representation of the
   * message.
   */
  htmlText: string | undefined;
  /**
   * The type of draft.
   */
  draftType: ComposerDraftType;
};

/**
 * Generated factory for {@link ComposerDraft} record objects.
 */
export const ComposerDraft = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ComposerDraft, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ComposerDraft}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ComposerDraft}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ComposerDraft>,
  });
})();

const FfiConverterTypeComposerDraft = (() => {
  type TypeName = ComposerDraft;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        plainText: FfiConverterString.read(from),
        htmlText: FfiConverterOptionalString.read(from),
        draftType: FfiConverterTypeComposerDraftType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.plainText, into);
      FfiConverterOptionalString.write(value.htmlText, into);
      FfiConverterTypeComposerDraftType.write(value.draftType, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.plainText) +
        FfiConverterOptionalString.allocationSize(value.htmlText) +
        FfiConverterTypeComposerDraftType.allocationSize(value.draftType)
      );
    }
  }
  return new FFIConverter();
})();

export type CreateRoomParameters = {
  name: string | undefined;
  topic: string | undefined;
  isEncrypted: boolean;
  isDirect: boolean;
  visibility: RoomVisibility;
  preset: RoomPreset;
  invite: Array<string> | undefined;
  avatar: string | undefined;
  powerLevelContentOverride: PowerLevels | undefined;
  joinRuleOverride: JoinRule | undefined;
  canonicalAlias: string | undefined;
};

/**
 * Generated factory for {@link CreateRoomParameters} record objects.
 */
export const CreateRoomParameters = (() => {
  const defaults = () => ({
    topic: undefined,
    isDirect: false,
    invite: undefined,
    avatar: undefined,
    powerLevelContentOverride: undefined,
    joinRuleOverride: undefined,
    canonicalAlias: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      CreateRoomParameters,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CreateRoomParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CreateRoomParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CreateRoomParameters>,
  });
})();

const FfiConverterTypeCreateRoomParameters = (() => {
  type TypeName = CreateRoomParameters;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        isEncrypted: FfiConverterBool.read(from),
        isDirect: FfiConverterBool.read(from),
        visibility: FfiConverterTypeRoomVisibility.read(from),
        preset: FfiConverterTypeRoomPreset.read(from),
        invite: FfiConverterOptionalArrayString.read(from),
        avatar: FfiConverterOptionalString.read(from),
        powerLevelContentOverride:
          FfiConverterOptionalTypePowerLevels.read(from),
        joinRuleOverride: FfiConverterOptionalTypeJoinRule.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterBool.write(value.isEncrypted, into);
      FfiConverterBool.write(value.isDirect, into);
      FfiConverterTypeRoomVisibility.write(value.visibility, into);
      FfiConverterTypeRoomPreset.write(value.preset, into);
      FfiConverterOptionalArrayString.write(value.invite, into);
      FfiConverterOptionalString.write(value.avatar, into);
      FfiConverterOptionalTypePowerLevels.write(
        value.powerLevelContentOverride,
        into
      );
      FfiConverterOptionalTypeJoinRule.write(value.joinRuleOverride, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterBool.allocationSize(value.isEncrypted) +
        FfiConverterBool.allocationSize(value.isDirect) +
        FfiConverterTypeRoomVisibility.allocationSize(value.visibility) +
        FfiConverterTypeRoomPreset.allocationSize(value.preset) +
        FfiConverterOptionalArrayString.allocationSize(value.invite) +
        FfiConverterOptionalString.allocationSize(value.avatar) +
        FfiConverterOptionalTypePowerLevels.allocationSize(
          value.powerLevelContentOverride
        ) +
        FfiConverterOptionalTypeJoinRule.allocationSize(
          value.joinRuleOverride
        ) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Well-known settings specific to ElementCall
 */
export type ElementCallWellKnown = {
  widgetUrl: string;
};

/**
 * Generated factory for {@link ElementCallWellKnown} record objects.
 */
export const ElementCallWellKnown = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ElementCallWellKnown,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ElementCallWellKnown}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ElementCallWellKnown}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ElementCallWellKnown>,
  });
})();

const FfiConverterTypeElementCallWellKnown = (() => {
  type TypeName = ElementCallWellKnown;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        widgetUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.widgetUrl, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.widgetUrl);
    }
  }
  return new FFIConverter();
})();

/**
 * Element specific well-known settings
 */
export type ElementWellKnown = {
  call: ElementCallWellKnown | undefined;
  registrationHelperUrl: string | undefined;
};

/**
 * Generated factory for {@link ElementWellKnown} record objects.
 */
export const ElementWellKnown = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ElementWellKnown, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ElementWellKnown}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ElementWellKnown}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ElementWellKnown>,
  });
})();

const FfiConverterTypeElementWellKnown = (() => {
  type TypeName = ElementWellKnown;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        call: FfiConverterOptionalTypeElementCallWellKnown.read(from),
        registrationHelperUrl: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeElementCallWellKnown.write(value.call, into);
      FfiConverterOptionalString.write(value.registrationHelperUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeElementCallWellKnown.allocationSize(
          value.call
        ) +
        FfiConverterOptionalString.allocationSize(value.registrationHelperUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type EmoteMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
};

/**
 * Generated factory for {@link EmoteMessageContent} record objects.
 */
export const EmoteMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EmoteMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmoteMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EmoteMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmoteMessageContent>,
  });
})();

const FfiConverterTypeEmoteMessageContent = (() => {
  type TypeName = EmoteMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted)
      );
    }
  }
  return new FFIConverter();
})();

export type EventTimelineItem = {
  /**
   * Indicates that an event is remote.
   */
  isRemote: boolean;
  eventOrTransactionId: EventOrTransactionId;
  sender: string;
  senderProfile: ProfileDetails;
  isOwn: boolean;
  isEditable: boolean;
  content: TimelineItemContent;
  timestamp: /*u64*/ bigint;
  reactions: Array<Reaction>;
  localSendState: EventSendState | undefined;
  readReceipts: Map<string, Receipt>;
  origin: EventItemOrigin | undefined;
  canBeRepliedTo: boolean;
  lazyProvider: LazyTimelineItemProviderInterface;
};

/**
 * Generated factory for {@link EventTimelineItem} record objects.
 */
export const EventTimelineItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EventTimelineItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EventTimelineItem}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EventTimelineItem}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EventTimelineItem>,
  });
})();

const FfiConverterTypeEventTimelineItem = (() => {
  type TypeName = EventTimelineItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        isRemote: FfiConverterBool.read(from),
        eventOrTransactionId: FfiConverterTypeEventOrTransactionId.read(from),
        sender: FfiConverterString.read(from),
        senderProfile: FfiConverterTypeProfileDetails.read(from),
        isOwn: FfiConverterBool.read(from),
        isEditable: FfiConverterBool.read(from),
        content: FfiConverterTypeTimelineItemContent.read(from),
        timestamp: FfiConverterUInt64.read(from),
        reactions: FfiConverterArrayTypeReaction.read(from),
        localSendState: FfiConverterOptionalTypeEventSendState.read(from),
        readReceipts: FfiConverterMapStringTypeReceipt.read(from),
        origin: FfiConverterOptionalTypeEventItemOrigin.read(from),
        canBeRepliedTo: FfiConverterBool.read(from),
        lazyProvider: FfiConverterTypeLazyTimelineItemProvider.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.isRemote, into);
      FfiConverterTypeEventOrTransactionId.write(
        value.eventOrTransactionId,
        into
      );
      FfiConverterString.write(value.sender, into);
      FfiConverterTypeProfileDetails.write(value.senderProfile, into);
      FfiConverterBool.write(value.isOwn, into);
      FfiConverterBool.write(value.isEditable, into);
      FfiConverterTypeTimelineItemContent.write(value.content, into);
      FfiConverterUInt64.write(value.timestamp, into);
      FfiConverterArrayTypeReaction.write(value.reactions, into);
      FfiConverterOptionalTypeEventSendState.write(value.localSendState, into);
      FfiConverterMapStringTypeReceipt.write(value.readReceipts, into);
      FfiConverterOptionalTypeEventItemOrigin.write(value.origin, into);
      FfiConverterBool.write(value.canBeRepliedTo, into);
      FfiConverterTypeLazyTimelineItemProvider.write(value.lazyProvider, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.isRemote) +
        FfiConverterTypeEventOrTransactionId.allocationSize(
          value.eventOrTransactionId
        ) +
        FfiConverterString.allocationSize(value.sender) +
        FfiConverterTypeProfileDetails.allocationSize(value.senderProfile) +
        FfiConverterBool.allocationSize(value.isOwn) +
        FfiConverterBool.allocationSize(value.isEditable) +
        FfiConverterTypeTimelineItemContent.allocationSize(value.content) +
        FfiConverterUInt64.allocationSize(value.timestamp) +
        FfiConverterArrayTypeReaction.allocationSize(value.reactions) +
        FfiConverterOptionalTypeEventSendState.allocationSize(
          value.localSendState
        ) +
        FfiConverterMapStringTypeReceipt.allocationSize(value.readReceipts) +
        FfiConverterOptionalTypeEventItemOrigin.allocationSize(value.origin) +
        FfiConverterBool.allocationSize(value.canBeRepliedTo) +
        FfiConverterTypeLazyTimelineItemProvider.allocationSize(
          value.lazyProvider
        )
      );
    }
  }
  return new FFIConverter();
})();

export type EventTimelineItemDebugInfo = {
  model: string;
  originalJson: string | undefined;
  latestEditJson: string | undefined;
};

/**
 * Generated factory for {@link EventTimelineItemDebugInfo} record objects.
 */
export const EventTimelineItemDebugInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      EventTimelineItemDebugInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EventTimelineItemDebugInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EventTimelineItemDebugInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<EventTimelineItemDebugInfo>,
  });
})();

const FfiConverterTypeEventTimelineItemDebugInfo = (() => {
  type TypeName = EventTimelineItemDebugInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        model: FfiConverterString.read(from),
        originalJson: FfiConverterOptionalString.read(from),
        latestEditJson: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.model, into);
      FfiConverterOptionalString.write(value.originalJson, into);
      FfiConverterOptionalString.write(value.latestEditJson, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.model) +
        FfiConverterOptionalString.allocationSize(value.originalJson) +
        FfiConverterOptionalString.allocationSize(value.latestEditJson)
      );
    }
  }
  return new FFIConverter();
})();

export type FileInfo = {
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
  thumbnailInfo: ThumbnailInfo | undefined;
  thumbnailSource: MediaSourceInterface | undefined;
};

/**
 * Generated factory for {@link FileInfo} record objects.
 */
export const FileInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FileInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FileInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FileInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FileInfo>,
  });
})();

const FfiConverterTypeFileInfo = (() => {
  type TypeName = FileInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
        thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
      FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalTypeThumbnailInfo.allocationSize(
          value.thumbnailInfo
        ) +
        FfiConverterOptionalTypeMediaSource.allocationSize(
          value.thumbnailSource
        )
      );
    }
  }
  return new FFIConverter();
})();

export type FileMessageContent = {
  /**
   * The computed filename, for use in a client.
   */
  filename: string;
  caption: string | undefined;
  formattedCaption: FormattedBody | undefined;
  source: MediaSourceInterface;
  info: FileInfo | undefined;
};

/**
 * Generated factory for {@link FileMessageContent} record objects.
 */
export const FileMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FileMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FileMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FileMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FileMessageContent>,
  });
})();

const FfiConverterTypeFileMessageContent = (() => {
  type TypeName = FileMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filename: FfiConverterString.read(from),
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeFileInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filename, into);
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeFileInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filename) +
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeFileInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

export type FormattedBody = {
  format: MessageFormat;
  body: string;
};

/**
 * Generated factory for {@link FormattedBody} record objects.
 */
export const FormattedBody = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FormattedBody, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FormattedBody}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FormattedBody}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FormattedBody>,
  });
})();

const FfiConverterTypeFormattedBody = (() => {
  type TypeName = FormattedBody;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        format: FfiConverterTypeMessageFormat.read(from),
        body: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMessageFormat.write(value.format, into);
      FfiConverterString.write(value.body, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMessageFormat.allocationSize(value.format) +
        FfiConverterString.allocationSize(value.body)
      );
    }
  }
  return new FFIConverter();
})();

export type HttpPusherData = {
  url: string;
  format: PushFormat | undefined;
  defaultPayload: string | undefined;
};

/**
 * Generated factory for {@link HttpPusherData} record objects.
 */
export const HttpPusherData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<HttpPusherData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link HttpPusherData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link HttpPusherData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<HttpPusherData>,
  });
})();

const FfiConverterTypeHttpPusherData = (() => {
  type TypeName = HttpPusherData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        url: FfiConverterString.read(from),
        format: FfiConverterOptionalTypePushFormat.read(from),
        defaultPayload: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.url, into);
      FfiConverterOptionalTypePushFormat.write(value.format, into);
      FfiConverterOptionalString.write(value.defaultPayload, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.url) +
        FfiConverterOptionalTypePushFormat.allocationSize(value.format) +
        FfiConverterOptionalString.allocationSize(value.defaultPayload)
      );
    }
  }
  return new FFIConverter();
})();

export type IdentityStatusChange = {
  /**
   * The user ID of the user whose identity status changed
   */
  userId: string;
  /**
   * The new state of the identity of the user.
   */
  changedTo: IdentityState;
};

/**
 * Generated factory for {@link IdentityStatusChange} record objects.
 */
export const IdentityStatusChange = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      IdentityStatusChange,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link IdentityStatusChange}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link IdentityStatusChange}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<IdentityStatusChange>,
  });
})();

const FfiConverterTypeIdentityStatusChange = (() => {
  type TypeName = IdentityStatusChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        changedTo: FfiConverterTypeIdentityState.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterTypeIdentityState.write(value.changedTo, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterTypeIdentityState.allocationSize(value.changedTo)
      );
    }
  }
  return new FFIConverter();
})();

export type ImageInfo = {
  height: /*u64*/ bigint | undefined;
  width: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
  thumbnailInfo: ThumbnailInfo | undefined;
  thumbnailSource: MediaSourceInterface | undefined;
  blurhash: string | undefined;
};

/**
 * Generated factory for {@link ImageInfo} record objects.
 */
export const ImageInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ImageInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ImageInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ImageInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ImageInfo>,
  });
})();

const FfiConverterTypeImageInfo = (() => {
  type TypeName = ImageInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        height: FfiConverterOptionalUInt64.read(from),
        width: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
        thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
        blurhash: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.height, into);
      FfiConverterOptionalUInt64.write(value.width, into);
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
      FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
      FfiConverterOptionalString.write(value.blurhash, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.height) +
        FfiConverterOptionalUInt64.allocationSize(value.width) +
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalTypeThumbnailInfo.allocationSize(
          value.thumbnailInfo
        ) +
        FfiConverterOptionalTypeMediaSource.allocationSize(
          value.thumbnailSource
        ) +
        FfiConverterOptionalString.allocationSize(value.blurhash)
      );
    }
  }
  return new FFIConverter();
})();

export type ImageMessageContent = {
  /**
   * The computed filename, for use in a client.
   */
  filename: string;
  caption: string | undefined;
  formattedCaption: FormattedBody | undefined;
  source: MediaSourceInterface;
  info: ImageInfo | undefined;
};

/**
 * Generated factory for {@link ImageMessageContent} record objects.
 */
export const ImageMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ImageMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ImageMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ImageMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ImageMessageContent>,
  });
})();

const FfiConverterTypeImageMessageContent = (() => {
  type TypeName = ImageMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filename: FfiConverterString.read(from),
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeImageInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filename, into);
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeImageInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filename) +
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeImageInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

export type InsertData = {
  index: /*u32*/ number;
  item: TimelineItemInterface;
};

/**
 * Generated factory for {@link InsertData} record objects.
 */
export const InsertData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<InsertData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link InsertData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link InsertData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<InsertData>,
  });
})();

const FfiConverterTypeInsertData = (() => {
  type TypeName = InsertData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        index: FfiConverterUInt32.read(from),
        item: FfiConverterTypeTimelineItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.index, into);
      FfiConverterTypeTimelineItem.write(value.item, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.index) +
        FfiConverterTypeTimelineItem.allocationSize(value.item)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * An FFI representation of a request to join a room.
 */
export type KnockRequest = {
  /**
   * The event id of the event that contains the `knock` membership change.
   */
  eventId: string;
  /**
   * The user id of the user who's requesting to join the room.
   */
  userId: string;
  /**
   * The room id of the room whose access was requested.
   */
  roomId: string;
  /**
   * The optional display name of the user who's requesting to join the room.
   */
  displayName: string | undefined;
  /**
   * The optional avatar url of the user who's requesting to join the room.
   */
  avatarUrl: string | undefined;
  /**
   * An optional reason why the user wants join the room.
   */
  reason: string | undefined;
  /**
   * The timestamp when this request was created.
   */
  timestamp: /*u64*/ bigint | undefined;
  /**
   * Whether the knock request has been marked as `seen` so it can be
   * filtered by the client.
   */
  isSeen: boolean;
  /**
   * A set of actions to perform for this knock request.
   */
  actions: KnockRequestActionsInterface;
};

/**
 * Generated factory for {@link KnockRequest} record objects.
 */
export const KnockRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<KnockRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link KnockRequest}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link KnockRequest}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<KnockRequest>,
  });
})();

const FfiConverterTypeKnockRequest = (() => {
  type TypeName = KnockRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        eventId: FfiConverterString.read(from),
        userId: FfiConverterString.read(from),
        roomId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        reason: FfiConverterOptionalString.read(from),
        timestamp: FfiConverterOptionalUInt64.read(from),
        isSeen: FfiConverterBool.read(from),
        actions: FfiConverterTypeKnockRequestActions.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.eventId, into);
      FfiConverterString.write(value.userId, into);
      FfiConverterString.write(value.roomId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterOptionalString.write(value.reason, into);
      FfiConverterOptionalUInt64.write(value.timestamp, into);
      FfiConverterBool.write(value.isSeen, into);
      FfiConverterTypeKnockRequestActions.write(value.actions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.eventId) +
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterOptionalString.allocationSize(value.reason) +
        FfiConverterOptionalUInt64.allocationSize(value.timestamp) +
        FfiConverterBool.allocationSize(value.isSeen) +
        FfiConverterTypeKnockRequestActions.allocationSize(value.actions)
      );
    }
  }
  return new FFIConverter();
})();

export type LocationContent = {
  body: string;
  geoUri: string;
  description: string | undefined;
  zoomLevel: /*u8*/ number | undefined;
  asset: AssetType | undefined;
};

/**
 * Generated factory for {@link LocationContent} record objects.
 */
export const LocationContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LocationContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LocationContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LocationContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LocationContent>,
  });
})();

const FfiConverterTypeLocationContent = (() => {
  type TypeName = LocationContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        geoUri: FfiConverterString.read(from),
        description: FfiConverterOptionalString.read(from),
        zoomLevel: FfiConverterOptionalUInt8.read(from),
        asset: FfiConverterOptionalTypeAssetType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterString.write(value.geoUri, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalUInt8.write(value.zoomLevel, into);
      FfiConverterOptionalTypeAssetType.write(value.asset, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterString.allocationSize(value.geoUri) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalUInt8.allocationSize(value.zoomLevel) +
        FfiConverterOptionalTypeAssetType.allocationSize(value.asset)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A Matrix entity that can be a room, room alias, user, or event, and a list
 * of via servers.
 */
export type MatrixEntity = {
  id: MatrixId;
  via: Array<string>;
};

/**
 * Generated factory for {@link MatrixEntity} record objects.
 */
export const MatrixEntity = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MatrixEntity, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MatrixEntity}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MatrixEntity}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MatrixEntity>,
  });
})();

const FfiConverterTypeMatrixEntity = (() => {
  type TypeName = MatrixEntity;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeMatrixId.read(from),
        via: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMatrixId.write(value.id, into);
      FfiConverterArrayString.write(value.via, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMatrixId.allocationSize(value.id) +
        FfiConverterArrayString.allocationSize(value.via)
      );
    }
  }
  return new FFIConverter();
})();

export type Mentions = {
  userIds: Array<string>;
  room: boolean;
};

/**
 * Generated factory for {@link Mentions} record objects.
 */
export const Mentions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Mentions, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Mentions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Mentions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Mentions>,
  });
})();

const FfiConverterTypeMentions = (() => {
  type TypeName = Mentions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userIds: FfiConverterArrayString.read(from),
        room: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.userIds, into);
      FfiConverterBool.write(value.room, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayString.allocationSize(value.userIds) +
        FfiConverterBool.allocationSize(value.room)
      );
    }
  }
  return new FFIConverter();
})();

export type MessageContent = {
  msgType: MessageType;
  body: string;
  inReplyTo: InReplyToDetailsInterface | undefined;
  threadRoot: string | undefined;
  isEdited: boolean;
  mentions: Mentions | undefined;
};

/**
 * Generated factory for {@link MessageContent} record objects.
 */
export const MessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MessageContent>,
  });
})();

const FfiConverterTypeMessageContent = (() => {
  type TypeName = MessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        msgType: FfiConverterTypeMessageType.read(from),
        body: FfiConverterString.read(from),
        inReplyTo: FfiConverterOptionalTypeInReplyToDetails.read(from),
        threadRoot: FfiConverterOptionalString.read(from),
        isEdited: FfiConverterBool.read(from),
        mentions: FfiConverterOptionalTypeMentions.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMessageType.write(value.msgType, into);
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeInReplyToDetails.write(value.inReplyTo, into);
      FfiConverterOptionalString.write(value.threadRoot, into);
      FfiConverterBool.write(value.isEdited, into);
      FfiConverterOptionalTypeMentions.write(value.mentions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMessageType.allocationSize(value.msgType) +
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeInReplyToDetails.allocationSize(
          value.inReplyTo
        ) +
        FfiConverterOptionalString.allocationSize(value.threadRoot) +
        FfiConverterBool.allocationSize(value.isEdited) +
        FfiConverterOptionalTypeMentions.allocationSize(value.mentions)
      );
    }
  }
  return new FFIConverter();
})();

export type NoticeMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
};

/**
 * Generated factory for {@link NoticeMessageContent} record objects.
 */
export const NoticeMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NoticeMessageContent,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NoticeMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NoticeMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NoticeMessageContent>,
  });
})();

const FfiConverterTypeNoticeMessageContent = (() => {
  type TypeName = NoticeMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted)
      );
    }
  }
  return new FFIConverter();
})();

export type NotificationItem = {
  event: NotificationEvent;
  senderInfo: NotificationSenderInfo;
  roomInfo: NotificationRoomInfo;
  /**
   * Is the notification supposed to be at the "noisy" level?
   * Can be `None` if we couldn't determine this, because we lacked
   * information to create a push context.
   */
  isNoisy: boolean | undefined;
  hasMention: boolean | undefined;
};

/**
 * Generated factory for {@link NotificationItem} record objects.
 */
export const NotificationItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<NotificationItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationItem}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NotificationItem}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NotificationItem>,
  });
})();

const FfiConverterTypeNotificationItem = (() => {
  type TypeName = NotificationItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        event: FfiConverterTypeNotificationEvent.read(from),
        senderInfo: FfiConverterTypeNotificationSenderInfo.read(from),
        roomInfo: FfiConverterTypeNotificationRoomInfo.read(from),
        isNoisy: FfiConverterOptionalBool.read(from),
        hasMention: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeNotificationEvent.write(value.event, into);
      FfiConverterTypeNotificationSenderInfo.write(value.senderInfo, into);
      FfiConverterTypeNotificationRoomInfo.write(value.roomInfo, into);
      FfiConverterOptionalBool.write(value.isNoisy, into);
      FfiConverterOptionalBool.write(value.hasMention, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeNotificationEvent.allocationSize(value.event) +
        FfiConverterTypeNotificationSenderInfo.allocationSize(
          value.senderInfo
        ) +
        FfiConverterTypeNotificationRoomInfo.allocationSize(value.roomInfo) +
        FfiConverterOptionalBool.allocationSize(value.isNoisy) +
        FfiConverterOptionalBool.allocationSize(value.hasMention)
      );
    }
  }
  return new FFIConverter();
})();

export type NotificationPowerLevels = {
  room: /*i32*/ number;
};

/**
 * Generated factory for {@link NotificationPowerLevels} record objects.
 */
export const NotificationPowerLevels = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NotificationPowerLevels,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NotificationPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<NotificationPowerLevels>,
  });
})();

const FfiConverterTypeNotificationPowerLevels = (() => {
  type TypeName = NotificationPowerLevels;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        room: FfiConverterInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt32.write(value.room, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterInt32.allocationSize(value.room);
    }
  }
  return new FFIConverter();
})();

export type NotificationRoomInfo = {
  displayName: string;
  avatarUrl: string | undefined;
  canonicalAlias: string | undefined;
  joinedMembersCount: /*u64*/ bigint;
  isEncrypted: boolean | undefined;
  isDirect: boolean;
};

/**
 * Generated factory for {@link NotificationRoomInfo} record objects.
 */
export const NotificationRoomInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NotificationRoomInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationRoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NotificationRoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NotificationRoomInfo>,
  });
})();

const FfiConverterTypeNotificationRoomInfo = (() => {
  type TypeName = NotificationRoomInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        displayName: FfiConverterString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
        joinedMembersCount: FfiConverterUInt64.read(from),
        isEncrypted: FfiConverterOptionalBool.read(from),
        isDirect: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
      FfiConverterUInt64.write(value.joinedMembersCount, into);
      FfiConverterOptionalBool.write(value.isEncrypted, into);
      FfiConverterBool.write(value.isDirect, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
        FfiConverterUInt64.allocationSize(value.joinedMembersCount) +
        FfiConverterOptionalBool.allocationSize(value.isEncrypted) +
        FfiConverterBool.allocationSize(value.isDirect)
      );
    }
  }
  return new FFIConverter();
})();

export type NotificationSenderInfo = {
  displayName: string | undefined;
  avatarUrl: string | undefined;
  isNameAmbiguous: boolean;
};

/**
 * Generated factory for {@link NotificationSenderInfo} record objects.
 */
export const NotificationSenderInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NotificationSenderInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationSenderInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NotificationSenderInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<NotificationSenderInfo>,
  });
})();

const FfiConverterTypeNotificationSenderInfo = (() => {
  type TypeName = NotificationSenderInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        isNameAmbiguous: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterBool.write(value.isNameAmbiguous, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterBool.allocationSize(value.isNameAmbiguous)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The configuration to use when authenticating with OIDC.
 */
export type OidcConfiguration = {
  /**
   * The name of the client that will be shown during OIDC authentication.
   */
  clientName: string | undefined;
  /**
   * The redirect URI that will be used when OIDC authentication is
   * successful.
   */
  redirectUri: string;
  /**
   * A URI that contains information about the client.
   */
  clientUri: string | undefined;
  /**
   * A URI that contains the client's logo.
   */
  logoUri: string | undefined;
  /**
   * A URI that contains the client's terms of service.
   */
  tosUri: string | undefined;
  /**
   * A URI that contains the client's privacy policy.
   */
  policyUri: string | undefined;
  /**
   * An array of e-mail addresses of people responsible for this client.
   */
  contacts: Array<string> | undefined;
  /**
   * Pre-configured registrations for use with issuers that don't support
   * dynamic client registration.
   */
  staticRegistrations: Map<string, string>;
  /**
   * A file path where any dynamic registrations should be stored.
   *
   * Suggested value: `{base_path}/oidc/registrations.json`
   */
  dynamicRegistrationsFile: string;
};

/**
 * Generated factory for {@link OidcConfiguration} record objects.
 */
export const OidcConfiguration = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<OidcConfiguration, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link OidcConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link OidcConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<OidcConfiguration>,
  });
})();

const FfiConverterTypeOidcConfiguration = (() => {
  type TypeName = OidcConfiguration;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        clientName: FfiConverterOptionalString.read(from),
        redirectUri: FfiConverterString.read(from),
        clientUri: FfiConverterOptionalString.read(from),
        logoUri: FfiConverterOptionalString.read(from),
        tosUri: FfiConverterOptionalString.read(from),
        policyUri: FfiConverterOptionalString.read(from),
        contacts: FfiConverterOptionalArrayString.read(from),
        staticRegistrations: FfiConverterMapStringString.read(from),
        dynamicRegistrationsFile: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.clientName, into);
      FfiConverterString.write(value.redirectUri, into);
      FfiConverterOptionalString.write(value.clientUri, into);
      FfiConverterOptionalString.write(value.logoUri, into);
      FfiConverterOptionalString.write(value.tosUri, into);
      FfiConverterOptionalString.write(value.policyUri, into);
      FfiConverterOptionalArrayString.write(value.contacts, into);
      FfiConverterMapStringString.write(value.staticRegistrations, into);
      FfiConverterString.write(value.dynamicRegistrationsFile, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.clientName) +
        FfiConverterString.allocationSize(value.redirectUri) +
        FfiConverterOptionalString.allocationSize(value.clientUri) +
        FfiConverterOptionalString.allocationSize(value.logoUri) +
        FfiConverterOptionalString.allocationSize(value.tosUri) +
        FfiConverterOptionalString.allocationSize(value.policyUri) +
        FfiConverterOptionalArrayString.allocationSize(value.contacts) +
        FfiConverterMapStringString.allocationSize(value.staticRegistrations) +
        FfiConverterString.allocationSize(value.dynamicRegistrationsFile)
      );
    }
  }
  return new FFIConverter();
})();

export type OidcCrossSigningResetInfo = {
  /**
   * The URL where the user can approve the reset of the cross-signing keys.
   */
  approvalUrl: string;
};

/**
 * Generated factory for {@link OidcCrossSigningResetInfo} record objects.
 */
export const OidcCrossSigningResetInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      OidcCrossSigningResetInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link OidcCrossSigningResetInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link OidcCrossSigningResetInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<OidcCrossSigningResetInfo>,
  });
})();

const FfiConverterTypeOidcCrossSigningResetInfo = (() => {
  type TypeName = OidcCrossSigningResetInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        approvalUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.approvalUrl, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.approvalUrl);
    }
  }
  return new FFIConverter();
})();

export type PollAnswer = {
  id: string;
  text: string;
};

/**
 * Generated factory for {@link PollAnswer} record objects.
 */
export const PollAnswer = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PollAnswer, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PollAnswer}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PollAnswer}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PollAnswer>,
  });
})();

const FfiConverterTypePollAnswer = (() => {
  type TypeName = PollAnswer;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        text: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.text, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.text)
      );
    }
  }
  return new FFIConverter();
})();

export type PollData = {
  question: string;
  answers: Array<string>;
  maxSelections: /*u8*/ number;
  pollKind: PollKind;
};

/**
 * Generated factory for {@link PollData} record objects.
 */
export const PollData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PollData, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PollData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PollData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PollData>,
  });
})();

const FfiConverterTypePollData = (() => {
  type TypeName = PollData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        question: FfiConverterString.read(from),
        answers: FfiConverterArrayString.read(from),
        maxSelections: FfiConverterUInt8.read(from),
        pollKind: FfiConverterTypePollKind.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.question, into);
      FfiConverterArrayString.write(value.answers, into);
      FfiConverterUInt8.write(value.maxSelections, into);
      FfiConverterTypePollKind.write(value.pollKind, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.question) +
        FfiConverterArrayString.allocationSize(value.answers) +
        FfiConverterUInt8.allocationSize(value.maxSelections) +
        FfiConverterTypePollKind.allocationSize(value.pollKind)
      );
    }
  }
  return new FFIConverter();
})();

export type PowerLevels = {
  usersDefault: /*i32*/ number | undefined;
  eventsDefault: /*i32*/ number | undefined;
  stateDefault: /*i32*/ number | undefined;
  ban: /*i32*/ number | undefined;
  kick: /*i32*/ number | undefined;
  redact: /*i32*/ number | undefined;
  invite: /*i32*/ number | undefined;
  notifications: NotificationPowerLevels | undefined;
  users: Map<string, /*i32*/ number>;
  events: Map<string, /*i32*/ number>;
};

/**
 * Generated factory for {@link PowerLevels} record objects.
 */
export const PowerLevels = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PowerLevels, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PowerLevels>,
  });
})();

const FfiConverterTypePowerLevels = (() => {
  type TypeName = PowerLevels;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        usersDefault: FfiConverterOptionalInt32.read(from),
        eventsDefault: FfiConverterOptionalInt32.read(from),
        stateDefault: FfiConverterOptionalInt32.read(from),
        ban: FfiConverterOptionalInt32.read(from),
        kick: FfiConverterOptionalInt32.read(from),
        redact: FfiConverterOptionalInt32.read(from),
        invite: FfiConverterOptionalInt32.read(from),
        notifications:
          FfiConverterOptionalTypeNotificationPowerLevels.read(from),
        users: FfiConverterMapStringInt32.read(from),
        events: FfiConverterMapStringInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt32.write(value.usersDefault, into);
      FfiConverterOptionalInt32.write(value.eventsDefault, into);
      FfiConverterOptionalInt32.write(value.stateDefault, into);
      FfiConverterOptionalInt32.write(value.ban, into);
      FfiConverterOptionalInt32.write(value.kick, into);
      FfiConverterOptionalInt32.write(value.redact, into);
      FfiConverterOptionalInt32.write(value.invite, into);
      FfiConverterOptionalTypeNotificationPowerLevels.write(
        value.notifications,
        into
      );
      FfiConverterMapStringInt32.write(value.users, into);
      FfiConverterMapStringInt32.write(value.events, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt32.allocationSize(value.usersDefault) +
        FfiConverterOptionalInt32.allocationSize(value.eventsDefault) +
        FfiConverterOptionalInt32.allocationSize(value.stateDefault) +
        FfiConverterOptionalInt32.allocationSize(value.ban) +
        FfiConverterOptionalInt32.allocationSize(value.kick) +
        FfiConverterOptionalInt32.allocationSize(value.redact) +
        FfiConverterOptionalInt32.allocationSize(value.invite) +
        FfiConverterOptionalTypeNotificationPowerLevels.allocationSize(
          value.notifications
        ) +
        FfiConverterMapStringInt32.allocationSize(value.users) +
        FfiConverterMapStringInt32.allocationSize(value.events)
      );
    }
  }
  return new FFIConverter();
})();

export type PusherIdentifiers = {
  pushkey: string;
  appId: string;
};

/**
 * Generated factory for {@link PusherIdentifiers} record objects.
 */
export const PusherIdentifiers = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PusherIdentifiers, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PusherIdentifiers}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PusherIdentifiers}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PusherIdentifiers>,
  });
})();

const FfiConverterTypePusherIdentifiers = (() => {
  type TypeName = PusherIdentifiers;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        pushkey: FfiConverterString.read(from),
        appId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.pushkey, into);
      FfiConverterString.write(value.appId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.pushkey) +
        FfiConverterString.allocationSize(value.appId)
      );
    }
  }
  return new FFIConverter();
})();

export type Reaction = {
  key: string;
  senders: Array<ReactionSenderData>;
};

/**
 * Generated factory for {@link Reaction} record objects.
 */
export const Reaction = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Reaction, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Reaction}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Reaction}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Reaction>,
  });
})();

const FfiConverterTypeReaction = (() => {
  type TypeName = Reaction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterString.read(from),
        senders: FfiConverterArrayTypeReactionSenderData.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.key, into);
      FfiConverterArrayTypeReactionSenderData.write(value.senders, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.key) +
        FfiConverterArrayTypeReactionSenderData.allocationSize(value.senders)
      );
    }
  }
  return new FFIConverter();
})();

export type ReactionSenderData = {
  senderId: string;
  timestamp: /*u64*/ bigint;
};

/**
 * Generated factory for {@link ReactionSenderData} record objects.
 */
export const ReactionSenderData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ReactionSenderData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReactionSenderData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReactionSenderData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReactionSenderData>,
  });
})();

const FfiConverterTypeReactionSenderData = (() => {
  type TypeName = ReactionSenderData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        senderId: FfiConverterString.read(from),
        timestamp: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.senderId, into);
      FfiConverterUInt64.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.senderId) +
        FfiConverterUInt64.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

export type Receipt = {
  timestamp: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link Receipt} record objects.
 */
export const Receipt = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Receipt, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Receipt}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Receipt}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Receipt>,
  });
})();

const FfiConverterTypeReceipt = (() => {
  type TypeName = Receipt;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        timestamp: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalUInt64.allocationSize(value.timestamp);
    }
  }
  return new FFIConverter();
})();

/**
 * The config to use for HTTP requests by default in this client.
 */
export type RequestConfig = {
  /**
   * Max number of retries.
   */
  retryLimit: /*u64*/ bigint | undefined;
  /**
   * Timeout for a request in milliseconds.
   */
  timeout: /*u64*/ bigint | undefined;
  /**
   * Max number of concurrent requests. No value means no limits.
   */
  maxConcurrentRequests: /*u64*/ bigint | undefined;
  /**
   * Base delay between retries.
   */
  retryTimeout: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link RequestConfig} record objects.
 */
export const RequestConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RequestConfig, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RequestConfig}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RequestConfig}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RequestConfig>,
  });
})();

const FfiConverterTypeRequestConfig = (() => {
  type TypeName = RequestConfig;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        retryLimit: FfiConverterOptionalUInt64.read(from),
        timeout: FfiConverterOptionalUInt64.read(from),
        maxConcurrentRequests: FfiConverterOptionalUInt64.read(from),
        retryTimeout: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.retryLimit, into);
      FfiConverterOptionalUInt64.write(value.timeout, into);
      FfiConverterOptionalUInt64.write(value.maxConcurrentRequests, into);
      FfiConverterOptionalUInt64.write(value.retryTimeout, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.retryLimit) +
        FfiConverterOptionalUInt64.allocationSize(value.timeout) +
        FfiConverterOptionalUInt64.allocationSize(value.maxConcurrentRequests) +
        FfiConverterOptionalUInt64.allocationSize(value.retryTimeout)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Information about a room, that was resolved from a room alias.
 */
export type ResolvedRoomAlias = {
  /**
   * The room ID that the alias resolved to.
   */
  roomId: string;
  /**
   * A list of servers that can be used to find the room by its room ID.
   */
  servers: Array<string>;
};

/**
 * Generated factory for {@link ResolvedRoomAlias} record objects.
 */
export const ResolvedRoomAlias = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ResolvedRoomAlias, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ResolvedRoomAlias}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ResolvedRoomAlias}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ResolvedRoomAlias>,
  });
})();

const FfiConverterTypeResolvedRoomAlias = (() => {
  type TypeName = ResolvedRoomAlias;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        servers: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterArrayString.write(value.servers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterArrayString.allocationSize(value.servers)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomDescription = {
  roomId: string;
  name: string | undefined;
  topic: string | undefined;
  alias: string | undefined;
  avatarUrl: string | undefined;
  joinRule: PublicRoomJoinRule | undefined;
  isWorldReadable: boolean;
  joinedMembers: /*u64*/ bigint;
};

/**
 * Generated factory for {@link RoomDescription} record objects.
 */
export const RoomDescription = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomDescription, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomDescription}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomDescription}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomDescription>,
  });
})();

const FfiConverterTypeRoomDescription = (() => {
  type TypeName = RoomDescription;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        alias: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        joinRule: FfiConverterOptionalTypePublicRoomJoinRule.read(from),
        isWorldReadable: FfiConverterBool.read(from),
        joinedMembers: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterOptionalString.write(value.alias, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterOptionalTypePublicRoomJoinRule.write(value.joinRule, into);
      FfiConverterBool.write(value.isWorldReadable, into);
      FfiConverterUInt64.write(value.joinedMembers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterOptionalString.allocationSize(value.alias) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterOptionalTypePublicRoomJoinRule.allocationSize(
          value.joinRule
        ) +
        FfiConverterBool.allocationSize(value.isWorldReadable) +
        FfiConverterUInt64.allocationSize(value.joinedMembers)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomDirectorySearchEntriesResult = {
  entriesStream: TaskHandleInterface;
};

/**
 * Generated factory for {@link RoomDirectorySearchEntriesResult} record objects.
 */
export const RoomDirectorySearchEntriesResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RoomDirectorySearchEntriesResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomDirectorySearchEntriesResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomDirectorySearchEntriesResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomDirectorySearchEntriesResult>,
  });
})();

const FfiConverterTypeRoomDirectorySearchEntriesResult = (() => {
  type TypeName = RoomDirectorySearchEntriesResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        entriesStream: FfiConverterTypeTaskHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeTaskHandle.write(value.entriesStream, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeTaskHandle.allocationSize(value.entriesStream);
    }
  }
  return new FFIConverter();
})();

/**
 * Information about a member considered to be a room hero.
 */
export type RoomHero = {
  /**
   * The user ID of the hero.
   */
  userId: string;
  /**
   * The display name of the hero.
   */
  displayName: string | undefined;
  /**
   * The avatar URL of the hero.
   */
  avatarUrl: string | undefined;
};

/**
 * Generated factory for {@link RoomHero} record objects.
 */
export const RoomHero = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomHero, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomHero}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomHero}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomHero>,
  });
})();

const FfiConverterTypeRoomHero = (() => {
  type TypeName = RoomHero;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomInfo = {
  id: string;
  creator: string | undefined;
  /**
   * The room's name from the room state event if received from sync, or one
   * that's been computed otherwise.
   */
  displayName: string | undefined;
  /**
   * Room name as defined by the room state event only.
   */
  rawName: string | undefined;
  topic: string | undefined;
  avatarUrl: string | undefined;
  isDirect: boolean;
  isPublic: boolean;
  isSpace: boolean;
  isTombstoned: boolean;
  isFavourite: boolean;
  canonicalAlias: string | undefined;
  alternativeAliases: Array<string>;
  membership: Membership;
  /**
   * Member who invited the current user to a room that's in the invited
   * state.
   *
   * Can be missing if the room membership invite event is missing from the
   * store.
   */
  inviter: RoomMember | undefined;
  heroes: Array<RoomHero>;
  activeMembersCount: /*u64*/ bigint;
  invitedMembersCount: /*u64*/ bigint;
  joinedMembersCount: /*u64*/ bigint;
  userPowerLevels: Map<string, /*i64*/ bigint>;
  highlightCount: /*u64*/ bigint;
  notificationCount: /*u64*/ bigint;
  cachedUserDefinedNotificationMode: RoomNotificationMode | undefined;
  hasRoomCall: boolean;
  activeRoomCallParticipants: Array<string>;
  /**
   * Whether this room has been explicitly marked as unread
   */
  isMarkedUnread: boolean;
  /**
   * "Interesting" messages received in that room, independently of the
   * notification settings.
   */
  numUnreadMessages: /*u64*/ bigint;
  /**
   * Events that will notify the user, according to their
   * notification settings.
   */
  numUnreadNotifications: /*u64*/ bigint;
  /**
   * Events causing mentions/highlights for the user, according to their
   * notification settings.
   */
  numUnreadMentions: /*u64*/ bigint;
  /**
   * The currently pinned event ids.
   */
  pinnedEventIds: Array<string>;
  /**
   * The join rule for this room, if known.
   */
  joinRule: JoinRule | undefined;
};

/**
 * Generated factory for {@link RoomInfo} record objects.
 */
export const RoomInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomInfo>,
  });
})();

const FfiConverterTypeRoomInfo = (() => {
  type TypeName = RoomInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        creator: FfiConverterOptionalString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        rawName: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        isDirect: FfiConverterBool.read(from),
        isPublic: FfiConverterBool.read(from),
        isSpace: FfiConverterBool.read(from),
        isTombstoned: FfiConverterBool.read(from),
        isFavourite: FfiConverterBool.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
        alternativeAliases: FfiConverterArrayString.read(from),
        membership: FfiConverterTypeMembership.read(from),
        inviter: FfiConverterOptionalTypeRoomMember.read(from),
        heroes: FfiConverterArrayTypeRoomHero.read(from),
        activeMembersCount: FfiConverterUInt64.read(from),
        invitedMembersCount: FfiConverterUInt64.read(from),
        joinedMembersCount: FfiConverterUInt64.read(from),
        userPowerLevels: FfiConverterMapStringInt64.read(from),
        highlightCount: FfiConverterUInt64.read(from),
        notificationCount: FfiConverterUInt64.read(from),
        cachedUserDefinedNotificationMode:
          FfiConverterOptionalTypeRoomNotificationMode.read(from),
        hasRoomCall: FfiConverterBool.read(from),
        activeRoomCallParticipants: FfiConverterArrayString.read(from),
        isMarkedUnread: FfiConverterBool.read(from),
        numUnreadMessages: FfiConverterUInt64.read(from),
        numUnreadNotifications: FfiConverterUInt64.read(from),
        numUnreadMentions: FfiConverterUInt64.read(from),
        pinnedEventIds: FfiConverterArrayString.read(from),
        joinRule: FfiConverterOptionalTypeJoinRule.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterOptionalString.write(value.creator, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.rawName, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterBool.write(value.isDirect, into);
      FfiConverterBool.write(value.isPublic, into);
      FfiConverterBool.write(value.isSpace, into);
      FfiConverterBool.write(value.isTombstoned, into);
      FfiConverterBool.write(value.isFavourite, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
      FfiConverterArrayString.write(value.alternativeAliases, into);
      FfiConverterTypeMembership.write(value.membership, into);
      FfiConverterOptionalTypeRoomMember.write(value.inviter, into);
      FfiConverterArrayTypeRoomHero.write(value.heroes, into);
      FfiConverterUInt64.write(value.activeMembersCount, into);
      FfiConverterUInt64.write(value.invitedMembersCount, into);
      FfiConverterUInt64.write(value.joinedMembersCount, into);
      FfiConverterMapStringInt64.write(value.userPowerLevels, into);
      FfiConverterUInt64.write(value.highlightCount, into);
      FfiConverterUInt64.write(value.notificationCount, into);
      FfiConverterOptionalTypeRoomNotificationMode.write(
        value.cachedUserDefinedNotificationMode,
        into
      );
      FfiConverterBool.write(value.hasRoomCall, into);
      FfiConverterArrayString.write(value.activeRoomCallParticipants, into);
      FfiConverterBool.write(value.isMarkedUnread, into);
      FfiConverterUInt64.write(value.numUnreadMessages, into);
      FfiConverterUInt64.write(value.numUnreadNotifications, into);
      FfiConverterUInt64.write(value.numUnreadMentions, into);
      FfiConverterArrayString.write(value.pinnedEventIds, into);
      FfiConverterOptionalTypeJoinRule.write(value.joinRule, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterOptionalString.allocationSize(value.creator) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.rawName) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterBool.allocationSize(value.isDirect) +
        FfiConverterBool.allocationSize(value.isPublic) +
        FfiConverterBool.allocationSize(value.isSpace) +
        FfiConverterBool.allocationSize(value.isTombstoned) +
        FfiConverterBool.allocationSize(value.isFavourite) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
        FfiConverterArrayString.allocationSize(value.alternativeAliases) +
        FfiConverterTypeMembership.allocationSize(value.membership) +
        FfiConverterOptionalTypeRoomMember.allocationSize(value.inviter) +
        FfiConverterArrayTypeRoomHero.allocationSize(value.heroes) +
        FfiConverterUInt64.allocationSize(value.activeMembersCount) +
        FfiConverterUInt64.allocationSize(value.invitedMembersCount) +
        FfiConverterUInt64.allocationSize(value.joinedMembersCount) +
        FfiConverterMapStringInt64.allocationSize(value.userPowerLevels) +
        FfiConverterUInt64.allocationSize(value.highlightCount) +
        FfiConverterUInt64.allocationSize(value.notificationCount) +
        FfiConverterOptionalTypeRoomNotificationMode.allocationSize(
          value.cachedUserDefinedNotificationMode
        ) +
        FfiConverterBool.allocationSize(value.hasRoomCall) +
        FfiConverterArrayString.allocationSize(
          value.activeRoomCallParticipants
        ) +
        FfiConverterBool.allocationSize(value.isMarkedUnread) +
        FfiConverterUInt64.allocationSize(value.numUnreadMessages) +
        FfiConverterUInt64.allocationSize(value.numUnreadNotifications) +
        FfiConverterUInt64.allocationSize(value.numUnreadMentions) +
        FfiConverterArrayString.allocationSize(value.pinnedEventIds) +
        FfiConverterOptionalTypeJoinRule.allocationSize(value.joinRule)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomListLoadingStateResult = {
  state: RoomListLoadingState;
  stateStream: TaskHandleInterface;
};

/**
 * Generated factory for {@link RoomListLoadingStateResult} record objects.
 */
export const RoomListLoadingStateResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RoomListLoadingStateResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomListLoadingStateResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomListLoadingStateResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomListLoadingStateResult>,
  });
})();

const FfiConverterTypeRoomListLoadingStateResult = (() => {
  type TypeName = RoomListLoadingStateResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        state: FfiConverterTypeRoomListLoadingState.read(from),
        stateStream: FfiConverterTypeTaskHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRoomListLoadingState.write(value.state, into);
      FfiConverterTypeTaskHandle.write(value.stateStream, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRoomListLoadingState.allocationSize(value.state) +
        FfiConverterTypeTaskHandle.allocationSize(value.stateStream)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomMember = {
  userId: string;
  displayName: string | undefined;
  avatarUrl: string | undefined;
  membership: MembershipState;
  isNameAmbiguous: boolean;
  powerLevel: /*i64*/ bigint;
  normalizedPowerLevel: /*i64*/ bigint;
  isIgnored: boolean;
  suggestedRoleForPowerLevel: RoomMemberRole;
};

/**
 * Generated factory for {@link RoomMember} record objects.
 */
export const RoomMember = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomMember, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomMember}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomMember}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomMember>,
  });
})();

const FfiConverterTypeRoomMember = (() => {
  type TypeName = RoomMember;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        membership: FfiConverterTypeMembershipState.read(from),
        isNameAmbiguous: FfiConverterBool.read(from),
        powerLevel: FfiConverterInt64.read(from),
        normalizedPowerLevel: FfiConverterInt64.read(from),
        isIgnored: FfiConverterBool.read(from),
        suggestedRoleForPowerLevel: FfiConverterTypeRoomMemberRole.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterTypeMembershipState.write(value.membership, into);
      FfiConverterBool.write(value.isNameAmbiguous, into);
      FfiConverterInt64.write(value.powerLevel, into);
      FfiConverterInt64.write(value.normalizedPowerLevel, into);
      FfiConverterBool.write(value.isIgnored, into);
      FfiConverterTypeRoomMemberRole.write(
        value.suggestedRoleForPowerLevel,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterTypeMembershipState.allocationSize(value.membership) +
        FfiConverterBool.allocationSize(value.isNameAmbiguous) +
        FfiConverterInt64.allocationSize(value.powerLevel) +
        FfiConverterInt64.allocationSize(value.normalizedPowerLevel) +
        FfiConverterBool.allocationSize(value.isIgnored) +
        FfiConverterTypeRoomMemberRole.allocationSize(
          value.suggestedRoleForPowerLevel
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * `RoomNotificationSettings` represents the current settings for a `Room`
 */
export type RoomNotificationSettings = {
  /**
   * The room notification mode
   */
  mode: RoomNotificationMode;
  /**
   * Whether the mode is the default one
   */
  isDefault: boolean;
};

/**
 * Generated factory for {@link RoomNotificationSettings} record objects.
 */
export const RoomNotificationSettings = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RoomNotificationSettings,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomNotificationSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomNotificationSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomNotificationSettings>,
  });
})();

const FfiConverterTypeRoomNotificationSettings = (() => {
  type TypeName = RoomNotificationSettings;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        mode: FfiConverterTypeRoomNotificationMode.read(from),
        isDefault: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRoomNotificationMode.write(value.mode, into);
      FfiConverterBool.write(value.isDefault, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRoomNotificationMode.allocationSize(value.mode) +
        FfiConverterBool.allocationSize(value.isDefault)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomPowerLevels = {
  /**
   * The level required to ban a user.
   */
  ban: /*i64*/ bigint;
  /**
   * The level required to invite a user.
   */
  invite: /*i64*/ bigint;
  /**
   * The level required to kick a user.
   */
  kick: /*i64*/ bigint;
  /**
   * The level required to redact an event.
   */
  redact: /*i64*/ bigint;
  /**
   * The default level required to send message events.
   */
  eventsDefault: /*i64*/ bigint;
  /**
   * The default level required to send state events.
   */
  stateDefault: /*i64*/ bigint;
  /**
   * The default power level for every user in the room.
   */
  usersDefault: /*i64*/ bigint;
  /**
   * The level required to change the room's name.
   */
  roomName: /*i64*/ bigint;
  /**
   * The level required to change the room's avatar.
   */
  roomAvatar: /*i64*/ bigint;
  /**
   * The level required to change the room's topic.
   */
  roomTopic: /*i64*/ bigint;
};

/**
 * Generated factory for {@link RoomPowerLevels} record objects.
 */
export const RoomPowerLevels = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomPowerLevels, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPowerLevels>,
  });
})();

const FfiConverterTypeRoomPowerLevels = (() => {
  type TypeName = RoomPowerLevels;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ban: FfiConverterInt64.read(from),
        invite: FfiConverterInt64.read(from),
        kick: FfiConverterInt64.read(from),
        redact: FfiConverterInt64.read(from),
        eventsDefault: FfiConverterInt64.read(from),
        stateDefault: FfiConverterInt64.read(from),
        usersDefault: FfiConverterInt64.read(from),
        roomName: FfiConverterInt64.read(from),
        roomAvatar: FfiConverterInt64.read(from),
        roomTopic: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt64.write(value.ban, into);
      FfiConverterInt64.write(value.invite, into);
      FfiConverterInt64.write(value.kick, into);
      FfiConverterInt64.write(value.redact, into);
      FfiConverterInt64.write(value.eventsDefault, into);
      FfiConverterInt64.write(value.stateDefault, into);
      FfiConverterInt64.write(value.usersDefault, into);
      FfiConverterInt64.write(value.roomName, into);
      FfiConverterInt64.write(value.roomAvatar, into);
      FfiConverterInt64.write(value.roomTopic, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterInt64.allocationSize(value.ban) +
        FfiConverterInt64.allocationSize(value.invite) +
        FfiConverterInt64.allocationSize(value.kick) +
        FfiConverterInt64.allocationSize(value.redact) +
        FfiConverterInt64.allocationSize(value.eventsDefault) +
        FfiConverterInt64.allocationSize(value.stateDefault) +
        FfiConverterInt64.allocationSize(value.usersDefault) +
        FfiConverterInt64.allocationSize(value.roomName) +
        FfiConverterInt64.allocationSize(value.roomAvatar) +
        FfiConverterInt64.allocationSize(value.roomTopic)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The preview of a room, be it invited/joined/left, or not.
 */
export type RoomPreviewInfo = {
  /**
   * The room id for this room.
   */
  roomId: string;
  /**
   * The canonical alias for the room.
   */
  canonicalAlias: string | undefined;
  /**
   * The room's name, if set.
   */
  name: string | undefined;
  /**
   * The room's topic, if set.
   */
  topic: string | undefined;
  /**
   * The MXC URI to the room's avatar, if set.
   */
  avatarUrl: string | undefined;
  /**
   * The number of joined members.
   */
  numJoinedMembers: /*u64*/ bigint;
  /**
   * The number of active members, if known (joined + invited).
   */
  numActiveMembers: /*u64*/ bigint | undefined;
  /**
   * The room type (space, custom) or nothing, if it's a regular room.
   */
  roomType: RoomType;
  /**
   * Is the history world-readable for this room?
   */
  isHistoryWorldReadable: boolean | undefined;
  /**
   * The membership state for the current user, if known.
   */
  membership: Membership | undefined;
  /**
   * The join rule for this room (private, public, knock, etc.).
   */
  joinRule: JoinRule;
  /**
   * Whether the room is direct or not, if known.
   */
  isDirect: boolean | undefined;
  /**
   * Room heroes.
   */
  heroes: Array<RoomHero> | undefined;
};

/**
 * Generated factory for {@link RoomPreviewInfo} record objects.
 */
export const RoomPreviewInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomPreviewInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPreviewInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomPreviewInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPreviewInfo>,
  });
})();

const FfiConverterTypeRoomPreviewInfo = (() => {
  type TypeName = RoomPreviewInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
        name: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        numJoinedMembers: FfiConverterUInt64.read(from),
        numActiveMembers: FfiConverterOptionalUInt64.read(from),
        roomType: FfiConverterTypeRoomType.read(from),
        isHistoryWorldReadable: FfiConverterOptionalBool.read(from),
        membership: FfiConverterOptionalTypeMembership.read(from),
        joinRule: FfiConverterTypeJoinRule.read(from),
        isDirect: FfiConverterOptionalBool.read(from),
        heroes: FfiConverterOptionalArrayTypeRoomHero.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterUInt64.write(value.numJoinedMembers, into);
      FfiConverterOptionalUInt64.write(value.numActiveMembers, into);
      FfiConverterTypeRoomType.write(value.roomType, into);
      FfiConverterOptionalBool.write(value.isHistoryWorldReadable, into);
      FfiConverterOptionalTypeMembership.write(value.membership, into);
      FfiConverterTypeJoinRule.write(value.joinRule, into);
      FfiConverterOptionalBool.write(value.isDirect, into);
      FfiConverterOptionalArrayTypeRoomHero.write(value.heroes, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterUInt64.allocationSize(value.numJoinedMembers) +
        FfiConverterOptionalUInt64.allocationSize(value.numActiveMembers) +
        FfiConverterTypeRoomType.allocationSize(value.roomType) +
        FfiConverterOptionalBool.allocationSize(value.isHistoryWorldReadable) +
        FfiConverterOptionalTypeMembership.allocationSize(value.membership) +
        FfiConverterTypeJoinRule.allocationSize(value.joinRule) +
        FfiConverterOptionalBool.allocationSize(value.isDirect) +
        FfiConverterOptionalArrayTypeRoomHero.allocationSize(value.heroes)
      );
    }
  }
  return new FFIConverter();
})();

export type SearchUsersResults = {
  results: Array<UserProfile>;
  limited: boolean;
};

/**
 * Generated factory for {@link SearchUsersResults} record objects.
 */
export const SearchUsersResults = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SearchUsersResults, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SearchUsersResults}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SearchUsersResults}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SearchUsersResults>,
  });
})();

const FfiConverterTypeSearchUsersResults = (() => {
  type TypeName = SearchUsersResults;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        results: FfiConverterArrayTypeUserProfile.read(from),
        limited: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeUserProfile.write(value.results, into);
      FfiConverterBool.write(value.limited, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeUserProfile.allocationSize(value.results) +
        FfiConverterBool.allocationSize(value.limited)
      );
    }
  }
  return new FFIConverter();
})();

export type Session = {
  /**
   * The access token used for this session.
   */
  accessToken: string;
  /**
   * The token used for [refreshing the access token], if any.
   *
   * [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
   */
  refreshToken: string | undefined;
  /**
   * The user the access token was issued for.
   */
  userId: string;
  /**
   * The ID of the client device.
   */
  deviceId: string;
  /**
   * The URL for the homeserver used for this session.
   */
  homeserverUrl: string;
  /**
   * Additional data for this session if OpenID Connect was used for
   * authentication.
   */
  oidcData: string | undefined;
  /**
   * The sliding sync version used for this session.
   */
  slidingSyncVersion: SlidingSyncVersion;
};

/**
 * Generated factory for {@link Session} record objects.
 */
export const Session = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Session, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Session}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Session}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Session>,
  });
})();

const FfiConverterTypeSession = (() => {
  type TypeName = Session;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        accessToken: FfiConverterString.read(from),
        refreshToken: FfiConverterOptionalString.read(from),
        userId: FfiConverterString.read(from),
        deviceId: FfiConverterString.read(from),
        homeserverUrl: FfiConverterString.read(from),
        oidcData: FfiConverterOptionalString.read(from),
        slidingSyncVersion: FfiConverterTypeSlidingSyncVersion.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.accessToken, into);
      FfiConverterOptionalString.write(value.refreshToken, into);
      FfiConverterString.write(value.userId, into);
      FfiConverterString.write(value.deviceId, into);
      FfiConverterString.write(value.homeserverUrl, into);
      FfiConverterOptionalString.write(value.oidcData, into);
      FfiConverterTypeSlidingSyncVersion.write(value.slidingSyncVersion, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.accessToken) +
        FfiConverterOptionalString.allocationSize(value.refreshToken) +
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterString.allocationSize(value.deviceId) +
        FfiConverterString.allocationSize(value.homeserverUrl) +
        FfiConverterOptionalString.allocationSize(value.oidcData) +
        FfiConverterTypeSlidingSyncVersion.allocationSize(
          value.slidingSyncVersion
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Details about the incoming verification request
 */
export type SessionVerificationRequestDetails = {
  senderId: string;
  flowId: string;
  deviceId: string;
  displayName: string | undefined;
  /**
   * First time this device was seen in milliseconds since epoch.
   */
  firstSeenTimestamp: /*u64*/ bigint;
};

/**
 * Generated factory for {@link SessionVerificationRequestDetails} record objects.
 */
export const SessionVerificationRequestDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SessionVerificationRequestDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SessionVerificationRequestDetails}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SessionVerificationRequestDetails}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<SessionVerificationRequestDetails>,
  });
})();

const FfiConverterTypeSessionVerificationRequestDetails = (() => {
  type TypeName = SessionVerificationRequestDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        senderId: FfiConverterString.read(from),
        flowId: FfiConverterString.read(from),
        deviceId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        firstSeenTimestamp: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.senderId, into);
      FfiConverterString.write(value.flowId, into);
      FfiConverterString.write(value.deviceId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterUInt64.write(value.firstSeenTimestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.senderId) +
        FfiConverterString.allocationSize(value.flowId) +
        FfiConverterString.allocationSize(value.deviceId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterUInt64.allocationSize(value.firstSeenTimestamp)
      );
    }
  }
  return new FFIConverter();
})();

export type SetData = {
  index: /*u32*/ number;
  item: TimelineItemInterface;
};

/**
 * Generated factory for {@link SetData} record objects.
 */
export const SetData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SetData, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SetData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SetData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SetData>,
  });
})();

const FfiConverterTypeSetData = (() => {
  type TypeName = SetData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        index: FfiConverterUInt32.read(from),
        item: FfiConverterTypeTimelineItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.index, into);
      FfiConverterTypeTimelineItem.write(value.item, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.index) +
        FfiConverterTypeTimelineItem.allocationSize(value.item)
      );
    }
  }
  return new FFIConverter();
})();

export type TextMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
};

/**
 * Generated factory for {@link TextMessageContent} record objects.
 */
export const TextMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TextMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TextMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TextMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TextMessageContent>,
  });
})();

const FfiConverterTypeTextMessageContent = (() => {
  type TypeName = TextMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted)
      );
    }
  }
  return new FFIConverter();
})();

export type ThumbnailInfo = {
  height: /*u64*/ bigint | undefined;
  width: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link ThumbnailInfo} record objects.
 */
export const ThumbnailInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ThumbnailInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ThumbnailInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ThumbnailInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ThumbnailInfo>,
  });
})();

const FfiConverterTypeThumbnailInfo = (() => {
  type TypeName = ThumbnailInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        height: FfiConverterOptionalUInt64.read(from),
        width: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.height, into);
      FfiConverterOptionalUInt64.write(value.width, into);
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.height) +
        FfiConverterOptionalUInt64.allocationSize(value.width) +
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size)
      );
    }
  }
  return new FFIConverter();
})();

export type TimelineUniqueId = {
  id: string;
};

/**
 * Generated factory for {@link TimelineUniqueId} record objects.
 */
export const TimelineUniqueId = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TimelineUniqueId, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TimelineUniqueId}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TimelineUniqueId}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TimelineUniqueId>,
  });
})();

const FfiConverterTypeTimelineUniqueId = (() => {
  type TypeName = TimelineUniqueId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.id);
    }
  }
  return new FFIConverter();
})();

export type TracingConfiguration = {
  /**
   * A filter line following the [RUST_LOG format].
   *
   * [RUST_LOG format]: https://rust-lang-nursery.github.io/rust-cookbook/development_tools/debugging/config_log.html
   */
  filter: string;
  /**
   * Whether to log to stdout, or in the logcat on Android.
   */
  writeToStdoutOrSystem: boolean;
  /**
   * If set, configures rotated log files where to write additional logs.
   */
  writeToFiles: TracingFileConfiguration | undefined;
};

/**
 * Generated factory for {@link TracingConfiguration} record objects.
 */
export const TracingConfiguration = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      TracingConfiguration,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TracingConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TracingConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TracingConfiguration>,
  });
})();

const FfiConverterTypeTracingConfiguration = (() => {
  type TypeName = TracingConfiguration;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filter: FfiConverterString.read(from),
        writeToStdoutOrSystem: FfiConverterBool.read(from),
        writeToFiles:
          FfiConverterOptionalTypeTracingFileConfiguration.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filter, into);
      FfiConverterBool.write(value.writeToStdoutOrSystem, into);
      FfiConverterOptionalTypeTracingFileConfiguration.write(
        value.writeToFiles,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filter) +
        FfiConverterBool.allocationSize(value.writeToStdoutOrSystem) +
        FfiConverterOptionalTypeTracingFileConfiguration.allocationSize(
          value.writeToFiles
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Configuration to save logs to (rotated) log-files.
 */
export type TracingFileConfiguration = {
  /**
   * Base location for all the log files.
   */
  path: string;
  /**
   * Prefix for the log files' names.
   */
  filePrefix: string;
  /**
   * Optional suffix for the log file's names.
   */
  fileSuffix: string | undefined;
  /**
   * Maximum number of rotated files.
   *
   * If not set, there's no max limit, i.e. the number of log files is
   * unlimited.
   */
  maxFiles: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link TracingFileConfiguration} record objects.
 */
export const TracingFileConfiguration = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      TracingFileConfiguration,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TracingFileConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TracingFileConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<TracingFileConfiguration>,
  });
})();

const FfiConverterTypeTracingFileConfiguration = (() => {
  type TypeName = TracingFileConfiguration;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        path: FfiConverterString.read(from),
        filePrefix: FfiConverterString.read(from),
        fileSuffix: FfiConverterOptionalString.read(from),
        maxFiles: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.path, into);
      FfiConverterString.write(value.filePrefix, into);
      FfiConverterOptionalString.write(value.fileSuffix, into);
      FfiConverterOptionalUInt64.write(value.maxFiles, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.path) +
        FfiConverterString.allocationSize(value.filePrefix) +
        FfiConverterOptionalString.allocationSize(value.fileSuffix) +
        FfiConverterOptionalUInt64.allocationSize(value.maxFiles)
      );
    }
  }
  return new FFIConverter();
})();

export type TransmissionProgress = {
  current: /*u64*/ bigint;
  total: /*u64*/ bigint;
};

/**
 * Generated factory for {@link TransmissionProgress} record objects.
 */
export const TransmissionProgress = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      TransmissionProgress,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TransmissionProgress}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TransmissionProgress}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TransmissionProgress>,
  });
})();

const FfiConverterTypeTransmissionProgress = (() => {
  type TypeName = TransmissionProgress;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        current: FfiConverterUInt64.read(from),
        total: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.current, into);
      FfiConverterUInt64.write(value.total, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.current) +
        FfiConverterUInt64.allocationSize(value.total)
      );
    }
  }
  return new FFIConverter();
})();

export type UnableToDecryptInfo = {
  /**
   * The identifier of the event that couldn't get decrypted.
   */
  eventId: string;
  /**
   * If the event could be decrypted late (that is, the event was encrypted
   * at first, but could be decrypted later on), then this indicates the
   * time it took to decrypt the event. If it is not set, this is
   * considered a definite UTD.
   *
   * If set, this is in milliseconds.
   */
  timeToDecryptMs: /*u64*/ bigint | undefined;
  /**
   * What we know about what caused this UTD. E.g. was this event sent when
   * we were not a member of this room?
   */
  cause: UtdCause;
  /**
   * The difference between the event creation time (`origin_server_ts`) and
   * the time our device was created. If negative, this event was sent
   * *before* our device was created.
   */
  eventLocalAgeMillis: /*i64*/ bigint;
  /**
   * Whether the user had verified their own identity at the point they
   * received the UTD event.
   */
  userTrustsOwnIdentity: boolean;
  /**
   * The homeserver of the user that sent the undecryptable event.
   */
  senderHomeserver: string;
  /**
   * Our local user's own homeserver, or `None` if the client is not logged
   * in.
   */
  ownHomeserver: string | undefined;
};

/**
 * Generated factory for {@link UnableToDecryptInfo} record objects.
 */
export const UnableToDecryptInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UnableToDecryptInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnableToDecryptInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UnableToDecryptInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UnableToDecryptInfo>,
  });
})();

const FfiConverterTypeUnableToDecryptInfo = (() => {
  type TypeName = UnableToDecryptInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        eventId: FfiConverterString.read(from),
        timeToDecryptMs: FfiConverterOptionalUInt64.read(from),
        cause: FfiConverterTypeUtdCause.read(from),
        eventLocalAgeMillis: FfiConverterInt64.read(from),
        userTrustsOwnIdentity: FfiConverterBool.read(from),
        senderHomeserver: FfiConverterString.read(from),
        ownHomeserver: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.eventId, into);
      FfiConverterOptionalUInt64.write(value.timeToDecryptMs, into);
      FfiConverterTypeUtdCause.write(value.cause, into);
      FfiConverterInt64.write(value.eventLocalAgeMillis, into);
      FfiConverterBool.write(value.userTrustsOwnIdentity, into);
      FfiConverterString.write(value.senderHomeserver, into);
      FfiConverterOptionalString.write(value.ownHomeserver, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.eventId) +
        FfiConverterOptionalUInt64.allocationSize(value.timeToDecryptMs) +
        FfiConverterTypeUtdCause.allocationSize(value.cause) +
        FfiConverterInt64.allocationSize(value.eventLocalAgeMillis) +
        FfiConverterBool.allocationSize(value.userTrustsOwnIdentity) +
        FfiConverterString.allocationSize(value.senderHomeserver) +
        FfiConverterOptionalString.allocationSize(value.ownHomeserver)
      );
    }
  }
  return new FFIConverter();
})();

export type UnstableAudioDetailsContent = {
  duration: UniffiDuration;
  waveform: Array</*u16*/ number>;
};

/**
 * Generated factory for {@link UnstableAudioDetailsContent} record objects.
 */
export const UnstableAudioDetailsContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UnstableAudioDetailsContent,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnstableAudioDetailsContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UnstableAudioDetailsContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<UnstableAudioDetailsContent>,
  });
})();

const FfiConverterTypeUnstableAudioDetailsContent = (() => {
  type TypeName = UnstableAudioDetailsContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        duration: FfiConverterDuration.read(from),
        waveform: FfiConverterArrayUInt16.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterDuration.write(value.duration, into);
      FfiConverterArrayUInt16.write(value.waveform, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterDuration.allocationSize(value.duration) +
        FfiConverterArrayUInt16.allocationSize(value.waveform)
      );
    }
  }
  return new FFIConverter();
})();

export type UnstableVoiceContent = {};

/**
 * Generated factory for {@link UnstableVoiceContent} record objects.
 */
export const UnstableVoiceContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UnstableVoiceContent,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnstableVoiceContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UnstableVoiceContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UnstableVoiceContent>,
  });
})();

const FfiConverterTypeUnstableVoiceContent = (() => {
  type TypeName = UnstableVoiceContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

/**
 * An update for a particular user's power level within the room.
 */
export type UserPowerLevelUpdate = {
  /**
   * The user ID of the user to update.
   */
  userId: string;
  /**
   * The power level to assign to the user.
   */
  powerLevel: /*i64*/ bigint;
};

/**
 * Generated factory for {@link UserPowerLevelUpdate} record objects.
 */
export const UserPowerLevelUpdate = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UserPowerLevelUpdate,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UserPowerLevelUpdate}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UserPowerLevelUpdate}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UserPowerLevelUpdate>,
  });
})();

const FfiConverterTypeUserPowerLevelUpdate = (() => {
  type TypeName = UserPowerLevelUpdate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        powerLevel: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterInt64.write(value.powerLevel, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterInt64.allocationSize(value.powerLevel)
      );
    }
  }
  return new FFIConverter();
})();

export type UserProfile = {
  userId: string;
  displayName: string | undefined;
  avatarUrl: string | undefined;
};

/**
 * Generated factory for {@link UserProfile} record objects.
 */
export const UserProfile = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UserProfile, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UserProfile}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UserProfile}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UserProfile>,
  });
})();

const FfiConverterTypeUserProfile = (() => {
  type TypeName = UserProfile;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type VideoInfo = {
  duration: UniffiDuration | undefined;
  height: /*u64*/ bigint | undefined;
  width: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
  thumbnailInfo: ThumbnailInfo | undefined;
  thumbnailSource: MediaSourceInterface | undefined;
  blurhash: string | undefined;
};

/**
 * Generated factory for {@link VideoInfo} record objects.
 */
export const VideoInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<VideoInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VideoInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VideoInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VideoInfo>,
  });
})();

const FfiConverterTypeVideoInfo = (() => {
  type TypeName = VideoInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        duration: FfiConverterOptionalDuration.read(from),
        height: FfiConverterOptionalUInt64.read(from),
        width: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
        thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
        blurhash: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalDuration.write(value.duration, into);
      FfiConverterOptionalUInt64.write(value.height, into);
      FfiConverterOptionalUInt64.write(value.width, into);
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
      FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
      FfiConverterOptionalString.write(value.blurhash, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalDuration.allocationSize(value.duration) +
        FfiConverterOptionalUInt64.allocationSize(value.height) +
        FfiConverterOptionalUInt64.allocationSize(value.width) +
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalTypeThumbnailInfo.allocationSize(
          value.thumbnailInfo
        ) +
        FfiConverterOptionalTypeMediaSource.allocationSize(
          value.thumbnailSource
        ) +
        FfiConverterOptionalString.allocationSize(value.blurhash)
      );
    }
  }
  return new FFIConverter();
})();

export type VideoMessageContent = {
  /**
   * The computed filename, for use in a client.
   */
  filename: string;
  caption: string | undefined;
  formattedCaption: FormattedBody | undefined;
  source: MediaSourceInterface;
  info: VideoInfo | undefined;
};

/**
 * Generated factory for {@link VideoMessageContent} record objects.
 */
export const VideoMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<VideoMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VideoMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VideoMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VideoMessageContent>,
  });
})();

const FfiConverterTypeVideoMessageContent = (() => {
  type TypeName = VideoMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filename: FfiConverterString.read(from),
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeVideoInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filename, into);
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeVideoInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filename) +
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeVideoInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Properties to create a new virtual Element Call widget.
 */
export type VirtualElementCallWidgetOptions = {
  /**
   * The url to the app.
   *
   * E.g. <https://call.element.io>, <https://call.element.dev>
   */
  elementCallUrl: string;
  /**
   * The widget id.
   */
  widgetId: string;
  /**
   * The url that is used as the target for the PostMessages sent
   * by the widget (to the client).
   *
   * For a web app client this is the client url. In case of using other
   * platforms the client most likely is setup up to listen to
   * postmessages in the same webview the widget is hosted. In this case
   * the `parent_url` is set to the url of the webview with the widget. Be
   * aware that this means that the widget will receive its own postmessage
   * messages. The `matrix-widget-api` (js) ignores those so this works but
   * it might break custom implementations.
   *
   * Defaults to `element_call_url` for the non-iframe (dedicated webview)
   * usecase.
   */
  parentUrl: string | undefined;
  /**
   * Whether the branding header of Element call should be hidden.
   *
   * Default: `true`
   */
  hideHeader: boolean | undefined;
  /**
   * If set, the lobby will be skipped and the widget will join the
   * call on the `io.element.join` action.
   *
   * Default: `false`
   */
  preload: boolean | undefined;
  /**
   * The font scale which will be used inside element call.
   *
   * Default: `1`
   */
  fontScale: /*f64*/ number | undefined;
  /**
   * Whether element call should prompt the user to open in the browser or
   * the app.
   *
   * Default: `false`
   */
  appPrompt: boolean | undefined;
  /**
   * Don't show the lobby and join the call immediately.
   *
   * Default: `false`
   */
  skipLobby: boolean | undefined;
  /**
   * Make it not possible to get to the calls list in the webview.
   *
   * Default: `true`
   */
  confineToRoom: boolean | undefined;
  /**
   * The font to use, to adapt to the system font.
   */
  font: string | undefined;
  /**
   * Can be used to pass a PostHog id to element call.
   */
  analyticsId: string | undefined;
  /**
   * The encryption system to use.
   *
   * Use `EncryptionSystem::Unencrypted` to disable encryption.
   */
  encryption: EncryptionSystem;
};

/**
 * Generated factory for {@link VirtualElementCallWidgetOptions} record objects.
 */
export const VirtualElementCallWidgetOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      VirtualElementCallWidgetOptions,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VirtualElementCallWidgetOptions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VirtualElementCallWidgetOptions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<VirtualElementCallWidgetOptions>,
  });
})();

const FfiConverterTypeVirtualElementCallWidgetOptions = (() => {
  type TypeName = VirtualElementCallWidgetOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        elementCallUrl: FfiConverterString.read(from),
        widgetId: FfiConverterString.read(from),
        parentUrl: FfiConverterOptionalString.read(from),
        hideHeader: FfiConverterOptionalBool.read(from),
        preload: FfiConverterOptionalBool.read(from),
        fontScale: FfiConverterOptionalFloat64.read(from),
        appPrompt: FfiConverterOptionalBool.read(from),
        skipLobby: FfiConverterOptionalBool.read(from),
        confineToRoom: FfiConverterOptionalBool.read(from),
        font: FfiConverterOptionalString.read(from),
        analyticsId: FfiConverterOptionalString.read(from),
        encryption: FfiConverterTypeEncryptionSystem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.elementCallUrl, into);
      FfiConverterString.write(value.widgetId, into);
      FfiConverterOptionalString.write(value.parentUrl, into);
      FfiConverterOptionalBool.write(value.hideHeader, into);
      FfiConverterOptionalBool.write(value.preload, into);
      FfiConverterOptionalFloat64.write(value.fontScale, into);
      FfiConverterOptionalBool.write(value.appPrompt, into);
      FfiConverterOptionalBool.write(value.skipLobby, into);
      FfiConverterOptionalBool.write(value.confineToRoom, into);
      FfiConverterOptionalString.write(value.font, into);
      FfiConverterOptionalString.write(value.analyticsId, into);
      FfiConverterTypeEncryptionSystem.write(value.encryption, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.elementCallUrl) +
        FfiConverterString.allocationSize(value.widgetId) +
        FfiConverterOptionalString.allocationSize(value.parentUrl) +
        FfiConverterOptionalBool.allocationSize(value.hideHeader) +
        FfiConverterOptionalBool.allocationSize(value.preload) +
        FfiConverterOptionalFloat64.allocationSize(value.fontScale) +
        FfiConverterOptionalBool.allocationSize(value.appPrompt) +
        FfiConverterOptionalBool.allocationSize(value.skipLobby) +
        FfiConverterOptionalBool.allocationSize(value.confineToRoom) +
        FfiConverterOptionalString.allocationSize(value.font) +
        FfiConverterOptionalString.allocationSize(value.analyticsId) +
        FfiConverterTypeEncryptionSystem.allocationSize(value.encryption)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Capabilities that a widget can request from a client.
 */
export type WidgetCapabilities = {
  /**
   * Types of the messages that a widget wants to be able to fetch.
   */
  read: Array<WidgetEventFilter>;
  /**
   * Types of the messages that a widget wants to be able to send.
   */
  send: Array<WidgetEventFilter>;
  /**
   * If this capability is requested by the widget, it can not operate
   * separately from the matrix client.
   *
   * This means clients should not offer to open the widget in a separate
   * browser/tab/webview that is not connected to the postmessage widget-api.
   */
  requiresClient: boolean;
  /**
   * This allows the widget to ask the client to update delayed events.
   */
  updateDelayedEvent: boolean;
  /**
   * This allows the widget to send events with a delay.
   */
  sendDelayedEvent: boolean;
};

/**
 * Generated factory for {@link WidgetCapabilities} record objects.
 */
export const WidgetCapabilities = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<WidgetCapabilities, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WidgetCapabilities}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WidgetCapabilities}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WidgetCapabilities>,
  });
})();

const FfiConverterTypeWidgetCapabilities = (() => {
  type TypeName = WidgetCapabilities;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        read: FfiConverterArrayTypeWidgetEventFilter.read(from),
        send: FfiConverterArrayTypeWidgetEventFilter.read(from),
        requiresClient: FfiConverterBool.read(from),
        updateDelayedEvent: FfiConverterBool.read(from),
        sendDelayedEvent: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeWidgetEventFilter.write(value.read, into);
      FfiConverterArrayTypeWidgetEventFilter.write(value.send, into);
      FfiConverterBool.write(value.requiresClient, into);
      FfiConverterBool.write(value.updateDelayedEvent, into);
      FfiConverterBool.write(value.sendDelayedEvent, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeWidgetEventFilter.allocationSize(value.read) +
        FfiConverterArrayTypeWidgetEventFilter.allocationSize(value.send) +
        FfiConverterBool.allocationSize(value.requiresClient) +
        FfiConverterBool.allocationSize(value.updateDelayedEvent) +
        FfiConverterBool.allocationSize(value.sendDelayedEvent)
      );
    }
  }
  return new FFIConverter();
})();

export type WidgetDriverAndHandle = {
  driver: WidgetDriverInterface;
  handle: WidgetDriverHandleInterface;
};

/**
 * Generated factory for {@link WidgetDriverAndHandle} record objects.
 */
export const WidgetDriverAndHandle = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      WidgetDriverAndHandle,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WidgetDriverAndHandle}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WidgetDriverAndHandle}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WidgetDriverAndHandle>,
  });
})();

const FfiConverterTypeWidgetDriverAndHandle = (() => {
  type TypeName = WidgetDriverAndHandle;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        driver: FfiConverterTypeWidgetDriver.read(from),
        handle: FfiConverterTypeWidgetDriverHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeWidgetDriver.write(value.driver, into);
      FfiConverterTypeWidgetDriverHandle.write(value.handle, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeWidgetDriver.allocationSize(value.driver) +
        FfiConverterTypeWidgetDriverHandle.allocationSize(value.handle)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Information about a widget.
 */
export type WidgetSettings = {
  /**
   * Widget's unique identifier.
   */
  widgetId: string;
  /**
   * Whether or not the widget should be initialized on load message
   * (`ContentLoad` message), or upon creation/attaching of the widget to
   * the SDK's state machine that drives the API.
   */
  initAfterContentLoad: boolean;
  /**
   * This contains the url from the widget state event.
   * In this url placeholders can be used to pass information from the client
   * to the widget. Possible values are: `$widgetId`, `$parentUrl`,
   * `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
   *
   * # Examples
   *
   * e.g `http://widget.domain?username=$userId`
   * will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
   */
  rawUrl: string;
};

/**
 * Generated factory for {@link WidgetSettings} record objects.
 */
export const WidgetSettings = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<WidgetSettings, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WidgetSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WidgetSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WidgetSettings>,
  });
})();

const FfiConverterTypeWidgetSettings = (() => {
  type TypeName = WidgetSettings;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        widgetId: FfiConverterString.read(from),
        initAfterContentLoad: FfiConverterBool.read(from),
        rawUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.widgetId, into);
      FfiConverterBool.write(value.initAfterContentLoad, into);
      FfiConverterString.write(value.rawUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.widgetId) +
        FfiConverterBool.allocationSize(value.initAfterContentLoad) +
        FfiConverterString.allocationSize(value.rawUrl)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Enum: AccountManagementAction
export enum AccountManagementAction_Tags {
  Profile = 'Profile',
  SessionsList = 'SessionsList',
  SessionView = 'SessionView',
  SessionEnd = 'SessionEnd',
  AccountDeactivate = 'AccountDeactivate',
  CrossSigningReset = 'CrossSigningReset',
}
export const AccountManagementAction = (() => {
  type Profile__interface = {
    tag: AccountManagementAction_Tags.Profile;
  };

  class Profile_ extends UniffiEnum implements Profile__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.Profile;
    constructor() {
      super('AccountManagementAction', 'Profile');
    }

    static new(): Profile_ {
      return new Profile_();
    }

    static instanceOf(obj: any): obj is Profile_ {
      return obj.tag === AccountManagementAction_Tags.Profile;
    }
  }

  type SessionsList__interface = {
    tag: AccountManagementAction_Tags.SessionsList;
  };

  class SessionsList_ extends UniffiEnum implements SessionsList__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.SessionsList;
    constructor() {
      super('AccountManagementAction', 'SessionsList');
    }

    static new(): SessionsList_ {
      return new SessionsList_();
    }

    static instanceOf(obj: any): obj is SessionsList_ {
      return obj.tag === AccountManagementAction_Tags.SessionsList;
    }
  }

  type SessionView__interface = {
    tag: AccountManagementAction_Tags.SessionView;
    inner: Readonly<{ deviceId: string }>;
  };

  class SessionView_ extends UniffiEnum implements SessionView__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.SessionView;
    readonly inner: Readonly<{ deviceId: string }>;
    constructor(inner: { deviceId: string }) {
      super('AccountManagementAction', 'SessionView');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { deviceId: string }): SessionView_ {
      return new SessionView_(inner);
    }

    static instanceOf(obj: any): obj is SessionView_ {
      return obj.tag === AccountManagementAction_Tags.SessionView;
    }
  }

  type SessionEnd__interface = {
    tag: AccountManagementAction_Tags.SessionEnd;
    inner: Readonly<{ deviceId: string }>;
  };

  class SessionEnd_ extends UniffiEnum implements SessionEnd__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.SessionEnd;
    readonly inner: Readonly<{ deviceId: string }>;
    constructor(inner: { deviceId: string }) {
      super('AccountManagementAction', 'SessionEnd');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { deviceId: string }): SessionEnd_ {
      return new SessionEnd_(inner);
    }

    static instanceOf(obj: any): obj is SessionEnd_ {
      return obj.tag === AccountManagementAction_Tags.SessionEnd;
    }
  }

  type AccountDeactivate__interface = {
    tag: AccountManagementAction_Tags.AccountDeactivate;
  };

  class AccountDeactivate_
    extends UniffiEnum
    implements AccountDeactivate__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.AccountDeactivate;
    constructor() {
      super('AccountManagementAction', 'AccountDeactivate');
    }

    static new(): AccountDeactivate_ {
      return new AccountDeactivate_();
    }

    static instanceOf(obj: any): obj is AccountDeactivate_ {
      return obj.tag === AccountManagementAction_Tags.AccountDeactivate;
    }
  }

  type CrossSigningReset__interface = {
    tag: AccountManagementAction_Tags.CrossSigningReset;
  };

  class CrossSigningReset_
    extends UniffiEnum
    implements CrossSigningReset__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.CrossSigningReset;
    constructor() {
      super('AccountManagementAction', 'CrossSigningReset');
    }

    static new(): CrossSigningReset_ {
      return new CrossSigningReset_();
    }

    static instanceOf(obj: any): obj is CrossSigningReset_ {
      return obj.tag === AccountManagementAction_Tags.CrossSigningReset;
    }
  }

  function instanceOf(obj: any): obj is AccountManagementAction {
    return obj[uniffiTypeNameSymbol] === 'AccountManagementAction';
  }

  return Object.freeze({
    instanceOf,
    Profile: Profile_,
    SessionsList: SessionsList_,
    SessionView: SessionView_,
    SessionEnd: SessionEnd_,
    AccountDeactivate: AccountDeactivate_,
    CrossSigningReset: CrossSigningReset_,
  });
})();

export type AccountManagementAction = InstanceType<
  (typeof AccountManagementAction)[keyof Omit<
    typeof AccountManagementAction,
    'instanceOf'
  >]
>;

// FfiConverter for enum AccountManagementAction
const FfiConverterTypeAccountManagementAction = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AccountManagementAction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AccountManagementAction.Profile();
        case 2:
          return new AccountManagementAction.SessionsList();
        case 3:
          return new AccountManagementAction.SessionView({
            deviceId: FfiConverterString.read(from),
          });
        case 4:
          return new AccountManagementAction.SessionEnd({
            deviceId: FfiConverterString.read(from),
          });
        case 5:
          return new AccountManagementAction.AccountDeactivate();
        case 6:
          return new AccountManagementAction.CrossSigningReset();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AccountManagementAction_Tags.Profile: {
          ordinalConverter.write(1, into);
          return;
        }
        case AccountManagementAction_Tags.SessionsList: {
          ordinalConverter.write(2, into);
          return;
        }
        case AccountManagementAction_Tags.SessionView: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.deviceId, into);
          return;
        }
        case AccountManagementAction_Tags.SessionEnd: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.deviceId, into);
          return;
        }
        case AccountManagementAction_Tags.AccountDeactivate: {
          ordinalConverter.write(5, into);
          return;
        }
        case AccountManagementAction_Tags.CrossSigningReset: {
          ordinalConverter.write(6, into);
          return;
        }
        default:
          // Throwing from here means that AccountManagementAction_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AccountManagementAction_Tags.Profile: {
          return ordinalConverter.allocationSize(1);
        }
        case AccountManagementAction_Tags.SessionsList: {
          return ordinalConverter.allocationSize(2);
        }
        case AccountManagementAction_Tags.SessionView: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.deviceId);
          return size;
        }
        case AccountManagementAction_Tags.SessionEnd: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.deviceId);
          return size;
        }
        case AccountManagementAction_Tags.AccountDeactivate: {
          return ordinalConverter.allocationSize(5);
        }
        case AccountManagementAction_Tags.CrossSigningReset: {
          return ordinalConverter.allocationSize(6);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: AllowRule
export enum AllowRule_Tags {
  RoomMembership = 'RoomMembership',
  Custom = 'Custom',
}
/**
 * An allow rule which defines a condition that allows joining a room.
 */
export const AllowRule = (() => {
  type RoomMembership__interface = {
    tag: AllowRule_Tags.RoomMembership;
    inner: Readonly<{ roomId: string }>;
  };

  /**
   * Only a member of the `room_id` Room can join the one this rule is used
   * in.
   */
  class RoomMembership_
    extends UniffiEnum
    implements RoomMembership__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AllowRule';
    readonly tag = AllowRule_Tags.RoomMembership;
    readonly inner: Readonly<{ roomId: string }>;
    constructor(inner: { roomId: string }) {
      super('AllowRule', 'RoomMembership');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomId: string }): RoomMembership_ {
      return new RoomMembership_(inner);
    }

    static instanceOf(obj: any): obj is RoomMembership_ {
      return obj.tag === AllowRule_Tags.RoomMembership;
    }
  }

  type Custom__interface = {
    tag: AllowRule_Tags.Custom;
    inner: Readonly<{ json: string }>;
  };

  /**
   * A custom allow rule implementation, containing its JSON representation
   * as a `String`.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AllowRule';
    readonly tag = AllowRule_Tags.Custom;
    readonly inner: Readonly<{ json: string }>;
    constructor(inner: { json: string }) {
      super('AllowRule', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { json: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === AllowRule_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is AllowRule {
    return obj[uniffiTypeNameSymbol] === 'AllowRule';
  }

  return Object.freeze({
    instanceOf,
    RoomMembership: RoomMembership_,
    Custom: Custom_,
  });
})();

/**
 * An allow rule which defines a condition that allows joining a room.
 */

export type AllowRule = InstanceType<
  (typeof AllowRule)[keyof Omit<typeof AllowRule, 'instanceOf'>]
>;

// FfiConverter for enum AllowRule
const FfiConverterTypeAllowRule = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AllowRule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AllowRule.RoomMembership({
            roomId: FfiConverterString.read(from),
          });
        case 2:
          return new AllowRule.Custom({ json: FfiConverterString.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AllowRule_Tags.RoomMembership: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomId, into);
          return;
        }
        case AllowRule_Tags.Custom: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.json, into);
          return;
        }
        default:
          // Throwing from here means that AllowRule_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AllowRule_Tags.RoomMembership: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.roomId);
          return size;
        }
        case AllowRule_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.json);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum AssetType {
  Sender,
  Pin,
}

const FfiConverterTypeAssetType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AssetType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return AssetType.Sender;
        case 2:
          return AssetType.Pin;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case AssetType.Sender:
          return ordinalConverter.write(1, into);
        case AssetType.Pin:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: AuthData
export enum AuthData_Tags {
  Password = 'Password',
}
export const AuthData = (() => {
  type Password__interface = {
    tag: AuthData_Tags.Password;
    inner: Readonly<{ passwordDetails: AuthDataPasswordDetails }>;
  };

  /**
   * Password-based authentication (`m.login.password`).
   */
  class Password_ extends UniffiEnum implements Password__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AuthData';
    readonly tag = AuthData_Tags.Password;
    readonly inner: Readonly<{ passwordDetails: AuthDataPasswordDetails }>;
    constructor(inner: { passwordDetails: AuthDataPasswordDetails }) {
      super('AuthData', 'Password');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { passwordDetails: AuthDataPasswordDetails }): Password_ {
      return new Password_(inner);
    }

    static instanceOf(obj: any): obj is Password_ {
      return obj.tag === AuthData_Tags.Password;
    }
  }

  function instanceOf(obj: any): obj is AuthData {
    return obj[uniffiTypeNameSymbol] === 'AuthData';
  }

  return Object.freeze({
    instanceOf,
    Password: Password_,
  });
})();

export type AuthData = InstanceType<
  (typeof AuthData)[keyof Omit<typeof AuthData, 'instanceOf'>]
>;

// FfiConverter for enum AuthData
const FfiConverterTypeAuthData = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AuthData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AuthData.Password({
            passwordDetails: FfiConverterTypeAuthDataPasswordDetails.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AuthData_Tags.Password: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeAuthDataPasswordDetails.write(
            inner.passwordDetails,
            into
          );
          return;
        }
        default:
          // Throwing from here means that AuthData_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AuthData_Tags.Password: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeAuthDataPasswordDetails.allocationSize(
            inner.passwordDetails
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum BackupState {
  Unknown,
  Creating,
  Enabling,
  Resuming,
  Enabled,
  Downloading,
  Disabling,
}

const FfiConverterTypeBackupState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BackupState.Unknown;
        case 2:
          return BackupState.Creating;
        case 3:
          return BackupState.Enabling;
        case 4:
          return BackupState.Resuming;
        case 5:
          return BackupState.Enabled;
        case 6:
          return BackupState.Downloading;
        case 7:
          return BackupState.Disabling;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BackupState.Unknown:
          return ordinalConverter.write(1, into);
        case BackupState.Creating:
          return ordinalConverter.write(2, into);
        case BackupState.Enabling:
          return ordinalConverter.write(3, into);
        case BackupState.Resuming:
          return ordinalConverter.write(4, into);
        case BackupState.Enabled:
          return ordinalConverter.write(5, into);
        case BackupState.Downloading:
          return ordinalConverter.write(6, into);
        case BackupState.Disabling:
          return ordinalConverter.write(7, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: BackupUploadState
export enum BackupUploadState_Tags {
  Waiting = 'Waiting',
  Uploading = 'Uploading',
  Error = 'Error',
  Done = 'Done',
}
export const BackupUploadState = (() => {
  type Waiting__interface = {
    tag: BackupUploadState_Tags.Waiting;
  };

  class Waiting_ extends UniffiEnum implements Waiting__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BackupUploadState';
    readonly tag = BackupUploadState_Tags.Waiting;
    constructor() {
      super('BackupUploadState', 'Waiting');
    }

    static new(): Waiting_ {
      return new Waiting_();
    }

    static instanceOf(obj: any): obj is Waiting_ {
      return obj.tag === BackupUploadState_Tags.Waiting;
    }
  }

  type Uploading__interface = {
    tag: BackupUploadState_Tags.Uploading;
    inner: Readonly<{
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }>;
  };

  class Uploading_ extends UniffiEnum implements Uploading__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BackupUploadState';
    readonly tag = BackupUploadState_Tags.Uploading;
    readonly inner: Readonly<{
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }>;
    constructor(inner: {
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }) {
      super('BackupUploadState', 'Uploading');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }): Uploading_ {
      return new Uploading_(inner);
    }

    static instanceOf(obj: any): obj is Uploading_ {
      return obj.tag === BackupUploadState_Tags.Uploading;
    }
  }

  type Error__interface = {
    tag: BackupUploadState_Tags.Error;
  };

  class Error_ extends UniffiEnum implements Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BackupUploadState';
    readonly tag = BackupUploadState_Tags.Error;
    constructor() {
      super('BackupUploadState', 'Error');
    }

    static new(): Error_ {
      return new Error_();
    }

    static instanceOf(obj: any): obj is Error_ {
      return obj.tag === BackupUploadState_Tags.Error;
    }
  }

  type Done__interface = {
    tag: BackupUploadState_Tags.Done;
  };

  class Done_ extends UniffiEnum implements Done__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BackupUploadState';
    readonly tag = BackupUploadState_Tags.Done;
    constructor() {
      super('BackupUploadState', 'Done');
    }

    static new(): Done_ {
      return new Done_();
    }

    static instanceOf(obj: any): obj is Done_ {
      return obj.tag === BackupUploadState_Tags.Done;
    }
  }

  function instanceOf(obj: any): obj is BackupUploadState {
    return obj[uniffiTypeNameSymbol] === 'BackupUploadState';
  }

  return Object.freeze({
    instanceOf,
    Waiting: Waiting_,
    Uploading: Uploading_,
    Error: Error_,
    Done: Done_,
  });
})();

export type BackupUploadState = InstanceType<
  (typeof BackupUploadState)[keyof Omit<typeof BackupUploadState, 'instanceOf'>]
>;

// FfiConverter for enum BackupUploadState
const FfiConverterTypeBackupUploadState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupUploadState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new BackupUploadState.Waiting();
        case 2:
          return new BackupUploadState.Uploading({
            backedUpCount: FfiConverterUInt32.read(from),
            totalCount: FfiConverterUInt32.read(from),
          });
        case 3:
          return new BackupUploadState.Error();
        case 4:
          return new BackupUploadState.Done();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case BackupUploadState_Tags.Waiting: {
          ordinalConverter.write(1, into);
          return;
        }
        case BackupUploadState_Tags.Uploading: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.backedUpCount, into);
          FfiConverterUInt32.write(inner.totalCount, into);
          return;
        }
        case BackupUploadState_Tags.Error: {
          ordinalConverter.write(3, into);
          return;
        }
        case BackupUploadState_Tags.Done: {
          ordinalConverter.write(4, into);
          return;
        }
        default:
          // Throwing from here means that BackupUploadState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case BackupUploadState_Tags.Waiting: {
          return ordinalConverter.allocationSize(1);
        }
        case BackupUploadState_Tags.Uploading: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt32.allocationSize(inner.backedUpCount);
          size += FfiConverterUInt32.allocationSize(inner.totalCount);
          return size;
        }
        case BackupUploadState_Tags.Error: {
          return ordinalConverter.allocationSize(3);
        }
        case BackupUploadState_Tags.Done: {
          return ordinalConverter.allocationSize(4);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: ClientBuildError
export enum ClientBuildError_Tags {
  InvalidServerName = 'InvalidServerName',
  ServerUnreachable = 'ServerUnreachable',
  WellKnownLookupFailed = 'WellKnownLookupFailed',
  WellKnownDeserializationError = 'WellKnownDeserializationError',
  SlidingSync = 'SlidingSync',
  SlidingSyncVersion = 'SlidingSyncVersion',
  Sdk = 'Sdk',
  EventCache = 'EventCache',
  Generic = 'Generic',
}
export const ClientBuildError = (() => {
  class InvalidServerName extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = ClientBuildError_Tags.InvalidServerName;

    constructor(message: string) {
      super('ClientBuildError', 'InvalidServerName', message);
    }

    static instanceOf(e: any): e is InvalidServerName {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class ServerUnreachable extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = ClientBuildError_Tags.ServerUnreachable;

    constructor(message: string) {
      super('ClientBuildError', 'ServerUnreachable', message);
    }

    static instanceOf(e: any): e is ServerUnreachable {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class WellKnownLookupFailed extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = ClientBuildError_Tags.WellKnownLookupFailed;

    constructor(message: string) {
      super('ClientBuildError', 'WellKnownLookupFailed', message);
    }

    static instanceOf(e: any): e is WellKnownLookupFailed {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class WellKnownDeserializationError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = ClientBuildError_Tags.WellKnownDeserializationError;

    constructor(message: string) {
      super('ClientBuildError', 'WellKnownDeserializationError', message);
    }

    static instanceOf(e: any): e is WellKnownDeserializationError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class SlidingSync extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = ClientBuildError_Tags.SlidingSync;

    constructor(message: string) {
      super('ClientBuildError', 'SlidingSync', message);
    }

    static instanceOf(e: any): e is SlidingSync {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class SlidingSyncVersion extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = ClientBuildError_Tags.SlidingSyncVersion;

    constructor(message: string) {
      super('ClientBuildError', 'SlidingSyncVersion', message);
    }

    static instanceOf(e: any): e is SlidingSyncVersion {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  class Sdk extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = ClientBuildError_Tags.Sdk;

    constructor(message: string) {
      super('ClientBuildError', 'Sdk', message);
    }

    static instanceOf(e: any): e is Sdk {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  class EventCache extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = ClientBuildError_Tags.EventCache;

    constructor(message: string) {
      super('ClientBuildError', 'EventCache', message);
    }

    static instanceOf(e: any): e is EventCache {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = ClientBuildError_Tags.Generic;

    constructor(message: string) {
      super('ClientBuildError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is ClientBuildError {
    return (e as any)[uniffiTypeNameSymbol] === 'ClientBuildError';
  }
  return {
    InvalidServerName,
    ServerUnreachable,
    WellKnownLookupFailed,
    WellKnownDeserializationError,
    SlidingSync,
    SlidingSyncVersion,
    Sdk,
    EventCache,
    Generic,
    instanceOf,
  };
})();

// Union type for ClientBuildError error type.

export type ClientBuildError = InstanceType<
  (typeof ClientBuildError)[keyof Omit<typeof ClientBuildError, 'instanceOf'>]
>;

const FfiConverterTypeClientBuildError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = ClientBuildError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new ClientBuildError.InvalidServerName(
            FfiConverterString.read(from)
          );

        case 2:
          return new ClientBuildError.ServerUnreachable(
            FfiConverterString.read(from)
          );

        case 3:
          return new ClientBuildError.WellKnownLookupFailed(
            FfiConverterString.read(from)
          );

        case 4:
          return new ClientBuildError.WellKnownDeserializationError(
            FfiConverterString.read(from)
          );

        case 5:
          return new ClientBuildError.SlidingSync(
            FfiConverterString.read(from)
          );

        case 6:
          return new ClientBuildError.SlidingSyncVersion(
            FfiConverterString.read(from)
          );

        case 7:
          return new ClientBuildError.Sdk(FfiConverterString.read(from));

        case 8:
          return new ClientBuildError.EventCache(FfiConverterString.read(from));

        case 9:
          return new ClientBuildError.Generic(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Error type: ClientError

// Enum: ClientError
export enum ClientError_Tags {
  Generic = 'Generic',
}
export const ClientError = (() => {
  type Generic__interface = {
    tag: ClientError_Tags.Generic;
    inner: Readonly<{ msg: string }>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientError';
    readonly tag = ClientError_Tags.Generic;
    readonly inner: Readonly<{ msg: string }>;
    constructor(inner: { msg: string }) {
      super('ClientError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === ClientError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<{ msg: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is ClientError {
    return obj[uniffiTypeNameSymbol] === 'ClientError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
  });
})();

export type ClientError = InstanceType<
  (typeof ClientError)[keyof Omit<typeof ClientError, 'instanceOf'>]
>;

// FfiConverter for enum ClientError
const FfiConverterTypeClientError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ClientError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ClientError.Generic({
            msg: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ClientError_Tags.Generic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          return;
        }
        default:
          // Throwing from here means that ClientError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ClientError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.msg);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ComposerDraftType
export enum ComposerDraftType_Tags {
  NewMessage = 'NewMessage',
  Reply = 'Reply',
  Edit = 'Edit',
}
/**
 * The type of draft of the composer.
 */
export const ComposerDraftType = (() => {
  type NewMessage__interface = {
    tag: ComposerDraftType_Tags.NewMessage;
  };

  /**
   * The draft is a new message.
   */
  class NewMessage_ extends UniffiEnum implements NewMessage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ComposerDraftType';
    readonly tag = ComposerDraftType_Tags.NewMessage;
    constructor() {
      super('ComposerDraftType', 'NewMessage');
    }

    static new(): NewMessage_ {
      return new NewMessage_();
    }

    static instanceOf(obj: any): obj is NewMessage_ {
      return obj.tag === ComposerDraftType_Tags.NewMessage;
    }
  }

  type Reply__interface = {
    tag: ComposerDraftType_Tags.Reply;
    inner: Readonly<{ eventId: string }>;
  };

  /**
   * The draft is a reply to an event.
   */
  class Reply_ extends UniffiEnum implements Reply__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ComposerDraftType';
    readonly tag = ComposerDraftType_Tags.Reply;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: {
      /**
       * The ID of the event being replied to.
       */ eventId: string;
    }) {
      super('ComposerDraftType', 'Reply');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The ID of the event being replied to.
       */ eventId: string;
    }): Reply_ {
      return new Reply_(inner);
    }

    static instanceOf(obj: any): obj is Reply_ {
      return obj.tag === ComposerDraftType_Tags.Reply;
    }
  }

  type Edit__interface = {
    tag: ComposerDraftType_Tags.Edit;
    inner: Readonly<{ eventId: string }>;
  };

  /**
   * The draft is an edit of an event.
   */
  class Edit_ extends UniffiEnum implements Edit__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ComposerDraftType';
    readonly tag = ComposerDraftType_Tags.Edit;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: {
      /**
       * The ID of the event being edited.
       */ eventId: string;
    }) {
      super('ComposerDraftType', 'Edit');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The ID of the event being edited.
       */ eventId: string;
    }): Edit_ {
      return new Edit_(inner);
    }

    static instanceOf(obj: any): obj is Edit_ {
      return obj.tag === ComposerDraftType_Tags.Edit;
    }
  }

  function instanceOf(obj: any): obj is ComposerDraftType {
    return obj[uniffiTypeNameSymbol] === 'ComposerDraftType';
  }

  return Object.freeze({
    instanceOf,
    NewMessage: NewMessage_,
    Reply: Reply_,
    Edit: Edit_,
  });
})();

/**
 * The type of draft of the composer.
 */

export type ComposerDraftType = InstanceType<
  (typeof ComposerDraftType)[keyof Omit<typeof ComposerDraftType, 'instanceOf'>]
>;

// FfiConverter for enum ComposerDraftType
const FfiConverterTypeComposerDraftType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ComposerDraftType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ComposerDraftType.NewMessage();
        case 2:
          return new ComposerDraftType.Reply({
            eventId: FfiConverterString.read(from),
          });
        case 3:
          return new ComposerDraftType.Edit({
            eventId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ComposerDraftType_Tags.NewMessage: {
          ordinalConverter.write(1, into);
          return;
        }
        case ComposerDraftType_Tags.Reply: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case ComposerDraftType_Tags.Edit: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        default:
          // Throwing from here means that ComposerDraftType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ComposerDraftType_Tags.NewMessage: {
          return ordinalConverter.allocationSize(1);
        }
        case ComposerDraftType_Tags.Reply: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case ComposerDraftType_Tags.Edit: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: CrossSigningResetAuthType
export enum CrossSigningResetAuthType_Tags {
  Uiaa = 'Uiaa',
  Oidc = 'Oidc',
}
export const CrossSigningResetAuthType = (() => {
  type Uiaa__interface = {
    tag: CrossSigningResetAuthType_Tags.Uiaa;
  };

  /**
   * The homeserver requires user-interactive authentication.
   */
  class Uiaa_ extends UniffiEnum implements Uiaa__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CrossSigningResetAuthType';
    readonly tag = CrossSigningResetAuthType_Tags.Uiaa;
    constructor() {
      super('CrossSigningResetAuthType', 'Uiaa');
    }

    static new(): Uiaa_ {
      return new Uiaa_();
    }

    static instanceOf(obj: any): obj is Uiaa_ {
      return obj.tag === CrossSigningResetAuthType_Tags.Uiaa;
    }
  }

  type Oidc__interface = {
    tag: CrossSigningResetAuthType_Tags.Oidc;
    inner: Readonly<{ info: OidcCrossSigningResetInfo }>;
  };

  class Oidc_ extends UniffiEnum implements Oidc__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CrossSigningResetAuthType';
    readonly tag = CrossSigningResetAuthType_Tags.Oidc;
    readonly inner: Readonly<{ info: OidcCrossSigningResetInfo }>;
    constructor(inner: { info: OidcCrossSigningResetInfo }) {
      super('CrossSigningResetAuthType', 'Oidc');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { info: OidcCrossSigningResetInfo }): Oidc_ {
      return new Oidc_(inner);
    }

    static instanceOf(obj: any): obj is Oidc_ {
      return obj.tag === CrossSigningResetAuthType_Tags.Oidc;
    }
  }

  function instanceOf(obj: any): obj is CrossSigningResetAuthType {
    return obj[uniffiTypeNameSymbol] === 'CrossSigningResetAuthType';
  }

  return Object.freeze({
    instanceOf,
    Uiaa: Uiaa_,
    Oidc: Oidc_,
  });
})();

export type CrossSigningResetAuthType = InstanceType<
  (typeof CrossSigningResetAuthType)[keyof Omit<
    typeof CrossSigningResetAuthType,
    'instanceOf'
  >]
>;

// FfiConverter for enum CrossSigningResetAuthType
const FfiConverterTypeCrossSigningResetAuthType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = CrossSigningResetAuthType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new CrossSigningResetAuthType.Uiaa();
        case 2:
          return new CrossSigningResetAuthType.Oidc({
            info: FfiConverterTypeOidcCrossSigningResetInfo.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case CrossSigningResetAuthType_Tags.Uiaa: {
          ordinalConverter.write(1, into);
          return;
        }
        case CrossSigningResetAuthType_Tags.Oidc: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeOidcCrossSigningResetInfo.write(inner.info, into);
          return;
        }
        default:
          // Throwing from here means that CrossSigningResetAuthType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case CrossSigningResetAuthType_Tags.Uiaa: {
          return ordinalConverter.allocationSize(1);
        }
        case CrossSigningResetAuthType_Tags.Oidc: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeOidcCrossSigningResetInfo.allocationSize(
            inner.info
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Changes how date dividers get inserted, either in between each day or in
 * between each month
 */
export enum DateDividerMode {
  Daily,
  Monthly,
}

const FfiConverterTypeDateDividerMode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = DateDividerMode;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return DateDividerMode.Daily;
        case 2:
          return DateDividerMode.Monthly;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case DateDividerMode.Daily:
          return ordinalConverter.write(1, into);
        case DateDividerMode.Monthly:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: EditedContent
export enum EditedContent_Tags {
  RoomMessage = 'RoomMessage',
  MediaCaption = 'MediaCaption',
  PollStart = 'PollStart',
}
export const EditedContent = (() => {
  type RoomMessage__interface = {
    tag: EditedContent_Tags.RoomMessage;
    inner: Readonly<{
      content: RoomMessageEventContentWithoutRelationInterface;
    }>;
  };

  class RoomMessage_ extends UniffiEnum implements RoomMessage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EditedContent';
    readonly tag = EditedContent_Tags.RoomMessage;
    readonly inner: Readonly<{
      content: RoomMessageEventContentWithoutRelationInterface;
    }>;
    constructor(inner: {
      content: RoomMessageEventContentWithoutRelationInterface;
    }) {
      super('EditedContent', 'RoomMessage');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      content: RoomMessageEventContentWithoutRelationInterface;
    }): RoomMessage_ {
      return new RoomMessage_(inner);
    }

    static instanceOf(obj: any): obj is RoomMessage_ {
      return obj.tag === EditedContent_Tags.RoomMessage;
    }
  }

  type MediaCaption__interface = {
    tag: EditedContent_Tags.MediaCaption;
    inner: Readonly<{
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }>;
  };

  class MediaCaption_ extends UniffiEnum implements MediaCaption__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EditedContent';
    readonly tag = EditedContent_Tags.MediaCaption;
    readonly inner: Readonly<{
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }>;
    constructor(inner: {
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }) {
      super('EditedContent', 'MediaCaption');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }): MediaCaption_ {
      return new MediaCaption_(inner);
    }

    static instanceOf(obj: any): obj is MediaCaption_ {
      return obj.tag === EditedContent_Tags.MediaCaption;
    }
  }

  type PollStart__interface = {
    tag: EditedContent_Tags.PollStart;
    inner: Readonly<{ pollData: PollData }>;
  };

  class PollStart_ extends UniffiEnum implements PollStart__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EditedContent';
    readonly tag = EditedContent_Tags.PollStart;
    readonly inner: Readonly<{ pollData: PollData }>;
    constructor(inner: { pollData: PollData }) {
      super('EditedContent', 'PollStart');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { pollData: PollData }): PollStart_ {
      return new PollStart_(inner);
    }

    static instanceOf(obj: any): obj is PollStart_ {
      return obj.tag === EditedContent_Tags.PollStart;
    }
  }

  function instanceOf(obj: any): obj is EditedContent {
    return obj[uniffiTypeNameSymbol] === 'EditedContent';
  }

  return Object.freeze({
    instanceOf,
    RoomMessage: RoomMessage_,
    MediaCaption: MediaCaption_,
    PollStart: PollStart_,
  });
})();

export type EditedContent = InstanceType<
  (typeof EditedContent)[keyof Omit<typeof EditedContent, 'instanceOf'>]
>;

// FfiConverter for enum EditedContent
const FfiConverterTypeEditedContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EditedContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EditedContent.RoomMessage({
            content:
              FfiConverterTypeRoomMessageEventContentWithoutRelation.read(from),
          });
        case 2:
          return new EditedContent.MediaCaption({
            caption: FfiConverterOptionalString.read(from),
            formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
          });
        case 3:
          return new EditedContent.PollStart({
            pollData: FfiConverterTypePollData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EditedContent_Tags.RoomMessage: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeRoomMessageEventContentWithoutRelation.write(
            inner.content,
            into
          );
          return;
        }
        case EditedContent_Tags.MediaCaption: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.caption, into);
          FfiConverterOptionalTypeFormattedBody.write(
            inner.formattedCaption,
            into
          );
          return;
        }
        case EditedContent_Tags.PollStart: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypePollData.write(inner.pollData, into);
          return;
        }
        default:
          // Throwing from here means that EditedContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EditedContent_Tags.RoomMessage: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size +=
            FfiConverterTypeRoomMessageEventContentWithoutRelation.allocationSize(
              inner.content
            );
          return size;
        }
        case EditedContent_Tags.MediaCaption: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalString.allocationSize(inner.caption);
          size += FfiConverterOptionalTypeFormattedBody.allocationSize(
            inner.formattedCaption
          );
          return size;
        }
        case EditedContent_Tags.PollStart: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypePollData.allocationSize(inner.pollData);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EnableRecoveryProgress
export enum EnableRecoveryProgress_Tags {
  Starting = 'Starting',
  CreatingBackup = 'CreatingBackup',
  CreatingRecoveryKey = 'CreatingRecoveryKey',
  BackingUp = 'BackingUp',
  RoomKeyUploadError = 'RoomKeyUploadError',
  Done = 'Done',
}
export const EnableRecoveryProgress = (() => {
  type Starting__interface = {
    tag: EnableRecoveryProgress_Tags.Starting;
  };

  class Starting_ extends UniffiEnum implements Starting__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.Starting;
    constructor() {
      super('EnableRecoveryProgress', 'Starting');
    }

    static new(): Starting_ {
      return new Starting_();
    }

    static instanceOf(obj: any): obj is Starting_ {
      return obj.tag === EnableRecoveryProgress_Tags.Starting;
    }
  }

  type CreatingBackup__interface = {
    tag: EnableRecoveryProgress_Tags.CreatingBackup;
  };

  class CreatingBackup_
    extends UniffiEnum
    implements CreatingBackup__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.CreatingBackup;
    constructor() {
      super('EnableRecoveryProgress', 'CreatingBackup');
    }

    static new(): CreatingBackup_ {
      return new CreatingBackup_();
    }

    static instanceOf(obj: any): obj is CreatingBackup_ {
      return obj.tag === EnableRecoveryProgress_Tags.CreatingBackup;
    }
  }

  type CreatingRecoveryKey__interface = {
    tag: EnableRecoveryProgress_Tags.CreatingRecoveryKey;
  };

  class CreatingRecoveryKey_
    extends UniffiEnum
    implements CreatingRecoveryKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.CreatingRecoveryKey;
    constructor() {
      super('EnableRecoveryProgress', 'CreatingRecoveryKey');
    }

    static new(): CreatingRecoveryKey_ {
      return new CreatingRecoveryKey_();
    }

    static instanceOf(obj: any): obj is CreatingRecoveryKey_ {
      return obj.tag === EnableRecoveryProgress_Tags.CreatingRecoveryKey;
    }
  }

  type BackingUp__interface = {
    tag: EnableRecoveryProgress_Tags.BackingUp;
    inner: Readonly<{
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }>;
  };

  class BackingUp_ extends UniffiEnum implements BackingUp__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.BackingUp;
    readonly inner: Readonly<{
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }>;
    constructor(inner: {
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }) {
      super('EnableRecoveryProgress', 'BackingUp');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }): BackingUp_ {
      return new BackingUp_(inner);
    }

    static instanceOf(obj: any): obj is BackingUp_ {
      return obj.tag === EnableRecoveryProgress_Tags.BackingUp;
    }
  }

  type RoomKeyUploadError__interface = {
    tag: EnableRecoveryProgress_Tags.RoomKeyUploadError;
  };

  class RoomKeyUploadError_
    extends UniffiEnum
    implements RoomKeyUploadError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.RoomKeyUploadError;
    constructor() {
      super('EnableRecoveryProgress', 'RoomKeyUploadError');
    }

    static new(): RoomKeyUploadError_ {
      return new RoomKeyUploadError_();
    }

    static instanceOf(obj: any): obj is RoomKeyUploadError_ {
      return obj.tag === EnableRecoveryProgress_Tags.RoomKeyUploadError;
    }
  }

  type Done__interface = {
    tag: EnableRecoveryProgress_Tags.Done;
    inner: Readonly<{ recoveryKey: string }>;
  };

  class Done_ extends UniffiEnum implements Done__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.Done;
    readonly inner: Readonly<{ recoveryKey: string }>;
    constructor(inner: { recoveryKey: string }) {
      super('EnableRecoveryProgress', 'Done');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { recoveryKey: string }): Done_ {
      return new Done_(inner);
    }

    static instanceOf(obj: any): obj is Done_ {
      return obj.tag === EnableRecoveryProgress_Tags.Done;
    }
  }

  function instanceOf(obj: any): obj is EnableRecoveryProgress {
    return obj[uniffiTypeNameSymbol] === 'EnableRecoveryProgress';
  }

  return Object.freeze({
    instanceOf,
    Starting: Starting_,
    CreatingBackup: CreatingBackup_,
    CreatingRecoveryKey: CreatingRecoveryKey_,
    BackingUp: BackingUp_,
    RoomKeyUploadError: RoomKeyUploadError_,
    Done: Done_,
  });
})();

export type EnableRecoveryProgress = InstanceType<
  (typeof EnableRecoveryProgress)[keyof Omit<
    typeof EnableRecoveryProgress,
    'instanceOf'
  >]
>;

// FfiConverter for enum EnableRecoveryProgress
const FfiConverterTypeEnableRecoveryProgress = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EnableRecoveryProgress;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EnableRecoveryProgress.Starting();
        case 2:
          return new EnableRecoveryProgress.CreatingBackup();
        case 3:
          return new EnableRecoveryProgress.CreatingRecoveryKey();
        case 4:
          return new EnableRecoveryProgress.BackingUp({
            backedUpCount: FfiConverterUInt32.read(from),
            totalCount: FfiConverterUInt32.read(from),
          });
        case 5:
          return new EnableRecoveryProgress.RoomKeyUploadError();
        case 6:
          return new EnableRecoveryProgress.Done({
            recoveryKey: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EnableRecoveryProgress_Tags.Starting: {
          ordinalConverter.write(1, into);
          return;
        }
        case EnableRecoveryProgress_Tags.CreatingBackup: {
          ordinalConverter.write(2, into);
          return;
        }
        case EnableRecoveryProgress_Tags.CreatingRecoveryKey: {
          ordinalConverter.write(3, into);
          return;
        }
        case EnableRecoveryProgress_Tags.BackingUp: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.backedUpCount, into);
          FfiConverterUInt32.write(inner.totalCount, into);
          return;
        }
        case EnableRecoveryProgress_Tags.RoomKeyUploadError: {
          ordinalConverter.write(5, into);
          return;
        }
        case EnableRecoveryProgress_Tags.Done: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.recoveryKey, into);
          return;
        }
        default:
          // Throwing from here means that EnableRecoveryProgress_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EnableRecoveryProgress_Tags.Starting: {
          return ordinalConverter.allocationSize(1);
        }
        case EnableRecoveryProgress_Tags.CreatingBackup: {
          return ordinalConverter.allocationSize(2);
        }
        case EnableRecoveryProgress_Tags.CreatingRecoveryKey: {
          return ordinalConverter.allocationSize(3);
        }
        case EnableRecoveryProgress_Tags.BackingUp: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterUInt32.allocationSize(inner.backedUpCount);
          size += FfiConverterUInt32.allocationSize(inner.totalCount);
          return size;
        }
        case EnableRecoveryProgress_Tags.RoomKeyUploadError: {
          return ordinalConverter.allocationSize(5);
        }
        case EnableRecoveryProgress_Tags.Done: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.recoveryKey);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EncryptedMessage
export enum EncryptedMessage_Tags {
  OlmV1Curve25519AesSha2 = 'OlmV1Curve25519AesSha2',
  MegolmV1AesSha2 = 'MegolmV1AesSha2',
  Unknown = 'Unknown',
}
export const EncryptedMessage = (() => {
  type OlmV1Curve25519AesSha2__interface = {
    tag: EncryptedMessage_Tags.OlmV1Curve25519AesSha2;
    inner: Readonly<{ senderKey: string }>;
  };

  class OlmV1Curve25519AesSha2_
    extends UniffiEnum
    implements OlmV1Curve25519AesSha2__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptedMessage';
    readonly tag = EncryptedMessage_Tags.OlmV1Curve25519AesSha2;
    readonly inner: Readonly<{ senderKey: string }>;
    constructor(inner: {
      /**
       * The Curve25519 key of the sender.
       */ senderKey: string;
    }) {
      super('EncryptedMessage', 'OlmV1Curve25519AesSha2');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The Curve25519 key of the sender.
       */ senderKey: string;
    }): OlmV1Curve25519AesSha2_ {
      return new OlmV1Curve25519AesSha2_(inner);
    }

    static instanceOf(obj: any): obj is OlmV1Curve25519AesSha2_ {
      return obj.tag === EncryptedMessage_Tags.OlmV1Curve25519AesSha2;
    }
  }

  type MegolmV1AesSha2__interface = {
    tag: EncryptedMessage_Tags.MegolmV1AesSha2;
    inner: Readonly<{ sessionId: string; cause: UtdCause }>;
  };

  class MegolmV1AesSha2_
    extends UniffiEnum
    implements MegolmV1AesSha2__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptedMessage';
    readonly tag = EncryptedMessage_Tags.MegolmV1AesSha2;
    readonly inner: Readonly<{ sessionId: string; cause: UtdCause }>;
    constructor(inner: {
      /**
       * The ID of the session used to encrypt the message.
       */ sessionId: string;
      /**
       * What we know about what caused this UTD. E.g. was this event sent
       * when we were not a member of this room?
       */ cause: UtdCause;
    }) {
      super('EncryptedMessage', 'MegolmV1AesSha2');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The ID of the session used to encrypt the message.
       */ sessionId: string;
      /**
       * What we know about what caused this UTD. E.g. was this event sent
       * when we were not a member of this room?
       */ cause: UtdCause;
    }): MegolmV1AesSha2_ {
      return new MegolmV1AesSha2_(inner);
    }

    static instanceOf(obj: any): obj is MegolmV1AesSha2_ {
      return obj.tag === EncryptedMessage_Tags.MegolmV1AesSha2;
    }
  }

  type Unknown__interface = {
    tag: EncryptedMessage_Tags.Unknown;
  };

  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptedMessage';
    readonly tag = EncryptedMessage_Tags.Unknown;
    constructor() {
      super('EncryptedMessage', 'Unknown');
    }

    static new(): Unknown_ {
      return new Unknown_();
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === EncryptedMessage_Tags.Unknown;
    }
  }

  function instanceOf(obj: any): obj is EncryptedMessage {
    return obj[uniffiTypeNameSymbol] === 'EncryptedMessage';
  }

  return Object.freeze({
    instanceOf,
    OlmV1Curve25519AesSha2: OlmV1Curve25519AesSha2_,
    MegolmV1AesSha2: MegolmV1AesSha2_,
    Unknown: Unknown_,
  });
})();

export type EncryptedMessage = InstanceType<
  (typeof EncryptedMessage)[keyof Omit<typeof EncryptedMessage, 'instanceOf'>]
>;

// FfiConverter for enum EncryptedMessage
const FfiConverterTypeEncryptedMessage = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EncryptedMessage;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EncryptedMessage.OlmV1Curve25519AesSha2({
            senderKey: FfiConverterString.read(from),
          });
        case 2:
          return new EncryptedMessage.MegolmV1AesSha2({
            sessionId: FfiConverterString.read(from),
            cause: FfiConverterTypeUtdCause.read(from),
          });
        case 3:
          return new EncryptedMessage.Unknown();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EncryptedMessage_Tags.OlmV1Curve25519AesSha2: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.senderKey, into);
          return;
        }
        case EncryptedMessage_Tags.MegolmV1AesSha2: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.sessionId, into);
          FfiConverterTypeUtdCause.write(inner.cause, into);
          return;
        }
        case EncryptedMessage_Tags.Unknown: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that EncryptedMessage_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EncryptedMessage_Tags.OlmV1Curve25519AesSha2: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.senderKey);
          return size;
        }
        case EncryptedMessage_Tags.MegolmV1AesSha2: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.sessionId);
          size += FfiConverterTypeUtdCause.allocationSize(inner.cause);
          return size;
        }
        case EncryptedMessage_Tags.Unknown: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EncryptionSystem
export enum EncryptionSystem_Tags {
  Unencrypted = 'Unencrypted',
  PerParticipantKeys = 'PerParticipantKeys',
  SharedSecret = 'SharedSecret',
}
/**
 * Defines if a call is encrypted and which encryption system should be used.
 *
 * This controls the url parameters: `perParticipantE2EE`, `password`.
 */
export const EncryptionSystem = (() => {
  type Unencrypted__interface = {
    tag: EncryptionSystem_Tags.Unencrypted;
  };

  /**
   * Equivalent to the element call url parameter: `enableE2EE=false`
   */
  class Unencrypted_ extends UniffiEnum implements Unencrypted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptionSystem';
    readonly tag = EncryptionSystem_Tags.Unencrypted;
    constructor() {
      super('EncryptionSystem', 'Unencrypted');
    }

    static new(): Unencrypted_ {
      return new Unencrypted_();
    }

    static instanceOf(obj: any): obj is Unencrypted_ {
      return obj.tag === EncryptionSystem_Tags.Unencrypted;
    }
  }

  type PerParticipantKeys__interface = {
    tag: EncryptionSystem_Tags.PerParticipantKeys;
  };

  /**
   * Equivalent to the element call url parameter:
   * `perParticipantE2EE=true`
   */
  class PerParticipantKeys_
    extends UniffiEnum
    implements PerParticipantKeys__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptionSystem';
    readonly tag = EncryptionSystem_Tags.PerParticipantKeys;
    constructor() {
      super('EncryptionSystem', 'PerParticipantKeys');
    }

    static new(): PerParticipantKeys_ {
      return new PerParticipantKeys_();
    }

    static instanceOf(obj: any): obj is PerParticipantKeys_ {
      return obj.tag === EncryptionSystem_Tags.PerParticipantKeys;
    }
  }

  type SharedSecret__interface = {
    tag: EncryptionSystem_Tags.SharedSecret;
    inner: Readonly<{ secret: string }>;
  };

  /**
   * Equivalent to the element call url parameter:
   * `password={secret}`
   */
  class SharedSecret_ extends UniffiEnum implements SharedSecret__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptionSystem';
    readonly tag = EncryptionSystem_Tags.SharedSecret;
    readonly inner: Readonly<{ secret: string }>;
    constructor(inner: {
      /**
       * The secret/password which is used in the url.
       */ secret: string;
    }) {
      super('EncryptionSystem', 'SharedSecret');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The secret/password which is used in the url.
       */ secret: string;
    }): SharedSecret_ {
      return new SharedSecret_(inner);
    }

    static instanceOf(obj: any): obj is SharedSecret_ {
      return obj.tag === EncryptionSystem_Tags.SharedSecret;
    }
  }

  function instanceOf(obj: any): obj is EncryptionSystem {
    return obj[uniffiTypeNameSymbol] === 'EncryptionSystem';
  }

  return Object.freeze({
    instanceOf,
    Unencrypted: Unencrypted_,
    PerParticipantKeys: PerParticipantKeys_,
    SharedSecret: SharedSecret_,
  });
})();

/**
 * Defines if a call is encrypted and which encryption system should be used.
 *
 * This controls the url parameters: `perParticipantE2EE`, `password`.
 */

export type EncryptionSystem = InstanceType<
  (typeof EncryptionSystem)[keyof Omit<typeof EncryptionSystem, 'instanceOf'>]
>;

// FfiConverter for enum EncryptionSystem
const FfiConverterTypeEncryptionSystem = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EncryptionSystem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EncryptionSystem.Unencrypted();
        case 2:
          return new EncryptionSystem.PerParticipantKeys();
        case 3:
          return new EncryptionSystem.SharedSecret({
            secret: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EncryptionSystem_Tags.Unencrypted: {
          ordinalConverter.write(1, into);
          return;
        }
        case EncryptionSystem_Tags.PerParticipantKeys: {
          ordinalConverter.write(2, into);
          return;
        }
        case EncryptionSystem_Tags.SharedSecret: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.secret, into);
          return;
        }
        default:
          // Throwing from here means that EncryptionSystem_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EncryptionSystem_Tags.Unencrypted: {
          return ordinalConverter.allocationSize(1);
        }
        case EncryptionSystem_Tags.PerParticipantKeys: {
          return ordinalConverter.allocationSize(2);
        }
        case EncryptionSystem_Tags.SharedSecret: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.secret);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EventOrTransactionId
export enum EventOrTransactionId_Tags {
  EventId = 'EventId',
  TransactionId = 'TransactionId',
}
/**
 * Contains the 2 possible identifiers of an event, either it has a remote
 * event id or a local transaction id, never both or none.
 */
export const EventOrTransactionId = (() => {
  type EventId__interface = {
    tag: EventOrTransactionId_Tags.EventId;
    inner: Readonly<{ eventId: string }>;
  };

  class EventId_ extends UniffiEnum implements EventId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventOrTransactionId';
    readonly tag = EventOrTransactionId_Tags.EventId;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: { eventId: string }) {
      super('EventOrTransactionId', 'EventId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: string }): EventId_ {
      return new EventId_(inner);
    }

    static instanceOf(obj: any): obj is EventId_ {
      return obj.tag === EventOrTransactionId_Tags.EventId;
    }
  }

  type TransactionId__interface = {
    tag: EventOrTransactionId_Tags.TransactionId;
    inner: Readonly<{ transactionId: string }>;
  };

  class TransactionId_ extends UniffiEnum implements TransactionId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventOrTransactionId';
    readonly tag = EventOrTransactionId_Tags.TransactionId;
    readonly inner: Readonly<{ transactionId: string }>;
    constructor(inner: { transactionId: string }) {
      super('EventOrTransactionId', 'TransactionId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { transactionId: string }): TransactionId_ {
      return new TransactionId_(inner);
    }

    static instanceOf(obj: any): obj is TransactionId_ {
      return obj.tag === EventOrTransactionId_Tags.TransactionId;
    }
  }

  function instanceOf(obj: any): obj is EventOrTransactionId {
    return obj[uniffiTypeNameSymbol] === 'EventOrTransactionId';
  }

  return Object.freeze({
    instanceOf,
    EventId: EventId_,
    TransactionId: TransactionId_,
  });
})();

/**
 * Contains the 2 possible identifiers of an event, either it has a remote
 * event id or a local transaction id, never both or none.
 */

export type EventOrTransactionId = InstanceType<
  (typeof EventOrTransactionId)[keyof Omit<
    typeof EventOrTransactionId,
    'instanceOf'
  >]
>;

// FfiConverter for enum EventOrTransactionId
const FfiConverterTypeEventOrTransactionId = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EventOrTransactionId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EventOrTransactionId.EventId({
            eventId: FfiConverterString.read(from),
          });
        case 2:
          return new EventOrTransactionId.TransactionId({
            transactionId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EventOrTransactionId_Tags.EventId: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case EventOrTransactionId_Tags.TransactionId: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.transactionId, into);
          return;
        }
        default:
          // Throwing from here means that EventOrTransactionId_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EventOrTransactionId_Tags.EventId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case EventOrTransactionId_Tags.TransactionId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.transactionId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EventSendState
export enum EventSendState_Tags {
  NotSentYet = 'NotSentYet',
  SendingFailed = 'SendingFailed',
  Sent = 'Sent',
}
/**
 * This type represents the “send state” of a local event timeline item.
 */
export const EventSendState = (() => {
  type NotSentYet__interface = {
    tag: EventSendState_Tags.NotSentYet;
  };

  /**
   * The local event has not been sent yet.
   */
  class NotSentYet_ extends UniffiEnum implements NotSentYet__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventSendState';
    readonly tag = EventSendState_Tags.NotSentYet;
    constructor() {
      super('EventSendState', 'NotSentYet');
    }

    static new(): NotSentYet_ {
      return new NotSentYet_();
    }

    static instanceOf(obj: any): obj is NotSentYet_ {
      return obj.tag === EventSendState_Tags.NotSentYet;
    }
  }

  type SendingFailed__interface = {
    tag: EventSendState_Tags.SendingFailed;
    inner: Readonly<{ error: QueueWedgeError; isRecoverable: boolean }>;
  };

  /**
   * The local event has been sent to the server, but unsuccessfully: The
   * sending has failed.
   */
  class SendingFailed_ extends UniffiEnum implements SendingFailed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventSendState';
    readonly tag = EventSendState_Tags.SendingFailed;
    readonly inner: Readonly<{
      error: QueueWedgeError;
      isRecoverable: boolean;
    }>;
    constructor(inner: {
      /**
       * The error reason, with information for the user.
       */ error: QueueWedgeError;
      /**
       * Whether the error is considered recoverable or not.
       *
       * An error that's recoverable will disable the room's send queue,
       * while an unrecoverable error will be parked, until the user
       * decides to cancel sending it.
       */ isRecoverable: boolean;
    }) {
      super('EventSendState', 'SendingFailed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The error reason, with information for the user.
       */ error: QueueWedgeError;
      /**
       * Whether the error is considered recoverable or not.
       *
       * An error that's recoverable will disable the room's send queue,
       * while an unrecoverable error will be parked, until the user
       * decides to cancel sending it.
       */ isRecoverable: boolean;
    }): SendingFailed_ {
      return new SendingFailed_(inner);
    }

    static instanceOf(obj: any): obj is SendingFailed_ {
      return obj.tag === EventSendState_Tags.SendingFailed;
    }
  }

  type Sent__interface = {
    tag: EventSendState_Tags.Sent;
    inner: Readonly<{ eventId: string }>;
  };

  /**
   * The local event has been sent successfully to the server.
   */
  class Sent_ extends UniffiEnum implements Sent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventSendState';
    readonly tag = EventSendState_Tags.Sent;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: { eventId: string }) {
      super('EventSendState', 'Sent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: string }): Sent_ {
      return new Sent_(inner);
    }

    static instanceOf(obj: any): obj is Sent_ {
      return obj.tag === EventSendState_Tags.Sent;
    }
  }

  function instanceOf(obj: any): obj is EventSendState {
    return obj[uniffiTypeNameSymbol] === 'EventSendState';
  }

  return Object.freeze({
    instanceOf,
    NotSentYet: NotSentYet_,
    SendingFailed: SendingFailed_,
    Sent: Sent_,
  });
})();

/**
 * This type represents the “send state” of a local event timeline item.
 */

export type EventSendState = InstanceType<
  (typeof EventSendState)[keyof Omit<typeof EventSendState, 'instanceOf'>]
>;

// FfiConverter for enum EventSendState
const FfiConverterTypeEventSendState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EventSendState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EventSendState.NotSentYet();
        case 2:
          return new EventSendState.SendingFailed({
            error: FfiConverterTypeQueueWedgeError.read(from),
            isRecoverable: FfiConverterBool.read(from),
          });
        case 3:
          return new EventSendState.Sent({
            eventId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EventSendState_Tags.NotSentYet: {
          ordinalConverter.write(1, into);
          return;
        }
        case EventSendState_Tags.SendingFailed: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeQueueWedgeError.write(inner.error, into);
          FfiConverterBool.write(inner.isRecoverable, into);
          return;
        }
        case EventSendState_Tags.Sent: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        default:
          // Throwing from here means that EventSendState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EventSendState_Tags.NotSentYet: {
          return ordinalConverter.allocationSize(1);
        }
        case EventSendState_Tags.SendingFailed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeQueueWedgeError.allocationSize(inner.error);
          size += FfiConverterBool.allocationSize(inner.isRecoverable);
          return size;
        }
        case EventSendState_Tags.Sent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: FilterTimelineEventType
export enum FilterTimelineEventType_Tags {
  MessageLike = 'MessageLike',
  State = 'State',
}
export const FilterTimelineEventType = (() => {
  type MessageLike__interface = {
    tag: FilterTimelineEventType_Tags.MessageLike;
    inner: Readonly<{ eventType: MessageLikeEventType }>;
  };

  class MessageLike_ extends UniffiEnum implements MessageLike__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FilterTimelineEventType';
    readonly tag = FilterTimelineEventType_Tags.MessageLike;
    readonly inner: Readonly<{ eventType: MessageLikeEventType }>;
    constructor(inner: { eventType: MessageLikeEventType }) {
      super('FilterTimelineEventType', 'MessageLike');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: MessageLikeEventType }): MessageLike_ {
      return new MessageLike_(inner);
    }

    static instanceOf(obj: any): obj is MessageLike_ {
      return obj.tag === FilterTimelineEventType_Tags.MessageLike;
    }
  }

  type State__interface = {
    tag: FilterTimelineEventType_Tags.State;
    inner: Readonly<{ eventType: StateEventType }>;
  };

  class State_ extends UniffiEnum implements State__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FilterTimelineEventType';
    readonly tag = FilterTimelineEventType_Tags.State;
    readonly inner: Readonly<{ eventType: StateEventType }>;
    constructor(inner: { eventType: StateEventType }) {
      super('FilterTimelineEventType', 'State');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: StateEventType }): State_ {
      return new State_(inner);
    }

    static instanceOf(obj: any): obj is State_ {
      return obj.tag === FilterTimelineEventType_Tags.State;
    }
  }

  function instanceOf(obj: any): obj is FilterTimelineEventType {
    return obj[uniffiTypeNameSymbol] === 'FilterTimelineEventType';
  }

  return Object.freeze({
    instanceOf,
    MessageLike: MessageLike_,
    State: State_,
  });
})();

export type FilterTimelineEventType = InstanceType<
  (typeof FilterTimelineEventType)[keyof Omit<
    typeof FilterTimelineEventType,
    'instanceOf'
  >]
>;

// FfiConverter for enum FilterTimelineEventType
const FfiConverterTypeFilterTimelineEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FilterTimelineEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FilterTimelineEventType.MessageLike({
            eventType: FfiConverterTypeMessageLikeEventType.read(from),
          });
        case 2:
          return new FilterTimelineEventType.State({
            eventType: FfiConverterTypeStateEventType.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FilterTimelineEventType_Tags.MessageLike: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeMessageLikeEventType.write(inner.eventType, into);
          return;
        }
        case FilterTimelineEventType_Tags.State: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeStateEventType.write(inner.eventType, into);
          return;
        }
        default:
          // Throwing from here means that FilterTimelineEventType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FilterTimelineEventType_Tags.MessageLike: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeMessageLikeEventType.allocationSize(
            inner.eventType
          );
          return size;
        }
        case FilterTimelineEventType_Tags.State: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeStateEventType.allocationSize(
            inner.eventType
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: FocusEventError

// Enum: FocusEventError
export enum FocusEventError_Tags {
  InvalidEventId = 'InvalidEventId',
  EventNotFound = 'EventNotFound',
  Other = 'Other',
}
export const FocusEventError = (() => {
  type InvalidEventId__interface = {
    tag: FocusEventError_Tags.InvalidEventId;
    inner: Readonly<{ eventId: string; err: string }>;
  };

  class InvalidEventId_
    extends UniffiError
    implements InvalidEventId__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FocusEventError';
    readonly tag = FocusEventError_Tags.InvalidEventId;
    readonly inner: Readonly<{ eventId: string; err: string }>;
    constructor(inner: { eventId: string; err: string }) {
      super('FocusEventError', 'InvalidEventId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: string; err: string }): InvalidEventId_ {
      return new InvalidEventId_(inner);
    }

    static instanceOf(obj: any): obj is InvalidEventId_ {
      return obj.tag === FocusEventError_Tags.InvalidEventId;
    }

    static hasInner(obj: any): obj is InvalidEventId_ {
      return InvalidEventId_.instanceOf(obj);
    }

    static getInner(
      obj: InvalidEventId_
    ): Readonly<{ eventId: string; err: string }> {
      return obj.inner;
    }
  }

  type EventNotFound__interface = {
    tag: FocusEventError_Tags.EventNotFound;
    inner: Readonly<{ eventId: string }>;
  };

  class EventNotFound_ extends UniffiError implements EventNotFound__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FocusEventError';
    readonly tag = FocusEventError_Tags.EventNotFound;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: { eventId: string }) {
      super('FocusEventError', 'EventNotFound');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: string }): EventNotFound_ {
      return new EventNotFound_(inner);
    }

    static instanceOf(obj: any): obj is EventNotFound_ {
      return obj.tag === FocusEventError_Tags.EventNotFound;
    }

    static hasInner(obj: any): obj is EventNotFound_ {
      return EventNotFound_.instanceOf(obj);
    }

    static getInner(obj: EventNotFound_): Readonly<{ eventId: string }> {
      return obj.inner;
    }
  }

  type Other__interface = {
    tag: FocusEventError_Tags.Other;
    inner: Readonly<{ msg: string }>;
  };

  class Other_ extends UniffiError implements Other__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FocusEventError';
    readonly tag = FocusEventError_Tags.Other;
    readonly inner: Readonly<{ msg: string }>;
    constructor(inner: { msg: string }) {
      super('FocusEventError', 'Other');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string }): Other_ {
      return new Other_(inner);
    }

    static instanceOf(obj: any): obj is Other_ {
      return obj.tag === FocusEventError_Tags.Other;
    }

    static hasInner(obj: any): obj is Other_ {
      return Other_.instanceOf(obj);
    }

    static getInner(obj: Other_): Readonly<{ msg: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is FocusEventError {
    return obj[uniffiTypeNameSymbol] === 'FocusEventError';
  }

  return Object.freeze({
    instanceOf,
    InvalidEventId: InvalidEventId_,
    EventNotFound: EventNotFound_,
    Other: Other_,
  });
})();

export type FocusEventError = InstanceType<
  (typeof FocusEventError)[keyof Omit<typeof FocusEventError, 'instanceOf'>]
>;

// FfiConverter for enum FocusEventError
const FfiConverterTypeFocusEventError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FocusEventError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FocusEventError.InvalidEventId({
            eventId: FfiConverterString.read(from),
            err: FfiConverterString.read(from),
          });
        case 2:
          return new FocusEventError.EventNotFound({
            eventId: FfiConverterString.read(from),
          });
        case 3:
          return new FocusEventError.Other({
            msg: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FocusEventError_Tags.InvalidEventId: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          FfiConverterString.write(inner.err, into);
          return;
        }
        case FocusEventError_Tags.EventNotFound: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case FocusEventError_Tags.Other: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          return;
        }
        default:
          // Throwing from here means that FocusEventError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FocusEventError_Tags.InvalidEventId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.eventId);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case FocusEventError_Tags.EventNotFound: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case FocusEventError_Tags.Other: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.msg);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: HumanQrLoginError

// Enum: HumanQrLoginError
export enum HumanQrLoginError_Tags {
  LinkingNotSupported = 'LinkingNotSupported',
  Cancelled = 'Cancelled',
  Expired = 'Expired',
  ConnectionInsecure = 'ConnectionInsecure',
  Declined = 'Declined',
  Unknown = 'Unknown',
  SlidingSyncNotAvailable = 'SlidingSyncNotAvailable',
  OidcMetadataInvalid = 'OidcMetadataInvalid',
  OtherDeviceNotSignedIn = 'OtherDeviceNotSignedIn',
}
export const HumanQrLoginError = (() => {
  type LinkingNotSupported__interface = {
    tag: HumanQrLoginError_Tags.LinkingNotSupported;
  };

  class LinkingNotSupported_
    extends UniffiError
    implements LinkingNotSupported__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.LinkingNotSupported;
    constructor() {
      super('HumanQrLoginError', 'LinkingNotSupported');
    }

    static new(): LinkingNotSupported_ {
      return new LinkingNotSupported_();
    }

    static instanceOf(obj: any): obj is LinkingNotSupported_ {
      return obj.tag === HumanQrLoginError_Tags.LinkingNotSupported;
    }

    static hasInner(obj: any): obj is LinkingNotSupported_ {
      return false;
    }
  }

  type Cancelled__interface = {
    tag: HumanQrLoginError_Tags.Cancelled;
  };

  class Cancelled_ extends UniffiError implements Cancelled__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.Cancelled;
    constructor() {
      super('HumanQrLoginError', 'Cancelled');
    }

    static new(): Cancelled_ {
      return new Cancelled_();
    }

    static instanceOf(obj: any): obj is Cancelled_ {
      return obj.tag === HumanQrLoginError_Tags.Cancelled;
    }

    static hasInner(obj: any): obj is Cancelled_ {
      return false;
    }
  }

  type Expired__interface = {
    tag: HumanQrLoginError_Tags.Expired;
  };

  class Expired_ extends UniffiError implements Expired__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.Expired;
    constructor() {
      super('HumanQrLoginError', 'Expired');
    }

    static new(): Expired_ {
      return new Expired_();
    }

    static instanceOf(obj: any): obj is Expired_ {
      return obj.tag === HumanQrLoginError_Tags.Expired;
    }

    static hasInner(obj: any): obj is Expired_ {
      return false;
    }
  }

  type ConnectionInsecure__interface = {
    tag: HumanQrLoginError_Tags.ConnectionInsecure;
  };

  class ConnectionInsecure_
    extends UniffiError
    implements ConnectionInsecure__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.ConnectionInsecure;
    constructor() {
      super('HumanQrLoginError', 'ConnectionInsecure');
    }

    static new(): ConnectionInsecure_ {
      return new ConnectionInsecure_();
    }

    static instanceOf(obj: any): obj is ConnectionInsecure_ {
      return obj.tag === HumanQrLoginError_Tags.ConnectionInsecure;
    }

    static hasInner(obj: any): obj is ConnectionInsecure_ {
      return false;
    }
  }

  type Declined__interface = {
    tag: HumanQrLoginError_Tags.Declined;
  };

  class Declined_ extends UniffiError implements Declined__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.Declined;
    constructor() {
      super('HumanQrLoginError', 'Declined');
    }

    static new(): Declined_ {
      return new Declined_();
    }

    static instanceOf(obj: any): obj is Declined_ {
      return obj.tag === HumanQrLoginError_Tags.Declined;
    }

    static hasInner(obj: any): obj is Declined_ {
      return false;
    }
  }

  type Unknown__interface = {
    tag: HumanQrLoginError_Tags.Unknown;
  };

  class Unknown_ extends UniffiError implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.Unknown;
    constructor() {
      super('HumanQrLoginError', 'Unknown');
    }

    static new(): Unknown_ {
      return new Unknown_();
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === HumanQrLoginError_Tags.Unknown;
    }

    static hasInner(obj: any): obj is Unknown_ {
      return false;
    }
  }

  type SlidingSyncNotAvailable__interface = {
    tag: HumanQrLoginError_Tags.SlidingSyncNotAvailable;
  };

  class SlidingSyncNotAvailable_
    extends UniffiError
    implements SlidingSyncNotAvailable__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.SlidingSyncNotAvailable;
    constructor() {
      super('HumanQrLoginError', 'SlidingSyncNotAvailable');
    }

    static new(): SlidingSyncNotAvailable_ {
      return new SlidingSyncNotAvailable_();
    }

    static instanceOf(obj: any): obj is SlidingSyncNotAvailable_ {
      return obj.tag === HumanQrLoginError_Tags.SlidingSyncNotAvailable;
    }

    static hasInner(obj: any): obj is SlidingSyncNotAvailable_ {
      return false;
    }
  }

  type OidcMetadataInvalid__interface = {
    tag: HumanQrLoginError_Tags.OidcMetadataInvalid;
  };

  class OidcMetadataInvalid_
    extends UniffiError
    implements OidcMetadataInvalid__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.OidcMetadataInvalid;
    constructor() {
      super('HumanQrLoginError', 'OidcMetadataInvalid');
    }

    static new(): OidcMetadataInvalid_ {
      return new OidcMetadataInvalid_();
    }

    static instanceOf(obj: any): obj is OidcMetadataInvalid_ {
      return obj.tag === HumanQrLoginError_Tags.OidcMetadataInvalid;
    }

    static hasInner(obj: any): obj is OidcMetadataInvalid_ {
      return false;
    }
  }

  type OtherDeviceNotSignedIn__interface = {
    tag: HumanQrLoginError_Tags.OtherDeviceNotSignedIn;
  };

  class OtherDeviceNotSignedIn_
    extends UniffiError
    implements OtherDeviceNotSignedIn__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.OtherDeviceNotSignedIn;
    constructor() {
      super('HumanQrLoginError', 'OtherDeviceNotSignedIn');
    }

    static new(): OtherDeviceNotSignedIn_ {
      return new OtherDeviceNotSignedIn_();
    }

    static instanceOf(obj: any): obj is OtherDeviceNotSignedIn_ {
      return obj.tag === HumanQrLoginError_Tags.OtherDeviceNotSignedIn;
    }

    static hasInner(obj: any): obj is OtherDeviceNotSignedIn_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is HumanQrLoginError {
    return obj[uniffiTypeNameSymbol] === 'HumanQrLoginError';
  }

  return Object.freeze({
    instanceOf,
    LinkingNotSupported: LinkingNotSupported_,
    Cancelled: Cancelled_,
    Expired: Expired_,
    ConnectionInsecure: ConnectionInsecure_,
    Declined: Declined_,
    Unknown: Unknown_,
    SlidingSyncNotAvailable: SlidingSyncNotAvailable_,
    OidcMetadataInvalid: OidcMetadataInvalid_,
    OtherDeviceNotSignedIn: OtherDeviceNotSignedIn_,
  });
})();

export type HumanQrLoginError = InstanceType<
  (typeof HumanQrLoginError)[keyof Omit<typeof HumanQrLoginError, 'instanceOf'>]
>;

// FfiConverter for enum HumanQrLoginError
const FfiConverterTypeHumanQrLoginError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = HumanQrLoginError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new HumanQrLoginError.LinkingNotSupported();
        case 2:
          return new HumanQrLoginError.Cancelled();
        case 3:
          return new HumanQrLoginError.Expired();
        case 4:
          return new HumanQrLoginError.ConnectionInsecure();
        case 5:
          return new HumanQrLoginError.Declined();
        case 6:
          return new HumanQrLoginError.Unknown();
        case 7:
          return new HumanQrLoginError.SlidingSyncNotAvailable();
        case 8:
          return new HumanQrLoginError.OidcMetadataInvalid();
        case 9:
          return new HumanQrLoginError.OtherDeviceNotSignedIn();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case HumanQrLoginError_Tags.LinkingNotSupported: {
          ordinalConverter.write(1, into);
          return;
        }
        case HumanQrLoginError_Tags.Cancelled: {
          ordinalConverter.write(2, into);
          return;
        }
        case HumanQrLoginError_Tags.Expired: {
          ordinalConverter.write(3, into);
          return;
        }
        case HumanQrLoginError_Tags.ConnectionInsecure: {
          ordinalConverter.write(4, into);
          return;
        }
        case HumanQrLoginError_Tags.Declined: {
          ordinalConverter.write(5, into);
          return;
        }
        case HumanQrLoginError_Tags.Unknown: {
          ordinalConverter.write(6, into);
          return;
        }
        case HumanQrLoginError_Tags.SlidingSyncNotAvailable: {
          ordinalConverter.write(7, into);
          return;
        }
        case HumanQrLoginError_Tags.OidcMetadataInvalid: {
          ordinalConverter.write(8, into);
          return;
        }
        case HumanQrLoginError_Tags.OtherDeviceNotSignedIn: {
          ordinalConverter.write(9, into);
          return;
        }
        default:
          // Throwing from here means that HumanQrLoginError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case HumanQrLoginError_Tags.LinkingNotSupported: {
          return ordinalConverter.allocationSize(1);
        }
        case HumanQrLoginError_Tags.Cancelled: {
          return ordinalConverter.allocationSize(2);
        }
        case HumanQrLoginError_Tags.Expired: {
          return ordinalConverter.allocationSize(3);
        }
        case HumanQrLoginError_Tags.ConnectionInsecure: {
          return ordinalConverter.allocationSize(4);
        }
        case HumanQrLoginError_Tags.Declined: {
          return ordinalConverter.allocationSize(5);
        }
        case HumanQrLoginError_Tags.Unknown: {
          return ordinalConverter.allocationSize(6);
        }
        case HumanQrLoginError_Tags.SlidingSyncNotAvailable: {
          return ordinalConverter.allocationSize(7);
        }
        case HumanQrLoginError_Tags.OidcMetadataInvalid: {
          return ordinalConverter.allocationSize(8);
        }
        case HumanQrLoginError_Tags.OtherDeviceNotSignedIn: {
          return ordinalConverter.allocationSize(9);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: JoinRule
export enum JoinRule_Tags {
  Public = 'Public',
  Invite = 'Invite',
  Knock = 'Knock',
  Private = 'Private',
  Restricted = 'Restricted',
  KnockRestricted = 'KnockRestricted',
  Custom = 'Custom',
}
/**
 * The rule used for users wishing to join this room.
 */
export const JoinRule = (() => {
  type Public__interface = {
    tag: JoinRule_Tags.Public;
  };

  /**
   * Anyone can join the room without any prior action.
   */
  class Public_ extends UniffiEnum implements Public__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Public;
    constructor() {
      super('JoinRule', 'Public');
    }

    static new(): Public_ {
      return new Public_();
    }

    static instanceOf(obj: any): obj is Public_ {
      return obj.tag === JoinRule_Tags.Public;
    }
  }

  type Invite__interface = {
    tag: JoinRule_Tags.Invite;
  };

  /**
   * A user who wishes to join the room must first receive an invite to the
   * room from someone already inside of the room.
   */
  class Invite_ extends UniffiEnum implements Invite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Invite;
    constructor() {
      super('JoinRule', 'Invite');
    }

    static new(): Invite_ {
      return new Invite_();
    }

    static instanceOf(obj: any): obj is Invite_ {
      return obj.tag === JoinRule_Tags.Invite;
    }
  }

  type Knock__interface = {
    tag: JoinRule_Tags.Knock;
  };

  /**
   * Users can join the room if they are invited, or they can request an
   * invite to the room.
   *
   * They can be allowed (invited) or denied (kicked/banned) access.
   */
  class Knock_ extends UniffiEnum implements Knock__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Knock;
    constructor() {
      super('JoinRule', 'Knock');
    }

    static new(): Knock_ {
      return new Knock_();
    }

    static instanceOf(obj: any): obj is Knock_ {
      return obj.tag === JoinRule_Tags.Knock;
    }
  }

  type Private__interface = {
    tag: JoinRule_Tags.Private;
  };

  /**
   * Reserved but not yet implemented by the Matrix specification.
   */
  class Private_ extends UniffiEnum implements Private__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Private;
    constructor() {
      super('JoinRule', 'Private');
    }

    static new(): Private_ {
      return new Private_();
    }

    static instanceOf(obj: any): obj is Private_ {
      return obj.tag === JoinRule_Tags.Private;
    }
  }

  type Restricted__interface = {
    tag: JoinRule_Tags.Restricted;
    inner: Readonly<{ rules: Array<AllowRule> }>;
  };

  /**
   * Users can join the room if they are invited, or if they meet any of the
   * conditions described in a set of [`AllowRule`]s.
   */
  class Restricted_ extends UniffiEnum implements Restricted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Restricted;
    readonly inner: Readonly<{ rules: Array<AllowRule> }>;
    constructor(inner: { rules: Array<AllowRule> }) {
      super('JoinRule', 'Restricted');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { rules: Array<AllowRule> }): Restricted_ {
      return new Restricted_(inner);
    }

    static instanceOf(obj: any): obj is Restricted_ {
      return obj.tag === JoinRule_Tags.Restricted;
    }
  }

  type KnockRestricted__interface = {
    tag: JoinRule_Tags.KnockRestricted;
    inner: Readonly<{ rules: Array<AllowRule> }>;
  };

  /**
   * Users can join the room if they are invited, or if they meet any of the
   * conditions described in a set of [`AllowRule`]s, or they can request
   * an invite to the room.
   */
  class KnockRestricted_
    extends UniffiEnum
    implements KnockRestricted__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.KnockRestricted;
    readonly inner: Readonly<{ rules: Array<AllowRule> }>;
    constructor(inner: { rules: Array<AllowRule> }) {
      super('JoinRule', 'KnockRestricted');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { rules: Array<AllowRule> }): KnockRestricted_ {
      return new KnockRestricted_(inner);
    }

    static instanceOf(obj: any): obj is KnockRestricted_ {
      return obj.tag === JoinRule_Tags.KnockRestricted;
    }
  }

  type Custom__interface = {
    tag: JoinRule_Tags.Custom;
    inner: Readonly<{ repr: string }>;
  };

  /**
   * A custom join rule, up for interpretation by the consumer.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Custom;
    readonly inner: Readonly<{ repr: string }>;
    constructor(inner: {
      /**
       * The string representation for this custom rule.
       */ repr: string;
    }) {
      super('JoinRule', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The string representation for this custom rule.
       */ repr: string;
    }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === JoinRule_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is JoinRule {
    return obj[uniffiTypeNameSymbol] === 'JoinRule';
  }

  return Object.freeze({
    instanceOf,
    Public: Public_,
    Invite: Invite_,
    Knock: Knock_,
    Private: Private_,
    Restricted: Restricted_,
    KnockRestricted: KnockRestricted_,
    Custom: Custom_,
  });
})();

/**
 * The rule used for users wishing to join this room.
 */

export type JoinRule = InstanceType<
  (typeof JoinRule)[keyof Omit<typeof JoinRule, 'instanceOf'>]
>;

// FfiConverter for enum JoinRule
const FfiConverterTypeJoinRule = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = JoinRule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new JoinRule.Public();
        case 2:
          return new JoinRule.Invite();
        case 3:
          return new JoinRule.Knock();
        case 4:
          return new JoinRule.Private();
        case 5:
          return new JoinRule.Restricted({
            rules: FfiConverterArrayTypeAllowRule.read(from),
          });
        case 6:
          return new JoinRule.KnockRestricted({
            rules: FfiConverterArrayTypeAllowRule.read(from),
          });
        case 7:
          return new JoinRule.Custom({ repr: FfiConverterString.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case JoinRule_Tags.Public: {
          ordinalConverter.write(1, into);
          return;
        }
        case JoinRule_Tags.Invite: {
          ordinalConverter.write(2, into);
          return;
        }
        case JoinRule_Tags.Knock: {
          ordinalConverter.write(3, into);
          return;
        }
        case JoinRule_Tags.Private: {
          ordinalConverter.write(4, into);
          return;
        }
        case JoinRule_Tags.Restricted: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterArrayTypeAllowRule.write(inner.rules, into);
          return;
        }
        case JoinRule_Tags.KnockRestricted: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterArrayTypeAllowRule.write(inner.rules, into);
          return;
        }
        case JoinRule_Tags.Custom: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.repr, into);
          return;
        }
        default:
          // Throwing from here means that JoinRule_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case JoinRule_Tags.Public: {
          return ordinalConverter.allocationSize(1);
        }
        case JoinRule_Tags.Invite: {
          return ordinalConverter.allocationSize(2);
        }
        case JoinRule_Tags.Knock: {
          return ordinalConverter.allocationSize(3);
        }
        case JoinRule_Tags.Private: {
          return ordinalConverter.allocationSize(4);
        }
        case JoinRule_Tags.Restricted: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterArrayTypeAllowRule.allocationSize(inner.rules);
          return size;
        }
        case JoinRule_Tags.KnockRestricted: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterArrayTypeAllowRule.allocationSize(inner.rules);
          return size;
        }
        case JoinRule_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.repr);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum LogLevel {
  Error,
  Warn,
  Info,
  Debug,
  Trace,
}

const FfiConverterTypeLogLevel = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LogLevel;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return LogLevel.Error;
        case 2:
          return LogLevel.Warn;
        case 3:
          return LogLevel.Info;
        case 4:
          return LogLevel.Debug;
        case 5:
          return LogLevel.Trace;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case LogLevel.Error:
          return ordinalConverter.write(1, into);
        case LogLevel.Warn:
          return ordinalConverter.write(2, into);
        case LogLevel.Info:
          return ordinalConverter.write(3, into);
        case LogLevel.Debug:
          return ordinalConverter.write(4, into);
        case LogLevel.Trace:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: MatrixId
export enum MatrixId_Tags {
  Room = 'Room',
  RoomAlias = 'RoomAlias',
  User = 'User',
  EventOnRoomId = 'EventOnRoomId',
  EventOnRoomAlias = 'EventOnRoomAlias',
}
/**
 * A Matrix ID that can be a room, room alias, user, or event.
 */
export const MatrixId = (() => {
  type Room__interface = {
    tag: MatrixId_Tags.Room;
    inner: Readonly<{ id: string }>;
  };

  class Room_ extends UniffiEnum implements Room__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.Room;
    readonly inner: Readonly<{ id: string }>;
    constructor(inner: { id: string }) {
      super('MatrixId', 'Room');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { id: string }): Room_ {
      return new Room_(inner);
    }

    static instanceOf(obj: any): obj is Room_ {
      return obj.tag === MatrixId_Tags.Room;
    }
  }

  type RoomAlias__interface = {
    tag: MatrixId_Tags.RoomAlias;
    inner: Readonly<{ alias: string }>;
  };

  class RoomAlias_ extends UniffiEnum implements RoomAlias__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.RoomAlias;
    readonly inner: Readonly<{ alias: string }>;
    constructor(inner: { alias: string }) {
      super('MatrixId', 'RoomAlias');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { alias: string }): RoomAlias_ {
      return new RoomAlias_(inner);
    }

    static instanceOf(obj: any): obj is RoomAlias_ {
      return obj.tag === MatrixId_Tags.RoomAlias;
    }
  }

  type User__interface = {
    tag: MatrixId_Tags.User;
    inner: Readonly<{ id: string }>;
  };

  class User_ extends UniffiEnum implements User__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.User;
    readonly inner: Readonly<{ id: string }>;
    constructor(inner: { id: string }) {
      super('MatrixId', 'User');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { id: string }): User_ {
      return new User_(inner);
    }

    static instanceOf(obj: any): obj is User_ {
      return obj.tag === MatrixId_Tags.User;
    }
  }

  type EventOnRoomId__interface = {
    tag: MatrixId_Tags.EventOnRoomId;
    inner: Readonly<{ roomId: string; eventId: string }>;
  };

  class EventOnRoomId_ extends UniffiEnum implements EventOnRoomId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.EventOnRoomId;
    readonly inner: Readonly<{ roomId: string; eventId: string }>;
    constructor(inner: { roomId: string; eventId: string }) {
      super('MatrixId', 'EventOnRoomId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomId: string; eventId: string }): EventOnRoomId_ {
      return new EventOnRoomId_(inner);
    }

    static instanceOf(obj: any): obj is EventOnRoomId_ {
      return obj.tag === MatrixId_Tags.EventOnRoomId;
    }
  }

  type EventOnRoomAlias__interface = {
    tag: MatrixId_Tags.EventOnRoomAlias;
    inner: Readonly<{ alias: string; eventId: string }>;
  };

  class EventOnRoomAlias_
    extends UniffiEnum
    implements EventOnRoomAlias__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.EventOnRoomAlias;
    readonly inner: Readonly<{ alias: string; eventId: string }>;
    constructor(inner: { alias: string; eventId: string }) {
      super('MatrixId', 'EventOnRoomAlias');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { alias: string; eventId: string }): EventOnRoomAlias_ {
      return new EventOnRoomAlias_(inner);
    }

    static instanceOf(obj: any): obj is EventOnRoomAlias_ {
      return obj.tag === MatrixId_Tags.EventOnRoomAlias;
    }
  }

  function instanceOf(obj: any): obj is MatrixId {
    return obj[uniffiTypeNameSymbol] === 'MatrixId';
  }

  return Object.freeze({
    instanceOf,
    Room: Room_,
    RoomAlias: RoomAlias_,
    User: User_,
    EventOnRoomId: EventOnRoomId_,
    EventOnRoomAlias: EventOnRoomAlias_,
  });
})();

/**
 * A Matrix ID that can be a room, room alias, user, or event.
 */

export type MatrixId = InstanceType<
  (typeof MatrixId)[keyof Omit<typeof MatrixId, 'instanceOf'>]
>;

// FfiConverter for enum MatrixId
const FfiConverterTypeMatrixId = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MatrixId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MatrixId.Room({ id: FfiConverterString.read(from) });
        case 2:
          return new MatrixId.RoomAlias({
            alias: FfiConverterString.read(from),
          });
        case 3:
          return new MatrixId.User({ id: FfiConverterString.read(from) });
        case 4:
          return new MatrixId.EventOnRoomId({
            roomId: FfiConverterString.read(from),
            eventId: FfiConverterString.read(from),
          });
        case 5:
          return new MatrixId.EventOnRoomAlias({
            alias: FfiConverterString.read(from),
            eventId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MatrixId_Tags.Room: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.id, into);
          return;
        }
        case MatrixId_Tags.RoomAlias: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.alias, into);
          return;
        }
        case MatrixId_Tags.User: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.id, into);
          return;
        }
        case MatrixId_Tags.EventOnRoomId: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomId, into);
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case MatrixId_Tags.EventOnRoomAlias: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.alias, into);
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        default:
          // Throwing from here means that MatrixId_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MatrixId_Tags.Room: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.id);
          return size;
        }
        case MatrixId_Tags.RoomAlias: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.alias);
          return size;
        }
        case MatrixId_Tags.User: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.id);
          return size;
        }
        case MatrixId_Tags.EventOnRoomId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.roomId);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case MatrixId_Tags.EventOnRoomAlias: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.alias);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: MediaInfoError
export enum MediaInfoError_Tags {
  MissingField = 'MissingField',
  InvalidField = 'InvalidField',
}
export const MediaInfoError = (() => {
  class MissingField extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'MediaInfoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = MediaInfoError_Tags.MissingField;

    constructor(message: string) {
      super('MediaInfoError', 'MissingField', message);
    }

    static instanceOf(e: any): e is MissingField {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class InvalidField extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'MediaInfoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = MediaInfoError_Tags.InvalidField;

    constructor(message: string) {
      super('MediaInfoError', 'InvalidField', message);
    }

    static instanceOf(e: any): e is InvalidField {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is MediaInfoError {
    return (e as any)[uniffiTypeNameSymbol] === 'MediaInfoError';
  }
  return {
    MissingField,
    InvalidField,
    instanceOf,
  };
})();

// Union type for MediaInfoError error type.

export type MediaInfoError = InstanceType<
  (typeof MediaInfoError)[keyof Omit<typeof MediaInfoError, 'instanceOf'>]
>;

const FfiConverterTypeMediaInfoError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = MediaInfoError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new MediaInfoError.MissingField(FfiConverterString.read(from));

        case 2:
          return new MediaInfoError.InvalidField(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum Membership {
  Invited,
  Joined,
  Left,
  Knocked,
  Banned,
}

const FfiConverterTypeMembership = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Membership;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Membership.Invited;
        case 2:
          return Membership.Joined;
        case 3:
          return Membership.Left;
        case 4:
          return Membership.Knocked;
        case 5:
          return Membership.Banned;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Membership.Invited:
          return ordinalConverter.write(1, into);
        case Membership.Joined:
          return ordinalConverter.write(2, into);
        case Membership.Left:
          return ordinalConverter.write(3, into);
        case Membership.Knocked:
          return ordinalConverter.write(4, into);
        case Membership.Banned:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum MembershipChange {
  None,
  Error,
  Joined,
  Left,
  Banned,
  Unbanned,
  Kicked,
  Invited,
  KickedAndBanned,
  InvitationAccepted,
  InvitationRejected,
  InvitationRevoked,
  Knocked,
  KnockAccepted,
  KnockRetracted,
  KnockDenied,
  NotImplemented,
}

const FfiConverterTypeMembershipChange = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MembershipChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return MembershipChange.None;
        case 2:
          return MembershipChange.Error;
        case 3:
          return MembershipChange.Joined;
        case 4:
          return MembershipChange.Left;
        case 5:
          return MembershipChange.Banned;
        case 6:
          return MembershipChange.Unbanned;
        case 7:
          return MembershipChange.Kicked;
        case 8:
          return MembershipChange.Invited;
        case 9:
          return MembershipChange.KickedAndBanned;
        case 10:
          return MembershipChange.InvitationAccepted;
        case 11:
          return MembershipChange.InvitationRejected;
        case 12:
          return MembershipChange.InvitationRevoked;
        case 13:
          return MembershipChange.Knocked;
        case 14:
          return MembershipChange.KnockAccepted;
        case 15:
          return MembershipChange.KnockRetracted;
        case 16:
          return MembershipChange.KnockDenied;
        case 17:
          return MembershipChange.NotImplemented;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case MembershipChange.None:
          return ordinalConverter.write(1, into);
        case MembershipChange.Error:
          return ordinalConverter.write(2, into);
        case MembershipChange.Joined:
          return ordinalConverter.write(3, into);
        case MembershipChange.Left:
          return ordinalConverter.write(4, into);
        case MembershipChange.Banned:
          return ordinalConverter.write(5, into);
        case MembershipChange.Unbanned:
          return ordinalConverter.write(6, into);
        case MembershipChange.Kicked:
          return ordinalConverter.write(7, into);
        case MembershipChange.Invited:
          return ordinalConverter.write(8, into);
        case MembershipChange.KickedAndBanned:
          return ordinalConverter.write(9, into);
        case MembershipChange.InvitationAccepted:
          return ordinalConverter.write(10, into);
        case MembershipChange.InvitationRejected:
          return ordinalConverter.write(11, into);
        case MembershipChange.InvitationRevoked:
          return ordinalConverter.write(12, into);
        case MembershipChange.Knocked:
          return ordinalConverter.write(13, into);
        case MembershipChange.KnockAccepted:
          return ordinalConverter.write(14, into);
        case MembershipChange.KnockRetracted:
          return ordinalConverter.write(15, into);
        case MembershipChange.KnockDenied:
          return ordinalConverter.write(16, into);
        case MembershipChange.NotImplemented:
          return ordinalConverter.write(17, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: MembershipState
export enum MembershipState_Tags {
  Ban = 'Ban',
  Invite = 'Invite',
  Join = 'Join',
  Knock = 'Knock',
  Leave = 'Leave',
  Custom = 'Custom',
}
export const MembershipState = (() => {
  type Ban__interface = {
    tag: MembershipState_Tags.Ban;
  };

  /**
   * The user is banned.
   */
  class Ban_ extends UniffiEnum implements Ban__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Ban;
    constructor() {
      super('MembershipState', 'Ban');
    }

    static new(): Ban_ {
      return new Ban_();
    }

    static instanceOf(obj: any): obj is Ban_ {
      return obj.tag === MembershipState_Tags.Ban;
    }
  }

  type Invite__interface = {
    tag: MembershipState_Tags.Invite;
  };

  /**
   * The user has been invited.
   */
  class Invite_ extends UniffiEnum implements Invite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Invite;
    constructor() {
      super('MembershipState', 'Invite');
    }

    static new(): Invite_ {
      return new Invite_();
    }

    static instanceOf(obj: any): obj is Invite_ {
      return obj.tag === MembershipState_Tags.Invite;
    }
  }

  type Join__interface = {
    tag: MembershipState_Tags.Join;
  };

  /**
   * The user has joined.
   */
  class Join_ extends UniffiEnum implements Join__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Join;
    constructor() {
      super('MembershipState', 'Join');
    }

    static new(): Join_ {
      return new Join_();
    }

    static instanceOf(obj: any): obj is Join_ {
      return obj.tag === MembershipState_Tags.Join;
    }
  }

  type Knock__interface = {
    tag: MembershipState_Tags.Knock;
  };

  /**
   * The user has requested to join.
   */
  class Knock_ extends UniffiEnum implements Knock__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Knock;
    constructor() {
      super('MembershipState', 'Knock');
    }

    static new(): Knock_ {
      return new Knock_();
    }

    static instanceOf(obj: any): obj is Knock_ {
      return obj.tag === MembershipState_Tags.Knock;
    }
  }

  type Leave__interface = {
    tag: MembershipState_Tags.Leave;
  };

  /**
   * The user has left.
   */
  class Leave_ extends UniffiEnum implements Leave__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Leave;
    constructor() {
      super('MembershipState', 'Leave');
    }

    static new(): Leave_ {
      return new Leave_();
    }

    static instanceOf(obj: any): obj is Leave_ {
      return obj.tag === MembershipState_Tags.Leave;
    }
  }

  type Custom__interface = {
    tag: MembershipState_Tags.Custom;
    inner: Readonly<{ value: string }>;
  };

  /**
   * A custom membership state value.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Custom;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('MembershipState', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === MembershipState_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is MembershipState {
    return obj[uniffiTypeNameSymbol] === 'MembershipState';
  }

  return Object.freeze({
    instanceOf,
    Ban: Ban_,
    Invite: Invite_,
    Join: Join_,
    Knock: Knock_,
    Leave: Leave_,
    Custom: Custom_,
  });
})();

export type MembershipState = InstanceType<
  (typeof MembershipState)[keyof Omit<typeof MembershipState, 'instanceOf'>]
>;

// FfiConverter for enum MembershipState
const FfiConverterTypeMembershipState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MembershipState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MembershipState.Ban();
        case 2:
          return new MembershipState.Invite();
        case 3:
          return new MembershipState.Join();
        case 4:
          return new MembershipState.Knock();
        case 5:
          return new MembershipState.Leave();
        case 6:
          return new MembershipState.Custom({
            value: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MembershipState_Tags.Ban: {
          ordinalConverter.write(1, into);
          return;
        }
        case MembershipState_Tags.Invite: {
          ordinalConverter.write(2, into);
          return;
        }
        case MembershipState_Tags.Join: {
          ordinalConverter.write(3, into);
          return;
        }
        case MembershipState_Tags.Knock: {
          ordinalConverter.write(4, into);
          return;
        }
        case MembershipState_Tags.Leave: {
          ordinalConverter.write(5, into);
          return;
        }
        case MembershipState_Tags.Custom: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that MembershipState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MembershipState_Tags.Ban: {
          return ordinalConverter.allocationSize(1);
        }
        case MembershipState_Tags.Invite: {
          return ordinalConverter.allocationSize(2);
        }
        case MembershipState_Tags.Join: {
          return ordinalConverter.allocationSize(3);
        }
        case MembershipState_Tags.Knock: {
          return ordinalConverter.allocationSize(4);
        }
        case MembershipState_Tags.Leave: {
          return ordinalConverter.allocationSize(5);
        }
        case MembershipState_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: MessageFormat
export enum MessageFormat_Tags {
  Html = 'Html',
  Unknown = 'Unknown',
}
export const MessageFormat = (() => {
  type Html__interface = {
    tag: MessageFormat_Tags.Html;
  };

  class Html_ extends UniffiEnum implements Html__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageFormat';
    readonly tag = MessageFormat_Tags.Html;
    constructor() {
      super('MessageFormat', 'Html');
    }

    static new(): Html_ {
      return new Html_();
    }

    static instanceOf(obj: any): obj is Html_ {
      return obj.tag === MessageFormat_Tags.Html;
    }
  }

  type Unknown__interface = {
    tag: MessageFormat_Tags.Unknown;
    inner: Readonly<{ format: string }>;
  };

  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageFormat';
    readonly tag = MessageFormat_Tags.Unknown;
    readonly inner: Readonly<{ format: string }>;
    constructor(inner: { format: string }) {
      super('MessageFormat', 'Unknown');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { format: string }): Unknown_ {
      return new Unknown_(inner);
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === MessageFormat_Tags.Unknown;
    }
  }

  function instanceOf(obj: any): obj is MessageFormat {
    return obj[uniffiTypeNameSymbol] === 'MessageFormat';
  }

  return Object.freeze({
    instanceOf,
    Html: Html_,
    Unknown: Unknown_,
  });
})();

export type MessageFormat = InstanceType<
  (typeof MessageFormat)[keyof Omit<typeof MessageFormat, 'instanceOf'>]
>;

// FfiConverter for enum MessageFormat
const FfiConverterTypeMessageFormat = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageFormat;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MessageFormat.Html();
        case 2:
          return new MessageFormat.Unknown({
            format: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MessageFormat_Tags.Html: {
          ordinalConverter.write(1, into);
          return;
        }
        case MessageFormat_Tags.Unknown: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.format, into);
          return;
        }
        default:
          // Throwing from here means that MessageFormat_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MessageFormat_Tags.Html: {
          return ordinalConverter.allocationSize(1);
        }
        case MessageFormat_Tags.Unknown: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.format);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: MessageLikeEventContent
export enum MessageLikeEventContent_Tags {
  CallAnswer = 'CallAnswer',
  CallInvite = 'CallInvite',
  CallNotify = 'CallNotify',
  CallHangup = 'CallHangup',
  CallCandidates = 'CallCandidates',
  KeyVerificationReady = 'KeyVerificationReady',
  KeyVerificationStart = 'KeyVerificationStart',
  KeyVerificationCancel = 'KeyVerificationCancel',
  KeyVerificationAccept = 'KeyVerificationAccept',
  KeyVerificationKey = 'KeyVerificationKey',
  KeyVerificationMac = 'KeyVerificationMac',
  KeyVerificationDone = 'KeyVerificationDone',
  Poll = 'Poll',
  ReactionContent = 'ReactionContent',
  RoomEncrypted = 'RoomEncrypted',
  RoomMessage = 'RoomMessage',
  RoomRedaction = 'RoomRedaction',
  Sticker = 'Sticker',
}
export const MessageLikeEventContent = (() => {
  type CallAnswer__interface = {
    tag: MessageLikeEventContent_Tags.CallAnswer;
  };

  class CallAnswer_ extends UniffiEnum implements CallAnswer__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallAnswer;
    constructor() {
      super('MessageLikeEventContent', 'CallAnswer');
    }

    static new(): CallAnswer_ {
      return new CallAnswer_();
    }

    static instanceOf(obj: any): obj is CallAnswer_ {
      return obj.tag === MessageLikeEventContent_Tags.CallAnswer;
    }
  }

  type CallInvite__interface = {
    tag: MessageLikeEventContent_Tags.CallInvite;
  };

  class CallInvite_ extends UniffiEnum implements CallInvite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallInvite;
    constructor() {
      super('MessageLikeEventContent', 'CallInvite');
    }

    static new(): CallInvite_ {
      return new CallInvite_();
    }

    static instanceOf(obj: any): obj is CallInvite_ {
      return obj.tag === MessageLikeEventContent_Tags.CallInvite;
    }
  }

  type CallNotify__interface = {
    tag: MessageLikeEventContent_Tags.CallNotify;
    inner: Readonly<{ notifyType: NotifyType }>;
  };

  class CallNotify_ extends UniffiEnum implements CallNotify__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallNotify;
    readonly inner: Readonly<{ notifyType: NotifyType }>;
    constructor(inner: { notifyType: NotifyType }) {
      super('MessageLikeEventContent', 'CallNotify');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { notifyType: NotifyType }): CallNotify_ {
      return new CallNotify_(inner);
    }

    static instanceOf(obj: any): obj is CallNotify_ {
      return obj.tag === MessageLikeEventContent_Tags.CallNotify;
    }
  }

  type CallHangup__interface = {
    tag: MessageLikeEventContent_Tags.CallHangup;
  };

  class CallHangup_ extends UniffiEnum implements CallHangup__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallHangup;
    constructor() {
      super('MessageLikeEventContent', 'CallHangup');
    }

    static new(): CallHangup_ {
      return new CallHangup_();
    }

    static instanceOf(obj: any): obj is CallHangup_ {
      return obj.tag === MessageLikeEventContent_Tags.CallHangup;
    }
  }

  type CallCandidates__interface = {
    tag: MessageLikeEventContent_Tags.CallCandidates;
  };

  class CallCandidates_
    extends UniffiEnum
    implements CallCandidates__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallCandidates;
    constructor() {
      super('MessageLikeEventContent', 'CallCandidates');
    }

    static new(): CallCandidates_ {
      return new CallCandidates_();
    }

    static instanceOf(obj: any): obj is CallCandidates_ {
      return obj.tag === MessageLikeEventContent_Tags.CallCandidates;
    }
  }

  type KeyVerificationReady__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationReady;
  };

  class KeyVerificationReady_
    extends UniffiEnum
    implements KeyVerificationReady__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationReady;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationReady');
    }

    static new(): KeyVerificationReady_ {
      return new KeyVerificationReady_();
    }

    static instanceOf(obj: any): obj is KeyVerificationReady_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationReady;
    }
  }

  type KeyVerificationStart__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationStart;
  };

  class KeyVerificationStart_
    extends UniffiEnum
    implements KeyVerificationStart__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationStart;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationStart');
    }

    static new(): KeyVerificationStart_ {
      return new KeyVerificationStart_();
    }

    static instanceOf(obj: any): obj is KeyVerificationStart_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationStart;
    }
  }

  type KeyVerificationCancel__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationCancel;
  };

  class KeyVerificationCancel_
    extends UniffiEnum
    implements KeyVerificationCancel__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationCancel;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationCancel');
    }

    static new(): KeyVerificationCancel_ {
      return new KeyVerificationCancel_();
    }

    static instanceOf(obj: any): obj is KeyVerificationCancel_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationCancel;
    }
  }

  type KeyVerificationAccept__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationAccept;
  };

  class KeyVerificationAccept_
    extends UniffiEnum
    implements KeyVerificationAccept__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationAccept;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationAccept');
    }

    static new(): KeyVerificationAccept_ {
      return new KeyVerificationAccept_();
    }

    static instanceOf(obj: any): obj is KeyVerificationAccept_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationAccept;
    }
  }

  type KeyVerificationKey__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationKey;
  };

  class KeyVerificationKey_
    extends UniffiEnum
    implements KeyVerificationKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationKey;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationKey');
    }

    static new(): KeyVerificationKey_ {
      return new KeyVerificationKey_();
    }

    static instanceOf(obj: any): obj is KeyVerificationKey_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationKey;
    }
  }

  type KeyVerificationMac__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationMac;
  };

  class KeyVerificationMac_
    extends UniffiEnum
    implements KeyVerificationMac__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationMac;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationMac');
    }

    static new(): KeyVerificationMac_ {
      return new KeyVerificationMac_();
    }

    static instanceOf(obj: any): obj is KeyVerificationMac_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationMac;
    }
  }

  type KeyVerificationDone__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationDone;
  };

  class KeyVerificationDone_
    extends UniffiEnum
    implements KeyVerificationDone__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationDone;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationDone');
    }

    static new(): KeyVerificationDone_ {
      return new KeyVerificationDone_();
    }

    static instanceOf(obj: any): obj is KeyVerificationDone_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationDone;
    }
  }

  type Poll__interface = {
    tag: MessageLikeEventContent_Tags.Poll;
    inner: Readonly<{ question: string }>;
  };

  class Poll_ extends UniffiEnum implements Poll__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.Poll;
    readonly inner: Readonly<{ question: string }>;
    constructor(inner: { question: string }) {
      super('MessageLikeEventContent', 'Poll');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { question: string }): Poll_ {
      return new Poll_(inner);
    }

    static instanceOf(obj: any): obj is Poll_ {
      return obj.tag === MessageLikeEventContent_Tags.Poll;
    }
  }

  type ReactionContent__interface = {
    tag: MessageLikeEventContent_Tags.ReactionContent;
    inner: Readonly<{ relatedEventId: string }>;
  };

  class ReactionContent_
    extends UniffiEnum
    implements ReactionContent__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.ReactionContent;
    readonly inner: Readonly<{ relatedEventId: string }>;
    constructor(inner: { relatedEventId: string }) {
      super('MessageLikeEventContent', 'ReactionContent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { relatedEventId: string }): ReactionContent_ {
      return new ReactionContent_(inner);
    }

    static instanceOf(obj: any): obj is ReactionContent_ {
      return obj.tag === MessageLikeEventContent_Tags.ReactionContent;
    }
  }

  type RoomEncrypted__interface = {
    tag: MessageLikeEventContent_Tags.RoomEncrypted;
  };

  class RoomEncrypted_ extends UniffiEnum implements RoomEncrypted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.RoomEncrypted;
    constructor() {
      super('MessageLikeEventContent', 'RoomEncrypted');
    }

    static new(): RoomEncrypted_ {
      return new RoomEncrypted_();
    }

    static instanceOf(obj: any): obj is RoomEncrypted_ {
      return obj.tag === MessageLikeEventContent_Tags.RoomEncrypted;
    }
  }

  type RoomMessage__interface = {
    tag: MessageLikeEventContent_Tags.RoomMessage;
    inner: Readonly<{
      messageType: MessageType;
      inReplyToEventId: string | undefined;
    }>;
  };

  class RoomMessage_ extends UniffiEnum implements RoomMessage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.RoomMessage;
    readonly inner: Readonly<{
      messageType: MessageType;
      inReplyToEventId: string | undefined;
    }>;
    constructor(inner: {
      messageType: MessageType;
      inReplyToEventId: string | undefined;
    }) {
      super('MessageLikeEventContent', 'RoomMessage');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      messageType: MessageType;
      inReplyToEventId: string | undefined;
    }): RoomMessage_ {
      return new RoomMessage_(inner);
    }

    static instanceOf(obj: any): obj is RoomMessage_ {
      return obj.tag === MessageLikeEventContent_Tags.RoomMessage;
    }
  }

  type RoomRedaction__interface = {
    tag: MessageLikeEventContent_Tags.RoomRedaction;
    inner: Readonly<{
      redactedEventId: string | undefined;
      reason: string | undefined;
    }>;
  };

  class RoomRedaction_ extends UniffiEnum implements RoomRedaction__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.RoomRedaction;
    readonly inner: Readonly<{
      redactedEventId: string | undefined;
      reason: string | undefined;
    }>;
    constructor(inner: {
      redactedEventId: string | undefined;
      reason: string | undefined;
    }) {
      super('MessageLikeEventContent', 'RoomRedaction');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      redactedEventId: string | undefined;
      reason: string | undefined;
    }): RoomRedaction_ {
      return new RoomRedaction_(inner);
    }

    static instanceOf(obj: any): obj is RoomRedaction_ {
      return obj.tag === MessageLikeEventContent_Tags.RoomRedaction;
    }
  }

  type Sticker__interface = {
    tag: MessageLikeEventContent_Tags.Sticker;
  };

  class Sticker_ extends UniffiEnum implements Sticker__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.Sticker;
    constructor() {
      super('MessageLikeEventContent', 'Sticker');
    }

    static new(): Sticker_ {
      return new Sticker_();
    }

    static instanceOf(obj: any): obj is Sticker_ {
      return obj.tag === MessageLikeEventContent_Tags.Sticker;
    }
  }

  function instanceOf(obj: any): obj is MessageLikeEventContent {
    return obj[uniffiTypeNameSymbol] === 'MessageLikeEventContent';
  }

  return Object.freeze({
    instanceOf,
    CallAnswer: CallAnswer_,
    CallInvite: CallInvite_,
    CallNotify: CallNotify_,
    CallHangup: CallHangup_,
    CallCandidates: CallCandidates_,
    KeyVerificationReady: KeyVerificationReady_,
    KeyVerificationStart: KeyVerificationStart_,
    KeyVerificationCancel: KeyVerificationCancel_,
    KeyVerificationAccept: KeyVerificationAccept_,
    KeyVerificationKey: KeyVerificationKey_,
    KeyVerificationMac: KeyVerificationMac_,
    KeyVerificationDone: KeyVerificationDone_,
    Poll: Poll_,
    ReactionContent: ReactionContent_,
    RoomEncrypted: RoomEncrypted_,
    RoomMessage: RoomMessage_,
    RoomRedaction: RoomRedaction_,
    Sticker: Sticker_,
  });
})();

export type MessageLikeEventContent = InstanceType<
  (typeof MessageLikeEventContent)[keyof Omit<
    typeof MessageLikeEventContent,
    'instanceOf'
  >]
>;

// FfiConverter for enum MessageLikeEventContent
const FfiConverterTypeMessageLikeEventContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageLikeEventContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MessageLikeEventContent.CallAnswer();
        case 2:
          return new MessageLikeEventContent.CallInvite();
        case 3:
          return new MessageLikeEventContent.CallNotify({
            notifyType: FfiConverterTypeNotifyType.read(from),
          });
        case 4:
          return new MessageLikeEventContent.CallHangup();
        case 5:
          return new MessageLikeEventContent.CallCandidates();
        case 6:
          return new MessageLikeEventContent.KeyVerificationReady();
        case 7:
          return new MessageLikeEventContent.KeyVerificationStart();
        case 8:
          return new MessageLikeEventContent.KeyVerificationCancel();
        case 9:
          return new MessageLikeEventContent.KeyVerificationAccept();
        case 10:
          return new MessageLikeEventContent.KeyVerificationKey();
        case 11:
          return new MessageLikeEventContent.KeyVerificationMac();
        case 12:
          return new MessageLikeEventContent.KeyVerificationDone();
        case 13:
          return new MessageLikeEventContent.Poll({
            question: FfiConverterString.read(from),
          });
        case 14:
          return new MessageLikeEventContent.ReactionContent({
            relatedEventId: FfiConverterString.read(from),
          });
        case 15:
          return new MessageLikeEventContent.RoomEncrypted();
        case 16:
          return new MessageLikeEventContent.RoomMessage({
            messageType: FfiConverterTypeMessageType.read(from),
            inReplyToEventId: FfiConverterOptionalString.read(from),
          });
        case 17:
          return new MessageLikeEventContent.RoomRedaction({
            redactedEventId: FfiConverterOptionalString.read(from),
            reason: FfiConverterOptionalString.read(from),
          });
        case 18:
          return new MessageLikeEventContent.Sticker();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MessageLikeEventContent_Tags.CallAnswer: {
          ordinalConverter.write(1, into);
          return;
        }
        case MessageLikeEventContent_Tags.CallInvite: {
          ordinalConverter.write(2, into);
          return;
        }
        case MessageLikeEventContent_Tags.CallNotify: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeNotifyType.write(inner.notifyType, into);
          return;
        }
        case MessageLikeEventContent_Tags.CallHangup: {
          ordinalConverter.write(4, into);
          return;
        }
        case MessageLikeEventContent_Tags.CallCandidates: {
          ordinalConverter.write(5, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationReady: {
          ordinalConverter.write(6, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationStart: {
          ordinalConverter.write(7, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationCancel: {
          ordinalConverter.write(8, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationAccept: {
          ordinalConverter.write(9, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationKey: {
          ordinalConverter.write(10, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationMac: {
          ordinalConverter.write(11, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationDone: {
          ordinalConverter.write(12, into);
          return;
        }
        case MessageLikeEventContent_Tags.Poll: {
          ordinalConverter.write(13, into);
          const inner = value.inner;
          FfiConverterString.write(inner.question, into);
          return;
        }
        case MessageLikeEventContent_Tags.ReactionContent: {
          ordinalConverter.write(14, into);
          const inner = value.inner;
          FfiConverterString.write(inner.relatedEventId, into);
          return;
        }
        case MessageLikeEventContent_Tags.RoomEncrypted: {
          ordinalConverter.write(15, into);
          return;
        }
        case MessageLikeEventContent_Tags.RoomMessage: {
          ordinalConverter.write(16, into);
          const inner = value.inner;
          FfiConverterTypeMessageType.write(inner.messageType, into);
          FfiConverterOptionalString.write(inner.inReplyToEventId, into);
          return;
        }
        case MessageLikeEventContent_Tags.RoomRedaction: {
          ordinalConverter.write(17, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.redactedEventId, into);
          FfiConverterOptionalString.write(inner.reason, into);
          return;
        }
        case MessageLikeEventContent_Tags.Sticker: {
          ordinalConverter.write(18, into);
          return;
        }
        default:
          // Throwing from here means that MessageLikeEventContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MessageLikeEventContent_Tags.CallAnswer: {
          return ordinalConverter.allocationSize(1);
        }
        case MessageLikeEventContent_Tags.CallInvite: {
          return ordinalConverter.allocationSize(2);
        }
        case MessageLikeEventContent_Tags.CallNotify: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeNotifyType.allocationSize(inner.notifyType);
          return size;
        }
        case MessageLikeEventContent_Tags.CallHangup: {
          return ordinalConverter.allocationSize(4);
        }
        case MessageLikeEventContent_Tags.CallCandidates: {
          return ordinalConverter.allocationSize(5);
        }
        case MessageLikeEventContent_Tags.KeyVerificationReady: {
          return ordinalConverter.allocationSize(6);
        }
        case MessageLikeEventContent_Tags.KeyVerificationStart: {
          return ordinalConverter.allocationSize(7);
        }
        case MessageLikeEventContent_Tags.KeyVerificationCancel: {
          return ordinalConverter.allocationSize(8);
        }
        case MessageLikeEventContent_Tags.KeyVerificationAccept: {
          return ordinalConverter.allocationSize(9);
        }
        case MessageLikeEventContent_Tags.KeyVerificationKey: {
          return ordinalConverter.allocationSize(10);
        }
        case MessageLikeEventContent_Tags.KeyVerificationMac: {
          return ordinalConverter.allocationSize(11);
        }
        case MessageLikeEventContent_Tags.KeyVerificationDone: {
          return ordinalConverter.allocationSize(12);
        }
        case MessageLikeEventContent_Tags.Poll: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(13);
          size += FfiConverterString.allocationSize(inner.question);
          return size;
        }
        case MessageLikeEventContent_Tags.ReactionContent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(14);
          size += FfiConverterString.allocationSize(inner.relatedEventId);
          return size;
        }
        case MessageLikeEventContent_Tags.RoomEncrypted: {
          return ordinalConverter.allocationSize(15);
        }
        case MessageLikeEventContent_Tags.RoomMessage: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(16);
          size += FfiConverterTypeMessageType.allocationSize(inner.messageType);
          size += FfiConverterOptionalString.allocationSize(
            inner.inReplyToEventId
          );
          return size;
        }
        case MessageLikeEventContent_Tags.RoomRedaction: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(17);
          size += FfiConverterOptionalString.allocationSize(
            inner.redactedEventId
          );
          size += FfiConverterOptionalString.allocationSize(inner.reason);
          return size;
        }
        case MessageLikeEventContent_Tags.Sticker: {
          return ordinalConverter.allocationSize(18);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum MessageLikeEventType {
  CallAnswer,
  CallCandidates,
  CallHangup,
  CallInvite,
  CallNotify,
  KeyVerificationAccept,
  KeyVerificationCancel,
  KeyVerificationDone,
  KeyVerificationKey,
  KeyVerificationMac,
  KeyVerificationReady,
  KeyVerificationStart,
  PollEnd,
  PollResponse,
  PollStart,
  Reaction,
  RoomEncrypted,
  RoomMessage,
  RoomRedaction,
  Sticker,
  UnstablePollEnd,
  UnstablePollResponse,
  UnstablePollStart,
}

const FfiConverterTypeMessageLikeEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageLikeEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return MessageLikeEventType.CallAnswer;
        case 2:
          return MessageLikeEventType.CallCandidates;
        case 3:
          return MessageLikeEventType.CallHangup;
        case 4:
          return MessageLikeEventType.CallInvite;
        case 5:
          return MessageLikeEventType.CallNotify;
        case 6:
          return MessageLikeEventType.KeyVerificationAccept;
        case 7:
          return MessageLikeEventType.KeyVerificationCancel;
        case 8:
          return MessageLikeEventType.KeyVerificationDone;
        case 9:
          return MessageLikeEventType.KeyVerificationKey;
        case 10:
          return MessageLikeEventType.KeyVerificationMac;
        case 11:
          return MessageLikeEventType.KeyVerificationReady;
        case 12:
          return MessageLikeEventType.KeyVerificationStart;
        case 13:
          return MessageLikeEventType.PollEnd;
        case 14:
          return MessageLikeEventType.PollResponse;
        case 15:
          return MessageLikeEventType.PollStart;
        case 16:
          return MessageLikeEventType.Reaction;
        case 17:
          return MessageLikeEventType.RoomEncrypted;
        case 18:
          return MessageLikeEventType.RoomMessage;
        case 19:
          return MessageLikeEventType.RoomRedaction;
        case 20:
          return MessageLikeEventType.Sticker;
        case 21:
          return MessageLikeEventType.UnstablePollEnd;
        case 22:
          return MessageLikeEventType.UnstablePollResponse;
        case 23:
          return MessageLikeEventType.UnstablePollStart;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case MessageLikeEventType.CallAnswer:
          return ordinalConverter.write(1, into);
        case MessageLikeEventType.CallCandidates:
          return ordinalConverter.write(2, into);
        case MessageLikeEventType.CallHangup:
          return ordinalConverter.write(3, into);
        case MessageLikeEventType.CallInvite:
          return ordinalConverter.write(4, into);
        case MessageLikeEventType.CallNotify:
          return ordinalConverter.write(5, into);
        case MessageLikeEventType.KeyVerificationAccept:
          return ordinalConverter.write(6, into);
        case MessageLikeEventType.KeyVerificationCancel:
          return ordinalConverter.write(7, into);
        case MessageLikeEventType.KeyVerificationDone:
          return ordinalConverter.write(8, into);
        case MessageLikeEventType.KeyVerificationKey:
          return ordinalConverter.write(9, into);
        case MessageLikeEventType.KeyVerificationMac:
          return ordinalConverter.write(10, into);
        case MessageLikeEventType.KeyVerificationReady:
          return ordinalConverter.write(11, into);
        case MessageLikeEventType.KeyVerificationStart:
          return ordinalConverter.write(12, into);
        case MessageLikeEventType.PollEnd:
          return ordinalConverter.write(13, into);
        case MessageLikeEventType.PollResponse:
          return ordinalConverter.write(14, into);
        case MessageLikeEventType.PollStart:
          return ordinalConverter.write(15, into);
        case MessageLikeEventType.Reaction:
          return ordinalConverter.write(16, into);
        case MessageLikeEventType.RoomEncrypted:
          return ordinalConverter.write(17, into);
        case MessageLikeEventType.RoomMessage:
          return ordinalConverter.write(18, into);
        case MessageLikeEventType.RoomRedaction:
          return ordinalConverter.write(19, into);
        case MessageLikeEventType.Sticker:
          return ordinalConverter.write(20, into);
        case MessageLikeEventType.UnstablePollEnd:
          return ordinalConverter.write(21, into);
        case MessageLikeEventType.UnstablePollResponse:
          return ordinalConverter.write(22, into);
        case MessageLikeEventType.UnstablePollStart:
          return ordinalConverter.write(23, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: MessageType
export enum MessageType_Tags {
  Emote = 'Emote',
  Image = 'Image',
  Audio = 'Audio',
  Video = 'Video',
  File = 'File',
  Notice = 'Notice',
  Text = 'Text',
  Location = 'Location',
  Other = 'Other',
}
export const MessageType = (() => {
  type Emote__interface = {
    tag: MessageType_Tags.Emote;
    inner: Readonly<{ content: EmoteMessageContent }>;
  };

  class Emote_ extends UniffiEnum implements Emote__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Emote;
    readonly inner: Readonly<{ content: EmoteMessageContent }>;
    constructor(inner: { content: EmoteMessageContent }) {
      super('MessageType', 'Emote');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: EmoteMessageContent }): Emote_ {
      return new Emote_(inner);
    }

    static instanceOf(obj: any): obj is Emote_ {
      return obj.tag === MessageType_Tags.Emote;
    }
  }

  type Image__interface = {
    tag: MessageType_Tags.Image;
    inner: Readonly<{ content: ImageMessageContent }>;
  };

  class Image_ extends UniffiEnum implements Image__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Image;
    readonly inner: Readonly<{ content: ImageMessageContent }>;
    constructor(inner: { content: ImageMessageContent }) {
      super('MessageType', 'Image');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: ImageMessageContent }): Image_ {
      return new Image_(inner);
    }

    static instanceOf(obj: any): obj is Image_ {
      return obj.tag === MessageType_Tags.Image;
    }
  }

  type Audio__interface = {
    tag: MessageType_Tags.Audio;
    inner: Readonly<{ content: AudioMessageContent }>;
  };

  class Audio_ extends UniffiEnum implements Audio__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Audio;
    readonly inner: Readonly<{ content: AudioMessageContent }>;
    constructor(inner: { content: AudioMessageContent }) {
      super('MessageType', 'Audio');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: AudioMessageContent }): Audio_ {
      return new Audio_(inner);
    }

    static instanceOf(obj: any): obj is Audio_ {
      return obj.tag === MessageType_Tags.Audio;
    }
  }

  type Video__interface = {
    tag: MessageType_Tags.Video;
    inner: Readonly<{ content: VideoMessageContent }>;
  };

  class Video_ extends UniffiEnum implements Video__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Video;
    readonly inner: Readonly<{ content: VideoMessageContent }>;
    constructor(inner: { content: VideoMessageContent }) {
      super('MessageType', 'Video');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: VideoMessageContent }): Video_ {
      return new Video_(inner);
    }

    static instanceOf(obj: any): obj is Video_ {
      return obj.tag === MessageType_Tags.Video;
    }
  }

  type File__interface = {
    tag: MessageType_Tags.File;
    inner: Readonly<{ content: FileMessageContent }>;
  };

  class File_ extends UniffiEnum implements File__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.File;
    readonly inner: Readonly<{ content: FileMessageContent }>;
    constructor(inner: { content: FileMessageContent }) {
      super('MessageType', 'File');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: FileMessageContent }): File_ {
      return new File_(inner);
    }

    static instanceOf(obj: any): obj is File_ {
      return obj.tag === MessageType_Tags.File;
    }
  }

  type Notice__interface = {
    tag: MessageType_Tags.Notice;
    inner: Readonly<{ content: NoticeMessageContent }>;
  };

  class Notice_ extends UniffiEnum implements Notice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Notice;
    readonly inner: Readonly<{ content: NoticeMessageContent }>;
    constructor(inner: { content: NoticeMessageContent }) {
      super('MessageType', 'Notice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: NoticeMessageContent }): Notice_ {
      return new Notice_(inner);
    }

    static instanceOf(obj: any): obj is Notice_ {
      return obj.tag === MessageType_Tags.Notice;
    }
  }

  type Text__interface = {
    tag: MessageType_Tags.Text;
    inner: Readonly<{ content: TextMessageContent }>;
  };

  class Text_ extends UniffiEnum implements Text__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Text;
    readonly inner: Readonly<{ content: TextMessageContent }>;
    constructor(inner: { content: TextMessageContent }) {
      super('MessageType', 'Text');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: TextMessageContent }): Text_ {
      return new Text_(inner);
    }

    static instanceOf(obj: any): obj is Text_ {
      return obj.tag === MessageType_Tags.Text;
    }
  }

  type Location__interface = {
    tag: MessageType_Tags.Location;
    inner: Readonly<{ content: LocationContent }>;
  };

  class Location_ extends UniffiEnum implements Location__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Location;
    readonly inner: Readonly<{ content: LocationContent }>;
    constructor(inner: { content: LocationContent }) {
      super('MessageType', 'Location');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: LocationContent }): Location_ {
      return new Location_(inner);
    }

    static instanceOf(obj: any): obj is Location_ {
      return obj.tag === MessageType_Tags.Location;
    }
  }

  type Other__interface = {
    tag: MessageType_Tags.Other;
    inner: Readonly<{ msgtype: string; body: string }>;
  };

  class Other_ extends UniffiEnum implements Other__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Other;
    readonly inner: Readonly<{ msgtype: string; body: string }>;
    constructor(inner: { msgtype: string; body: string }) {
      super('MessageType', 'Other');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msgtype: string; body: string }): Other_ {
      return new Other_(inner);
    }

    static instanceOf(obj: any): obj is Other_ {
      return obj.tag === MessageType_Tags.Other;
    }
  }

  function instanceOf(obj: any): obj is MessageType {
    return obj[uniffiTypeNameSymbol] === 'MessageType';
  }

  return Object.freeze({
    instanceOf,
    Emote: Emote_,
    Image: Image_,
    Audio: Audio_,
    Video: Video_,
    File: File_,
    Notice: Notice_,
    Text: Text_,
    Location: Location_,
    Other: Other_,
  });
})();

export type MessageType = InstanceType<
  (typeof MessageType)[keyof Omit<typeof MessageType, 'instanceOf'>]
>;

// FfiConverter for enum MessageType
const FfiConverterTypeMessageType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MessageType.Emote({
            content: FfiConverterTypeEmoteMessageContent.read(from),
          });
        case 2:
          return new MessageType.Image({
            content: FfiConverterTypeImageMessageContent.read(from),
          });
        case 3:
          return new MessageType.Audio({
            content: FfiConverterTypeAudioMessageContent.read(from),
          });
        case 4:
          return new MessageType.Video({
            content: FfiConverterTypeVideoMessageContent.read(from),
          });
        case 5:
          return new MessageType.File({
            content: FfiConverterTypeFileMessageContent.read(from),
          });
        case 6:
          return new MessageType.Notice({
            content: FfiConverterTypeNoticeMessageContent.read(from),
          });
        case 7:
          return new MessageType.Text({
            content: FfiConverterTypeTextMessageContent.read(from),
          });
        case 8:
          return new MessageType.Location({
            content: FfiConverterTypeLocationContent.read(from),
          });
        case 9:
          return new MessageType.Other({
            msgtype: FfiConverterString.read(from),
            body: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MessageType_Tags.Emote: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeEmoteMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Image: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeImageMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Audio: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeAudioMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Video: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeVideoMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.File: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeFileMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Notice: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeNoticeMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Text: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeTextMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Location: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeLocationContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Other: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msgtype, into);
          FfiConverterString.write(inner.body, into);
          return;
        }
        default:
          // Throwing from here means that MessageType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MessageType_Tags.Emote: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeEmoteMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Image: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeImageMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Audio: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeAudioMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Video: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeVideoMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.File: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeFileMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Notice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeNoticeMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Text: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeTextMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Location: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeLocationContent.allocationSize(inner.content);
          return size;
        }
        case MessageType_Tags.Other: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner.msgtype);
          size += FfiConverterString.allocationSize(inner.body);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: NotificationEvent
export enum NotificationEvent_Tags {
  Timeline = 'Timeline',
  Invite = 'Invite',
}
export const NotificationEvent = (() => {
  type Timeline__interface = {
    tag: NotificationEvent_Tags.Timeline;
    inner: Readonly<{ event: TimelineEventInterface }>;
  };

  class Timeline_ extends UniffiEnum implements Timeline__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationEvent';
    readonly tag = NotificationEvent_Tags.Timeline;
    readonly inner: Readonly<{ event: TimelineEventInterface }>;
    constructor(inner: { event: TimelineEventInterface }) {
      super('NotificationEvent', 'Timeline');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { event: TimelineEventInterface }): Timeline_ {
      return new Timeline_(inner);
    }

    static instanceOf(obj: any): obj is Timeline_ {
      return obj.tag === NotificationEvent_Tags.Timeline;
    }
  }

  type Invite__interface = {
    tag: NotificationEvent_Tags.Invite;
    inner: Readonly<{ sender: string }>;
  };

  class Invite_ extends UniffiEnum implements Invite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationEvent';
    readonly tag = NotificationEvent_Tags.Invite;
    readonly inner: Readonly<{ sender: string }>;
    constructor(inner: { sender: string }) {
      super('NotificationEvent', 'Invite');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { sender: string }): Invite_ {
      return new Invite_(inner);
    }

    static instanceOf(obj: any): obj is Invite_ {
      return obj.tag === NotificationEvent_Tags.Invite;
    }
  }

  function instanceOf(obj: any): obj is NotificationEvent {
    return obj[uniffiTypeNameSymbol] === 'NotificationEvent';
  }

  return Object.freeze({
    instanceOf,
    Timeline: Timeline_,
    Invite: Invite_,
  });
})();

export type NotificationEvent = InstanceType<
  (typeof NotificationEvent)[keyof Omit<typeof NotificationEvent, 'instanceOf'>]
>;

// FfiConverter for enum NotificationEvent
const FfiConverterTypeNotificationEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotificationEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new NotificationEvent.Timeline({
            event: FfiConverterTypeTimelineEvent.read(from),
          });
        case 2:
          return new NotificationEvent.Invite({
            sender: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case NotificationEvent_Tags.Timeline: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeTimelineEvent.write(inner.event, into);
          return;
        }
        case NotificationEvent_Tags.Invite: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.sender, into);
          return;
        }
        default:
          // Throwing from here means that NotificationEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case NotificationEvent_Tags.Timeline: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeTimelineEvent.allocationSize(inner.event);
          return size;
        }
        case NotificationEvent_Tags.Invite: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.sender);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: NotificationProcessSetup
export enum NotificationProcessSetup_Tags {
  MultipleProcesses = 'MultipleProcesses',
  SingleProcess = 'SingleProcess',
}
export const NotificationProcessSetup = (() => {
  type MultipleProcesses__interface = {
    tag: NotificationProcessSetup_Tags.MultipleProcesses;
  };

  class MultipleProcesses_
    extends UniffiEnum
    implements MultipleProcesses__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationProcessSetup';
    readonly tag = NotificationProcessSetup_Tags.MultipleProcesses;
    constructor() {
      super('NotificationProcessSetup', 'MultipleProcesses');
    }

    static new(): MultipleProcesses_ {
      return new MultipleProcesses_();
    }

    static instanceOf(obj: any): obj is MultipleProcesses_ {
      return obj.tag === NotificationProcessSetup_Tags.MultipleProcesses;
    }
  }

  type SingleProcess__interface = {
    tag: NotificationProcessSetup_Tags.SingleProcess;
    inner: Readonly<{ syncService: SyncServiceInterface }>;
  };

  class SingleProcess_ extends UniffiEnum implements SingleProcess__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationProcessSetup';
    readonly tag = NotificationProcessSetup_Tags.SingleProcess;
    readonly inner: Readonly<{ syncService: SyncServiceInterface }>;
    constructor(inner: { syncService: SyncServiceInterface }) {
      super('NotificationProcessSetup', 'SingleProcess');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { syncService: SyncServiceInterface }): SingleProcess_ {
      return new SingleProcess_(inner);
    }

    static instanceOf(obj: any): obj is SingleProcess_ {
      return obj.tag === NotificationProcessSetup_Tags.SingleProcess;
    }
  }

  function instanceOf(obj: any): obj is NotificationProcessSetup {
    return obj[uniffiTypeNameSymbol] === 'NotificationProcessSetup';
  }

  return Object.freeze({
    instanceOf,
    MultipleProcesses: MultipleProcesses_,
    SingleProcess: SingleProcess_,
  });
})();

export type NotificationProcessSetup = InstanceType<
  (typeof NotificationProcessSetup)[keyof Omit<
    typeof NotificationProcessSetup,
    'instanceOf'
  >]
>;

// FfiConverter for enum NotificationProcessSetup
const FfiConverterTypeNotificationProcessSetup = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotificationProcessSetup;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new NotificationProcessSetup.MultipleProcesses();
        case 2:
          return new NotificationProcessSetup.SingleProcess({
            syncService: FfiConverterTypeSyncService.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case NotificationProcessSetup_Tags.MultipleProcesses: {
          ordinalConverter.write(1, into);
          return;
        }
        case NotificationProcessSetup_Tags.SingleProcess: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeSyncService.write(inner.syncService, into);
          return;
        }
        default:
          // Throwing from here means that NotificationProcessSetup_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case NotificationProcessSetup_Tags.MultipleProcesses: {
          return ordinalConverter.allocationSize(1);
        }
        case NotificationProcessSetup_Tags.SingleProcess: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeSyncService.allocationSize(inner.syncService);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: NotificationSettingsError

// Enum: NotificationSettingsError
export enum NotificationSettingsError_Tags {
  Generic = 'Generic',
  InvalidParameter = 'InvalidParameter',
  InvalidRoomId = 'InvalidRoomId',
  RuleNotFound = 'RuleNotFound',
  UnableToAddPushRule = 'UnableToAddPushRule',
  UnableToRemovePushRule = 'UnableToRemovePushRule',
  UnableToSavePushRules = 'UnableToSavePushRules',
  UnableToUpdatePushRule = 'UnableToUpdatePushRule',
}
export const NotificationSettingsError = (() => {
  type Generic__interface = {
    tag: NotificationSettingsError_Tags.Generic;
    inner: Readonly<{ msg: string }>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.Generic;
    readonly inner: Readonly<{ msg: string }>;
    constructor(inner: { msg: string }) {
      super('NotificationSettingsError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === NotificationSettingsError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<{ msg: string }> {
      return obj.inner;
    }
  }

  type InvalidParameter__interface = {
    tag: NotificationSettingsError_Tags.InvalidParameter;
    inner: Readonly<{ msg: string }>;
  };

  /**
   * Invalid parameter.
   */
  class InvalidParameter_
    extends UniffiError
    implements InvalidParameter__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.InvalidParameter;
    readonly inner: Readonly<{ msg: string }>;
    constructor(inner: { msg: string }) {
      super('NotificationSettingsError', 'InvalidParameter');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string }): InvalidParameter_ {
      return new InvalidParameter_(inner);
    }

    static instanceOf(obj: any): obj is InvalidParameter_ {
      return obj.tag === NotificationSettingsError_Tags.InvalidParameter;
    }

    static hasInner(obj: any): obj is InvalidParameter_ {
      return InvalidParameter_.instanceOf(obj);
    }

    static getInner(obj: InvalidParameter_): Readonly<{ msg: string }> {
      return obj.inner;
    }
  }

  type InvalidRoomId__interface = {
    tag: NotificationSettingsError_Tags.InvalidRoomId;
    inner: Readonly<{ roomId: string }>;
  };

  /**
   * Invalid room id.
   */
  class InvalidRoomId_ extends UniffiError implements InvalidRoomId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.InvalidRoomId;
    readonly inner: Readonly<{ roomId: string }>;
    constructor(inner: { roomId: string }) {
      super('NotificationSettingsError', 'InvalidRoomId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomId: string }): InvalidRoomId_ {
      return new InvalidRoomId_(inner);
    }

    static instanceOf(obj: any): obj is InvalidRoomId_ {
      return obj.tag === NotificationSettingsError_Tags.InvalidRoomId;
    }

    static hasInner(obj: any): obj is InvalidRoomId_ {
      return InvalidRoomId_.instanceOf(obj);
    }

    static getInner(obj: InvalidRoomId_): Readonly<{ roomId: string }> {
      return obj.inner;
    }
  }

  type RuleNotFound__interface = {
    tag: NotificationSettingsError_Tags.RuleNotFound;
    inner: Readonly<{ ruleId: string }>;
  };

  /**
   * Rule not found
   */
  class RuleNotFound_ extends UniffiError implements RuleNotFound__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.RuleNotFound;
    readonly inner: Readonly<{ ruleId: string }>;
    constructor(inner: { ruleId: string }) {
      super('NotificationSettingsError', 'RuleNotFound');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { ruleId: string }): RuleNotFound_ {
      return new RuleNotFound_(inner);
    }

    static instanceOf(obj: any): obj is RuleNotFound_ {
      return obj.tag === NotificationSettingsError_Tags.RuleNotFound;
    }

    static hasInner(obj: any): obj is RuleNotFound_ {
      return RuleNotFound_.instanceOf(obj);
    }

    static getInner(obj: RuleNotFound_): Readonly<{ ruleId: string }> {
      return obj.inner;
    }
  }

  type UnableToAddPushRule__interface = {
    tag: NotificationSettingsError_Tags.UnableToAddPushRule;
  };

  /**
   * Unable to add push rule.
   */
  class UnableToAddPushRule_
    extends UniffiError
    implements UnableToAddPushRule__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.UnableToAddPushRule;
    constructor() {
      super('NotificationSettingsError', 'UnableToAddPushRule');
    }

    static new(): UnableToAddPushRule_ {
      return new UnableToAddPushRule_();
    }

    static instanceOf(obj: any): obj is UnableToAddPushRule_ {
      return obj.tag === NotificationSettingsError_Tags.UnableToAddPushRule;
    }

    static hasInner(obj: any): obj is UnableToAddPushRule_ {
      return false;
    }
  }

  type UnableToRemovePushRule__interface = {
    tag: NotificationSettingsError_Tags.UnableToRemovePushRule;
  };

  /**
   * Unable to remove push rule.
   */
  class UnableToRemovePushRule_
    extends UniffiError
    implements UnableToRemovePushRule__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.UnableToRemovePushRule;
    constructor() {
      super('NotificationSettingsError', 'UnableToRemovePushRule');
    }

    static new(): UnableToRemovePushRule_ {
      return new UnableToRemovePushRule_();
    }

    static instanceOf(obj: any): obj is UnableToRemovePushRule_ {
      return obj.tag === NotificationSettingsError_Tags.UnableToRemovePushRule;
    }

    static hasInner(obj: any): obj is UnableToRemovePushRule_ {
      return false;
    }
  }

  type UnableToSavePushRules__interface = {
    tag: NotificationSettingsError_Tags.UnableToSavePushRules;
  };

  /**
   * Unable to save the push rules
   */
  class UnableToSavePushRules_
    extends UniffiError
    implements UnableToSavePushRules__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.UnableToSavePushRules;
    constructor() {
      super('NotificationSettingsError', 'UnableToSavePushRules');
    }

    static new(): UnableToSavePushRules_ {
      return new UnableToSavePushRules_();
    }

    static instanceOf(obj: any): obj is UnableToSavePushRules_ {
      return obj.tag === NotificationSettingsError_Tags.UnableToSavePushRules;
    }

    static hasInner(obj: any): obj is UnableToSavePushRules_ {
      return false;
    }
  }

  type UnableToUpdatePushRule__interface = {
    tag: NotificationSettingsError_Tags.UnableToUpdatePushRule;
  };

  /**
   * Unable to update push rule.
   */
  class UnableToUpdatePushRule_
    extends UniffiError
    implements UnableToUpdatePushRule__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.UnableToUpdatePushRule;
    constructor() {
      super('NotificationSettingsError', 'UnableToUpdatePushRule');
    }

    static new(): UnableToUpdatePushRule_ {
      return new UnableToUpdatePushRule_();
    }

    static instanceOf(obj: any): obj is UnableToUpdatePushRule_ {
      return obj.tag === NotificationSettingsError_Tags.UnableToUpdatePushRule;
    }

    static hasInner(obj: any): obj is UnableToUpdatePushRule_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is NotificationSettingsError {
    return obj[uniffiTypeNameSymbol] === 'NotificationSettingsError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
    InvalidParameter: InvalidParameter_,
    InvalidRoomId: InvalidRoomId_,
    RuleNotFound: RuleNotFound_,
    UnableToAddPushRule: UnableToAddPushRule_,
    UnableToRemovePushRule: UnableToRemovePushRule_,
    UnableToSavePushRules: UnableToSavePushRules_,
    UnableToUpdatePushRule: UnableToUpdatePushRule_,
  });
})();

export type NotificationSettingsError = InstanceType<
  (typeof NotificationSettingsError)[keyof Omit<
    typeof NotificationSettingsError,
    'instanceOf'
  >]
>;

// FfiConverter for enum NotificationSettingsError
const FfiConverterTypeNotificationSettingsError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotificationSettingsError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new NotificationSettingsError.Generic({
            msg: FfiConverterString.read(from),
          });
        case 2:
          return new NotificationSettingsError.InvalidParameter({
            msg: FfiConverterString.read(from),
          });
        case 3:
          return new NotificationSettingsError.InvalidRoomId({
            roomId: FfiConverterString.read(from),
          });
        case 4:
          return new NotificationSettingsError.RuleNotFound({
            ruleId: FfiConverterString.read(from),
          });
        case 5:
          return new NotificationSettingsError.UnableToAddPushRule();
        case 6:
          return new NotificationSettingsError.UnableToRemovePushRule();
        case 7:
          return new NotificationSettingsError.UnableToSavePushRules();
        case 8:
          return new NotificationSettingsError.UnableToUpdatePushRule();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case NotificationSettingsError_Tags.Generic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          return;
        }
        case NotificationSettingsError_Tags.InvalidParameter: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          return;
        }
        case NotificationSettingsError_Tags.InvalidRoomId: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomId, into);
          return;
        }
        case NotificationSettingsError_Tags.RuleNotFound: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.ruleId, into);
          return;
        }
        case NotificationSettingsError_Tags.UnableToAddPushRule: {
          ordinalConverter.write(5, into);
          return;
        }
        case NotificationSettingsError_Tags.UnableToRemovePushRule: {
          ordinalConverter.write(6, into);
          return;
        }
        case NotificationSettingsError_Tags.UnableToSavePushRules: {
          ordinalConverter.write(7, into);
          return;
        }
        case NotificationSettingsError_Tags.UnableToUpdatePushRule: {
          ordinalConverter.write(8, into);
          return;
        }
        default:
          // Throwing from here means that NotificationSettingsError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case NotificationSettingsError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.msg);
          return size;
        }
        case NotificationSettingsError_Tags.InvalidParameter: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.msg);
          return size;
        }
        case NotificationSettingsError_Tags.InvalidRoomId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.roomId);
          return size;
        }
        case NotificationSettingsError_Tags.RuleNotFound: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.ruleId);
          return size;
        }
        case NotificationSettingsError_Tags.UnableToAddPushRule: {
          return ordinalConverter.allocationSize(5);
        }
        case NotificationSettingsError_Tags.UnableToRemovePushRule: {
          return ordinalConverter.allocationSize(6);
        }
        case NotificationSettingsError_Tags.UnableToSavePushRules: {
          return ordinalConverter.allocationSize(7);
        }
        case NotificationSettingsError_Tags.UnableToUpdatePushRule: {
          return ordinalConverter.allocationSize(8);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum NotifyType {
  Ring,
  Notify,
}

const FfiConverterTypeNotifyType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotifyType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return NotifyType.Ring;
        case 2:
          return NotifyType.Notify;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case NotifyType.Ring:
          return ordinalConverter.write(1, into);
        case NotifyType.Notify:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: OidcError
export enum OidcError_Tags {
  NotSupported = 'NotSupported',
  MetadataInvalid = 'MetadataInvalid',
  RegistrationsPathInvalid = 'RegistrationsPathInvalid',
  CallbackUrlInvalid = 'CallbackUrlInvalid',
  Cancelled = 'Cancelled',
  Generic = 'Generic',
}
export const OidcError = (() => {
  class NotSupported extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = OidcError_Tags.NotSupported;

    constructor(message: string) {
      super('OidcError', 'NotSupported', message);
    }

    static instanceOf(e: any): e is NotSupported {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class MetadataInvalid extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = OidcError_Tags.MetadataInvalid;

    constructor(message: string) {
      super('OidcError', 'MetadataInvalid', message);
    }

    static instanceOf(e: any): e is MetadataInvalid {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class RegistrationsPathInvalid extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = OidcError_Tags.RegistrationsPathInvalid;

    constructor(message: string) {
      super('OidcError', 'RegistrationsPathInvalid', message);
    }

    static instanceOf(e: any): e is RegistrationsPathInvalid {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class CallbackUrlInvalid extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = OidcError_Tags.CallbackUrlInvalid;

    constructor(message: string) {
      super('OidcError', 'CallbackUrlInvalid', message);
    }

    static instanceOf(e: any): e is CallbackUrlInvalid {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class Cancelled extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = OidcError_Tags.Cancelled;

    constructor(message: string) {
      super('OidcError', 'Cancelled', message);
    }

    static instanceOf(e: any): e is Cancelled {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = OidcError_Tags.Generic;

    constructor(message: string) {
      super('OidcError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is OidcError {
    return (e as any)[uniffiTypeNameSymbol] === 'OidcError';
  }
  return {
    NotSupported,
    MetadataInvalid,
    RegistrationsPathInvalid,
    CallbackUrlInvalid,
    Cancelled,
    Generic,
    instanceOf,
  };
})();

// Union type for OidcError error type.

export type OidcError = InstanceType<
  (typeof OidcError)[keyof Omit<typeof OidcError, 'instanceOf'>]
>;

const FfiConverterTypeOidcError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = OidcError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new OidcError.NotSupported(FfiConverterString.read(from));

        case 2:
          return new OidcError.MetadataInvalid(FfiConverterString.read(from));

        case 3:
          return new OidcError.RegistrationsPathInvalid(
            FfiConverterString.read(from)
          );

        case 4:
          return new OidcError.CallbackUrlInvalid(
            FfiConverterString.read(from)
          );

        case 5:
          return new OidcError.Cancelled(FfiConverterString.read(from));

        case 6:
          return new OidcError.Generic(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: OidcPrompt
export enum OidcPrompt_Tags {
  None = 'None',
  Login = 'Login',
  Consent = 'Consent',
  SelectAccount = 'SelectAccount',
  Create = 'Create',
  Unknown = 'Unknown',
}
export const OidcPrompt = (() => {
  type None__interface = {
    tag: OidcPrompt_Tags.None;
  };

  /**
   * The Authorization Server must not display any authentication or consent
   * user interface pages.
   */
  class None_ extends UniffiEnum implements None__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.None;
    constructor() {
      super('OidcPrompt', 'None');
    }

    static new(): None_ {
      return new None_();
    }

    static instanceOf(obj: any): obj is None_ {
      return obj.tag === OidcPrompt_Tags.None;
    }
  }

  type Login__interface = {
    tag: OidcPrompt_Tags.Login;
  };

  /**
   * The Authorization Server should prompt the End-User for
   * reauthentication.
   */
  class Login_ extends UniffiEnum implements Login__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.Login;
    constructor() {
      super('OidcPrompt', 'Login');
    }

    static new(): Login_ {
      return new Login_();
    }

    static instanceOf(obj: any): obj is Login_ {
      return obj.tag === OidcPrompt_Tags.Login;
    }
  }

  type Consent__interface = {
    tag: OidcPrompt_Tags.Consent;
  };

  /**
   * The Authorization Server should prompt the End-User for consent before
   * returning information to the Client.
   */
  class Consent_ extends UniffiEnum implements Consent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.Consent;
    constructor() {
      super('OidcPrompt', 'Consent');
    }

    static new(): Consent_ {
      return new Consent_();
    }

    static instanceOf(obj: any): obj is Consent_ {
      return obj.tag === OidcPrompt_Tags.Consent;
    }
  }

  type SelectAccount__interface = {
    tag: OidcPrompt_Tags.SelectAccount;
  };

  /**
   * The Authorization Server should prompt the End-User to select a user
   * account.
   *
   * This enables an End-User who has multiple accounts at the Authorization
   * Server to select amongst the multiple accounts that they might have
   * current sessions for.
   */
  class SelectAccount_ extends UniffiEnum implements SelectAccount__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.SelectAccount;
    constructor() {
      super('OidcPrompt', 'SelectAccount');
    }

    static new(): SelectAccount_ {
      return new SelectAccount_();
    }

    static instanceOf(obj: any): obj is SelectAccount_ {
      return obj.tag === OidcPrompt_Tags.SelectAccount;
    }
  }

  type Create__interface = {
    tag: OidcPrompt_Tags.Create;
  };

  /**
   * The Authorization Server should prompt the End-User to create a user
   * account.
   *
   * Defined in [Initiating User Registration via OpenID Connect](https://openid.net/specs/openid-connect-prompt-create-1_0.html).
   */
  class Create_ extends UniffiEnum implements Create__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.Create;
    constructor() {
      super('OidcPrompt', 'Create');
    }

    static new(): Create_ {
      return new Create_();
    }

    static instanceOf(obj: any): obj is Create_ {
      return obj.tag === OidcPrompt_Tags.Create;
    }
  }

  type Unknown__interface = {
    tag: OidcPrompt_Tags.Unknown;
    inner: Readonly<{ value: string }>;
  };

  /**
   * An unknown value.
   */
  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.Unknown;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('OidcPrompt', 'Unknown');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Unknown_ {
      return new Unknown_(inner);
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === OidcPrompt_Tags.Unknown;
    }
  }

  function instanceOf(obj: any): obj is OidcPrompt {
    return obj[uniffiTypeNameSymbol] === 'OidcPrompt';
  }

  return Object.freeze({
    instanceOf,
    None: None_,
    Login: Login_,
    Consent: Consent_,
    SelectAccount: SelectAccount_,
    Create: Create_,
    Unknown: Unknown_,
  });
})();

export type OidcPrompt = InstanceType<
  (typeof OidcPrompt)[keyof Omit<typeof OidcPrompt, 'instanceOf'>]
>;

// FfiConverter for enum OidcPrompt
const FfiConverterTypeOidcPrompt = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = OidcPrompt;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new OidcPrompt.None();
        case 2:
          return new OidcPrompt.Login();
        case 3:
          return new OidcPrompt.Consent();
        case 4:
          return new OidcPrompt.SelectAccount();
        case 5:
          return new OidcPrompt.Create();
        case 6:
          return new OidcPrompt.Unknown({
            value: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case OidcPrompt_Tags.None: {
          ordinalConverter.write(1, into);
          return;
        }
        case OidcPrompt_Tags.Login: {
          ordinalConverter.write(2, into);
          return;
        }
        case OidcPrompt_Tags.Consent: {
          ordinalConverter.write(3, into);
          return;
        }
        case OidcPrompt_Tags.SelectAccount: {
          ordinalConverter.write(4, into);
          return;
        }
        case OidcPrompt_Tags.Create: {
          ordinalConverter.write(5, into);
          return;
        }
        case OidcPrompt_Tags.Unknown: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that OidcPrompt_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case OidcPrompt_Tags.None: {
          return ordinalConverter.allocationSize(1);
        }
        case OidcPrompt_Tags.Login: {
          return ordinalConverter.allocationSize(2);
        }
        case OidcPrompt_Tags.Consent: {
          return ordinalConverter.allocationSize(3);
        }
        case OidcPrompt_Tags.SelectAccount: {
          return ordinalConverter.allocationSize(4);
        }
        case OidcPrompt_Tags.Create: {
          return ordinalConverter.allocationSize(5);
        }
        case OidcPrompt_Tags.Unknown: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: OtherState
export enum OtherState_Tags {
  PolicyRuleRoom = 'PolicyRuleRoom',
  PolicyRuleServer = 'PolicyRuleServer',
  PolicyRuleUser = 'PolicyRuleUser',
  RoomAliases = 'RoomAliases',
  RoomAvatar = 'RoomAvatar',
  RoomCanonicalAlias = 'RoomCanonicalAlias',
  RoomCreate = 'RoomCreate',
  RoomEncryption = 'RoomEncryption',
  RoomGuestAccess = 'RoomGuestAccess',
  RoomHistoryVisibility = 'RoomHistoryVisibility',
  RoomJoinRules = 'RoomJoinRules',
  RoomName = 'RoomName',
  RoomPinnedEvents = 'RoomPinnedEvents',
  RoomPowerLevels = 'RoomPowerLevels',
  RoomServerAcl = 'RoomServerAcl',
  RoomThirdPartyInvite = 'RoomThirdPartyInvite',
  RoomTombstone = 'RoomTombstone',
  RoomTopic = 'RoomTopic',
  SpaceChild = 'SpaceChild',
  SpaceParent = 'SpaceParent',
  Custom = 'Custom',
}
export const OtherState = (() => {
  type PolicyRuleRoom__interface = {
    tag: OtherState_Tags.PolicyRuleRoom;
  };

  class PolicyRuleRoom_
    extends UniffiEnum
    implements PolicyRuleRoom__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.PolicyRuleRoom;
    constructor() {
      super('OtherState', 'PolicyRuleRoom');
    }

    static new(): PolicyRuleRoom_ {
      return new PolicyRuleRoom_();
    }

    static instanceOf(obj: any): obj is PolicyRuleRoom_ {
      return obj.tag === OtherState_Tags.PolicyRuleRoom;
    }
  }

  type PolicyRuleServer__interface = {
    tag: OtherState_Tags.PolicyRuleServer;
  };

  class PolicyRuleServer_
    extends UniffiEnum
    implements PolicyRuleServer__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.PolicyRuleServer;
    constructor() {
      super('OtherState', 'PolicyRuleServer');
    }

    static new(): PolicyRuleServer_ {
      return new PolicyRuleServer_();
    }

    static instanceOf(obj: any): obj is PolicyRuleServer_ {
      return obj.tag === OtherState_Tags.PolicyRuleServer;
    }
  }

  type PolicyRuleUser__interface = {
    tag: OtherState_Tags.PolicyRuleUser;
  };

  class PolicyRuleUser_
    extends UniffiEnum
    implements PolicyRuleUser__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.PolicyRuleUser;
    constructor() {
      super('OtherState', 'PolicyRuleUser');
    }

    static new(): PolicyRuleUser_ {
      return new PolicyRuleUser_();
    }

    static instanceOf(obj: any): obj is PolicyRuleUser_ {
      return obj.tag === OtherState_Tags.PolicyRuleUser;
    }
  }

  type RoomAliases__interface = {
    tag: OtherState_Tags.RoomAliases;
  };

  class RoomAliases_ extends UniffiEnum implements RoomAliases__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomAliases;
    constructor() {
      super('OtherState', 'RoomAliases');
    }

    static new(): RoomAliases_ {
      return new RoomAliases_();
    }

    static instanceOf(obj: any): obj is RoomAliases_ {
      return obj.tag === OtherState_Tags.RoomAliases;
    }
  }

  type RoomAvatar__interface = {
    tag: OtherState_Tags.RoomAvatar;
    inner: Readonly<{ url: string | undefined }>;
  };

  class RoomAvatar_ extends UniffiEnum implements RoomAvatar__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomAvatar;
    readonly inner: Readonly<{ url: string | undefined }>;
    constructor(inner: { url: string | undefined }) {
      super('OtherState', 'RoomAvatar');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string | undefined }): RoomAvatar_ {
      return new RoomAvatar_(inner);
    }

    static instanceOf(obj: any): obj is RoomAvatar_ {
      return obj.tag === OtherState_Tags.RoomAvatar;
    }
  }

  type RoomCanonicalAlias__interface = {
    tag: OtherState_Tags.RoomCanonicalAlias;
  };

  class RoomCanonicalAlias_
    extends UniffiEnum
    implements RoomCanonicalAlias__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomCanonicalAlias;
    constructor() {
      super('OtherState', 'RoomCanonicalAlias');
    }

    static new(): RoomCanonicalAlias_ {
      return new RoomCanonicalAlias_();
    }

    static instanceOf(obj: any): obj is RoomCanonicalAlias_ {
      return obj.tag === OtherState_Tags.RoomCanonicalAlias;
    }
  }

  type RoomCreate__interface = {
    tag: OtherState_Tags.RoomCreate;
  };

  class RoomCreate_ extends UniffiEnum implements RoomCreate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomCreate;
    constructor() {
      super('OtherState', 'RoomCreate');
    }

    static new(): RoomCreate_ {
      return new RoomCreate_();
    }

    static instanceOf(obj: any): obj is RoomCreate_ {
      return obj.tag === OtherState_Tags.RoomCreate;
    }
  }

  type RoomEncryption__interface = {
    tag: OtherState_Tags.RoomEncryption;
  };

  class RoomEncryption_
    extends UniffiEnum
    implements RoomEncryption__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomEncryption;
    constructor() {
      super('OtherState', 'RoomEncryption');
    }

    static new(): RoomEncryption_ {
      return new RoomEncryption_();
    }

    static instanceOf(obj: any): obj is RoomEncryption_ {
      return obj.tag === OtherState_Tags.RoomEncryption;
    }
  }

  type RoomGuestAccess__interface = {
    tag: OtherState_Tags.RoomGuestAccess;
  };

  class RoomGuestAccess_
    extends UniffiEnum
    implements RoomGuestAccess__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomGuestAccess;
    constructor() {
      super('OtherState', 'RoomGuestAccess');
    }

    static new(): RoomGuestAccess_ {
      return new RoomGuestAccess_();
    }

    static instanceOf(obj: any): obj is RoomGuestAccess_ {
      return obj.tag === OtherState_Tags.RoomGuestAccess;
    }
  }

  type RoomHistoryVisibility__interface = {
    tag: OtherState_Tags.RoomHistoryVisibility;
  };

  class RoomHistoryVisibility_
    extends UniffiEnum
    implements RoomHistoryVisibility__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomHistoryVisibility;
    constructor() {
      super('OtherState', 'RoomHistoryVisibility');
    }

    static new(): RoomHistoryVisibility_ {
      return new RoomHistoryVisibility_();
    }

    static instanceOf(obj: any): obj is RoomHistoryVisibility_ {
      return obj.tag === OtherState_Tags.RoomHistoryVisibility;
    }
  }

  type RoomJoinRules__interface = {
    tag: OtherState_Tags.RoomJoinRules;
  };

  class RoomJoinRules_ extends UniffiEnum implements RoomJoinRules__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomJoinRules;
    constructor() {
      super('OtherState', 'RoomJoinRules');
    }

    static new(): RoomJoinRules_ {
      return new RoomJoinRules_();
    }

    static instanceOf(obj: any): obj is RoomJoinRules_ {
      return obj.tag === OtherState_Tags.RoomJoinRules;
    }
  }

  type RoomName__interface = {
    tag: OtherState_Tags.RoomName;
    inner: Readonly<{ name: string | undefined }>;
  };

  class RoomName_ extends UniffiEnum implements RoomName__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomName;
    readonly inner: Readonly<{ name: string | undefined }>;
    constructor(inner: { name: string | undefined }) {
      super('OtherState', 'RoomName');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { name: string | undefined }): RoomName_ {
      return new RoomName_(inner);
    }

    static instanceOf(obj: any): obj is RoomName_ {
      return obj.tag === OtherState_Tags.RoomName;
    }
  }

  type RoomPinnedEvents__interface = {
    tag: OtherState_Tags.RoomPinnedEvents;
    inner: Readonly<{ change: RoomPinnedEventsChange }>;
  };

  class RoomPinnedEvents_
    extends UniffiEnum
    implements RoomPinnedEvents__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomPinnedEvents;
    readonly inner: Readonly<{ change: RoomPinnedEventsChange }>;
    constructor(inner: { change: RoomPinnedEventsChange }) {
      super('OtherState', 'RoomPinnedEvents');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { change: RoomPinnedEventsChange }): RoomPinnedEvents_ {
      return new RoomPinnedEvents_(inner);
    }

    static instanceOf(obj: any): obj is RoomPinnedEvents_ {
      return obj.tag === OtherState_Tags.RoomPinnedEvents;
    }
  }

  type RoomPowerLevels__interface = {
    tag: OtherState_Tags.RoomPowerLevels;
    inner: Readonly<{
      users: Map<string, /*i64*/ bigint>;
      previous: Map<string, /*i64*/ bigint> | undefined;
    }>;
  };

  class RoomPowerLevels_
    extends UniffiEnum
    implements RoomPowerLevels__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomPowerLevels;
    readonly inner: Readonly<{
      users: Map<string, /*i64*/ bigint>;
      previous: Map<string, /*i64*/ bigint> | undefined;
    }>;
    constructor(inner: {
      users: Map<string, /*i64*/ bigint>;
      previous: Map<string, /*i64*/ bigint> | undefined;
    }) {
      super('OtherState', 'RoomPowerLevels');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      users: Map<string, /*i64*/ bigint>;
      previous: Map<string, /*i64*/ bigint> | undefined;
    }): RoomPowerLevels_ {
      return new RoomPowerLevels_(inner);
    }

    static instanceOf(obj: any): obj is RoomPowerLevels_ {
      return obj.tag === OtherState_Tags.RoomPowerLevels;
    }
  }

  type RoomServerAcl__interface = {
    tag: OtherState_Tags.RoomServerAcl;
  };

  class RoomServerAcl_ extends UniffiEnum implements RoomServerAcl__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomServerAcl;
    constructor() {
      super('OtherState', 'RoomServerAcl');
    }

    static new(): RoomServerAcl_ {
      return new RoomServerAcl_();
    }

    static instanceOf(obj: any): obj is RoomServerAcl_ {
      return obj.tag === OtherState_Tags.RoomServerAcl;
    }
  }

  type RoomThirdPartyInvite__interface = {
    tag: OtherState_Tags.RoomThirdPartyInvite;
    inner: Readonly<{ displayName: string | undefined }>;
  };

  class RoomThirdPartyInvite_
    extends UniffiEnum
    implements RoomThirdPartyInvite__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomThirdPartyInvite;
    readonly inner: Readonly<{ displayName: string | undefined }>;
    constructor(inner: { displayName: string | undefined }) {
      super('OtherState', 'RoomThirdPartyInvite');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      displayName: string | undefined;
    }): RoomThirdPartyInvite_ {
      return new RoomThirdPartyInvite_(inner);
    }

    static instanceOf(obj: any): obj is RoomThirdPartyInvite_ {
      return obj.tag === OtherState_Tags.RoomThirdPartyInvite;
    }
  }

  type RoomTombstone__interface = {
    tag: OtherState_Tags.RoomTombstone;
  };

  class RoomTombstone_ extends UniffiEnum implements RoomTombstone__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomTombstone;
    constructor() {
      super('OtherState', 'RoomTombstone');
    }

    static new(): RoomTombstone_ {
      return new RoomTombstone_();
    }

    static instanceOf(obj: any): obj is RoomTombstone_ {
      return obj.tag === OtherState_Tags.RoomTombstone;
    }
  }

  type RoomTopic__interface = {
    tag: OtherState_Tags.RoomTopic;
    inner: Readonly<{ topic: string | undefined }>;
  };

  class RoomTopic_ extends UniffiEnum implements RoomTopic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomTopic;
    readonly inner: Readonly<{ topic: string | undefined }>;
    constructor(inner: { topic: string | undefined }) {
      super('OtherState', 'RoomTopic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { topic: string | undefined }): RoomTopic_ {
      return new RoomTopic_(inner);
    }

    static instanceOf(obj: any): obj is RoomTopic_ {
      return obj.tag === OtherState_Tags.RoomTopic;
    }
  }

  type SpaceChild__interface = {
    tag: OtherState_Tags.SpaceChild;
  };

  class SpaceChild_ extends UniffiEnum implements SpaceChild__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.SpaceChild;
    constructor() {
      super('OtherState', 'SpaceChild');
    }

    static new(): SpaceChild_ {
      return new SpaceChild_();
    }

    static instanceOf(obj: any): obj is SpaceChild_ {
      return obj.tag === OtherState_Tags.SpaceChild;
    }
  }

  type SpaceParent__interface = {
    tag: OtherState_Tags.SpaceParent;
  };

  class SpaceParent_ extends UniffiEnum implements SpaceParent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.SpaceParent;
    constructor() {
      super('OtherState', 'SpaceParent');
    }

    static new(): SpaceParent_ {
      return new SpaceParent_();
    }

    static instanceOf(obj: any): obj is SpaceParent_ {
      return obj.tag === OtherState_Tags.SpaceParent;
    }
  }

  type Custom__interface = {
    tag: OtherState_Tags.Custom;
    inner: Readonly<{ eventType: string }>;
  };

  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.Custom;
    readonly inner: Readonly<{ eventType: string }>;
    constructor(inner: { eventType: string }) {
      super('OtherState', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === OtherState_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is OtherState {
    return obj[uniffiTypeNameSymbol] === 'OtherState';
  }

  return Object.freeze({
    instanceOf,
    PolicyRuleRoom: PolicyRuleRoom_,
    PolicyRuleServer: PolicyRuleServer_,
    PolicyRuleUser: PolicyRuleUser_,
    RoomAliases: RoomAliases_,
    RoomAvatar: RoomAvatar_,
    RoomCanonicalAlias: RoomCanonicalAlias_,
    RoomCreate: RoomCreate_,
    RoomEncryption: RoomEncryption_,
    RoomGuestAccess: RoomGuestAccess_,
    RoomHistoryVisibility: RoomHistoryVisibility_,
    RoomJoinRules: RoomJoinRules_,
    RoomName: RoomName_,
    RoomPinnedEvents: RoomPinnedEvents_,
    RoomPowerLevels: RoomPowerLevels_,
    RoomServerAcl: RoomServerAcl_,
    RoomThirdPartyInvite: RoomThirdPartyInvite_,
    RoomTombstone: RoomTombstone_,
    RoomTopic: RoomTopic_,
    SpaceChild: SpaceChild_,
    SpaceParent: SpaceParent_,
    Custom: Custom_,
  });
})();

export type OtherState = InstanceType<
  (typeof OtherState)[keyof Omit<typeof OtherState, 'instanceOf'>]
>;

// FfiConverter for enum OtherState
const FfiConverterTypeOtherState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = OtherState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new OtherState.PolicyRuleRoom();
        case 2:
          return new OtherState.PolicyRuleServer();
        case 3:
          return new OtherState.PolicyRuleUser();
        case 4:
          return new OtherState.RoomAliases();
        case 5:
          return new OtherState.RoomAvatar({
            url: FfiConverterOptionalString.read(from),
          });
        case 6:
          return new OtherState.RoomCanonicalAlias();
        case 7:
          return new OtherState.RoomCreate();
        case 8:
          return new OtherState.RoomEncryption();
        case 9:
          return new OtherState.RoomGuestAccess();
        case 10:
          return new OtherState.RoomHistoryVisibility();
        case 11:
          return new OtherState.RoomJoinRules();
        case 12:
          return new OtherState.RoomName({
            name: FfiConverterOptionalString.read(from),
          });
        case 13:
          return new OtherState.RoomPinnedEvents({
            change: FfiConverterTypeRoomPinnedEventsChange.read(from),
          });
        case 14:
          return new OtherState.RoomPowerLevels({
            users: FfiConverterMapStringInt64.read(from),
            previous: FfiConverterOptionalMapStringInt64.read(from),
          });
        case 15:
          return new OtherState.RoomServerAcl();
        case 16:
          return new OtherState.RoomThirdPartyInvite({
            displayName: FfiConverterOptionalString.read(from),
          });
        case 17:
          return new OtherState.RoomTombstone();
        case 18:
          return new OtherState.RoomTopic({
            topic: FfiConverterOptionalString.read(from),
          });
        case 19:
          return new OtherState.SpaceChild();
        case 20:
          return new OtherState.SpaceParent();
        case 21:
          return new OtherState.Custom({
            eventType: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case OtherState_Tags.PolicyRuleRoom: {
          ordinalConverter.write(1, into);
          return;
        }
        case OtherState_Tags.PolicyRuleServer: {
          ordinalConverter.write(2, into);
          return;
        }
        case OtherState_Tags.PolicyRuleUser: {
          ordinalConverter.write(3, into);
          return;
        }
        case OtherState_Tags.RoomAliases: {
          ordinalConverter.write(4, into);
          return;
        }
        case OtherState_Tags.RoomAvatar: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.url, into);
          return;
        }
        case OtherState_Tags.RoomCanonicalAlias: {
          ordinalConverter.write(6, into);
          return;
        }
        case OtherState_Tags.RoomCreate: {
          ordinalConverter.write(7, into);
          return;
        }
        case OtherState_Tags.RoomEncryption: {
          ordinalConverter.write(8, into);
          return;
        }
        case OtherState_Tags.RoomGuestAccess: {
          ordinalConverter.write(9, into);
          return;
        }
        case OtherState_Tags.RoomHistoryVisibility: {
          ordinalConverter.write(10, into);
          return;
        }
        case OtherState_Tags.RoomJoinRules: {
          ordinalConverter.write(11, into);
          return;
        }
        case OtherState_Tags.RoomName: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.name, into);
          return;
        }
        case OtherState_Tags.RoomPinnedEvents: {
          ordinalConverter.write(13, into);
          const inner = value.inner;
          FfiConverterTypeRoomPinnedEventsChange.write(inner.change, into);
          return;
        }
        case OtherState_Tags.RoomPowerLevels: {
          ordinalConverter.write(14, into);
          const inner = value.inner;
          FfiConverterMapStringInt64.write(inner.users, into);
          FfiConverterOptionalMapStringInt64.write(inner.previous, into);
          return;
        }
        case OtherState_Tags.RoomServerAcl: {
          ordinalConverter.write(15, into);
          return;
        }
        case OtherState_Tags.RoomThirdPartyInvite: {
          ordinalConverter.write(16, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.displayName, into);
          return;
        }
        case OtherState_Tags.RoomTombstone: {
          ordinalConverter.write(17, into);
          return;
        }
        case OtherState_Tags.RoomTopic: {
          ordinalConverter.write(18, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.topic, into);
          return;
        }
        case OtherState_Tags.SpaceChild: {
          ordinalConverter.write(19, into);
          return;
        }
        case OtherState_Tags.SpaceParent: {
          ordinalConverter.write(20, into);
          return;
        }
        case OtherState_Tags.Custom: {
          ordinalConverter.write(21, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        default:
          // Throwing from here means that OtherState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case OtherState_Tags.PolicyRuleRoom: {
          return ordinalConverter.allocationSize(1);
        }
        case OtherState_Tags.PolicyRuleServer: {
          return ordinalConverter.allocationSize(2);
        }
        case OtherState_Tags.PolicyRuleUser: {
          return ordinalConverter.allocationSize(3);
        }
        case OtherState_Tags.RoomAliases: {
          return ordinalConverter.allocationSize(4);
        }
        case OtherState_Tags.RoomAvatar: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterOptionalString.allocationSize(inner.url);
          return size;
        }
        case OtherState_Tags.RoomCanonicalAlias: {
          return ordinalConverter.allocationSize(6);
        }
        case OtherState_Tags.RoomCreate: {
          return ordinalConverter.allocationSize(7);
        }
        case OtherState_Tags.RoomEncryption: {
          return ordinalConverter.allocationSize(8);
        }
        case OtherState_Tags.RoomGuestAccess: {
          return ordinalConverter.allocationSize(9);
        }
        case OtherState_Tags.RoomHistoryVisibility: {
          return ordinalConverter.allocationSize(10);
        }
        case OtherState_Tags.RoomJoinRules: {
          return ordinalConverter.allocationSize(11);
        }
        case OtherState_Tags.RoomName: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterOptionalString.allocationSize(inner.name);
          return size;
        }
        case OtherState_Tags.RoomPinnedEvents: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(13);
          size += FfiConverterTypeRoomPinnedEventsChange.allocationSize(
            inner.change
          );
          return size;
        }
        case OtherState_Tags.RoomPowerLevels: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(14);
          size += FfiConverterMapStringInt64.allocationSize(inner.users);
          size += FfiConverterOptionalMapStringInt64.allocationSize(
            inner.previous
          );
          return size;
        }
        case OtherState_Tags.RoomServerAcl: {
          return ordinalConverter.allocationSize(15);
        }
        case OtherState_Tags.RoomThirdPartyInvite: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(16);
          size += FfiConverterOptionalString.allocationSize(inner.displayName);
          return size;
        }
        case OtherState_Tags.RoomTombstone: {
          return ordinalConverter.allocationSize(17);
        }
        case OtherState_Tags.RoomTopic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(18);
          size += FfiConverterOptionalString.allocationSize(inner.topic);
          return size;
        }
        case OtherState_Tags.SpaceChild: {
          return ordinalConverter.allocationSize(19);
        }
        case OtherState_Tags.SpaceParent: {
          return ordinalConverter.allocationSize(20);
        }
        case OtherState_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(21);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: ParseError
export enum ParseError_Tags {
  EmptyHost = 'EmptyHost',
  IdnaError = 'IdnaError',
  InvalidPort = 'InvalidPort',
  InvalidIpv4Address = 'InvalidIpv4Address',
  InvalidIpv6Address = 'InvalidIpv6Address',
  InvalidDomainCharacter = 'InvalidDomainCharacter',
  RelativeUrlWithoutBase = 'RelativeUrlWithoutBase',
  RelativeUrlWithCannotBeABaseBase = 'RelativeUrlWithCannotBeABaseBase',
  SetHostOnCannotBeABaseUrl = 'SetHostOnCannotBeABaseUrl',
  Overflow = 'Overflow',
  Other = 'Other',
}
export const ParseError = (() => {
  class EmptyHost extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = ParseError_Tags.EmptyHost;

    constructor(message: string) {
      super('ParseError', 'EmptyHost', message);
    }

    static instanceOf(e: any): e is EmptyHost {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class IdnaError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = ParseError_Tags.IdnaError;

    constructor(message: string) {
      super('ParseError', 'IdnaError', message);
    }

    static instanceOf(e: any): e is IdnaError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class InvalidPort extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = ParseError_Tags.InvalidPort;

    constructor(message: string) {
      super('ParseError', 'InvalidPort', message);
    }

    static instanceOf(e: any): e is InvalidPort {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class InvalidIpv4Address extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = ParseError_Tags.InvalidIpv4Address;

    constructor(message: string) {
      super('ParseError', 'InvalidIpv4Address', message);
    }

    static instanceOf(e: any): e is InvalidIpv4Address {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class InvalidIpv6Address extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = ParseError_Tags.InvalidIpv6Address;

    constructor(message: string) {
      super('ParseError', 'InvalidIpv6Address', message);
    }

    static instanceOf(e: any): e is InvalidIpv6Address {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class InvalidDomainCharacter extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = ParseError_Tags.InvalidDomainCharacter;

    constructor(message: string) {
      super('ParseError', 'InvalidDomainCharacter', message);
    }

    static instanceOf(e: any): e is InvalidDomainCharacter {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  class RelativeUrlWithoutBase extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = ParseError_Tags.RelativeUrlWithoutBase;

    constructor(message: string) {
      super('ParseError', 'RelativeUrlWithoutBase', message);
    }

    static instanceOf(e: any): e is RelativeUrlWithoutBase {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  class RelativeUrlWithCannotBeABaseBase extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = ParseError_Tags.RelativeUrlWithCannotBeABaseBase;

    constructor(message: string) {
      super('ParseError', 'RelativeUrlWithCannotBeABaseBase', message);
    }

    static instanceOf(e: any): e is RelativeUrlWithCannotBeABaseBase {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  class SetHostOnCannotBeABaseUrl extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = ParseError_Tags.SetHostOnCannotBeABaseUrl;

    constructor(message: string) {
      super('ParseError', 'SetHostOnCannotBeABaseUrl', message);
    }

    static instanceOf(e: any): e is SetHostOnCannotBeABaseUrl {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }
  class Overflow extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 10;

    public readonly tag = ParseError_Tags.Overflow;

    constructor(message: string) {
      super('ParseError', 'Overflow', message);
    }

    static instanceOf(e: any): e is Overflow {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 10;
    }
  }
  class Other extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 11;

    public readonly tag = ParseError_Tags.Other;

    constructor(message: string) {
      super('ParseError', 'Other', message);
    }

    static instanceOf(e: any): e is Other {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 11;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is ParseError {
    return (e as any)[uniffiTypeNameSymbol] === 'ParseError';
  }
  return {
    EmptyHost,
    IdnaError,
    InvalidPort,
    InvalidIpv4Address,
    InvalidIpv6Address,
    InvalidDomainCharacter,
    RelativeUrlWithoutBase,
    RelativeUrlWithCannotBeABaseBase,
    SetHostOnCannotBeABaseUrl,
    Overflow,
    Other,
    instanceOf,
  };
})();

// Union type for ParseError error type.

export type ParseError = InstanceType<
  (typeof ParseError)[keyof Omit<typeof ParseError, 'instanceOf'>]
>;

const FfiConverterTypeParseError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = ParseError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new ParseError.EmptyHost(FfiConverterString.read(from));

        case 2:
          return new ParseError.IdnaError(FfiConverterString.read(from));

        case 3:
          return new ParseError.InvalidPort(FfiConverterString.read(from));

        case 4:
          return new ParseError.InvalidIpv4Address(
            FfiConverterString.read(from)
          );

        case 5:
          return new ParseError.InvalidIpv6Address(
            FfiConverterString.read(from)
          );

        case 6:
          return new ParseError.InvalidDomainCharacter(
            FfiConverterString.read(from)
          );

        case 7:
          return new ParseError.RelativeUrlWithoutBase(
            FfiConverterString.read(from)
          );

        case 8:
          return new ParseError.RelativeUrlWithCannotBeABaseBase(
            FfiConverterString.read(from)
          );

        case 9:
          return new ParseError.SetHostOnCannotBeABaseUrl(
            FfiConverterString.read(from)
          );

        case 10:
          return new ParseError.Overflow(FfiConverterString.read(from));

        case 11:
          return new ParseError.Other(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum PollKind {
  Disclosed,
  Undisclosed,
}

const FfiConverterTypePollKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PollKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PollKind.Disclosed;
        case 2:
          return PollKind.Undisclosed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PollKind.Disclosed:
          return ordinalConverter.write(1, into);
        case PollKind.Undisclosed:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ProfileDetails
export enum ProfileDetails_Tags {
  Unavailable = 'Unavailable',
  Pending = 'Pending',
  Ready = 'Ready',
  Error = 'Error',
}
export const ProfileDetails = (() => {
  type Unavailable__interface = {
    tag: ProfileDetails_Tags.Unavailable;
  };

  class Unavailable_ extends UniffiEnum implements Unavailable__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProfileDetails';
    readonly tag = ProfileDetails_Tags.Unavailable;
    constructor() {
      super('ProfileDetails', 'Unavailable');
    }

    static new(): Unavailable_ {
      return new Unavailable_();
    }

    static instanceOf(obj: any): obj is Unavailable_ {
      return obj.tag === ProfileDetails_Tags.Unavailable;
    }
  }

  type Pending__interface = {
    tag: ProfileDetails_Tags.Pending;
  };

  class Pending_ extends UniffiEnum implements Pending__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProfileDetails';
    readonly tag = ProfileDetails_Tags.Pending;
    constructor() {
      super('ProfileDetails', 'Pending');
    }

    static new(): Pending_ {
      return new Pending_();
    }

    static instanceOf(obj: any): obj is Pending_ {
      return obj.tag === ProfileDetails_Tags.Pending;
    }
  }

  type Ready__interface = {
    tag: ProfileDetails_Tags.Ready;
    inner: Readonly<{
      displayName: string | undefined;
      displayNameAmbiguous: boolean;
      avatarUrl: string | undefined;
    }>;
  };

  class Ready_ extends UniffiEnum implements Ready__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProfileDetails';
    readonly tag = ProfileDetails_Tags.Ready;
    readonly inner: Readonly<{
      displayName: string | undefined;
      displayNameAmbiguous: boolean;
      avatarUrl: string | undefined;
    }>;
    constructor(inner: {
      displayName: string | undefined;
      displayNameAmbiguous: boolean;
      avatarUrl: string | undefined;
    }) {
      super('ProfileDetails', 'Ready');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      displayName: string | undefined;
      displayNameAmbiguous: boolean;
      avatarUrl: string | undefined;
    }): Ready_ {
      return new Ready_(inner);
    }

    static instanceOf(obj: any): obj is Ready_ {
      return obj.tag === ProfileDetails_Tags.Ready;
    }
  }

  type Error__interface = {
    tag: ProfileDetails_Tags.Error;
    inner: Readonly<{ message: string }>;
  };

  class Error_ extends UniffiEnum implements Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProfileDetails';
    readonly tag = ProfileDetails_Tags.Error;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('ProfileDetails', 'Error');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Error_ {
      return new Error_(inner);
    }

    static instanceOf(obj: any): obj is Error_ {
      return obj.tag === ProfileDetails_Tags.Error;
    }
  }

  function instanceOf(obj: any): obj is ProfileDetails {
    return obj[uniffiTypeNameSymbol] === 'ProfileDetails';
  }

  return Object.freeze({
    instanceOf,
    Unavailable: Unavailable_,
    Pending: Pending_,
    Ready: Ready_,
    Error: Error_,
  });
})();

export type ProfileDetails = InstanceType<
  (typeof ProfileDetails)[keyof Omit<typeof ProfileDetails, 'instanceOf'>]
>;

// FfiConverter for enum ProfileDetails
const FfiConverterTypeProfileDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ProfileDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ProfileDetails.Unavailable();
        case 2:
          return new ProfileDetails.Pending();
        case 3:
          return new ProfileDetails.Ready({
            displayName: FfiConverterOptionalString.read(from),
            displayNameAmbiguous: FfiConverterBool.read(from),
            avatarUrl: FfiConverterOptionalString.read(from),
          });
        case 4:
          return new ProfileDetails.Error({
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ProfileDetails_Tags.Unavailable: {
          ordinalConverter.write(1, into);
          return;
        }
        case ProfileDetails_Tags.Pending: {
          ordinalConverter.write(2, into);
          return;
        }
        case ProfileDetails_Tags.Ready: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.displayName, into);
          FfiConverterBool.write(inner.displayNameAmbiguous, into);
          FfiConverterOptionalString.write(inner.avatarUrl, into);
          return;
        }
        case ProfileDetails_Tags.Error: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that ProfileDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ProfileDetails_Tags.Unavailable: {
          return ordinalConverter.allocationSize(1);
        }
        case ProfileDetails_Tags.Pending: {
          return ordinalConverter.allocationSize(2);
        }
        case ProfileDetails_Tags.Ready: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterOptionalString.allocationSize(inner.displayName);
          size += FfiConverterBool.allocationSize(inner.displayNameAmbiguous);
          size += FfiConverterOptionalString.allocationSize(inner.avatarUrl);
          return size;
        }
        case ProfileDetails_Tags.Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum PublicRoomJoinRule {
  Public,
  Knock,
}

const FfiConverterTypePublicRoomJoinRule = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PublicRoomJoinRule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PublicRoomJoinRule.Public;
        case 2:
          return PublicRoomJoinRule.Knock;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PublicRoomJoinRule.Public:
          return ordinalConverter.write(1, into);
        case PublicRoomJoinRule.Knock:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum PushFormat {
  EventIdOnly,
}

const FfiConverterTypePushFormat = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PushFormat;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PushFormat.EventIdOnly;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PushFormat.EventIdOnly:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: PusherKind
export enum PusherKind_Tags {
  Http = 'Http',
  Email = 'Email',
}
export const PusherKind = (() => {
  type Http__interface = {
    tag: PusherKind_Tags.Http;
    inner: Readonly<{ data: HttpPusherData }>;
  };

  class Http_ extends UniffiEnum implements Http__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PusherKind';
    readonly tag = PusherKind_Tags.Http;
    readonly inner: Readonly<{ data: HttpPusherData }>;
    constructor(inner: { data: HttpPusherData }) {
      super('PusherKind', 'Http');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: HttpPusherData }): Http_ {
      return new Http_(inner);
    }

    static instanceOf(obj: any): obj is Http_ {
      return obj.tag === PusherKind_Tags.Http;
    }
  }

  type Email__interface = {
    tag: PusherKind_Tags.Email;
  };

  class Email_ extends UniffiEnum implements Email__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PusherKind';
    readonly tag = PusherKind_Tags.Email;
    constructor() {
      super('PusherKind', 'Email');
    }

    static new(): Email_ {
      return new Email_();
    }

    static instanceOf(obj: any): obj is Email_ {
      return obj.tag === PusherKind_Tags.Email;
    }
  }

  function instanceOf(obj: any): obj is PusherKind {
    return obj[uniffiTypeNameSymbol] === 'PusherKind';
  }

  return Object.freeze({
    instanceOf,
    Http: Http_,
    Email: Email_,
  });
})();

export type PusherKind = InstanceType<
  (typeof PusherKind)[keyof Omit<typeof PusherKind, 'instanceOf'>]
>;

// FfiConverter for enum PusherKind
const FfiConverterTypePusherKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PusherKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PusherKind.Http({
            data: FfiConverterTypeHttpPusherData.read(from),
          });
        case 2:
          return new PusherKind.Email();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PusherKind_Tags.Http: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeHttpPusherData.write(inner.data, into);
          return;
        }
        case PusherKind_Tags.Email: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that PusherKind_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PusherKind_Tags.Http: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeHttpPusherData.allocationSize(inner.data);
          return size;
        }
        case PusherKind_Tags.Email: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: QrCodeDecodeError
export enum QrCodeDecodeError_Tags {
  Crypto = 'Crypto',
}
/**
 * Error type for the decoding of the [`QrCodeData`].
 */
export const QrCodeDecodeError = (() => {
  class Crypto extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeDecodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = QrCodeDecodeError_Tags.Crypto;

    constructor(message: string) {
      super('QrCodeDecodeError', 'Crypto', message);
    }

    static instanceOf(e: any): e is Crypto {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is QrCodeDecodeError {
    return (e as any)[uniffiTypeNameSymbol] === 'QrCodeDecodeError';
  }
  return {
    Crypto,
    instanceOf,
  };
})();

// Union type for QrCodeDecodeError error type.

/**
 * Error type for the decoding of the [`QrCodeData`].
 */

export type QrCodeDecodeError = InstanceType<
  (typeof QrCodeDecodeError)[keyof Omit<typeof QrCodeDecodeError, 'instanceOf'>]
>;

const FfiConverterTypeQrCodeDecodeError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = QrCodeDecodeError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new QrCodeDecodeError.Crypto(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: QrLoginProgress
export enum QrLoginProgress_Tags {
  Starting = 'Starting',
  EstablishingSecureChannel = 'EstablishingSecureChannel',
  WaitingForToken = 'WaitingForToken',
  Done = 'Done',
}
/**
 * Enum describing the progress of the QR-code login.
 */
export const QrLoginProgress = (() => {
  type Starting__interface = {
    tag: QrLoginProgress_Tags.Starting;
  };

  /**
   * The login process is starting.
   */
  class Starting_ extends UniffiEnum implements Starting__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QrLoginProgress';
    readonly tag = QrLoginProgress_Tags.Starting;
    constructor() {
      super('QrLoginProgress', 'Starting');
    }

    static new(): Starting_ {
      return new Starting_();
    }

    static instanceOf(obj: any): obj is Starting_ {
      return obj.tag === QrLoginProgress_Tags.Starting;
    }
  }

  type EstablishingSecureChannel__interface = {
    tag: QrLoginProgress_Tags.EstablishingSecureChannel;
    inner: Readonly<{ checkCode: /*u8*/ number; checkCodeString: string }>;
  };

  /**
   * We established a secure channel with the other device.
   */
  class EstablishingSecureChannel_
    extends UniffiEnum
    implements EstablishingSecureChannel__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QrLoginProgress';
    readonly tag = QrLoginProgress_Tags.EstablishingSecureChannel;
    readonly inner: Readonly<{
      checkCode: /*u8*/ number;
      checkCodeString: string;
    }>;
    constructor(inner: {
      /**
       * The check code that the device should display so the other device
       * can confirm that the channel is secure as well.
       */ checkCode: /*u8*/ number;
      /**
       * The string representation of the check code, will be guaranteed to
       * be 2 characters long, preserving the leading zero if the
       * first digit is a zero.
       */ checkCodeString: string;
    }) {
      super('QrLoginProgress', 'EstablishingSecureChannel');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The check code that the device should display so the other device
       * can confirm that the channel is secure as well.
       */ checkCode: /*u8*/ number;
      /**
       * The string representation of the check code, will be guaranteed to
       * be 2 characters long, preserving the leading zero if the
       * first digit is a zero.
       */ checkCodeString: string;
    }): EstablishingSecureChannel_ {
      return new EstablishingSecureChannel_(inner);
    }

    static instanceOf(obj: any): obj is EstablishingSecureChannel_ {
      return obj.tag === QrLoginProgress_Tags.EstablishingSecureChannel;
    }
  }

  type WaitingForToken__interface = {
    tag: QrLoginProgress_Tags.WaitingForToken;
    inner: Readonly<{ userCode: string }>;
  };

  /**
   * We are waiting for the login and for the OIDC provider to give us an
   * access token.
   */
  class WaitingForToken_
    extends UniffiEnum
    implements WaitingForToken__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QrLoginProgress';
    readonly tag = QrLoginProgress_Tags.WaitingForToken;
    readonly inner: Readonly<{ userCode: string }>;
    constructor(inner: { userCode: string }) {
      super('QrLoginProgress', 'WaitingForToken');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { userCode: string }): WaitingForToken_ {
      return new WaitingForToken_(inner);
    }

    static instanceOf(obj: any): obj is WaitingForToken_ {
      return obj.tag === QrLoginProgress_Tags.WaitingForToken;
    }
  }

  type Done__interface = {
    tag: QrLoginProgress_Tags.Done;
  };

  /**
   * The login has successfully finished.
   */
  class Done_ extends UniffiEnum implements Done__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QrLoginProgress';
    readonly tag = QrLoginProgress_Tags.Done;
    constructor() {
      super('QrLoginProgress', 'Done');
    }

    static new(): Done_ {
      return new Done_();
    }

    static instanceOf(obj: any): obj is Done_ {
      return obj.tag === QrLoginProgress_Tags.Done;
    }
  }

  function instanceOf(obj: any): obj is QrLoginProgress {
    return obj[uniffiTypeNameSymbol] === 'QrLoginProgress';
  }

  return Object.freeze({
    instanceOf,
    Starting: Starting_,
    EstablishingSecureChannel: EstablishingSecureChannel_,
    WaitingForToken: WaitingForToken_,
    Done: Done_,
  });
})();

/**
 * Enum describing the progress of the QR-code login.
 */

export type QrLoginProgress = InstanceType<
  (typeof QrLoginProgress)[keyof Omit<typeof QrLoginProgress, 'instanceOf'>]
>;

// FfiConverter for enum QrLoginProgress
const FfiConverterTypeQrLoginProgress = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = QrLoginProgress;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new QrLoginProgress.Starting();
        case 2:
          return new QrLoginProgress.EstablishingSecureChannel({
            checkCode: FfiConverterUInt8.read(from),
            checkCodeString: FfiConverterString.read(from),
          });
        case 3:
          return new QrLoginProgress.WaitingForToken({
            userCode: FfiConverterString.read(from),
          });
        case 4:
          return new QrLoginProgress.Done();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case QrLoginProgress_Tags.Starting: {
          ordinalConverter.write(1, into);
          return;
        }
        case QrLoginProgress_Tags.EstablishingSecureChannel: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt8.write(inner.checkCode, into);
          FfiConverterString.write(inner.checkCodeString, into);
          return;
        }
        case QrLoginProgress_Tags.WaitingForToken: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.userCode, into);
          return;
        }
        case QrLoginProgress_Tags.Done: {
          ordinalConverter.write(4, into);
          return;
        }
        default:
          // Throwing from here means that QrLoginProgress_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case QrLoginProgress_Tags.Starting: {
          return ordinalConverter.allocationSize(1);
        }
        case QrLoginProgress_Tags.EstablishingSecureChannel: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt8.allocationSize(inner.checkCode);
          size += FfiConverterString.allocationSize(inner.checkCodeString);
          return size;
        }
        case QrLoginProgress_Tags.WaitingForToken: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.userCode);
          return size;
        }
        case QrLoginProgress_Tags.Done: {
          return ordinalConverter.allocationSize(4);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: QueueWedgeError
export enum QueueWedgeError_Tags {
  InsecureDevices = 'InsecureDevices',
  IdentityViolations = 'IdentityViolations',
  CrossVerificationRequired = 'CrossVerificationRequired',
  MissingMediaContent = 'MissingMediaContent',
  InvalidMimeType = 'InvalidMimeType',
  GenericApiError = 'GenericApiError',
}
/**
 * Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
 * String.
 *
 * Represent a failed to send unrecoverable error of an event sent via the
 * send_queue. It is a serializable representation of a client error, see
 * `From` implementation for more details. These errors can not be
 * automatically retried, but yet some manual action can be taken before retry
 * sending. If not the only solution is to delete the local event.
 */
export const QueueWedgeError = (() => {
  type InsecureDevices__interface = {
    tag: QueueWedgeError_Tags.InsecureDevices;
    inner: Readonly<{ userDeviceMap: Map<string, Array<string>> }>;
  };

  /**
   * This error occurs when there are some insecure devices in the room, and
   * the current encryption setting prohibit sharing with them.
   */
  class InsecureDevices_
    extends UniffiEnum
    implements InsecureDevices__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.InsecureDevices;
    readonly inner: Readonly<{ userDeviceMap: Map<string, Array<string>> }>;
    constructor(inner: {
      /**
       * The insecure devices as a Map of userID to deviceID.
       */ userDeviceMap: Map<string, Array<string>>;
    }) {
      super('QueueWedgeError', 'InsecureDevices');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The insecure devices as a Map of userID to deviceID.
       */ userDeviceMap: Map<string, Array<string>>;
    }): InsecureDevices_ {
      return new InsecureDevices_(inner);
    }

    static instanceOf(obj: any): obj is InsecureDevices_ {
      return obj.tag === QueueWedgeError_Tags.InsecureDevices;
    }
  }

  type IdentityViolations__interface = {
    tag: QueueWedgeError_Tags.IdentityViolations;
    inner: Readonly<{ users: Array<string> }>;
  };

  /**
   * This error occurs when a previously verified user is not anymore, and
   * the current encryption setting prohibit sharing when it happens.
   */
  class IdentityViolations_
    extends UniffiEnum
    implements IdentityViolations__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.IdentityViolations;
    readonly inner: Readonly<{ users: Array<string> }>;
    constructor(inner: {
      /**
       * The users that are expected to be verified but are not.
       */ users: Array<string>;
    }) {
      super('QueueWedgeError', 'IdentityViolations');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The users that are expected to be verified but are not.
       */ users: Array<string>;
    }): IdentityViolations_ {
      return new IdentityViolations_(inner);
    }

    static instanceOf(obj: any): obj is IdentityViolations_ {
      return obj.tag === QueueWedgeError_Tags.IdentityViolations;
    }
  }

  type CrossVerificationRequired__interface = {
    tag: QueueWedgeError_Tags.CrossVerificationRequired;
  };

  /**
   * It is required to set up cross-signing and properly erify the current
   * session before sending.
   */
  class CrossVerificationRequired_
    extends UniffiEnum
    implements CrossVerificationRequired__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.CrossVerificationRequired;
    constructor() {
      super('QueueWedgeError', 'CrossVerificationRequired');
    }

    static new(): CrossVerificationRequired_ {
      return new CrossVerificationRequired_();
    }

    static instanceOf(obj: any): obj is CrossVerificationRequired_ {
      return obj.tag === QueueWedgeError_Tags.CrossVerificationRequired;
    }
  }

  type MissingMediaContent__interface = {
    tag: QueueWedgeError_Tags.MissingMediaContent;
  };

  /**
   * Some media content to be sent has disappeared from the cache.
   */
  class MissingMediaContent_
    extends UniffiEnum
    implements MissingMediaContent__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.MissingMediaContent;
    constructor() {
      super('QueueWedgeError', 'MissingMediaContent');
    }

    static new(): MissingMediaContent_ {
      return new MissingMediaContent_();
    }

    static instanceOf(obj: any): obj is MissingMediaContent_ {
      return obj.tag === QueueWedgeError_Tags.MissingMediaContent;
    }
  }

  type InvalidMimeType__interface = {
    tag: QueueWedgeError_Tags.InvalidMimeType;
    inner: Readonly<{ mimeType: string }>;
  };

  /**
   * Some mime type couldn't be parsed.
   */
  class InvalidMimeType_
    extends UniffiEnum
    implements InvalidMimeType__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.InvalidMimeType;
    readonly inner: Readonly<{ mimeType: string }>;
    constructor(inner: { mimeType: string }) {
      super('QueueWedgeError', 'InvalidMimeType');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { mimeType: string }): InvalidMimeType_ {
      return new InvalidMimeType_(inner);
    }

    static instanceOf(obj: any): obj is InvalidMimeType_ {
      return obj.tag === QueueWedgeError_Tags.InvalidMimeType;
    }
  }

  type GenericApiError__interface = {
    tag: QueueWedgeError_Tags.GenericApiError;
    inner: Readonly<{ msg: string }>;
  };

  /**
   * Other errors.
   */
  class GenericApiError_
    extends UniffiEnum
    implements GenericApiError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.GenericApiError;
    readonly inner: Readonly<{ msg: string }>;
    constructor(inner: { msg: string }) {
      super('QueueWedgeError', 'GenericApiError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string }): GenericApiError_ {
      return new GenericApiError_(inner);
    }

    static instanceOf(obj: any): obj is GenericApiError_ {
      return obj.tag === QueueWedgeError_Tags.GenericApiError;
    }
  }

  function instanceOf(obj: any): obj is QueueWedgeError {
    return obj[uniffiTypeNameSymbol] === 'QueueWedgeError';
  }

  return Object.freeze({
    instanceOf,
    InsecureDevices: InsecureDevices_,
    IdentityViolations: IdentityViolations_,
    CrossVerificationRequired: CrossVerificationRequired_,
    MissingMediaContent: MissingMediaContent_,
    InvalidMimeType: InvalidMimeType_,
    GenericApiError: GenericApiError_,
  });
})();

/**
 * Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
 * String.
 *
 * Represent a failed to send unrecoverable error of an event sent via the
 * send_queue. It is a serializable representation of a client error, see
 * `From` implementation for more details. These errors can not be
 * automatically retried, but yet some manual action can be taken before retry
 * sending. If not the only solution is to delete the local event.
 */

export type QueueWedgeError = InstanceType<
  (typeof QueueWedgeError)[keyof Omit<typeof QueueWedgeError, 'instanceOf'>]
>;

// FfiConverter for enum QueueWedgeError
const FfiConverterTypeQueueWedgeError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = QueueWedgeError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new QueueWedgeError.InsecureDevices({
            userDeviceMap: FfiConverterMapStringArrayString.read(from),
          });
        case 2:
          return new QueueWedgeError.IdentityViolations({
            users: FfiConverterArrayString.read(from),
          });
        case 3:
          return new QueueWedgeError.CrossVerificationRequired();
        case 4:
          return new QueueWedgeError.MissingMediaContent();
        case 5:
          return new QueueWedgeError.InvalidMimeType({
            mimeType: FfiConverterString.read(from),
          });
        case 6:
          return new QueueWedgeError.GenericApiError({
            msg: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case QueueWedgeError_Tags.InsecureDevices: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterMapStringArrayString.write(inner.userDeviceMap, into);
          return;
        }
        case QueueWedgeError_Tags.IdentityViolations: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayString.write(inner.users, into);
          return;
        }
        case QueueWedgeError_Tags.CrossVerificationRequired: {
          ordinalConverter.write(3, into);
          return;
        }
        case QueueWedgeError_Tags.MissingMediaContent: {
          ordinalConverter.write(4, into);
          return;
        }
        case QueueWedgeError_Tags.InvalidMimeType: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.mimeType, into);
          return;
        }
        case QueueWedgeError_Tags.GenericApiError: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          return;
        }
        default:
          // Throwing from here means that QueueWedgeError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case QueueWedgeError_Tags.InsecureDevices: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterMapStringArrayString.allocationSize(
            inner.userDeviceMap
          );
          return size;
        }
        case QueueWedgeError_Tags.IdentityViolations: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayString.allocationSize(inner.users);
          return size;
        }
        case QueueWedgeError_Tags.CrossVerificationRequired: {
          return ordinalConverter.allocationSize(3);
        }
        case QueueWedgeError_Tags.MissingMediaContent: {
          return ordinalConverter.allocationSize(4);
        }
        case QueueWedgeError_Tags.InvalidMimeType: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.mimeType);
          return size;
        }
        case QueueWedgeError_Tags.GenericApiError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.msg);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */
export enum ReceiptType {
  Read,
  ReadPrivate,
  FullyRead,
}

const FfiConverterTypeReceiptType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ReceiptType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ReceiptType.Read;
        case 2:
          return ReceiptType.ReadPrivate;
        case 3:
          return ReceiptType.FullyRead;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ReceiptType.Read:
          return ordinalConverter.write(1, into);
        case ReceiptType.ReadPrivate:
          return ordinalConverter.write(2, into);
        case ReceiptType.FullyRead:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: RecoveryError

// Enum: RecoveryError
export enum RecoveryError_Tags {
  BackupExistsOnServer = 'BackupExistsOnServer',
  Client = 'Client',
  SecretStorage = 'SecretStorage',
}
export const RecoveryError = (() => {
  type BackupExistsOnServer__interface = {
    tag: RecoveryError_Tags.BackupExistsOnServer;
  };

  /**
   * A backup already exists on the homeserver, the recovery subsystem does
   * not allow backups to be overwritten, disable recovery first.
   */
  class BackupExistsOnServer_
    extends UniffiError
    implements BackupExistsOnServer__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RecoveryError';
    readonly tag = RecoveryError_Tags.BackupExistsOnServer;
    constructor() {
      super('RecoveryError', 'BackupExistsOnServer');
    }

    static new(): BackupExistsOnServer_ {
      return new BackupExistsOnServer_();
    }

    static instanceOf(obj: any): obj is BackupExistsOnServer_ {
      return obj.tag === RecoveryError_Tags.BackupExistsOnServer;
    }

    static hasInner(obj: any): obj is BackupExistsOnServer_ {
      return false;
    }
  }

  type Client__interface = {
    tag: RecoveryError_Tags.Client;
    inner: Readonly<{ source: ClientError }>;
  };

  /**
   * A typical SDK error.
   */
  class Client_ extends UniffiError implements Client__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RecoveryError';
    readonly tag = RecoveryError_Tags.Client;
    readonly inner: Readonly<{ source: ClientError }>;
    constructor(inner: { source: ClientError }) {
      super('RecoveryError', 'Client');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { source: ClientError }): Client_ {
      return new Client_(inner);
    }

    static instanceOf(obj: any): obj is Client_ {
      return obj.tag === RecoveryError_Tags.Client;
    }

    static hasInner(obj: any): obj is Client_ {
      return Client_.instanceOf(obj);
    }

    static getInner(obj: Client_): Readonly<{ source: ClientError }> {
      return obj.inner;
    }
  }

  type SecretStorage__interface = {
    tag: RecoveryError_Tags.SecretStorage;
    inner: Readonly<{ errorMessage: string }>;
  };

  /**
   * Error in the secret storage subsystem.
   */
  class SecretStorage_ extends UniffiError implements SecretStorage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RecoveryError';
    readonly tag = RecoveryError_Tags.SecretStorage;
    readonly inner: Readonly<{ errorMessage: string }>;
    constructor(inner: { errorMessage: string }) {
      super('RecoveryError', 'SecretStorage');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { errorMessage: string }): SecretStorage_ {
      return new SecretStorage_(inner);
    }

    static instanceOf(obj: any): obj is SecretStorage_ {
      return obj.tag === RecoveryError_Tags.SecretStorage;
    }

    static hasInner(obj: any): obj is SecretStorage_ {
      return SecretStorage_.instanceOf(obj);
    }

    static getInner(obj: SecretStorage_): Readonly<{ errorMessage: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is RecoveryError {
    return obj[uniffiTypeNameSymbol] === 'RecoveryError';
  }

  return Object.freeze({
    instanceOf,
    BackupExistsOnServer: BackupExistsOnServer_,
    Client: Client_,
    SecretStorage: SecretStorage_,
  });
})();

export type RecoveryError = InstanceType<
  (typeof RecoveryError)[keyof Omit<typeof RecoveryError, 'instanceOf'>]
>;

// FfiConverter for enum RecoveryError
const FfiConverterTypeRecoveryError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RecoveryError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RecoveryError.BackupExistsOnServer();
        case 2:
          return new RecoveryError.Client({
            source: FfiConverterTypeClientError.read(from),
          });
        case 3:
          return new RecoveryError.SecretStorage({
            errorMessage: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RecoveryError_Tags.BackupExistsOnServer: {
          ordinalConverter.write(1, into);
          return;
        }
        case RecoveryError_Tags.Client: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeClientError.write(inner.source, into);
          return;
        }
        case RecoveryError_Tags.SecretStorage: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.errorMessage, into);
          return;
        }
        default:
          // Throwing from here means that RecoveryError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RecoveryError_Tags.BackupExistsOnServer: {
          return ordinalConverter.allocationSize(1);
        }
        case RecoveryError_Tags.Client: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeClientError.allocationSize(inner.source);
          return size;
        }
        case RecoveryError_Tags.SecretStorage: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.errorMessage);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RecoveryState {
  Unknown,
  Enabled,
  Disabled,
  Incomplete,
}

const FfiConverterTypeRecoveryState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RecoveryState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RecoveryState.Unknown;
        case 2:
          return RecoveryState.Enabled;
        case 3:
          return RecoveryState.Disabled;
        case 4:
          return RecoveryState.Incomplete;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RecoveryState.Unknown:
          return ordinalConverter.write(1, into);
        case RecoveryState.Enabled:
          return ordinalConverter.write(2, into);
        case RecoveryState.Disabled:
          return ordinalConverter.write(3, into);
        case RecoveryState.Incomplete:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RepliedToEventDetails
export enum RepliedToEventDetails_Tags {
  Unavailable = 'Unavailable',
  Pending = 'Pending',
  Ready = 'Ready',
  Error = 'Error',
}
export const RepliedToEventDetails = (() => {
  type Unavailable__interface = {
    tag: RepliedToEventDetails_Tags.Unavailable;
  };

  class Unavailable_ extends UniffiEnum implements Unavailable__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RepliedToEventDetails';
    readonly tag = RepliedToEventDetails_Tags.Unavailable;
    constructor() {
      super('RepliedToEventDetails', 'Unavailable');
    }

    static new(): Unavailable_ {
      return new Unavailable_();
    }

    static instanceOf(obj: any): obj is Unavailable_ {
      return obj.tag === RepliedToEventDetails_Tags.Unavailable;
    }
  }

  type Pending__interface = {
    tag: RepliedToEventDetails_Tags.Pending;
  };

  class Pending_ extends UniffiEnum implements Pending__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RepliedToEventDetails';
    readonly tag = RepliedToEventDetails_Tags.Pending;
    constructor() {
      super('RepliedToEventDetails', 'Pending');
    }

    static new(): Pending_ {
      return new Pending_();
    }

    static instanceOf(obj: any): obj is Pending_ {
      return obj.tag === RepliedToEventDetails_Tags.Pending;
    }
  }

  type Ready__interface = {
    tag: RepliedToEventDetails_Tags.Ready;
    inner: Readonly<{
      content: TimelineItemContent;
      sender: string;
      senderProfile: ProfileDetails;
    }>;
  };

  class Ready_ extends UniffiEnum implements Ready__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RepliedToEventDetails';
    readonly tag = RepliedToEventDetails_Tags.Ready;
    readonly inner: Readonly<{
      content: TimelineItemContent;
      sender: string;
      senderProfile: ProfileDetails;
    }>;
    constructor(inner: {
      content: TimelineItemContent;
      sender: string;
      senderProfile: ProfileDetails;
    }) {
      super('RepliedToEventDetails', 'Ready');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      content: TimelineItemContent;
      sender: string;
      senderProfile: ProfileDetails;
    }): Ready_ {
      return new Ready_(inner);
    }

    static instanceOf(obj: any): obj is Ready_ {
      return obj.tag === RepliedToEventDetails_Tags.Ready;
    }
  }

  type Error__interface = {
    tag: RepliedToEventDetails_Tags.Error;
    inner: Readonly<{ message: string }>;
  };

  class Error_ extends UniffiEnum implements Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RepliedToEventDetails';
    readonly tag = RepliedToEventDetails_Tags.Error;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('RepliedToEventDetails', 'Error');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Error_ {
      return new Error_(inner);
    }

    static instanceOf(obj: any): obj is Error_ {
      return obj.tag === RepliedToEventDetails_Tags.Error;
    }
  }

  function instanceOf(obj: any): obj is RepliedToEventDetails {
    return obj[uniffiTypeNameSymbol] === 'RepliedToEventDetails';
  }

  return Object.freeze({
    instanceOf,
    Unavailable: Unavailable_,
    Pending: Pending_,
    Ready: Ready_,
    Error: Error_,
  });
})();

export type RepliedToEventDetails = InstanceType<
  (typeof RepliedToEventDetails)[keyof Omit<
    typeof RepliedToEventDetails,
    'instanceOf'
  >]
>;

// FfiConverter for enum RepliedToEventDetails
const FfiConverterTypeRepliedToEventDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RepliedToEventDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RepliedToEventDetails.Unavailable();
        case 2:
          return new RepliedToEventDetails.Pending();
        case 3:
          return new RepliedToEventDetails.Ready({
            content: FfiConverterTypeTimelineItemContent.read(from),
            sender: FfiConverterString.read(from),
            senderProfile: FfiConverterTypeProfileDetails.read(from),
          });
        case 4:
          return new RepliedToEventDetails.Error({
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RepliedToEventDetails_Tags.Unavailable: {
          ordinalConverter.write(1, into);
          return;
        }
        case RepliedToEventDetails_Tags.Pending: {
          ordinalConverter.write(2, into);
          return;
        }
        case RepliedToEventDetails_Tags.Ready: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeTimelineItemContent.write(inner.content, into);
          FfiConverterString.write(inner.sender, into);
          FfiConverterTypeProfileDetails.write(inner.senderProfile, into);
          return;
        }
        case RepliedToEventDetails_Tags.Error: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that RepliedToEventDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RepliedToEventDetails_Tags.Unavailable: {
          return ordinalConverter.allocationSize(1);
        }
        case RepliedToEventDetails_Tags.Pending: {
          return ordinalConverter.allocationSize(2);
        }
        case RepliedToEventDetails_Tags.Ready: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeTimelineItemContent.allocationSize(
            inner.content
          );
          size += FfiConverterString.allocationSize(inner.sender);
          size += FfiConverterTypeProfileDetails.allocationSize(
            inner.senderProfile
          );
          return size;
        }
        case RepliedToEventDetails_Tags.Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RoomDirectorySearchEntryUpdate
export enum RoomDirectorySearchEntryUpdate_Tags {
  Append = 'Append',
  Clear = 'Clear',
  PushFront = 'PushFront',
  PushBack = 'PushBack',
  PopFront = 'PopFront',
  PopBack = 'PopBack',
  Insert = 'Insert',
  Set = 'Set',
  Remove = 'Remove',
  Truncate = 'Truncate',
  Reset = 'Reset',
}
export const RoomDirectorySearchEntryUpdate = (() => {
  type Append__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Append;
    inner: Readonly<{ values: Array<RoomDescription> }>;
  };

  class Append_ extends UniffiEnum implements Append__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Append;
    readonly inner: Readonly<{ values: Array<RoomDescription> }>;
    constructor(inner: { values: Array<RoomDescription> }) {
      super('RoomDirectorySearchEntryUpdate', 'Append');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array<RoomDescription> }): Append_ {
      return new Append_(inner);
    }

    static instanceOf(obj: any): obj is Append_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Append;
    }
  }

  type Clear__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Clear;
  };

  class Clear_ extends UniffiEnum implements Clear__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Clear;
    constructor() {
      super('RoomDirectorySearchEntryUpdate', 'Clear');
    }

    static new(): Clear_ {
      return new Clear_();
    }

    static instanceOf(obj: any): obj is Clear_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Clear;
    }
  }

  type PushFront__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.PushFront;
    inner: Readonly<{ value: RoomDescription }>;
  };

  class PushFront_ extends UniffiEnum implements PushFront__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.PushFront;
    readonly inner: Readonly<{ value: RoomDescription }>;
    constructor(inner: { value: RoomDescription }) {
      super('RoomDirectorySearchEntryUpdate', 'PushFront');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: RoomDescription }): PushFront_ {
      return new PushFront_(inner);
    }

    static instanceOf(obj: any): obj is PushFront_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PushFront;
    }
  }

  type PushBack__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.PushBack;
    inner: Readonly<{ value: RoomDescription }>;
  };

  class PushBack_ extends UniffiEnum implements PushBack__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.PushBack;
    readonly inner: Readonly<{ value: RoomDescription }>;
    constructor(inner: { value: RoomDescription }) {
      super('RoomDirectorySearchEntryUpdate', 'PushBack');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: RoomDescription }): PushBack_ {
      return new PushBack_(inner);
    }

    static instanceOf(obj: any): obj is PushBack_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PushBack;
    }
  }

  type PopFront__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.PopFront;
  };

  class PopFront_ extends UniffiEnum implements PopFront__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.PopFront;
    constructor() {
      super('RoomDirectorySearchEntryUpdate', 'PopFront');
    }

    static new(): PopFront_ {
      return new PopFront_();
    }

    static instanceOf(obj: any): obj is PopFront_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PopFront;
    }
  }

  type PopBack__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.PopBack;
  };

  class PopBack_ extends UniffiEnum implements PopBack__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.PopBack;
    constructor() {
      super('RoomDirectorySearchEntryUpdate', 'PopBack');
    }

    static new(): PopBack_ {
      return new PopBack_();
    }

    static instanceOf(obj: any): obj is PopBack_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PopBack;
    }
  }

  type Insert__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Insert;
    inner: Readonly<{ index: /*u32*/ number; value: RoomDescription }>;
  };

  class Insert_ extends UniffiEnum implements Insert__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Insert;
    readonly inner: Readonly<{ index: /*u32*/ number; value: RoomDescription }>;
    constructor(inner: { index: /*u32*/ number; value: RoomDescription }) {
      super('RoomDirectorySearchEntryUpdate', 'Insert');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      index: /*u32*/ number;
      value: RoomDescription;
    }): Insert_ {
      return new Insert_(inner);
    }

    static instanceOf(obj: any): obj is Insert_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Insert;
    }
  }

  type Set__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Set;
    inner: Readonly<{ index: /*u32*/ number; value: RoomDescription }>;
  };

  class Set_ extends UniffiEnum implements Set__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Set;
    readonly inner: Readonly<{ index: /*u32*/ number; value: RoomDescription }>;
    constructor(inner: { index: /*u32*/ number; value: RoomDescription }) {
      super('RoomDirectorySearchEntryUpdate', 'Set');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { index: /*u32*/ number; value: RoomDescription }): Set_ {
      return new Set_(inner);
    }

    static instanceOf(obj: any): obj is Set_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Set;
    }
  }

  type Remove__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Remove;
    inner: Readonly<{ index: /*u32*/ number }>;
  };

  class Remove_ extends UniffiEnum implements Remove__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Remove;
    readonly inner: Readonly<{ index: /*u32*/ number }>;
    constructor(inner: { index: /*u32*/ number }) {
      super('RoomDirectorySearchEntryUpdate', 'Remove');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { index: /*u32*/ number }): Remove_ {
      return new Remove_(inner);
    }

    static instanceOf(obj: any): obj is Remove_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Remove;
    }
  }

  type Truncate__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Truncate;
    inner: Readonly<{ length: /*u32*/ number }>;
  };

  class Truncate_ extends UniffiEnum implements Truncate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Truncate;
    readonly inner: Readonly<{ length: /*u32*/ number }>;
    constructor(inner: { length: /*u32*/ number }) {
      super('RoomDirectorySearchEntryUpdate', 'Truncate');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { length: /*u32*/ number }): Truncate_ {
      return new Truncate_(inner);
    }

    static instanceOf(obj: any): obj is Truncate_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Truncate;
    }
  }

  type Reset__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Reset;
    inner: Readonly<{ values: Array<RoomDescription> }>;
  };

  class Reset_ extends UniffiEnum implements Reset__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Reset;
    readonly inner: Readonly<{ values: Array<RoomDescription> }>;
    constructor(inner: { values: Array<RoomDescription> }) {
      super('RoomDirectorySearchEntryUpdate', 'Reset');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array<RoomDescription> }): Reset_ {
      return new Reset_(inner);
    }

    static instanceOf(obj: any): obj is Reset_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Reset;
    }
  }

  function instanceOf(obj: any): obj is RoomDirectorySearchEntryUpdate {
    return obj[uniffiTypeNameSymbol] === 'RoomDirectorySearchEntryUpdate';
  }

  return Object.freeze({
    instanceOf,
    Append: Append_,
    Clear: Clear_,
    PushFront: PushFront_,
    PushBack: PushBack_,
    PopFront: PopFront_,
    PopBack: PopBack_,
    Insert: Insert_,
    Set: Set_,
    Remove: Remove_,
    Truncate: Truncate_,
    Reset: Reset_,
  });
})();

export type RoomDirectorySearchEntryUpdate = InstanceType<
  (typeof RoomDirectorySearchEntryUpdate)[keyof Omit<
    typeof RoomDirectorySearchEntryUpdate,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomDirectorySearchEntryUpdate
const FfiConverterTypeRoomDirectorySearchEntryUpdate = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomDirectorySearchEntryUpdate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomDirectorySearchEntryUpdate.Append({
            values: FfiConverterArrayTypeRoomDescription.read(from),
          });
        case 2:
          return new RoomDirectorySearchEntryUpdate.Clear();
        case 3:
          return new RoomDirectorySearchEntryUpdate.PushFront({
            value: FfiConverterTypeRoomDescription.read(from),
          });
        case 4:
          return new RoomDirectorySearchEntryUpdate.PushBack({
            value: FfiConverterTypeRoomDescription.read(from),
          });
        case 5:
          return new RoomDirectorySearchEntryUpdate.PopFront();
        case 6:
          return new RoomDirectorySearchEntryUpdate.PopBack();
        case 7:
          return new RoomDirectorySearchEntryUpdate.Insert({
            index: FfiConverterUInt32.read(from),
            value: FfiConverterTypeRoomDescription.read(from),
          });
        case 8:
          return new RoomDirectorySearchEntryUpdate.Set({
            index: FfiConverterUInt32.read(from),
            value: FfiConverterTypeRoomDescription.read(from),
          });
        case 9:
          return new RoomDirectorySearchEntryUpdate.Remove({
            index: FfiConverterUInt32.read(from),
          });
        case 10:
          return new RoomDirectorySearchEntryUpdate.Truncate({
            length: FfiConverterUInt32.read(from),
          });
        case 11:
          return new RoomDirectorySearchEntryUpdate.Reset({
            values: FfiConverterArrayTypeRoomDescription.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomDirectorySearchEntryUpdate_Tags.Append: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomDescription.write(inner.values, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Clear: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PushFront: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PushBack: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PopFront: {
          ordinalConverter.write(5, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PopBack: {
          ordinalConverter.write(6, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Insert: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Set: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Remove: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Truncate: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.length, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Reset: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomDescription.write(inner.values, into);
          return;
        }
        default:
          // Throwing from here means that RoomDirectorySearchEntryUpdate_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomDirectorySearchEntryUpdate_Tags.Append: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeRoomDescription.allocationSize(
            inner.values
          );
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Clear: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomDirectorySearchEntryUpdate_Tags.PushFront: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PushBack: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PopFront: {
          return ordinalConverter.allocationSize(5);
        }
        case RoomDirectorySearchEntryUpdate_Tags.PopBack: {
          return ordinalConverter.allocationSize(6);
        }
        case RoomDirectorySearchEntryUpdate_Tags.Insert: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Set: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Remove: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterUInt32.allocationSize(inner.index);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Truncate: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterUInt32.allocationSize(inner.length);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Reset: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterArrayTypeRoomDescription.allocationSize(
            inner.values
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: RoomError
export enum RoomError_Tags {
  InvalidAttachmentData = 'InvalidAttachmentData',
  InvalidAttachmentMimeType = 'InvalidAttachmentMimeType',
  InvalidMediaInfo = 'InvalidMediaInfo',
  TimelineUnavailable = 'TimelineUnavailable',
  InvalidThumbnailData = 'InvalidThumbnailData',
  FailedSendingAttachment = 'FailedSendingAttachment',
}
export const RoomError = (() => {
  class InvalidAttachmentData extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = RoomError_Tags.InvalidAttachmentData;

    constructor(message: string) {
      super('RoomError', 'InvalidAttachmentData', message);
    }

    static instanceOf(e: any): e is InvalidAttachmentData {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class InvalidAttachmentMimeType extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = RoomError_Tags.InvalidAttachmentMimeType;

    constructor(message: string) {
      super('RoomError', 'InvalidAttachmentMimeType', message);
    }

    static instanceOf(e: any): e is InvalidAttachmentMimeType {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class InvalidMediaInfo extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = RoomError_Tags.InvalidMediaInfo;

    constructor(message: string) {
      super('RoomError', 'InvalidMediaInfo', message);
    }

    static instanceOf(e: any): e is InvalidMediaInfo {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class TimelineUnavailable extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = RoomError_Tags.TimelineUnavailable;

    constructor(message: string) {
      super('RoomError', 'TimelineUnavailable', message);
    }

    static instanceOf(e: any): e is TimelineUnavailable {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class InvalidThumbnailData extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = RoomError_Tags.InvalidThumbnailData;

    constructor(message: string) {
      super('RoomError', 'InvalidThumbnailData', message);
    }

    static instanceOf(e: any): e is InvalidThumbnailData {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class FailedSendingAttachment extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = RoomError_Tags.FailedSendingAttachment;

    constructor(message: string) {
      super('RoomError', 'FailedSendingAttachment', message);
    }

    static instanceOf(e: any): e is FailedSendingAttachment {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is RoomError {
    return (e as any)[uniffiTypeNameSymbol] === 'RoomError';
  }
  return {
    InvalidAttachmentData,
    InvalidAttachmentMimeType,
    InvalidMediaInfo,
    TimelineUnavailable,
    InvalidThumbnailData,
    FailedSendingAttachment,
    instanceOf,
  };
})();

// Union type for RoomError error type.

export type RoomError = InstanceType<
  (typeof RoomError)[keyof Omit<typeof RoomError, 'instanceOf'>]
>;

const FfiConverterTypeRoomError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = RoomError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new RoomError.InvalidAttachmentData(
            FfiConverterString.read(from)
          );

        case 2:
          return new RoomError.InvalidAttachmentMimeType(
            FfiConverterString.read(from)
          );

        case 3:
          return new RoomError.InvalidMediaInfo(FfiConverterString.read(from));

        case 4:
          return new RoomError.TimelineUnavailable(
            FfiConverterString.read(from)
          );

        case 5:
          return new RoomError.InvalidThumbnailData(
            FfiConverterString.read(from)
          );

        case 6:
          return new RoomError.FailedSendingAttachment(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: RoomListEntriesDynamicFilterKind
export enum RoomListEntriesDynamicFilterKind_Tags {
  All = 'All',
  Any = 'Any',
  NonLeft = 'NonLeft',
  Joined = 'Joined',
  Unread = 'Unread',
  Favourite = 'Favourite',
  Invite = 'Invite',
  Category = 'Category',
  None = 'None',
  NormalizedMatchRoomName = 'NormalizedMatchRoomName',
  FuzzyMatchRoomName = 'FuzzyMatchRoomName',
}
export const RoomListEntriesDynamicFilterKind = (() => {
  type All__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.All;
    inner: Readonly<{ filters: Array<RoomListEntriesDynamicFilterKind> }>;
  };

  class All_ extends UniffiEnum implements All__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.All;
    readonly inner: Readonly<{
      filters: Array<RoomListEntriesDynamicFilterKind>;
    }>;
    constructor(inner: { filters: Array<RoomListEntriesDynamicFilterKind> }) {
      super('RoomListEntriesDynamicFilterKind', 'All');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      filters: Array<RoomListEntriesDynamicFilterKind>;
    }): All_ {
      return new All_(inner);
    }

    static instanceOf(obj: any): obj is All_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.All;
    }
  }

  type Any__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Any;
    inner: Readonly<{ filters: Array<RoomListEntriesDynamicFilterKind> }>;
  };

  class Any_ extends UniffiEnum implements Any__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Any;
    readonly inner: Readonly<{
      filters: Array<RoomListEntriesDynamicFilterKind>;
    }>;
    constructor(inner: { filters: Array<RoomListEntriesDynamicFilterKind> }) {
      super('RoomListEntriesDynamicFilterKind', 'Any');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      filters: Array<RoomListEntriesDynamicFilterKind>;
    }): Any_ {
      return new Any_(inner);
    }

    static instanceOf(obj: any): obj is Any_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Any;
    }
  }

  type NonLeft__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.NonLeft;
  };

  class NonLeft_ extends UniffiEnum implements NonLeft__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.NonLeft;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'NonLeft');
    }

    static new(): NonLeft_ {
      return new NonLeft_();
    }

    static instanceOf(obj: any): obj is NonLeft_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.NonLeft;
    }
  }

  type Joined__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Joined;
  };

  class Joined_ extends UniffiEnum implements Joined__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Joined;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'Joined');
    }

    static new(): Joined_ {
      return new Joined_();
    }

    static instanceOf(obj: any): obj is Joined_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Joined;
    }
  }

  type Unread__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Unread;
  };

  class Unread_ extends UniffiEnum implements Unread__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Unread;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'Unread');
    }

    static new(): Unread_ {
      return new Unread_();
    }

    static instanceOf(obj: any): obj is Unread_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Unread;
    }
  }

  type Favourite__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Favourite;
  };

  class Favourite_ extends UniffiEnum implements Favourite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Favourite;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'Favourite');
    }

    static new(): Favourite_ {
      return new Favourite_();
    }

    static instanceOf(obj: any): obj is Favourite_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Favourite;
    }
  }

  type Invite__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Invite;
  };

  class Invite_ extends UniffiEnum implements Invite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Invite;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'Invite');
    }

    static new(): Invite_ {
      return new Invite_();
    }

    static instanceOf(obj: any): obj is Invite_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Invite;
    }
  }

  type Category__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Category;
    inner: Readonly<{ expect: RoomListFilterCategory }>;
  };

  class Category_ extends UniffiEnum implements Category__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Category;
    readonly inner: Readonly<{ expect: RoomListFilterCategory }>;
    constructor(inner: { expect: RoomListFilterCategory }) {
      super('RoomListEntriesDynamicFilterKind', 'Category');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { expect: RoomListFilterCategory }): Category_ {
      return new Category_(inner);
    }

    static instanceOf(obj: any): obj is Category_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Category;
    }
  }

  type None__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.None;
  };

  class None_ extends UniffiEnum implements None__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.None;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'None');
    }

    static new(): None_ {
      return new None_();
    }

    static instanceOf(obj: any): obj is None_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.None;
    }
  }

  type NormalizedMatchRoomName__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName;
    inner: Readonly<{ pattern: string }>;
  };

  class NormalizedMatchRoomName_
    extends UniffiEnum
    implements NormalizedMatchRoomName__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag =
      RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName;
    readonly inner: Readonly<{ pattern: string }>;
    constructor(inner: { pattern: string }) {
      super('RoomListEntriesDynamicFilterKind', 'NormalizedMatchRoomName');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { pattern: string }): NormalizedMatchRoomName_ {
      return new NormalizedMatchRoomName_(inner);
    }

    static instanceOf(obj: any): obj is NormalizedMatchRoomName_ {
      return (
        obj.tag ===
        RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName
      );
    }
  }

  type FuzzyMatchRoomName__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName;
    inner: Readonly<{ pattern: string }>;
  };

  class FuzzyMatchRoomName_
    extends UniffiEnum
    implements FuzzyMatchRoomName__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName;
    readonly inner: Readonly<{ pattern: string }>;
    constructor(inner: { pattern: string }) {
      super('RoomListEntriesDynamicFilterKind', 'FuzzyMatchRoomName');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { pattern: string }): FuzzyMatchRoomName_ {
      return new FuzzyMatchRoomName_(inner);
    }

    static instanceOf(obj: any): obj is FuzzyMatchRoomName_ {
      return (
        obj.tag === RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName
      );
    }
  }

  function instanceOf(obj: any): obj is RoomListEntriesDynamicFilterKind {
    return obj[uniffiTypeNameSymbol] === 'RoomListEntriesDynamicFilterKind';
  }

  return Object.freeze({
    instanceOf,
    All: All_,
    Any: Any_,
    NonLeft: NonLeft_,
    Joined: Joined_,
    Unread: Unread_,
    Favourite: Favourite_,
    Invite: Invite_,
    Category: Category_,
    None: None_,
    NormalizedMatchRoomName: NormalizedMatchRoomName_,
    FuzzyMatchRoomName: FuzzyMatchRoomName_,
  });
})();

export type RoomListEntriesDynamicFilterKind = InstanceType<
  (typeof RoomListEntriesDynamicFilterKind)[keyof Omit<
    typeof RoomListEntriesDynamicFilterKind,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomListEntriesDynamicFilterKind
const FfiConverterTypeRoomListEntriesDynamicFilterKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListEntriesDynamicFilterKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomListEntriesDynamicFilterKind.All({
            filters:
              FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.read(from),
          });
        case 2:
          return new RoomListEntriesDynamicFilterKind.Any({
            filters:
              FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.read(from),
          });
        case 3:
          return new RoomListEntriesDynamicFilterKind.NonLeft();
        case 4:
          return new RoomListEntriesDynamicFilterKind.Joined();
        case 5:
          return new RoomListEntriesDynamicFilterKind.Unread();
        case 6:
          return new RoomListEntriesDynamicFilterKind.Favourite();
        case 7:
          return new RoomListEntriesDynamicFilterKind.Invite();
        case 8:
          return new RoomListEntriesDynamicFilterKind.Category({
            expect: FfiConverterTypeRoomListFilterCategory.read(from),
          });
        case 9:
          return new RoomListEntriesDynamicFilterKind.None();
        case 10:
          return new RoomListEntriesDynamicFilterKind.NormalizedMatchRoomName({
            pattern: FfiConverterString.read(from),
          });
        case 11:
          return new RoomListEntriesDynamicFilterKind.FuzzyMatchRoomName({
            pattern: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomListEntriesDynamicFilterKind_Tags.All: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.write(
            inner.filters,
            into
          );
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Any: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.write(
            inner.filters,
            into
          );
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.NonLeft: {
          ordinalConverter.write(3, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Joined: {
          ordinalConverter.write(4, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Unread: {
          ordinalConverter.write(5, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Favourite: {
          ordinalConverter.write(6, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Invite: {
          ordinalConverter.write(7, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Category: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeRoomListFilterCategory.write(inner.expect, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.None: {
          ordinalConverter.write(9, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner.pattern, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterString.write(inner.pattern, into);
          return;
        }
        default:
          // Throwing from here means that RoomListEntriesDynamicFilterKind_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomListEntriesDynamicFilterKind_Tags.All: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size +=
            FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.allocationSize(
              inner.filters
            );
          return size;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Any: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size +=
            FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.allocationSize(
              inner.filters
            );
          return size;
        }
        case RoomListEntriesDynamicFilterKind_Tags.NonLeft: {
          return ordinalConverter.allocationSize(3);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Joined: {
          return ordinalConverter.allocationSize(4);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Unread: {
          return ordinalConverter.allocationSize(5);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Favourite: {
          return ordinalConverter.allocationSize(6);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Invite: {
          return ordinalConverter.allocationSize(7);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Category: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeRoomListFilterCategory.allocationSize(
            inner.expect
          );
          return size;
        }
        case RoomListEntriesDynamicFilterKind_Tags.None: {
          return ordinalConverter.allocationSize(9);
        }
        case RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner.pattern);
          return size;
        }
        case RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterString.allocationSize(inner.pattern);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RoomListEntriesUpdate
export enum RoomListEntriesUpdate_Tags {
  Append = 'Append',
  Clear = 'Clear',
  PushFront = 'PushFront',
  PushBack = 'PushBack',
  PopFront = 'PopFront',
  PopBack = 'PopBack',
  Insert = 'Insert',
  Set = 'Set',
  Remove = 'Remove',
  Truncate = 'Truncate',
  Reset = 'Reset',
}
export const RoomListEntriesUpdate = (() => {
  type Append__interface = {
    tag: RoomListEntriesUpdate_Tags.Append;
    inner: Readonly<{ values: Array<RoomListItemInterface> }>;
  };

  class Append_ extends UniffiEnum implements Append__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Append;
    readonly inner: Readonly<{ values: Array<RoomListItemInterface> }>;
    constructor(inner: { values: Array<RoomListItemInterface> }) {
      super('RoomListEntriesUpdate', 'Append');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array<RoomListItemInterface> }): Append_ {
      return new Append_(inner);
    }

    static instanceOf(obj: any): obj is Append_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Append;
    }
  }

  type Clear__interface = {
    tag: RoomListEntriesUpdate_Tags.Clear;
  };

  class Clear_ extends UniffiEnum implements Clear__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Clear;
    constructor() {
      super('RoomListEntriesUpdate', 'Clear');
    }

    static new(): Clear_ {
      return new Clear_();
    }

    static instanceOf(obj: any): obj is Clear_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Clear;
    }
  }

  type PushFront__interface = {
    tag: RoomListEntriesUpdate_Tags.PushFront;
    inner: Readonly<{ value: RoomListItemInterface }>;
  };

  class PushFront_ extends UniffiEnum implements PushFront__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.PushFront;
    readonly inner: Readonly<{ value: RoomListItemInterface }>;
    constructor(inner: { value: RoomListItemInterface }) {
      super('RoomListEntriesUpdate', 'PushFront');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: RoomListItemInterface }): PushFront_ {
      return new PushFront_(inner);
    }

    static instanceOf(obj: any): obj is PushFront_ {
      return obj.tag === RoomListEntriesUpdate_Tags.PushFront;
    }
  }

  type PushBack__interface = {
    tag: RoomListEntriesUpdate_Tags.PushBack;
    inner: Readonly<{ value: RoomListItemInterface }>;
  };

  class PushBack_ extends UniffiEnum implements PushBack__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.PushBack;
    readonly inner: Readonly<{ value: RoomListItemInterface }>;
    constructor(inner: { value: RoomListItemInterface }) {
      super('RoomListEntriesUpdate', 'PushBack');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: RoomListItemInterface }): PushBack_ {
      return new PushBack_(inner);
    }

    static instanceOf(obj: any): obj is PushBack_ {
      return obj.tag === RoomListEntriesUpdate_Tags.PushBack;
    }
  }

  type PopFront__interface = {
    tag: RoomListEntriesUpdate_Tags.PopFront;
  };

  class PopFront_ extends UniffiEnum implements PopFront__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.PopFront;
    constructor() {
      super('RoomListEntriesUpdate', 'PopFront');
    }

    static new(): PopFront_ {
      return new PopFront_();
    }

    static instanceOf(obj: any): obj is PopFront_ {
      return obj.tag === RoomListEntriesUpdate_Tags.PopFront;
    }
  }

  type PopBack__interface = {
    tag: RoomListEntriesUpdate_Tags.PopBack;
  };

  class PopBack_ extends UniffiEnum implements PopBack__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.PopBack;
    constructor() {
      super('RoomListEntriesUpdate', 'PopBack');
    }

    static new(): PopBack_ {
      return new PopBack_();
    }

    static instanceOf(obj: any): obj is PopBack_ {
      return obj.tag === RoomListEntriesUpdate_Tags.PopBack;
    }
  }

  type Insert__interface = {
    tag: RoomListEntriesUpdate_Tags.Insert;
    inner: Readonly<{ index: /*u32*/ number; value: RoomListItemInterface }>;
  };

  class Insert_ extends UniffiEnum implements Insert__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Insert;
    readonly inner: Readonly<{
      index: /*u32*/ number;
      value: RoomListItemInterface;
    }>;
    constructor(inner: {
      index: /*u32*/ number;
      value: RoomListItemInterface;
    }) {
      super('RoomListEntriesUpdate', 'Insert');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      index: /*u32*/ number;
      value: RoomListItemInterface;
    }): Insert_ {
      return new Insert_(inner);
    }

    static instanceOf(obj: any): obj is Insert_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Insert;
    }
  }

  type Set__interface = {
    tag: RoomListEntriesUpdate_Tags.Set;
    inner: Readonly<{ index: /*u32*/ number; value: RoomListItemInterface }>;
  };

  class Set_ extends UniffiEnum implements Set__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Set;
    readonly inner: Readonly<{
      index: /*u32*/ number;
      value: RoomListItemInterface;
    }>;
    constructor(inner: {
      index: /*u32*/ number;
      value: RoomListItemInterface;
    }) {
      super('RoomListEntriesUpdate', 'Set');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      index: /*u32*/ number;
      value: RoomListItemInterface;
    }): Set_ {
      return new Set_(inner);
    }

    static instanceOf(obj: any): obj is Set_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Set;
    }
  }

  type Remove__interface = {
    tag: RoomListEntriesUpdate_Tags.Remove;
    inner: Readonly<{ index: /*u32*/ number }>;
  };

  class Remove_ extends UniffiEnum implements Remove__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Remove;
    readonly inner: Readonly<{ index: /*u32*/ number }>;
    constructor(inner: { index: /*u32*/ number }) {
      super('RoomListEntriesUpdate', 'Remove');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { index: /*u32*/ number }): Remove_ {
      return new Remove_(inner);
    }

    static instanceOf(obj: any): obj is Remove_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Remove;
    }
  }

  type Truncate__interface = {
    tag: RoomListEntriesUpdate_Tags.Truncate;
    inner: Readonly<{ length: /*u32*/ number }>;
  };

  class Truncate_ extends UniffiEnum implements Truncate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Truncate;
    readonly inner: Readonly<{ length: /*u32*/ number }>;
    constructor(inner: { length: /*u32*/ number }) {
      super('RoomListEntriesUpdate', 'Truncate');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { length: /*u32*/ number }): Truncate_ {
      return new Truncate_(inner);
    }

    static instanceOf(obj: any): obj is Truncate_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Truncate;
    }
  }

  type Reset__interface = {
    tag: RoomListEntriesUpdate_Tags.Reset;
    inner: Readonly<{ values: Array<RoomListItemInterface> }>;
  };

  class Reset_ extends UniffiEnum implements Reset__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Reset;
    readonly inner: Readonly<{ values: Array<RoomListItemInterface> }>;
    constructor(inner: { values: Array<RoomListItemInterface> }) {
      super('RoomListEntriesUpdate', 'Reset');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array<RoomListItemInterface> }): Reset_ {
      return new Reset_(inner);
    }

    static instanceOf(obj: any): obj is Reset_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Reset;
    }
  }

  function instanceOf(obj: any): obj is RoomListEntriesUpdate {
    return obj[uniffiTypeNameSymbol] === 'RoomListEntriesUpdate';
  }

  return Object.freeze({
    instanceOf,
    Append: Append_,
    Clear: Clear_,
    PushFront: PushFront_,
    PushBack: PushBack_,
    PopFront: PopFront_,
    PopBack: PopBack_,
    Insert: Insert_,
    Set: Set_,
    Remove: Remove_,
    Truncate: Truncate_,
    Reset: Reset_,
  });
})();

export type RoomListEntriesUpdate = InstanceType<
  (typeof RoomListEntriesUpdate)[keyof Omit<
    typeof RoomListEntriesUpdate,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomListEntriesUpdate
const FfiConverterTypeRoomListEntriesUpdate = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListEntriesUpdate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomListEntriesUpdate.Append({
            values: FfiConverterArrayTypeRoomListItem.read(from),
          });
        case 2:
          return new RoomListEntriesUpdate.Clear();
        case 3:
          return new RoomListEntriesUpdate.PushFront({
            value: FfiConverterTypeRoomListItem.read(from),
          });
        case 4:
          return new RoomListEntriesUpdate.PushBack({
            value: FfiConverterTypeRoomListItem.read(from),
          });
        case 5:
          return new RoomListEntriesUpdate.PopFront();
        case 6:
          return new RoomListEntriesUpdate.PopBack();
        case 7:
          return new RoomListEntriesUpdate.Insert({
            index: FfiConverterUInt32.read(from),
            value: FfiConverterTypeRoomListItem.read(from),
          });
        case 8:
          return new RoomListEntriesUpdate.Set({
            index: FfiConverterUInt32.read(from),
            value: FfiConverterTypeRoomListItem.read(from),
          });
        case 9:
          return new RoomListEntriesUpdate.Remove({
            index: FfiConverterUInt32.read(from),
          });
        case 10:
          return new RoomListEntriesUpdate.Truncate({
            length: FfiConverterUInt32.read(from),
          });
        case 11:
          return new RoomListEntriesUpdate.Reset({
            values: FfiConverterArrayTypeRoomListItem.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomListEntriesUpdate_Tags.Append: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomListItem.write(inner.values, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Clear: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.PushFront: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeRoomListItem.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.PushBack: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeRoomListItem.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.PopFront: {
          ordinalConverter.write(5, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.PopBack: {
          ordinalConverter.write(6, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Insert: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomListItem.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Set: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomListItem.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Remove: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Truncate: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.length, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Reset: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomListItem.write(inner.values, into);
          return;
        }
        default:
          // Throwing from here means that RoomListEntriesUpdate_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomListEntriesUpdate_Tags.Append: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeRoomListItem.allocationSize(
            inner.values
          );
          return size;
        }
        case RoomListEntriesUpdate_Tags.Clear: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomListEntriesUpdate_Tags.PushFront: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeRoomListItem.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdate_Tags.PushBack: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeRoomListItem.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdate_Tags.PopFront: {
          return ordinalConverter.allocationSize(5);
        }
        case RoomListEntriesUpdate_Tags.PopBack: {
          return ordinalConverter.allocationSize(6);
        }
        case RoomListEntriesUpdate_Tags.Insert: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomListItem.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdate_Tags.Set: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomListItem.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdate_Tags.Remove: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterUInt32.allocationSize(inner.index);
          return size;
        }
        case RoomListEntriesUpdate_Tags.Truncate: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterUInt32.allocationSize(inner.length);
          return size;
        }
        case RoomListEntriesUpdate_Tags.Reset: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterArrayTypeRoomListItem.allocationSize(
            inner.values
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: RoomListError

// Enum: RoomListError
export enum RoomListError_Tags {
  SlidingSync = 'SlidingSync',
  UnknownList = 'UnknownList',
  InputCannotBeApplied = 'InputCannotBeApplied',
  RoomNotFound = 'RoomNotFound',
  InvalidRoomId = 'InvalidRoomId',
  TimelineAlreadyExists = 'TimelineAlreadyExists',
  TimelineNotInitialized = 'TimelineNotInitialized',
  InitializingTimeline = 'InitializingTimeline',
  EventCache = 'EventCache',
  IncorrectRoomMembership = 'IncorrectRoomMembership',
}
export const RoomListError = (() => {
  type SlidingSync__interface = {
    tag: RoomListError_Tags.SlidingSync;
    inner: Readonly<{ error: string }>;
  };

  class SlidingSync_ extends UniffiError implements SlidingSync__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.SlidingSync;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('RoomListError', 'SlidingSync');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): SlidingSync_ {
      return new SlidingSync_(inner);
    }

    static instanceOf(obj: any): obj is SlidingSync_ {
      return obj.tag === RoomListError_Tags.SlidingSync;
    }

    static hasInner(obj: any): obj is SlidingSync_ {
      return SlidingSync_.instanceOf(obj);
    }

    static getInner(obj: SlidingSync_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type UnknownList__interface = {
    tag: RoomListError_Tags.UnknownList;
    inner: Readonly<{ listName: string }>;
  };

  class UnknownList_ extends UniffiError implements UnknownList__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.UnknownList;
    readonly inner: Readonly<{ listName: string }>;
    constructor(inner: { listName: string }) {
      super('RoomListError', 'UnknownList');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { listName: string }): UnknownList_ {
      return new UnknownList_(inner);
    }

    static instanceOf(obj: any): obj is UnknownList_ {
      return obj.tag === RoomListError_Tags.UnknownList;
    }

    static hasInner(obj: any): obj is UnknownList_ {
      return UnknownList_.instanceOf(obj);
    }

    static getInner(obj: UnknownList_): Readonly<{ listName: string }> {
      return obj.inner;
    }
  }

  type InputCannotBeApplied__interface = {
    tag: RoomListError_Tags.InputCannotBeApplied;
  };

  class InputCannotBeApplied_
    extends UniffiError
    implements InputCannotBeApplied__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.InputCannotBeApplied;
    constructor() {
      super('RoomListError', 'InputCannotBeApplied');
    }

    static new(): InputCannotBeApplied_ {
      return new InputCannotBeApplied_();
    }

    static instanceOf(obj: any): obj is InputCannotBeApplied_ {
      return obj.tag === RoomListError_Tags.InputCannotBeApplied;
    }

    static hasInner(obj: any): obj is InputCannotBeApplied_ {
      return false;
    }
  }

  type RoomNotFound__interface = {
    tag: RoomListError_Tags.RoomNotFound;
    inner: Readonly<{ roomName: string }>;
  };

  class RoomNotFound_ extends UniffiError implements RoomNotFound__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.RoomNotFound;
    readonly inner: Readonly<{ roomName: string }>;
    constructor(inner: { roomName: string }) {
      super('RoomListError', 'RoomNotFound');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomName: string }): RoomNotFound_ {
      return new RoomNotFound_(inner);
    }

    static instanceOf(obj: any): obj is RoomNotFound_ {
      return obj.tag === RoomListError_Tags.RoomNotFound;
    }

    static hasInner(obj: any): obj is RoomNotFound_ {
      return RoomNotFound_.instanceOf(obj);
    }

    static getInner(obj: RoomNotFound_): Readonly<{ roomName: string }> {
      return obj.inner;
    }
  }

  type InvalidRoomId__interface = {
    tag: RoomListError_Tags.InvalidRoomId;
    inner: Readonly<{ error: string }>;
  };

  class InvalidRoomId_ extends UniffiError implements InvalidRoomId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.InvalidRoomId;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('RoomListError', 'InvalidRoomId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): InvalidRoomId_ {
      return new InvalidRoomId_(inner);
    }

    static instanceOf(obj: any): obj is InvalidRoomId_ {
      return obj.tag === RoomListError_Tags.InvalidRoomId;
    }

    static hasInner(obj: any): obj is InvalidRoomId_ {
      return InvalidRoomId_.instanceOf(obj);
    }

    static getInner(obj: InvalidRoomId_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type TimelineAlreadyExists__interface = {
    tag: RoomListError_Tags.TimelineAlreadyExists;
    inner: Readonly<{ roomName: string }>;
  };

  class TimelineAlreadyExists_
    extends UniffiError
    implements TimelineAlreadyExists__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.TimelineAlreadyExists;
    readonly inner: Readonly<{ roomName: string }>;
    constructor(inner: { roomName: string }) {
      super('RoomListError', 'TimelineAlreadyExists');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomName: string }): TimelineAlreadyExists_ {
      return new TimelineAlreadyExists_(inner);
    }

    static instanceOf(obj: any): obj is TimelineAlreadyExists_ {
      return obj.tag === RoomListError_Tags.TimelineAlreadyExists;
    }

    static hasInner(obj: any): obj is TimelineAlreadyExists_ {
      return TimelineAlreadyExists_.instanceOf(obj);
    }

    static getInner(
      obj: TimelineAlreadyExists_
    ): Readonly<{ roomName: string }> {
      return obj.inner;
    }
  }

  type TimelineNotInitialized__interface = {
    tag: RoomListError_Tags.TimelineNotInitialized;
    inner: Readonly<{ roomName: string }>;
  };

  class TimelineNotInitialized_
    extends UniffiError
    implements TimelineNotInitialized__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.TimelineNotInitialized;
    readonly inner: Readonly<{ roomName: string }>;
    constructor(inner: { roomName: string }) {
      super('RoomListError', 'TimelineNotInitialized');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomName: string }): TimelineNotInitialized_ {
      return new TimelineNotInitialized_(inner);
    }

    static instanceOf(obj: any): obj is TimelineNotInitialized_ {
      return obj.tag === RoomListError_Tags.TimelineNotInitialized;
    }

    static hasInner(obj: any): obj is TimelineNotInitialized_ {
      return TimelineNotInitialized_.instanceOf(obj);
    }

    static getInner(
      obj: TimelineNotInitialized_
    ): Readonly<{ roomName: string }> {
      return obj.inner;
    }
  }

  type InitializingTimeline__interface = {
    tag: RoomListError_Tags.InitializingTimeline;
    inner: Readonly<{ error: string }>;
  };

  class InitializingTimeline_
    extends UniffiError
    implements InitializingTimeline__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.InitializingTimeline;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('RoomListError', 'InitializingTimeline');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): InitializingTimeline_ {
      return new InitializingTimeline_(inner);
    }

    static instanceOf(obj: any): obj is InitializingTimeline_ {
      return obj.tag === RoomListError_Tags.InitializingTimeline;
    }

    static hasInner(obj: any): obj is InitializingTimeline_ {
      return InitializingTimeline_.instanceOf(obj);
    }

    static getInner(obj: InitializingTimeline_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type EventCache__interface = {
    tag: RoomListError_Tags.EventCache;
    inner: Readonly<{ error: string }>;
  };

  class EventCache_ extends UniffiError implements EventCache__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.EventCache;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('RoomListError', 'EventCache');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): EventCache_ {
      return new EventCache_(inner);
    }

    static instanceOf(obj: any): obj is EventCache_ {
      return obj.tag === RoomListError_Tags.EventCache;
    }

    static hasInner(obj: any): obj is EventCache_ {
      return EventCache_.instanceOf(obj);
    }

    static getInner(obj: EventCache_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type IncorrectRoomMembership__interface = {
    tag: RoomListError_Tags.IncorrectRoomMembership;
    inner: Readonly<{ expected: Array<Membership>; actual: Membership }>;
  };

  class IncorrectRoomMembership_
    extends UniffiError
    implements IncorrectRoomMembership__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.IncorrectRoomMembership;
    readonly inner: Readonly<{
      expected: Array<Membership>;
      actual: Membership;
    }>;
    constructor(inner: { expected: Array<Membership>; actual: Membership }) {
      super('RoomListError', 'IncorrectRoomMembership');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      expected: Array<Membership>;
      actual: Membership;
    }): IncorrectRoomMembership_ {
      return new IncorrectRoomMembership_(inner);
    }

    static instanceOf(obj: any): obj is IncorrectRoomMembership_ {
      return obj.tag === RoomListError_Tags.IncorrectRoomMembership;
    }

    static hasInner(obj: any): obj is IncorrectRoomMembership_ {
      return IncorrectRoomMembership_.instanceOf(obj);
    }

    static getInner(
      obj: IncorrectRoomMembership_
    ): Readonly<{ expected: Array<Membership>; actual: Membership }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is RoomListError {
    return obj[uniffiTypeNameSymbol] === 'RoomListError';
  }

  return Object.freeze({
    instanceOf,
    SlidingSync: SlidingSync_,
    UnknownList: UnknownList_,
    InputCannotBeApplied: InputCannotBeApplied_,
    RoomNotFound: RoomNotFound_,
    InvalidRoomId: InvalidRoomId_,
    TimelineAlreadyExists: TimelineAlreadyExists_,
    TimelineNotInitialized: TimelineNotInitialized_,
    InitializingTimeline: InitializingTimeline_,
    EventCache: EventCache_,
    IncorrectRoomMembership: IncorrectRoomMembership_,
  });
})();

export type RoomListError = InstanceType<
  (typeof RoomListError)[keyof Omit<typeof RoomListError, 'instanceOf'>]
>;

// FfiConverter for enum RoomListError
const FfiConverterTypeRoomListError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomListError.SlidingSync({
            error: FfiConverterString.read(from),
          });
        case 2:
          return new RoomListError.UnknownList({
            listName: FfiConverterString.read(from),
          });
        case 3:
          return new RoomListError.InputCannotBeApplied();
        case 4:
          return new RoomListError.RoomNotFound({
            roomName: FfiConverterString.read(from),
          });
        case 5:
          return new RoomListError.InvalidRoomId({
            error: FfiConverterString.read(from),
          });
        case 6:
          return new RoomListError.TimelineAlreadyExists({
            roomName: FfiConverterString.read(from),
          });
        case 7:
          return new RoomListError.TimelineNotInitialized({
            roomName: FfiConverterString.read(from),
          });
        case 8:
          return new RoomListError.InitializingTimeline({
            error: FfiConverterString.read(from),
          });
        case 9:
          return new RoomListError.EventCache({
            error: FfiConverterString.read(from),
          });
        case 10:
          return new RoomListError.IncorrectRoomMembership({
            expected: FfiConverterArrayTypeMembership.read(from),
            actual: FfiConverterTypeMembership.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomListError_Tags.SlidingSync: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case RoomListError_Tags.UnknownList: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.listName, into);
          return;
        }
        case RoomListError_Tags.InputCannotBeApplied: {
          ordinalConverter.write(3, into);
          return;
        }
        case RoomListError_Tags.RoomNotFound: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomName, into);
          return;
        }
        case RoomListError_Tags.InvalidRoomId: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case RoomListError_Tags.TimelineAlreadyExists: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomName, into);
          return;
        }
        case RoomListError_Tags.TimelineNotInitialized: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomName, into);
          return;
        }
        case RoomListError_Tags.InitializingTimeline: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case RoomListError_Tags.EventCache: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case RoomListError_Tags.IncorrectRoomMembership: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterArrayTypeMembership.write(inner.expected, into);
          FfiConverterTypeMembership.write(inner.actual, into);
          return;
        }
        default:
          // Throwing from here means that RoomListError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomListError_Tags.SlidingSync: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case RoomListError_Tags.UnknownList: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.listName);
          return size;
        }
        case RoomListError_Tags.InputCannotBeApplied: {
          return ordinalConverter.allocationSize(3);
        }
        case RoomListError_Tags.RoomNotFound: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.roomName);
          return size;
        }
        case RoomListError_Tags.InvalidRoomId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case RoomListError_Tags.TimelineAlreadyExists: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.roomName);
          return size;
        }
        case RoomListError_Tags.TimelineNotInitialized: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.roomName);
          return size;
        }
        case RoomListError_Tags.InitializingTimeline: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case RoomListError_Tags.EventCache: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case RoomListError_Tags.IncorrectRoomMembership: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterArrayTypeMembership.allocationSize(
            inner.expected
          );
          size += FfiConverterTypeMembership.allocationSize(inner.actual);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RoomListFilterCategory {
  Group,
  People,
}

const FfiConverterTypeRoomListFilterCategory = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListFilterCategory;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomListFilterCategory.Group;
        case 2:
          return RoomListFilterCategory.People;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomListFilterCategory.Group:
          return ordinalConverter.write(1, into);
        case RoomListFilterCategory.People:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomListLoadingState
export enum RoomListLoadingState_Tags {
  NotLoaded = 'NotLoaded',
  Loaded = 'Loaded',
}
export const RoomListLoadingState = (() => {
  type NotLoaded__interface = {
    tag: RoomListLoadingState_Tags.NotLoaded;
  };

  class NotLoaded_ extends UniffiEnum implements NotLoaded__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListLoadingState';
    readonly tag = RoomListLoadingState_Tags.NotLoaded;
    constructor() {
      super('RoomListLoadingState', 'NotLoaded');
    }

    static new(): NotLoaded_ {
      return new NotLoaded_();
    }

    static instanceOf(obj: any): obj is NotLoaded_ {
      return obj.tag === RoomListLoadingState_Tags.NotLoaded;
    }
  }

  type Loaded__interface = {
    tag: RoomListLoadingState_Tags.Loaded;
    inner: Readonly<{ maximumNumberOfRooms: /*u32*/ number | undefined }>;
  };

  class Loaded_ extends UniffiEnum implements Loaded__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListLoadingState';
    readonly tag = RoomListLoadingState_Tags.Loaded;
    readonly inner: Readonly<{
      maximumNumberOfRooms: /*u32*/ number | undefined;
    }>;
    constructor(inner: { maximumNumberOfRooms: /*u32*/ number | undefined }) {
      super('RoomListLoadingState', 'Loaded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      maximumNumberOfRooms: /*u32*/ number | undefined;
    }): Loaded_ {
      return new Loaded_(inner);
    }

    static instanceOf(obj: any): obj is Loaded_ {
      return obj.tag === RoomListLoadingState_Tags.Loaded;
    }
  }

  function instanceOf(obj: any): obj is RoomListLoadingState {
    return obj[uniffiTypeNameSymbol] === 'RoomListLoadingState';
  }

  return Object.freeze({
    instanceOf,
    NotLoaded: NotLoaded_,
    Loaded: Loaded_,
  });
})();

export type RoomListLoadingState = InstanceType<
  (typeof RoomListLoadingState)[keyof Omit<
    typeof RoomListLoadingState,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomListLoadingState
const FfiConverterTypeRoomListLoadingState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListLoadingState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomListLoadingState.NotLoaded();
        case 2:
          return new RoomListLoadingState.Loaded({
            maximumNumberOfRooms: FfiConverterOptionalUInt32.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomListLoadingState_Tags.NotLoaded: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoomListLoadingState_Tags.Loaded: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalUInt32.write(inner.maximumNumberOfRooms, into);
          return;
        }
        default:
          // Throwing from here means that RoomListLoadingState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomListLoadingState_Tags.NotLoaded: {
          return ordinalConverter.allocationSize(1);
        }
        case RoomListLoadingState_Tags.Loaded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalUInt32.allocationSize(
            inner.maximumNumberOfRooms
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RoomListServiceState {
  Initial,
  SettingUp,
  Recovering,
  Running,
  Error,
  Terminated,
}

const FfiConverterTypeRoomListServiceState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListServiceState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomListServiceState.Initial;
        case 2:
          return RoomListServiceState.SettingUp;
        case 3:
          return RoomListServiceState.Recovering;
        case 4:
          return RoomListServiceState.Running;
        case 5:
          return RoomListServiceState.Error;
        case 6:
          return RoomListServiceState.Terminated;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomListServiceState.Initial:
          return ordinalConverter.write(1, into);
        case RoomListServiceState.SettingUp:
          return ordinalConverter.write(2, into);
        case RoomListServiceState.Recovering:
          return ordinalConverter.write(3, into);
        case RoomListServiceState.Running:
          return ordinalConverter.write(4, into);
        case RoomListServiceState.Error:
          return ordinalConverter.write(5, into);
        case RoomListServiceState.Terminated:
          return ordinalConverter.write(6, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum RoomListServiceSyncIndicator {
  Show,
  Hide,
}

const FfiConverterTypeRoomListServiceSyncIndicator = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListServiceSyncIndicator;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomListServiceSyncIndicator.Show;
        case 2:
          return RoomListServiceSyncIndicator.Hide;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomListServiceSyncIndicator.Show:
          return ordinalConverter.write(1, into);
        case RoomListServiceSyncIndicator.Hide:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum RoomMessageEventMessageType {
  Audio,
  Emote,
  File,
  Image,
  Location,
  Notice,
  ServerNotice,
  Text,
  Video,
  VerificationRequest,
  Other,
}

const FfiConverterTypeRoomMessageEventMessageType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomMessageEventMessageType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomMessageEventMessageType.Audio;
        case 2:
          return RoomMessageEventMessageType.Emote;
        case 3:
          return RoomMessageEventMessageType.File;
        case 4:
          return RoomMessageEventMessageType.Image;
        case 5:
          return RoomMessageEventMessageType.Location;
        case 6:
          return RoomMessageEventMessageType.Notice;
        case 7:
          return RoomMessageEventMessageType.ServerNotice;
        case 8:
          return RoomMessageEventMessageType.Text;
        case 9:
          return RoomMessageEventMessageType.Video;
        case 10:
          return RoomMessageEventMessageType.VerificationRequest;
        case 11:
          return RoomMessageEventMessageType.Other;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomMessageEventMessageType.Audio:
          return ordinalConverter.write(1, into);
        case RoomMessageEventMessageType.Emote:
          return ordinalConverter.write(2, into);
        case RoomMessageEventMessageType.File:
          return ordinalConverter.write(3, into);
        case RoomMessageEventMessageType.Image:
          return ordinalConverter.write(4, into);
        case RoomMessageEventMessageType.Location:
          return ordinalConverter.write(5, into);
        case RoomMessageEventMessageType.Notice:
          return ordinalConverter.write(6, into);
        case RoomMessageEventMessageType.ServerNotice:
          return ordinalConverter.write(7, into);
        case RoomMessageEventMessageType.Text:
          return ordinalConverter.write(8, into);
        case RoomMessageEventMessageType.Video:
          return ordinalConverter.write(9, into);
        case RoomMessageEventMessageType.VerificationRequest:
          return ordinalConverter.write(10, into);
        case RoomMessageEventMessageType.Other:
          return ordinalConverter.write(11, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Enum representing the push notification modes for a room.
 */
export enum RoomNotificationMode {
  /**
   * Receive notifications for all messages.
   */
  AllMessages,
  /**
   * Receive notifications for mentions and keywords only.
   */
  MentionsAndKeywordsOnly,
  /**
   * Do not receive any notifications.
   */
  Mute,
}

const FfiConverterTypeRoomNotificationMode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomNotificationMode;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomNotificationMode.AllMessages;
        case 2:
          return RoomNotificationMode.MentionsAndKeywordsOnly;
        case 3:
          return RoomNotificationMode.Mute;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomNotificationMode.AllMessages:
          return ordinalConverter.write(1, into);
        case RoomNotificationMode.MentionsAndKeywordsOnly:
          return ordinalConverter.write(2, into);
        case RoomNotificationMode.Mute:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum RoomPreset {
  /**
   * `join_rules` is set to `invite` and `history_visibility` is set to
   * `shared`.
   */
  PrivateChat,
  /**
   * `join_rules` is set to `public` and `history_visibility` is set to
   * `shared`.
   */
  PublicChat,
  /**
   * Same as `PrivateChat`, but all initial invitees get the same power level
   * as the creator.
   */
  TrustedPrivateChat,
}

const FfiConverterTypeRoomPreset = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomPreset;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomPreset.PrivateChat;
        case 2:
          return RoomPreset.PublicChat;
        case 3:
          return RoomPreset.TrustedPrivateChat;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomPreset.PrivateChat:
          return ordinalConverter.write(1, into);
        case RoomPreset.PublicChat:
          return ordinalConverter.write(2, into);
        case RoomPreset.TrustedPrivateChat:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomType
export enum RoomType_Tags {
  Room = 'Room',
  Space = 'Space',
  Custom = 'Custom',
}
/**
 * The type of room for a [`RoomPreviewInfo`].
 */
export const RoomType = (() => {
  type Room__interface = {
    tag: RoomType_Tags.Room;
  };

  /**
   * It's a plain chat room.
   */
  class Room_ extends UniffiEnum implements Room__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomType';
    readonly tag = RoomType_Tags.Room;
    constructor() {
      super('RoomType', 'Room');
    }

    static new(): Room_ {
      return new Room_();
    }

    static instanceOf(obj: any): obj is Room_ {
      return obj.tag === RoomType_Tags.Room;
    }
  }

  type Space__interface = {
    tag: RoomType_Tags.Space;
  };

  /**
   * It's a space that can group several rooms.
   */
  class Space_ extends UniffiEnum implements Space__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomType';
    readonly tag = RoomType_Tags.Space;
    constructor() {
      super('RoomType', 'Space');
    }

    static new(): Space_ {
      return new Space_();
    }

    static instanceOf(obj: any): obj is Space_ {
      return obj.tag === RoomType_Tags.Space;
    }
  }

  type Custom__interface = {
    tag: RoomType_Tags.Custom;
    inner: Readonly<{ value: string }>;
  };

  /**
   * It's a custom implementation.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomType';
    readonly tag = RoomType_Tags.Custom;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('RoomType', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === RoomType_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is RoomType {
    return obj[uniffiTypeNameSymbol] === 'RoomType';
  }

  return Object.freeze({
    instanceOf,
    Room: Room_,
    Space: Space_,
    Custom: Custom_,
  });
})();

/**
 * The type of room for a [`RoomPreviewInfo`].
 */

export type RoomType = InstanceType<
  (typeof RoomType)[keyof Omit<typeof RoomType, 'instanceOf'>]
>;

// FfiConverter for enum RoomType
const FfiConverterTypeRoomType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomType.Room();
        case 2:
          return new RoomType.Space();
        case 3:
          return new RoomType.Custom({ value: FfiConverterString.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomType_Tags.Room: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoomType_Tags.Space: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomType_Tags.Custom: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that RoomType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomType_Tags.Room: {
          return ordinalConverter.allocationSize(1);
        }
        case RoomType_Tags.Space: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomType_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RoomVisibility {
  /**
   * Indicates that the room will be shown in the published room list.
   */
  Public,
  /**
   * Indicates that the room will not be shown in the published room list.
   */
  Private,
}

const FfiConverterTypeRoomVisibility = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomVisibility;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomVisibility.Public;
        case 2:
          return RoomVisibility.Private;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomVisibility.Public:
          return ordinalConverter.write(1, into);
        case RoomVisibility.Private:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum RtcApplicationType {
  Call,
}

const FfiConverterTypeRtcApplicationType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RtcApplicationType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RtcApplicationType.Call;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RtcApplicationType.Call:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: SessionVerificationData
export enum SessionVerificationData_Tags {
  Emojis = 'Emojis',
  Decimals = 'Decimals',
}
export const SessionVerificationData = (() => {
  type Emojis__interface = {
    tag: SessionVerificationData_Tags.Emojis;
    inner: Readonly<{
      emojis: Array<SessionVerificationEmojiInterface>;
      indices: ArrayBuffer;
    }>;
  };

  class Emojis_ extends UniffiEnum implements Emojis__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionVerificationData';
    readonly tag = SessionVerificationData_Tags.Emojis;
    readonly inner: Readonly<{
      emojis: Array<SessionVerificationEmojiInterface>;
      indices: ArrayBuffer;
    }>;
    constructor(inner: {
      emojis: Array<SessionVerificationEmojiInterface>;
      indices: ArrayBuffer;
    }) {
      super('SessionVerificationData', 'Emojis');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      emojis: Array<SessionVerificationEmojiInterface>;
      indices: ArrayBuffer;
    }): Emojis_ {
      return new Emojis_(inner);
    }

    static instanceOf(obj: any): obj is Emojis_ {
      return obj.tag === SessionVerificationData_Tags.Emojis;
    }
  }

  type Decimals__interface = {
    tag: SessionVerificationData_Tags.Decimals;
    inner: Readonly<{ values: Array</*u16*/ number> }>;
  };

  class Decimals_ extends UniffiEnum implements Decimals__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionVerificationData';
    readonly tag = SessionVerificationData_Tags.Decimals;
    readonly inner: Readonly<{ values: Array</*u16*/ number> }>;
    constructor(inner: { values: Array</*u16*/ number> }) {
      super('SessionVerificationData', 'Decimals');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array</*u16*/ number> }): Decimals_ {
      return new Decimals_(inner);
    }

    static instanceOf(obj: any): obj is Decimals_ {
      return obj.tag === SessionVerificationData_Tags.Decimals;
    }
  }

  function instanceOf(obj: any): obj is SessionVerificationData {
    return obj[uniffiTypeNameSymbol] === 'SessionVerificationData';
  }

  return Object.freeze({
    instanceOf,
    Emojis: Emojis_,
    Decimals: Decimals_,
  });
})();

export type SessionVerificationData = InstanceType<
  (typeof SessionVerificationData)[keyof Omit<
    typeof SessionVerificationData,
    'instanceOf'
  >]
>;

// FfiConverter for enum SessionVerificationData
const FfiConverterTypeSessionVerificationData = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SessionVerificationData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SessionVerificationData.Emojis({
            emojis: FfiConverterArrayTypeSessionVerificationEmoji.read(from),
            indices: FfiConverterArrayBuffer.read(from),
          });
        case 2:
          return new SessionVerificationData.Decimals({
            values: FfiConverterArrayUInt16.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SessionVerificationData_Tags.Emojis: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeSessionVerificationEmoji.write(
            inner.emojis,
            into
          );
          FfiConverterArrayBuffer.write(inner.indices, into);
          return;
        }
        case SessionVerificationData_Tags.Decimals: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayUInt16.write(inner.values, into);
          return;
        }
        default:
          // Throwing from here means that SessionVerificationData_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SessionVerificationData_Tags.Emojis: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeSessionVerificationEmoji.allocationSize(
            inner.emojis
          );
          size += FfiConverterArrayBuffer.allocationSize(inner.indices);
          return size;
        }
        case SessionVerificationData_Tags.Decimals: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayUInt16.allocationSize(inner.values);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ShieldState
export enum ShieldState_Tags {
  Red = 'Red',
  Grey = 'Grey',
  None = 'None',
}
/**
 * Recommended decorations for decrypted messages, representing the message's
 * authenticity properties.
 */
export const ShieldState = (() => {
  type Red__interface = {
    tag: ShieldState_Tags.Red;
    inner: Readonly<{ code: ShieldStateCode; message: string }>;
  };

  /**
   * A red shield with a tooltip containing the associated message should be
   * presented.
   */
  class Red_ extends UniffiEnum implements Red__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ShieldState';
    readonly tag = ShieldState_Tags.Red;
    readonly inner: Readonly<{ code: ShieldStateCode; message: string }>;
    constructor(inner: { code: ShieldStateCode; message: string }) {
      super('ShieldState', 'Red');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { code: ShieldStateCode; message: string }): Red_ {
      return new Red_(inner);
    }

    static instanceOf(obj: any): obj is Red_ {
      return obj.tag === ShieldState_Tags.Red;
    }
  }

  type Grey__interface = {
    tag: ShieldState_Tags.Grey;
    inner: Readonly<{ code: ShieldStateCode; message: string }>;
  };

  /**
   * A grey shield with a tooltip containing the associated message should be
   * presented.
   */
  class Grey_ extends UniffiEnum implements Grey__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ShieldState';
    readonly tag = ShieldState_Tags.Grey;
    readonly inner: Readonly<{ code: ShieldStateCode; message: string }>;
    constructor(inner: { code: ShieldStateCode; message: string }) {
      super('ShieldState', 'Grey');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { code: ShieldStateCode; message: string }): Grey_ {
      return new Grey_(inner);
    }

    static instanceOf(obj: any): obj is Grey_ {
      return obj.tag === ShieldState_Tags.Grey;
    }
  }

  type None__interface = {
    tag: ShieldState_Tags.None;
  };

  /**
   * No shield should be presented.
   */
  class None_ extends UniffiEnum implements None__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ShieldState';
    readonly tag = ShieldState_Tags.None;
    constructor() {
      super('ShieldState', 'None');
    }

    static new(): None_ {
      return new None_();
    }

    static instanceOf(obj: any): obj is None_ {
      return obj.tag === ShieldState_Tags.None;
    }
  }

  function instanceOf(obj: any): obj is ShieldState {
    return obj[uniffiTypeNameSymbol] === 'ShieldState';
  }

  return Object.freeze({
    instanceOf,
    Red: Red_,
    Grey: Grey_,
    None: None_,
  });
})();

/**
 * Recommended decorations for decrypted messages, representing the message's
 * authenticity properties.
 */

export type ShieldState = InstanceType<
  (typeof ShieldState)[keyof Omit<typeof ShieldState, 'instanceOf'>]
>;

// FfiConverter for enum ShieldState
const FfiConverterTypeShieldState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ShieldState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ShieldState.Red({
            code: FfiConverterTypeShieldStateCode.read(from),
            message: FfiConverterString.read(from),
          });
        case 2:
          return new ShieldState.Grey({
            code: FfiConverterTypeShieldStateCode.read(from),
            message: FfiConverterString.read(from),
          });
        case 3:
          return new ShieldState.None();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ShieldState_Tags.Red: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeShieldStateCode.write(inner.code, into);
          FfiConverterString.write(inner.message, into);
          return;
        }
        case ShieldState_Tags.Grey: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeShieldStateCode.write(inner.code, into);
          FfiConverterString.write(inner.message, into);
          return;
        }
        case ShieldState_Tags.None: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that ShieldState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ShieldState_Tags.Red: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeShieldStateCode.allocationSize(inner.code);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case ShieldState_Tags.Grey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeShieldStateCode.allocationSize(inner.code);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case ShieldState_Tags.None: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SlidingSyncVersion
export enum SlidingSyncVersion_Tags {
  None = 'None',
  Proxy = 'Proxy',
  Native = 'Native',
}
export const SlidingSyncVersion = (() => {
  type None__interface = {
    tag: SlidingSyncVersion_Tags.None;
  };

  class None_ extends UniffiEnum implements None__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SlidingSyncVersion';
    readonly tag = SlidingSyncVersion_Tags.None;
    constructor() {
      super('SlidingSyncVersion', 'None');
    }

    static new(): None_ {
      return new None_();
    }

    static instanceOf(obj: any): obj is None_ {
      return obj.tag === SlidingSyncVersion_Tags.None;
    }
  }

  type Proxy__interface = {
    tag: SlidingSyncVersion_Tags.Proxy;
    inner: Readonly<{ url: string }>;
  };

  class Proxy_ extends UniffiEnum implements Proxy__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SlidingSyncVersion';
    readonly tag = SlidingSyncVersion_Tags.Proxy;
    readonly inner: Readonly<{ url: string }>;
    constructor(inner: { url: string }) {
      super('SlidingSyncVersion', 'Proxy');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string }): Proxy_ {
      return new Proxy_(inner);
    }

    static instanceOf(obj: any): obj is Proxy_ {
      return obj.tag === SlidingSyncVersion_Tags.Proxy;
    }
  }

  type Native__interface = {
    tag: SlidingSyncVersion_Tags.Native;
  };

  class Native_ extends UniffiEnum implements Native__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SlidingSyncVersion';
    readonly tag = SlidingSyncVersion_Tags.Native;
    constructor() {
      super('SlidingSyncVersion', 'Native');
    }

    static new(): Native_ {
      return new Native_();
    }

    static instanceOf(obj: any): obj is Native_ {
      return obj.tag === SlidingSyncVersion_Tags.Native;
    }
  }

  function instanceOf(obj: any): obj is SlidingSyncVersion {
    return obj[uniffiTypeNameSymbol] === 'SlidingSyncVersion';
  }

  return Object.freeze({
    instanceOf,
    None: None_,
    Proxy: Proxy_,
    Native: Native_,
  });
})();

export type SlidingSyncVersion = InstanceType<
  (typeof SlidingSyncVersion)[keyof Omit<
    typeof SlidingSyncVersion,
    'instanceOf'
  >]
>;

// FfiConverter for enum SlidingSyncVersion
const FfiConverterTypeSlidingSyncVersion = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SlidingSyncVersion;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SlidingSyncVersion.None();
        case 2:
          return new SlidingSyncVersion.Proxy({
            url: FfiConverterString.read(from),
          });
        case 3:
          return new SlidingSyncVersion.Native();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SlidingSyncVersion_Tags.None: {
          ordinalConverter.write(1, into);
          return;
        }
        case SlidingSyncVersion_Tags.Proxy: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          return;
        }
        case SlidingSyncVersion_Tags.Native: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that SlidingSyncVersion_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SlidingSyncVersion_Tags.None: {
          return ordinalConverter.allocationSize(1);
        }
        case SlidingSyncVersion_Tags.Proxy: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case SlidingSyncVersion_Tags.Native: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SlidingSyncVersionBuilder
export enum SlidingSyncVersionBuilder_Tags {
  None = 'None',
  Proxy = 'Proxy',
  Native = 'Native',
  DiscoverProxy = 'DiscoverProxy',
  DiscoverNative = 'DiscoverNative',
}
export const SlidingSyncVersionBuilder = (() => {
  type None__interface = {
    tag: SlidingSyncVersionBuilder_Tags.None;
  };

  class None_ extends UniffiEnum implements None__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SlidingSyncVersionBuilder';
    readonly tag = SlidingSyncVersionBuilder_Tags.None;
    constructor() {
      super('SlidingSyncVersionBuilder', 'None');
    }

    static new(): None_ {
      return new None_();
    }

    static instanceOf(obj: any): obj is None_ {
      return obj.tag === SlidingSyncVersionBuilder_Tags.None;
    }
  }

  type Proxy__interface = {
    tag: SlidingSyncVersionBuilder_Tags.Proxy;
    inner: Readonly<{ url: string }>;
  };

  class Proxy_ extends UniffiEnum implements Proxy__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SlidingSyncVersionBuilder';
    readonly tag = SlidingSyncVersionBuilder_Tags.Proxy;
    readonly inner: Readonly<{ url: string }>;
    constructor(inner: { url: string }) {
      super('SlidingSyncVersionBuilder', 'Proxy');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string }): Proxy_ {
      return new Proxy_(inner);
    }

    static instanceOf(obj: any): obj is Proxy_ {
      return obj.tag === SlidingSyncVersionBuilder_Tags.Proxy;
    }
  }

  type Native__interface = {
    tag: SlidingSyncVersionBuilder_Tags.Native;
  };

  class Native_ extends UniffiEnum implements Native__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SlidingSyncVersionBuilder';
    readonly tag = SlidingSyncVersionBuilder_Tags.Native;
    constructor() {
      super('SlidingSyncVersionBuilder', 'Native');
    }

    static new(): Native_ {
      return new Native_();
    }

    static instanceOf(obj: any): obj is Native_ {
      return obj.tag === SlidingSyncVersionBuilder_Tags.Native;
    }
  }

  type DiscoverProxy__interface = {
    tag: SlidingSyncVersionBuilder_Tags.DiscoverProxy;
  };

  class DiscoverProxy_ extends UniffiEnum implements DiscoverProxy__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SlidingSyncVersionBuilder';
    readonly tag = SlidingSyncVersionBuilder_Tags.DiscoverProxy;
    constructor() {
      super('SlidingSyncVersionBuilder', 'DiscoverProxy');
    }

    static new(): DiscoverProxy_ {
      return new DiscoverProxy_();
    }

    static instanceOf(obj: any): obj is DiscoverProxy_ {
      return obj.tag === SlidingSyncVersionBuilder_Tags.DiscoverProxy;
    }
  }

  type DiscoverNative__interface = {
    tag: SlidingSyncVersionBuilder_Tags.DiscoverNative;
  };

  class DiscoverNative_
    extends UniffiEnum
    implements DiscoverNative__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SlidingSyncVersionBuilder';
    readonly tag = SlidingSyncVersionBuilder_Tags.DiscoverNative;
    constructor() {
      super('SlidingSyncVersionBuilder', 'DiscoverNative');
    }

    static new(): DiscoverNative_ {
      return new DiscoverNative_();
    }

    static instanceOf(obj: any): obj is DiscoverNative_ {
      return obj.tag === SlidingSyncVersionBuilder_Tags.DiscoverNative;
    }
  }

  function instanceOf(obj: any): obj is SlidingSyncVersionBuilder {
    return obj[uniffiTypeNameSymbol] === 'SlidingSyncVersionBuilder';
  }

  return Object.freeze({
    instanceOf,
    None: None_,
    Proxy: Proxy_,
    Native: Native_,
    DiscoverProxy: DiscoverProxy_,
    DiscoverNative: DiscoverNative_,
  });
})();

export type SlidingSyncVersionBuilder = InstanceType<
  (typeof SlidingSyncVersionBuilder)[keyof Omit<
    typeof SlidingSyncVersionBuilder,
    'instanceOf'
  >]
>;

// FfiConverter for enum SlidingSyncVersionBuilder
const FfiConverterTypeSlidingSyncVersionBuilder = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SlidingSyncVersionBuilder;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SlidingSyncVersionBuilder.None();
        case 2:
          return new SlidingSyncVersionBuilder.Proxy({
            url: FfiConverterString.read(from),
          });
        case 3:
          return new SlidingSyncVersionBuilder.Native();
        case 4:
          return new SlidingSyncVersionBuilder.DiscoverProxy();
        case 5:
          return new SlidingSyncVersionBuilder.DiscoverNative();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SlidingSyncVersionBuilder_Tags.None: {
          ordinalConverter.write(1, into);
          return;
        }
        case SlidingSyncVersionBuilder_Tags.Proxy: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          return;
        }
        case SlidingSyncVersionBuilder_Tags.Native: {
          ordinalConverter.write(3, into);
          return;
        }
        case SlidingSyncVersionBuilder_Tags.DiscoverProxy: {
          ordinalConverter.write(4, into);
          return;
        }
        case SlidingSyncVersionBuilder_Tags.DiscoverNative: {
          ordinalConverter.write(5, into);
          return;
        }
        default:
          // Throwing from here means that SlidingSyncVersionBuilder_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SlidingSyncVersionBuilder_Tags.None: {
          return ordinalConverter.allocationSize(1);
        }
        case SlidingSyncVersionBuilder_Tags.Proxy: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case SlidingSyncVersionBuilder_Tags.Native: {
          return ordinalConverter.allocationSize(3);
        }
        case SlidingSyncVersionBuilder_Tags.DiscoverProxy: {
          return ordinalConverter.allocationSize(4);
        }
        case SlidingSyncVersionBuilder_Tags.DiscoverNative: {
          return ordinalConverter.allocationSize(5);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: SsoError
export enum SsoError_Tags {
  CallbackUrlInvalid = 'CallbackUrlInvalid',
  LoginWithTokenFailed = 'LoginWithTokenFailed',
  Generic = 'Generic',
}
export const SsoError = (() => {
  class CallbackUrlInvalid extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SsoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = SsoError_Tags.CallbackUrlInvalid;

    constructor(message: string) {
      super('SsoError', 'CallbackUrlInvalid', message);
    }

    static instanceOf(e: any): e is CallbackUrlInvalid {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class LoginWithTokenFailed extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SsoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = SsoError_Tags.LoginWithTokenFailed;

    constructor(message: string) {
      super('SsoError', 'LoginWithTokenFailed', message);
    }

    static instanceOf(e: any): e is LoginWithTokenFailed {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SsoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = SsoError_Tags.Generic;

    constructor(message: string) {
      super('SsoError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is SsoError {
    return (e as any)[uniffiTypeNameSymbol] === 'SsoError';
  }
  return {
    CallbackUrlInvalid,
    LoginWithTokenFailed,
    Generic,
    instanceOf,
  };
})();

// Union type for SsoError error type.

export type SsoError = InstanceType<
  (typeof SsoError)[keyof Omit<typeof SsoError, 'instanceOf'>]
>;

const FfiConverterTypeSsoError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = SsoError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new SsoError.CallbackUrlInvalid(FfiConverterString.read(from));

        case 2:
          return new SsoError.LoginWithTokenFailed(
            FfiConverterString.read(from)
          );

        case 3:
          return new SsoError.Generic(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: StateEventContent
export enum StateEventContent_Tags {
  PolicyRuleRoom = 'PolicyRuleRoom',
  PolicyRuleServer = 'PolicyRuleServer',
  PolicyRuleUser = 'PolicyRuleUser',
  RoomAliases = 'RoomAliases',
  RoomAvatar = 'RoomAvatar',
  RoomCanonicalAlias = 'RoomCanonicalAlias',
  RoomCreate = 'RoomCreate',
  RoomEncryption = 'RoomEncryption',
  RoomGuestAccess = 'RoomGuestAccess',
  RoomHistoryVisibility = 'RoomHistoryVisibility',
  RoomJoinRules = 'RoomJoinRules',
  RoomMemberContent = 'RoomMemberContent',
  RoomName = 'RoomName',
  RoomPinnedEvents = 'RoomPinnedEvents',
  RoomPowerLevels = 'RoomPowerLevels',
  RoomServerAcl = 'RoomServerAcl',
  RoomThirdPartyInvite = 'RoomThirdPartyInvite',
  RoomTombstone = 'RoomTombstone',
  RoomTopic = 'RoomTopic',
  SpaceChild = 'SpaceChild',
  SpaceParent = 'SpaceParent',
}
export const StateEventContent = (() => {
  type PolicyRuleRoom__interface = {
    tag: StateEventContent_Tags.PolicyRuleRoom;
  };

  class PolicyRuleRoom_
    extends UniffiEnum
    implements PolicyRuleRoom__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.PolicyRuleRoom;
    constructor() {
      super('StateEventContent', 'PolicyRuleRoom');
    }

    static new(): PolicyRuleRoom_ {
      return new PolicyRuleRoom_();
    }

    static instanceOf(obj: any): obj is PolicyRuleRoom_ {
      return obj.tag === StateEventContent_Tags.PolicyRuleRoom;
    }
  }

  type PolicyRuleServer__interface = {
    tag: StateEventContent_Tags.PolicyRuleServer;
  };

  class PolicyRuleServer_
    extends UniffiEnum
    implements PolicyRuleServer__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.PolicyRuleServer;
    constructor() {
      super('StateEventContent', 'PolicyRuleServer');
    }

    static new(): PolicyRuleServer_ {
      return new PolicyRuleServer_();
    }

    static instanceOf(obj: any): obj is PolicyRuleServer_ {
      return obj.tag === StateEventContent_Tags.PolicyRuleServer;
    }
  }

  type PolicyRuleUser__interface = {
    tag: StateEventContent_Tags.PolicyRuleUser;
  };

  class PolicyRuleUser_
    extends UniffiEnum
    implements PolicyRuleUser__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.PolicyRuleUser;
    constructor() {
      super('StateEventContent', 'PolicyRuleUser');
    }

    static new(): PolicyRuleUser_ {
      return new PolicyRuleUser_();
    }

    static instanceOf(obj: any): obj is PolicyRuleUser_ {
      return obj.tag === StateEventContent_Tags.PolicyRuleUser;
    }
  }

  type RoomAliases__interface = {
    tag: StateEventContent_Tags.RoomAliases;
  };

  class RoomAliases_ extends UniffiEnum implements RoomAliases__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomAliases;
    constructor() {
      super('StateEventContent', 'RoomAliases');
    }

    static new(): RoomAliases_ {
      return new RoomAliases_();
    }

    static instanceOf(obj: any): obj is RoomAliases_ {
      return obj.tag === StateEventContent_Tags.RoomAliases;
    }
  }

  type RoomAvatar__interface = {
    tag: StateEventContent_Tags.RoomAvatar;
  };

  class RoomAvatar_ extends UniffiEnum implements RoomAvatar__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomAvatar;
    constructor() {
      super('StateEventContent', 'RoomAvatar');
    }

    static new(): RoomAvatar_ {
      return new RoomAvatar_();
    }

    static instanceOf(obj: any): obj is RoomAvatar_ {
      return obj.tag === StateEventContent_Tags.RoomAvatar;
    }
  }

  type RoomCanonicalAlias__interface = {
    tag: StateEventContent_Tags.RoomCanonicalAlias;
  };

  class RoomCanonicalAlias_
    extends UniffiEnum
    implements RoomCanonicalAlias__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomCanonicalAlias;
    constructor() {
      super('StateEventContent', 'RoomCanonicalAlias');
    }

    static new(): RoomCanonicalAlias_ {
      return new RoomCanonicalAlias_();
    }

    static instanceOf(obj: any): obj is RoomCanonicalAlias_ {
      return obj.tag === StateEventContent_Tags.RoomCanonicalAlias;
    }
  }

  type RoomCreate__interface = {
    tag: StateEventContent_Tags.RoomCreate;
  };

  class RoomCreate_ extends UniffiEnum implements RoomCreate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomCreate;
    constructor() {
      super('StateEventContent', 'RoomCreate');
    }

    static new(): RoomCreate_ {
      return new RoomCreate_();
    }

    static instanceOf(obj: any): obj is RoomCreate_ {
      return obj.tag === StateEventContent_Tags.RoomCreate;
    }
  }

  type RoomEncryption__interface = {
    tag: StateEventContent_Tags.RoomEncryption;
  };

  class RoomEncryption_
    extends UniffiEnum
    implements RoomEncryption__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomEncryption;
    constructor() {
      super('StateEventContent', 'RoomEncryption');
    }

    static new(): RoomEncryption_ {
      return new RoomEncryption_();
    }

    static instanceOf(obj: any): obj is RoomEncryption_ {
      return obj.tag === StateEventContent_Tags.RoomEncryption;
    }
  }

  type RoomGuestAccess__interface = {
    tag: StateEventContent_Tags.RoomGuestAccess;
  };

  class RoomGuestAccess_
    extends UniffiEnum
    implements RoomGuestAccess__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomGuestAccess;
    constructor() {
      super('StateEventContent', 'RoomGuestAccess');
    }

    static new(): RoomGuestAccess_ {
      return new RoomGuestAccess_();
    }

    static instanceOf(obj: any): obj is RoomGuestAccess_ {
      return obj.tag === StateEventContent_Tags.RoomGuestAccess;
    }
  }

  type RoomHistoryVisibility__interface = {
    tag: StateEventContent_Tags.RoomHistoryVisibility;
  };

  class RoomHistoryVisibility_
    extends UniffiEnum
    implements RoomHistoryVisibility__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomHistoryVisibility;
    constructor() {
      super('StateEventContent', 'RoomHistoryVisibility');
    }

    static new(): RoomHistoryVisibility_ {
      return new RoomHistoryVisibility_();
    }

    static instanceOf(obj: any): obj is RoomHistoryVisibility_ {
      return obj.tag === StateEventContent_Tags.RoomHistoryVisibility;
    }
  }

  type RoomJoinRules__interface = {
    tag: StateEventContent_Tags.RoomJoinRules;
  };

  class RoomJoinRules_ extends UniffiEnum implements RoomJoinRules__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomJoinRules;
    constructor() {
      super('StateEventContent', 'RoomJoinRules');
    }

    static new(): RoomJoinRules_ {
      return new RoomJoinRules_();
    }

    static instanceOf(obj: any): obj is RoomJoinRules_ {
      return obj.tag === StateEventContent_Tags.RoomJoinRules;
    }
  }

  type RoomMemberContent__interface = {
    tag: StateEventContent_Tags.RoomMemberContent;
    inner: Readonly<{ userId: string; membershipState: MembershipState }>;
  };

  class RoomMemberContent_
    extends UniffiEnum
    implements RoomMemberContent__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomMemberContent;
    readonly inner: Readonly<{
      userId: string;
      membershipState: MembershipState;
    }>;
    constructor(inner: { userId: string; membershipState: MembershipState }) {
      super('StateEventContent', 'RoomMemberContent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      userId: string;
      membershipState: MembershipState;
    }): RoomMemberContent_ {
      return new RoomMemberContent_(inner);
    }

    static instanceOf(obj: any): obj is RoomMemberContent_ {
      return obj.tag === StateEventContent_Tags.RoomMemberContent;
    }
  }

  type RoomName__interface = {
    tag: StateEventContent_Tags.RoomName;
  };

  class RoomName_ extends UniffiEnum implements RoomName__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomName;
    constructor() {
      super('StateEventContent', 'RoomName');
    }

    static new(): RoomName_ {
      return new RoomName_();
    }

    static instanceOf(obj: any): obj is RoomName_ {
      return obj.tag === StateEventContent_Tags.RoomName;
    }
  }

  type RoomPinnedEvents__interface = {
    tag: StateEventContent_Tags.RoomPinnedEvents;
  };

  class RoomPinnedEvents_
    extends UniffiEnum
    implements RoomPinnedEvents__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomPinnedEvents;
    constructor() {
      super('StateEventContent', 'RoomPinnedEvents');
    }

    static new(): RoomPinnedEvents_ {
      return new RoomPinnedEvents_();
    }

    static instanceOf(obj: any): obj is RoomPinnedEvents_ {
      return obj.tag === StateEventContent_Tags.RoomPinnedEvents;
    }
  }

  type RoomPowerLevels__interface = {
    tag: StateEventContent_Tags.RoomPowerLevels;
  };

  class RoomPowerLevels_
    extends UniffiEnum
    implements RoomPowerLevels__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomPowerLevels;
    constructor() {
      super('StateEventContent', 'RoomPowerLevels');
    }

    static new(): RoomPowerLevels_ {
      return new RoomPowerLevels_();
    }

    static instanceOf(obj: any): obj is RoomPowerLevels_ {
      return obj.tag === StateEventContent_Tags.RoomPowerLevels;
    }
  }

  type RoomServerAcl__interface = {
    tag: StateEventContent_Tags.RoomServerAcl;
  };

  class RoomServerAcl_ extends UniffiEnum implements RoomServerAcl__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomServerAcl;
    constructor() {
      super('StateEventContent', 'RoomServerAcl');
    }

    static new(): RoomServerAcl_ {
      return new RoomServerAcl_();
    }

    static instanceOf(obj: any): obj is RoomServerAcl_ {
      return obj.tag === StateEventContent_Tags.RoomServerAcl;
    }
  }

  type RoomThirdPartyInvite__interface = {
    tag: StateEventContent_Tags.RoomThirdPartyInvite;
  };

  class RoomThirdPartyInvite_
    extends UniffiEnum
    implements RoomThirdPartyInvite__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomThirdPartyInvite;
    constructor() {
      super('StateEventContent', 'RoomThirdPartyInvite');
    }

    static new(): RoomThirdPartyInvite_ {
      return new RoomThirdPartyInvite_();
    }

    static instanceOf(obj: any): obj is RoomThirdPartyInvite_ {
      return obj.tag === StateEventContent_Tags.RoomThirdPartyInvite;
    }
  }

  type RoomTombstone__interface = {
    tag: StateEventContent_Tags.RoomTombstone;
  };

  class RoomTombstone_ extends UniffiEnum implements RoomTombstone__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomTombstone;
    constructor() {
      super('StateEventContent', 'RoomTombstone');
    }

    static new(): RoomTombstone_ {
      return new RoomTombstone_();
    }

    static instanceOf(obj: any): obj is RoomTombstone_ {
      return obj.tag === StateEventContent_Tags.RoomTombstone;
    }
  }

  type RoomTopic__interface = {
    tag: StateEventContent_Tags.RoomTopic;
  };

  class RoomTopic_ extends UniffiEnum implements RoomTopic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomTopic;
    constructor() {
      super('StateEventContent', 'RoomTopic');
    }

    static new(): RoomTopic_ {
      return new RoomTopic_();
    }

    static instanceOf(obj: any): obj is RoomTopic_ {
      return obj.tag === StateEventContent_Tags.RoomTopic;
    }
  }

  type SpaceChild__interface = {
    tag: StateEventContent_Tags.SpaceChild;
  };

  class SpaceChild_ extends UniffiEnum implements SpaceChild__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.SpaceChild;
    constructor() {
      super('StateEventContent', 'SpaceChild');
    }

    static new(): SpaceChild_ {
      return new SpaceChild_();
    }

    static instanceOf(obj: any): obj is SpaceChild_ {
      return obj.tag === StateEventContent_Tags.SpaceChild;
    }
  }

  type SpaceParent__interface = {
    tag: StateEventContent_Tags.SpaceParent;
  };

  class SpaceParent_ extends UniffiEnum implements SpaceParent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.SpaceParent;
    constructor() {
      super('StateEventContent', 'SpaceParent');
    }

    static new(): SpaceParent_ {
      return new SpaceParent_();
    }

    static instanceOf(obj: any): obj is SpaceParent_ {
      return obj.tag === StateEventContent_Tags.SpaceParent;
    }
  }

  function instanceOf(obj: any): obj is StateEventContent {
    return obj[uniffiTypeNameSymbol] === 'StateEventContent';
  }

  return Object.freeze({
    instanceOf,
    PolicyRuleRoom: PolicyRuleRoom_,
    PolicyRuleServer: PolicyRuleServer_,
    PolicyRuleUser: PolicyRuleUser_,
    RoomAliases: RoomAliases_,
    RoomAvatar: RoomAvatar_,
    RoomCanonicalAlias: RoomCanonicalAlias_,
    RoomCreate: RoomCreate_,
    RoomEncryption: RoomEncryption_,
    RoomGuestAccess: RoomGuestAccess_,
    RoomHistoryVisibility: RoomHistoryVisibility_,
    RoomJoinRules: RoomJoinRules_,
    RoomMemberContent: RoomMemberContent_,
    RoomName: RoomName_,
    RoomPinnedEvents: RoomPinnedEvents_,
    RoomPowerLevels: RoomPowerLevels_,
    RoomServerAcl: RoomServerAcl_,
    RoomThirdPartyInvite: RoomThirdPartyInvite_,
    RoomTombstone: RoomTombstone_,
    RoomTopic: RoomTopic_,
    SpaceChild: SpaceChild_,
    SpaceParent: SpaceParent_,
  });
})();

export type StateEventContent = InstanceType<
  (typeof StateEventContent)[keyof Omit<typeof StateEventContent, 'instanceOf'>]
>;

// FfiConverter for enum StateEventContent
const FfiConverterTypeStateEventContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StateEventContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new StateEventContent.PolicyRuleRoom();
        case 2:
          return new StateEventContent.PolicyRuleServer();
        case 3:
          return new StateEventContent.PolicyRuleUser();
        case 4:
          return new StateEventContent.RoomAliases();
        case 5:
          return new StateEventContent.RoomAvatar();
        case 6:
          return new StateEventContent.RoomCanonicalAlias();
        case 7:
          return new StateEventContent.RoomCreate();
        case 8:
          return new StateEventContent.RoomEncryption();
        case 9:
          return new StateEventContent.RoomGuestAccess();
        case 10:
          return new StateEventContent.RoomHistoryVisibility();
        case 11:
          return new StateEventContent.RoomJoinRules();
        case 12:
          return new StateEventContent.RoomMemberContent({
            userId: FfiConverterString.read(from),
            membershipState: FfiConverterTypeMembershipState.read(from),
          });
        case 13:
          return new StateEventContent.RoomName();
        case 14:
          return new StateEventContent.RoomPinnedEvents();
        case 15:
          return new StateEventContent.RoomPowerLevels();
        case 16:
          return new StateEventContent.RoomServerAcl();
        case 17:
          return new StateEventContent.RoomThirdPartyInvite();
        case 18:
          return new StateEventContent.RoomTombstone();
        case 19:
          return new StateEventContent.RoomTopic();
        case 20:
          return new StateEventContent.SpaceChild();
        case 21:
          return new StateEventContent.SpaceParent();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case StateEventContent_Tags.PolicyRuleRoom: {
          ordinalConverter.write(1, into);
          return;
        }
        case StateEventContent_Tags.PolicyRuleServer: {
          ordinalConverter.write(2, into);
          return;
        }
        case StateEventContent_Tags.PolicyRuleUser: {
          ordinalConverter.write(3, into);
          return;
        }
        case StateEventContent_Tags.RoomAliases: {
          ordinalConverter.write(4, into);
          return;
        }
        case StateEventContent_Tags.RoomAvatar: {
          ordinalConverter.write(5, into);
          return;
        }
        case StateEventContent_Tags.RoomCanonicalAlias: {
          ordinalConverter.write(6, into);
          return;
        }
        case StateEventContent_Tags.RoomCreate: {
          ordinalConverter.write(7, into);
          return;
        }
        case StateEventContent_Tags.RoomEncryption: {
          ordinalConverter.write(8, into);
          return;
        }
        case StateEventContent_Tags.RoomGuestAccess: {
          ordinalConverter.write(9, into);
          return;
        }
        case StateEventContent_Tags.RoomHistoryVisibility: {
          ordinalConverter.write(10, into);
          return;
        }
        case StateEventContent_Tags.RoomJoinRules: {
          ordinalConverter.write(11, into);
          return;
        }
        case StateEventContent_Tags.RoomMemberContent: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterString.write(inner.userId, into);
          FfiConverterTypeMembershipState.write(inner.membershipState, into);
          return;
        }
        case StateEventContent_Tags.RoomName: {
          ordinalConverter.write(13, into);
          return;
        }
        case StateEventContent_Tags.RoomPinnedEvents: {
          ordinalConverter.write(14, into);
          return;
        }
        case StateEventContent_Tags.RoomPowerLevels: {
          ordinalConverter.write(15, into);
          return;
        }
        case StateEventContent_Tags.RoomServerAcl: {
          ordinalConverter.write(16, into);
          return;
        }
        case StateEventContent_Tags.RoomThirdPartyInvite: {
          ordinalConverter.write(17, into);
          return;
        }
        case StateEventContent_Tags.RoomTombstone: {
          ordinalConverter.write(18, into);
          return;
        }
        case StateEventContent_Tags.RoomTopic: {
          ordinalConverter.write(19, into);
          return;
        }
        case StateEventContent_Tags.SpaceChild: {
          ordinalConverter.write(20, into);
          return;
        }
        case StateEventContent_Tags.SpaceParent: {
          ordinalConverter.write(21, into);
          return;
        }
        default:
          // Throwing from here means that StateEventContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case StateEventContent_Tags.PolicyRuleRoom: {
          return ordinalConverter.allocationSize(1);
        }
        case StateEventContent_Tags.PolicyRuleServer: {
          return ordinalConverter.allocationSize(2);
        }
        case StateEventContent_Tags.PolicyRuleUser: {
          return ordinalConverter.allocationSize(3);
        }
        case StateEventContent_Tags.RoomAliases: {
          return ordinalConverter.allocationSize(4);
        }
        case StateEventContent_Tags.RoomAvatar: {
          return ordinalConverter.allocationSize(5);
        }
        case StateEventContent_Tags.RoomCanonicalAlias: {
          return ordinalConverter.allocationSize(6);
        }
        case StateEventContent_Tags.RoomCreate: {
          return ordinalConverter.allocationSize(7);
        }
        case StateEventContent_Tags.RoomEncryption: {
          return ordinalConverter.allocationSize(8);
        }
        case StateEventContent_Tags.RoomGuestAccess: {
          return ordinalConverter.allocationSize(9);
        }
        case StateEventContent_Tags.RoomHistoryVisibility: {
          return ordinalConverter.allocationSize(10);
        }
        case StateEventContent_Tags.RoomJoinRules: {
          return ordinalConverter.allocationSize(11);
        }
        case StateEventContent_Tags.RoomMemberContent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterString.allocationSize(inner.userId);
          size += FfiConverterTypeMembershipState.allocationSize(
            inner.membershipState
          );
          return size;
        }
        case StateEventContent_Tags.RoomName: {
          return ordinalConverter.allocationSize(13);
        }
        case StateEventContent_Tags.RoomPinnedEvents: {
          return ordinalConverter.allocationSize(14);
        }
        case StateEventContent_Tags.RoomPowerLevels: {
          return ordinalConverter.allocationSize(15);
        }
        case StateEventContent_Tags.RoomServerAcl: {
          return ordinalConverter.allocationSize(16);
        }
        case StateEventContent_Tags.RoomThirdPartyInvite: {
          return ordinalConverter.allocationSize(17);
        }
        case StateEventContent_Tags.RoomTombstone: {
          return ordinalConverter.allocationSize(18);
        }
        case StateEventContent_Tags.RoomTopic: {
          return ordinalConverter.allocationSize(19);
        }
        case StateEventContent_Tags.SpaceChild: {
          return ordinalConverter.allocationSize(20);
        }
        case StateEventContent_Tags.SpaceParent: {
          return ordinalConverter.allocationSize(21);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum StateEventType {
  CallMember,
  PolicyRuleRoom,
  PolicyRuleServer,
  PolicyRuleUser,
  RoomAliases,
  RoomAvatar,
  RoomCanonicalAlias,
  RoomCreate,
  RoomEncryption,
  RoomGuestAccess,
  RoomHistoryVisibility,
  RoomJoinRules,
  RoomMemberEvent,
  RoomName,
  RoomPinnedEvents,
  RoomPowerLevels,
  RoomServerAcl,
  RoomThirdPartyInvite,
  RoomTombstone,
  RoomTopic,
  SpaceChild,
  SpaceParent,
}

const FfiConverterTypeStateEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StateEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return StateEventType.CallMember;
        case 2:
          return StateEventType.PolicyRuleRoom;
        case 3:
          return StateEventType.PolicyRuleServer;
        case 4:
          return StateEventType.PolicyRuleUser;
        case 5:
          return StateEventType.RoomAliases;
        case 6:
          return StateEventType.RoomAvatar;
        case 7:
          return StateEventType.RoomCanonicalAlias;
        case 8:
          return StateEventType.RoomCreate;
        case 9:
          return StateEventType.RoomEncryption;
        case 10:
          return StateEventType.RoomGuestAccess;
        case 11:
          return StateEventType.RoomHistoryVisibility;
        case 12:
          return StateEventType.RoomJoinRules;
        case 13:
          return StateEventType.RoomMemberEvent;
        case 14:
          return StateEventType.RoomName;
        case 15:
          return StateEventType.RoomPinnedEvents;
        case 16:
          return StateEventType.RoomPowerLevels;
        case 17:
          return StateEventType.RoomServerAcl;
        case 18:
          return StateEventType.RoomThirdPartyInvite;
        case 19:
          return StateEventType.RoomTombstone;
        case 20:
          return StateEventType.RoomTopic;
        case 21:
          return StateEventType.SpaceChild;
        case 22:
          return StateEventType.SpaceParent;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case StateEventType.CallMember:
          return ordinalConverter.write(1, into);
        case StateEventType.PolicyRuleRoom:
          return ordinalConverter.write(2, into);
        case StateEventType.PolicyRuleServer:
          return ordinalConverter.write(3, into);
        case StateEventType.PolicyRuleUser:
          return ordinalConverter.write(4, into);
        case StateEventType.RoomAliases:
          return ordinalConverter.write(5, into);
        case StateEventType.RoomAvatar:
          return ordinalConverter.write(6, into);
        case StateEventType.RoomCanonicalAlias:
          return ordinalConverter.write(7, into);
        case StateEventType.RoomCreate:
          return ordinalConverter.write(8, into);
        case StateEventType.RoomEncryption:
          return ordinalConverter.write(9, into);
        case StateEventType.RoomGuestAccess:
          return ordinalConverter.write(10, into);
        case StateEventType.RoomHistoryVisibility:
          return ordinalConverter.write(11, into);
        case StateEventType.RoomJoinRules:
          return ordinalConverter.write(12, into);
        case StateEventType.RoomMemberEvent:
          return ordinalConverter.write(13, into);
        case StateEventType.RoomName:
          return ordinalConverter.write(14, into);
        case StateEventType.RoomPinnedEvents:
          return ordinalConverter.write(15, into);
        case StateEventType.RoomPowerLevels:
          return ordinalConverter.write(16, into);
        case StateEventType.RoomServerAcl:
          return ordinalConverter.write(17, into);
        case StateEventType.RoomThirdPartyInvite:
          return ordinalConverter.write(18, into);
        case StateEventType.RoomTombstone:
          return ordinalConverter.write(19, into);
        case StateEventType.RoomTopic:
          return ordinalConverter.write(20, into);
        case StateEventType.SpaceChild:
          return ordinalConverter.write(21, into);
        case StateEventType.SpaceParent:
          return ordinalConverter.write(22, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: SteadyStateError
export enum SteadyStateError_Tags {
  BackupDisabled = 'BackupDisabled',
  Connection = 'Connection',
  Lagged = 'Lagged',
}
export const SteadyStateError = (() => {
  class BackupDisabled extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SteadyStateError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = SteadyStateError_Tags.BackupDisabled;

    constructor(message: string) {
      super('SteadyStateError', 'BackupDisabled', message);
    }

    static instanceOf(e: any): e is BackupDisabled {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class Connection extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SteadyStateError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = SteadyStateError_Tags.Connection;

    constructor(message: string) {
      super('SteadyStateError', 'Connection', message);
    }

    static instanceOf(e: any): e is Connection {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class Lagged extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SteadyStateError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = SteadyStateError_Tags.Lagged;

    constructor(message: string) {
      super('SteadyStateError', 'Lagged', message);
    }

    static instanceOf(e: any): e is Lagged {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is SteadyStateError {
    return (e as any)[uniffiTypeNameSymbol] === 'SteadyStateError';
  }
  return {
    BackupDisabled,
    Connection,
    Lagged,
    instanceOf,
  };
})();

// Union type for SteadyStateError error type.

export type SteadyStateError = InstanceType<
  (typeof SteadyStateError)[keyof Omit<typeof SteadyStateError, 'instanceOf'>]
>;

const FfiConverterTypeSteadyStateError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = SteadyStateError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new SteadyStateError.BackupDisabled(
            FfiConverterString.read(from)
          );

        case 2:
          return new SteadyStateError.Connection(FfiConverterString.read(from));

        case 3:
          return new SteadyStateError.Lagged(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum SyncServiceState {
  Idle,
  Running,
  Terminated,
  Error,
}

const FfiConverterTypeSyncServiceState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SyncServiceState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SyncServiceState.Idle;
        case 2:
          return SyncServiceState.Running;
        case 3:
          return SyncServiceState.Terminated;
        case 4:
          return SyncServiceState.Error;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case SyncServiceState.Idle:
          return ordinalConverter.write(1, into);
        case SyncServiceState.Running:
          return ordinalConverter.write(2, into);
        case SyncServiceState.Terminated:
          return ordinalConverter.write(3, into);
        case SyncServiceState.Error:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum TimelineChange {
  Append,
  Clear,
  Insert,
  Set,
  Remove,
  PushBack,
  PushFront,
  PopBack,
  PopFront,
  Truncate,
  Reset,
}

const FfiConverterTypeTimelineChange = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TimelineChange.Append;
        case 2:
          return TimelineChange.Clear;
        case 3:
          return TimelineChange.Insert;
        case 4:
          return TimelineChange.Set;
        case 5:
          return TimelineChange.Remove;
        case 6:
          return TimelineChange.PushBack;
        case 7:
          return TimelineChange.PushFront;
        case 8:
          return TimelineChange.PopBack;
        case 9:
          return TimelineChange.PopFront;
        case 10:
          return TimelineChange.Truncate;
        case 11:
          return TimelineChange.Reset;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case TimelineChange.Append:
          return ordinalConverter.write(1, into);
        case TimelineChange.Clear:
          return ordinalConverter.write(2, into);
        case TimelineChange.Insert:
          return ordinalConverter.write(3, into);
        case TimelineChange.Set:
          return ordinalConverter.write(4, into);
        case TimelineChange.Remove:
          return ordinalConverter.write(5, into);
        case TimelineChange.PushBack:
          return ordinalConverter.write(6, into);
        case TimelineChange.PushFront:
          return ordinalConverter.write(7, into);
        case TimelineChange.PopBack:
          return ordinalConverter.write(8, into);
        case TimelineChange.PopFront:
          return ordinalConverter.write(9, into);
        case TimelineChange.Truncate:
          return ordinalConverter.write(10, into);
        case TimelineChange.Reset:
          return ordinalConverter.write(11, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: TimelineEventType
export enum TimelineEventType_Tags {
  MessageLike = 'MessageLike',
  State = 'State',
}
export const TimelineEventType = (() => {
  type MessageLike__interface = {
    tag: TimelineEventType_Tags.MessageLike;
    inner: Readonly<{ content: MessageLikeEventContent }>;
  };

  class MessageLike_ extends UniffiEnum implements MessageLike__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineEventType';
    readonly tag = TimelineEventType_Tags.MessageLike;
    readonly inner: Readonly<{ content: MessageLikeEventContent }>;
    constructor(inner: { content: MessageLikeEventContent }) {
      super('TimelineEventType', 'MessageLike');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: MessageLikeEventContent }): MessageLike_ {
      return new MessageLike_(inner);
    }

    static instanceOf(obj: any): obj is MessageLike_ {
      return obj.tag === TimelineEventType_Tags.MessageLike;
    }
  }

  type State__interface = {
    tag: TimelineEventType_Tags.State;
    inner: Readonly<{ content: StateEventContent }>;
  };

  class State_ extends UniffiEnum implements State__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineEventType';
    readonly tag = TimelineEventType_Tags.State;
    readonly inner: Readonly<{ content: StateEventContent }>;
    constructor(inner: { content: StateEventContent }) {
      super('TimelineEventType', 'State');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: StateEventContent }): State_ {
      return new State_(inner);
    }

    static instanceOf(obj: any): obj is State_ {
      return obj.tag === TimelineEventType_Tags.State;
    }
  }

  function instanceOf(obj: any): obj is TimelineEventType {
    return obj[uniffiTypeNameSymbol] === 'TimelineEventType';
  }

  return Object.freeze({
    instanceOf,
    MessageLike: MessageLike_,
    State: State_,
  });
})();

export type TimelineEventType = InstanceType<
  (typeof TimelineEventType)[keyof Omit<typeof TimelineEventType, 'instanceOf'>]
>;

// FfiConverter for enum TimelineEventType
const FfiConverterTypeTimelineEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TimelineEventType.MessageLike({
            content: FfiConverterTypeMessageLikeEventContent.read(from),
          });
        case 2:
          return new TimelineEventType.State({
            content: FfiConverterTypeStateEventContent.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TimelineEventType_Tags.MessageLike: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeMessageLikeEventContent.write(inner.content, into);
          return;
        }
        case TimelineEventType_Tags.State: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeStateEventContent.write(inner.content, into);
          return;
        }
        default:
          // Throwing from here means that TimelineEventType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TimelineEventType_Tags.MessageLike: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeMessageLikeEventContent.allocationSize(
            inner.content
          );
          return size;
        }
        case TimelineEventType_Tags.State: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeStateEventContent.allocationSize(
            inner.content
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: TimelineItemContent
export enum TimelineItemContent_Tags {
  Message = 'Message',
  RedactedMessage = 'RedactedMessage',
  Sticker = 'Sticker',
  Poll = 'Poll',
  CallInvite = 'CallInvite',
  CallNotify = 'CallNotify',
  UnableToDecrypt = 'UnableToDecrypt',
  RoomMembership = 'RoomMembership',
  ProfileChange = 'ProfileChange',
  State = 'State',
  FailedToParseMessageLike = 'FailedToParseMessageLike',
  FailedToParseState = 'FailedToParseState',
}
export const TimelineItemContent = (() => {
  type Message__interface = {
    tag: TimelineItemContent_Tags.Message;
    inner: Readonly<{ content: MessageContent }>;
  };

  class Message_ extends UniffiEnum implements Message__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.Message;
    readonly inner: Readonly<{ content: MessageContent }>;
    constructor(inner: { content: MessageContent }) {
      super('TimelineItemContent', 'Message');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: MessageContent }): Message_ {
      return new Message_(inner);
    }

    static instanceOf(obj: any): obj is Message_ {
      return obj.tag === TimelineItemContent_Tags.Message;
    }
  }

  type RedactedMessage__interface = {
    tag: TimelineItemContent_Tags.RedactedMessage;
  };

  class RedactedMessage_
    extends UniffiEnum
    implements RedactedMessage__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.RedactedMessage;
    constructor() {
      super('TimelineItemContent', 'RedactedMessage');
    }

    static new(): RedactedMessage_ {
      return new RedactedMessage_();
    }

    static instanceOf(obj: any): obj is RedactedMessage_ {
      return obj.tag === TimelineItemContent_Tags.RedactedMessage;
    }
  }

  type Sticker__interface = {
    tag: TimelineItemContent_Tags.Sticker;
    inner: Readonly<{
      body: string;
      info: ImageInfo;
      source: MediaSourceInterface;
    }>;
  };

  class Sticker_ extends UniffiEnum implements Sticker__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.Sticker;
    readonly inner: Readonly<{
      body: string;
      info: ImageInfo;
      source: MediaSourceInterface;
    }>;
    constructor(inner: {
      body: string;
      info: ImageInfo;
      source: MediaSourceInterface;
    }) {
      super('TimelineItemContent', 'Sticker');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      body: string;
      info: ImageInfo;
      source: MediaSourceInterface;
    }): Sticker_ {
      return new Sticker_(inner);
    }

    static instanceOf(obj: any): obj is Sticker_ {
      return obj.tag === TimelineItemContent_Tags.Sticker;
    }
  }

  type Poll__interface = {
    tag: TimelineItemContent_Tags.Poll;
    inner: Readonly<{
      question: string;
      kind: PollKind;
      maxSelections: /*u64*/ bigint;
      answers: Array<PollAnswer>;
      votes: Map<string, Array<string>>;
      endTime: /*u64*/ bigint | undefined;
      hasBeenEdited: boolean;
    }>;
  };

  class Poll_ extends UniffiEnum implements Poll__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.Poll;
    readonly inner: Readonly<{
      question: string;
      kind: PollKind;
      maxSelections: /*u64*/ bigint;
      answers: Array<PollAnswer>;
      votes: Map<string, Array<string>>;
      endTime: /*u64*/ bigint | undefined;
      hasBeenEdited: boolean;
    }>;
    constructor(inner: {
      question: string;
      kind: PollKind;
      maxSelections: /*u64*/ bigint;
      answers: Array<PollAnswer>;
      votes: Map<string, Array<string>>;
      endTime: /*u64*/ bigint | undefined;
      hasBeenEdited: boolean;
    }) {
      super('TimelineItemContent', 'Poll');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      question: string;
      kind: PollKind;
      maxSelections: /*u64*/ bigint;
      answers: Array<PollAnswer>;
      votes: Map<string, Array<string>>;
      endTime: /*u64*/ bigint | undefined;
      hasBeenEdited: boolean;
    }): Poll_ {
      return new Poll_(inner);
    }

    static instanceOf(obj: any): obj is Poll_ {
      return obj.tag === TimelineItemContent_Tags.Poll;
    }
  }

  type CallInvite__interface = {
    tag: TimelineItemContent_Tags.CallInvite;
  };

  class CallInvite_ extends UniffiEnum implements CallInvite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.CallInvite;
    constructor() {
      super('TimelineItemContent', 'CallInvite');
    }

    static new(): CallInvite_ {
      return new CallInvite_();
    }

    static instanceOf(obj: any): obj is CallInvite_ {
      return obj.tag === TimelineItemContent_Tags.CallInvite;
    }
  }

  type CallNotify__interface = {
    tag: TimelineItemContent_Tags.CallNotify;
  };

  class CallNotify_ extends UniffiEnum implements CallNotify__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.CallNotify;
    constructor() {
      super('TimelineItemContent', 'CallNotify');
    }

    static new(): CallNotify_ {
      return new CallNotify_();
    }

    static instanceOf(obj: any): obj is CallNotify_ {
      return obj.tag === TimelineItemContent_Tags.CallNotify;
    }
  }

  type UnableToDecrypt__interface = {
    tag: TimelineItemContent_Tags.UnableToDecrypt;
    inner: Readonly<{ msg: EncryptedMessage }>;
  };

  class UnableToDecrypt_
    extends UniffiEnum
    implements UnableToDecrypt__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.UnableToDecrypt;
    readonly inner: Readonly<{ msg: EncryptedMessage }>;
    constructor(inner: { msg: EncryptedMessage }) {
      super('TimelineItemContent', 'UnableToDecrypt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: EncryptedMessage }): UnableToDecrypt_ {
      return new UnableToDecrypt_(inner);
    }

    static instanceOf(obj: any): obj is UnableToDecrypt_ {
      return obj.tag === TimelineItemContent_Tags.UnableToDecrypt;
    }
  }

  type RoomMembership__interface = {
    tag: TimelineItemContent_Tags.RoomMembership;
    inner: Readonly<{
      userId: string;
      userDisplayName: string | undefined;
      change: MembershipChange | undefined;
      reason: string | undefined;
    }>;
  };

  class RoomMembership_
    extends UniffiEnum
    implements RoomMembership__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.RoomMembership;
    readonly inner: Readonly<{
      userId: string;
      userDisplayName: string | undefined;
      change: MembershipChange | undefined;
      reason: string | undefined;
    }>;
    constructor(inner: {
      userId: string;
      userDisplayName: string | undefined;
      change: MembershipChange | undefined;
      reason: string | undefined;
    }) {
      super('TimelineItemContent', 'RoomMembership');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      userId: string;
      userDisplayName: string | undefined;
      change: MembershipChange | undefined;
      reason: string | undefined;
    }): RoomMembership_ {
      return new RoomMembership_(inner);
    }

    static instanceOf(obj: any): obj is RoomMembership_ {
      return obj.tag === TimelineItemContent_Tags.RoomMembership;
    }
  }

  type ProfileChange__interface = {
    tag: TimelineItemContent_Tags.ProfileChange;
    inner: Readonly<{
      displayName: string | undefined;
      prevDisplayName: string | undefined;
      avatarUrl: string | undefined;
      prevAvatarUrl: string | undefined;
    }>;
  };

  class ProfileChange_ extends UniffiEnum implements ProfileChange__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.ProfileChange;
    readonly inner: Readonly<{
      displayName: string | undefined;
      prevDisplayName: string | undefined;
      avatarUrl: string | undefined;
      prevAvatarUrl: string | undefined;
    }>;
    constructor(inner: {
      displayName: string | undefined;
      prevDisplayName: string | undefined;
      avatarUrl: string | undefined;
      prevAvatarUrl: string | undefined;
    }) {
      super('TimelineItemContent', 'ProfileChange');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      displayName: string | undefined;
      prevDisplayName: string | undefined;
      avatarUrl: string | undefined;
      prevAvatarUrl: string | undefined;
    }): ProfileChange_ {
      return new ProfileChange_(inner);
    }

    static instanceOf(obj: any): obj is ProfileChange_ {
      return obj.tag === TimelineItemContent_Tags.ProfileChange;
    }
  }

  type State__interface = {
    tag: TimelineItemContent_Tags.State;
    inner: Readonly<{ stateKey: string; content: OtherState }>;
  };

  class State_ extends UniffiEnum implements State__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.State;
    readonly inner: Readonly<{ stateKey: string; content: OtherState }>;
    constructor(inner: { stateKey: string; content: OtherState }) {
      super('TimelineItemContent', 'State');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { stateKey: string; content: OtherState }): State_ {
      return new State_(inner);
    }

    static instanceOf(obj: any): obj is State_ {
      return obj.tag === TimelineItemContent_Tags.State;
    }
  }

  type FailedToParseMessageLike__interface = {
    tag: TimelineItemContent_Tags.FailedToParseMessageLike;
    inner: Readonly<{ eventType: string; error: string }>;
  };

  class FailedToParseMessageLike_
    extends UniffiEnum
    implements FailedToParseMessageLike__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.FailedToParseMessageLike;
    readonly inner: Readonly<{ eventType: string; error: string }>;
    constructor(inner: { eventType: string; error: string }) {
      super('TimelineItemContent', 'FailedToParseMessageLike');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventType: string;
      error: string;
    }): FailedToParseMessageLike_ {
      return new FailedToParseMessageLike_(inner);
    }

    static instanceOf(obj: any): obj is FailedToParseMessageLike_ {
      return obj.tag === TimelineItemContent_Tags.FailedToParseMessageLike;
    }
  }

  type FailedToParseState__interface = {
    tag: TimelineItemContent_Tags.FailedToParseState;
    inner: Readonly<{ eventType: string; stateKey: string; error: string }>;
  };

  class FailedToParseState_
    extends UniffiEnum
    implements FailedToParseState__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.FailedToParseState;
    readonly inner: Readonly<{
      eventType: string;
      stateKey: string;
      error: string;
    }>;
    constructor(inner: { eventType: string; stateKey: string; error: string }) {
      super('TimelineItemContent', 'FailedToParseState');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventType: string;
      stateKey: string;
      error: string;
    }): FailedToParseState_ {
      return new FailedToParseState_(inner);
    }

    static instanceOf(obj: any): obj is FailedToParseState_ {
      return obj.tag === TimelineItemContent_Tags.FailedToParseState;
    }
  }

  function instanceOf(obj: any): obj is TimelineItemContent {
    return obj[uniffiTypeNameSymbol] === 'TimelineItemContent';
  }

  return Object.freeze({
    instanceOf,
    Message: Message_,
    RedactedMessage: RedactedMessage_,
    Sticker: Sticker_,
    Poll: Poll_,
    CallInvite: CallInvite_,
    CallNotify: CallNotify_,
    UnableToDecrypt: UnableToDecrypt_,
    RoomMembership: RoomMembership_,
    ProfileChange: ProfileChange_,
    State: State_,
    FailedToParseMessageLike: FailedToParseMessageLike_,
    FailedToParseState: FailedToParseState_,
  });
})();

export type TimelineItemContent = InstanceType<
  (typeof TimelineItemContent)[keyof Omit<
    typeof TimelineItemContent,
    'instanceOf'
  >]
>;

// FfiConverter for enum TimelineItemContent
const FfiConverterTypeTimelineItemContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineItemContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TimelineItemContent.Message({
            content: FfiConverterTypeMessageContent.read(from),
          });
        case 2:
          return new TimelineItemContent.RedactedMessage();
        case 3:
          return new TimelineItemContent.Sticker({
            body: FfiConverterString.read(from),
            info: FfiConverterTypeImageInfo.read(from),
            source: FfiConverterTypeMediaSource.read(from),
          });
        case 4:
          return new TimelineItemContent.Poll({
            question: FfiConverterString.read(from),
            kind: FfiConverterTypePollKind.read(from),
            maxSelections: FfiConverterUInt64.read(from),
            answers: FfiConverterArrayTypePollAnswer.read(from),
            votes: FfiConverterMapStringArrayString.read(from),
            endTime: FfiConverterOptionalUInt64.read(from),
            hasBeenEdited: FfiConverterBool.read(from),
          });
        case 5:
          return new TimelineItemContent.CallInvite();
        case 6:
          return new TimelineItemContent.CallNotify();
        case 7:
          return new TimelineItemContent.UnableToDecrypt({
            msg: FfiConverterTypeEncryptedMessage.read(from),
          });
        case 8:
          return new TimelineItemContent.RoomMembership({
            userId: FfiConverterString.read(from),
            userDisplayName: FfiConverterOptionalString.read(from),
            change: FfiConverterOptionalTypeMembershipChange.read(from),
            reason: FfiConverterOptionalString.read(from),
          });
        case 9:
          return new TimelineItemContent.ProfileChange({
            displayName: FfiConverterOptionalString.read(from),
            prevDisplayName: FfiConverterOptionalString.read(from),
            avatarUrl: FfiConverterOptionalString.read(from),
            prevAvatarUrl: FfiConverterOptionalString.read(from),
          });
        case 10:
          return new TimelineItemContent.State({
            stateKey: FfiConverterString.read(from),
            content: FfiConverterTypeOtherState.read(from),
          });
        case 11:
          return new TimelineItemContent.FailedToParseMessageLike({
            eventType: FfiConverterString.read(from),
            error: FfiConverterString.read(from),
          });
        case 12:
          return new TimelineItemContent.FailedToParseState({
            eventType: FfiConverterString.read(from),
            stateKey: FfiConverterString.read(from),
            error: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TimelineItemContent_Tags.Message: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeMessageContent.write(inner.content, into);
          return;
        }
        case TimelineItemContent_Tags.RedactedMessage: {
          ordinalConverter.write(2, into);
          return;
        }
        case TimelineItemContent_Tags.Sticker: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.body, into);
          FfiConverterTypeImageInfo.write(inner.info, into);
          FfiConverterTypeMediaSource.write(inner.source, into);
          return;
        }
        case TimelineItemContent_Tags.Poll: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.question, into);
          FfiConverterTypePollKind.write(inner.kind, into);
          FfiConverterUInt64.write(inner.maxSelections, into);
          FfiConverterArrayTypePollAnswer.write(inner.answers, into);
          FfiConverterMapStringArrayString.write(inner.votes, into);
          FfiConverterOptionalUInt64.write(inner.endTime, into);
          FfiConverterBool.write(inner.hasBeenEdited, into);
          return;
        }
        case TimelineItemContent_Tags.CallInvite: {
          ordinalConverter.write(5, into);
          return;
        }
        case TimelineItemContent_Tags.CallNotify: {
          ordinalConverter.write(6, into);
          return;
        }
        case TimelineItemContent_Tags.UnableToDecrypt: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeEncryptedMessage.write(inner.msg, into);
          return;
        }
        case TimelineItemContent_Tags.RoomMembership: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner.userId, into);
          FfiConverterOptionalString.write(inner.userDisplayName, into);
          FfiConverterOptionalTypeMembershipChange.write(inner.change, into);
          FfiConverterOptionalString.write(inner.reason, into);
          return;
        }
        case TimelineItemContent_Tags.ProfileChange: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.displayName, into);
          FfiConverterOptionalString.write(inner.prevDisplayName, into);
          FfiConverterOptionalString.write(inner.avatarUrl, into);
          FfiConverterOptionalString.write(inner.prevAvatarUrl, into);
          return;
        }
        case TimelineItemContent_Tags.State: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner.stateKey, into);
          FfiConverterTypeOtherState.write(inner.content, into);
          return;
        }
        case TimelineItemContent_Tags.FailedToParseMessageLike: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          FfiConverterString.write(inner.error, into);
          return;
        }
        case TimelineItemContent_Tags.FailedToParseState: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          FfiConverterString.write(inner.stateKey, into);
          FfiConverterString.write(inner.error, into);
          return;
        }
        default:
          // Throwing from here means that TimelineItemContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TimelineItemContent_Tags.Message: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeMessageContent.allocationSize(inner.content);
          return size;
        }
        case TimelineItemContent_Tags.RedactedMessage: {
          return ordinalConverter.allocationSize(2);
        }
        case TimelineItemContent_Tags.Sticker: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.body);
          size += FfiConverterTypeImageInfo.allocationSize(inner.info);
          size += FfiConverterTypeMediaSource.allocationSize(inner.source);
          return size;
        }
        case TimelineItemContent_Tags.Poll: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.question);
          size += FfiConverterTypePollKind.allocationSize(inner.kind);
          size += FfiConverterUInt64.allocationSize(inner.maxSelections);
          size += FfiConverterArrayTypePollAnswer.allocationSize(inner.answers);
          size += FfiConverterMapStringArrayString.allocationSize(inner.votes);
          size += FfiConverterOptionalUInt64.allocationSize(inner.endTime);
          size += FfiConverterBool.allocationSize(inner.hasBeenEdited);
          return size;
        }
        case TimelineItemContent_Tags.CallInvite: {
          return ordinalConverter.allocationSize(5);
        }
        case TimelineItemContent_Tags.CallNotify: {
          return ordinalConverter.allocationSize(6);
        }
        case TimelineItemContent_Tags.UnableToDecrypt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeEncryptedMessage.allocationSize(inner.msg);
          return size;
        }
        case TimelineItemContent_Tags.RoomMembership: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner.userId);
          size += FfiConverterOptionalString.allocationSize(
            inner.userDisplayName
          );
          size += FfiConverterOptionalTypeMembershipChange.allocationSize(
            inner.change
          );
          size += FfiConverterOptionalString.allocationSize(inner.reason);
          return size;
        }
        case TimelineItemContent_Tags.ProfileChange: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterOptionalString.allocationSize(inner.displayName);
          size += FfiConverterOptionalString.allocationSize(
            inner.prevDisplayName
          );
          size += FfiConverterOptionalString.allocationSize(inner.avatarUrl);
          size += FfiConverterOptionalString.allocationSize(
            inner.prevAvatarUrl
          );
          return size;
        }
        case TimelineItemContent_Tags.State: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner.stateKey);
          size += FfiConverterTypeOtherState.allocationSize(inner.content);
          return size;
        }
        case TimelineItemContent_Tags.FailedToParseMessageLike: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterString.allocationSize(inner.eventType);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case TimelineItemContent_Tags.FailedToParseState: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterString.allocationSize(inner.eventType);
          size += FfiConverterString.allocationSize(inner.stateKey);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum VerificationState {
  Unknown,
  Verified,
  Unverified,
}

const FfiConverterTypeVerificationState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = VerificationState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return VerificationState.Unknown;
        case 2:
          return VerificationState.Verified;
        case 3:
          return VerificationState.Unverified;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case VerificationState.Unknown:
          return ordinalConverter.write(1, into);
        case VerificationState.Verified:
          return ordinalConverter.write(2, into);
        case VerificationState.Unverified:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: VirtualTimelineItem
export enum VirtualTimelineItem_Tags {
  DateDivider = 'DateDivider',
  ReadMarker = 'ReadMarker',
}
/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */
export const VirtualTimelineItem = (() => {
  type DateDivider__interface = {
    tag: VirtualTimelineItem_Tags.DateDivider;
    inner: Readonly<{ ts: /*u64*/ bigint }>;
  };

  /**
   * A divider between messages of different day or month depending on
   * timeline settings.
   */
  class DateDivider_ extends UniffiEnum implements DateDivider__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'VirtualTimelineItem';
    readonly tag = VirtualTimelineItem_Tags.DateDivider;
    readonly inner: Readonly<{ ts: /*u64*/ bigint }>;
    constructor(inner: {
      /**
       * A timestamp in milliseconds since Unix Epoch on that day in local
       * time.
       */ ts: /*u64*/ bigint;
    }) {
      super('VirtualTimelineItem', 'DateDivider');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * A timestamp in milliseconds since Unix Epoch on that day in local
       * time.
       */ ts: /*u64*/ bigint;
    }): DateDivider_ {
      return new DateDivider_(inner);
    }

    static instanceOf(obj: any): obj is DateDivider_ {
      return obj.tag === VirtualTimelineItem_Tags.DateDivider;
    }
  }

  type ReadMarker__interface = {
    tag: VirtualTimelineItem_Tags.ReadMarker;
  };

  /**
   * The user's own read marker.
   */
  class ReadMarker_ extends UniffiEnum implements ReadMarker__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'VirtualTimelineItem';
    readonly tag = VirtualTimelineItem_Tags.ReadMarker;
    constructor() {
      super('VirtualTimelineItem', 'ReadMarker');
    }

    static new(): ReadMarker_ {
      return new ReadMarker_();
    }

    static instanceOf(obj: any): obj is ReadMarker_ {
      return obj.tag === VirtualTimelineItem_Tags.ReadMarker;
    }
  }

  function instanceOf(obj: any): obj is VirtualTimelineItem {
    return obj[uniffiTypeNameSymbol] === 'VirtualTimelineItem';
  }

  return Object.freeze({
    instanceOf,
    DateDivider: DateDivider_,
    ReadMarker: ReadMarker_,
  });
})();

/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */

export type VirtualTimelineItem = InstanceType<
  (typeof VirtualTimelineItem)[keyof Omit<
    typeof VirtualTimelineItem,
    'instanceOf'
  >]
>;

// FfiConverter for enum VirtualTimelineItem
const FfiConverterTypeVirtualTimelineItem = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = VirtualTimelineItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new VirtualTimelineItem.DateDivider({
            ts: FfiConverterUInt64.read(from),
          });
        case 2:
          return new VirtualTimelineItem.ReadMarker();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case VirtualTimelineItem_Tags.DateDivider: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.ts, into);
          return;
        }
        case VirtualTimelineItem_Tags.ReadMarker: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that VirtualTimelineItem_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case VirtualTimelineItem_Tags.DateDivider: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.ts);
          return size;
        }
        case VirtualTimelineItem_Tags.ReadMarker: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: WidgetEventFilter
export enum WidgetEventFilter_Tags {
  MessageLikeWithType = 'MessageLikeWithType',
  RoomMessageWithMsgtype = 'RoomMessageWithMsgtype',
  StateWithType = 'StateWithType',
  StateWithTypeAndStateKey = 'StateWithTypeAndStateKey',
}
/**
 * Different kinds of filters that could be applied to the timeline events.
 */
export const WidgetEventFilter = (() => {
  type MessageLikeWithType__interface = {
    tag: WidgetEventFilter_Tags.MessageLikeWithType;
    inner: Readonly<{ eventType: string }>;
  };

  /**
   * Matches message-like events with the given `type`.
   */
  class MessageLikeWithType_
    extends UniffiEnum
    implements MessageLikeWithType__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WidgetEventFilter';
    readonly tag = WidgetEventFilter_Tags.MessageLikeWithType;
    readonly inner: Readonly<{ eventType: string }>;
    constructor(inner: { eventType: string }) {
      super('WidgetEventFilter', 'MessageLikeWithType');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: string }): MessageLikeWithType_ {
      return new MessageLikeWithType_(inner);
    }

    static instanceOf(obj: any): obj is MessageLikeWithType_ {
      return obj.tag === WidgetEventFilter_Tags.MessageLikeWithType;
    }
  }

  type RoomMessageWithMsgtype__interface = {
    tag: WidgetEventFilter_Tags.RoomMessageWithMsgtype;
    inner: Readonly<{ msgtype: string }>;
  };

  /**
   * Matches `m.room.message` events with the given `msgtype`.
   */
  class RoomMessageWithMsgtype_
    extends UniffiEnum
    implements RoomMessageWithMsgtype__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WidgetEventFilter';
    readonly tag = WidgetEventFilter_Tags.RoomMessageWithMsgtype;
    readonly inner: Readonly<{ msgtype: string }>;
    constructor(inner: { msgtype: string }) {
      super('WidgetEventFilter', 'RoomMessageWithMsgtype');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msgtype: string }): RoomMessageWithMsgtype_ {
      return new RoomMessageWithMsgtype_(inner);
    }

    static instanceOf(obj: any): obj is RoomMessageWithMsgtype_ {
      return obj.tag === WidgetEventFilter_Tags.RoomMessageWithMsgtype;
    }
  }

  type StateWithType__interface = {
    tag: WidgetEventFilter_Tags.StateWithType;
    inner: Readonly<{ eventType: string }>;
  };

  /**
   * Matches state events with the given `type`, regardless of `state_key`.
   */
  class StateWithType_ extends UniffiEnum implements StateWithType__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WidgetEventFilter';
    readonly tag = WidgetEventFilter_Tags.StateWithType;
    readonly inner: Readonly<{ eventType: string }>;
    constructor(inner: { eventType: string }) {
      super('WidgetEventFilter', 'StateWithType');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: string }): StateWithType_ {
      return new StateWithType_(inner);
    }

    static instanceOf(obj: any): obj is StateWithType_ {
      return obj.tag === WidgetEventFilter_Tags.StateWithType;
    }
  }

  type StateWithTypeAndStateKey__interface = {
    tag: WidgetEventFilter_Tags.StateWithTypeAndStateKey;
    inner: Readonly<{ eventType: string; stateKey: string }>;
  };

  /**
   * Matches state events with the given `type` and `state_key`.
   */
  class StateWithTypeAndStateKey_
    extends UniffiEnum
    implements StateWithTypeAndStateKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WidgetEventFilter';
    readonly tag = WidgetEventFilter_Tags.StateWithTypeAndStateKey;
    readonly inner: Readonly<{ eventType: string; stateKey: string }>;
    constructor(inner: { eventType: string; stateKey: string }) {
      super('WidgetEventFilter', 'StateWithTypeAndStateKey');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventType: string;
      stateKey: string;
    }): StateWithTypeAndStateKey_ {
      return new StateWithTypeAndStateKey_(inner);
    }

    static instanceOf(obj: any): obj is StateWithTypeAndStateKey_ {
      return obj.tag === WidgetEventFilter_Tags.StateWithTypeAndStateKey;
    }
  }

  function instanceOf(obj: any): obj is WidgetEventFilter {
    return obj[uniffiTypeNameSymbol] === 'WidgetEventFilter';
  }

  return Object.freeze({
    instanceOf,
    MessageLikeWithType: MessageLikeWithType_,
    RoomMessageWithMsgtype: RoomMessageWithMsgtype_,
    StateWithType: StateWithType_,
    StateWithTypeAndStateKey: StateWithTypeAndStateKey_,
  });
})();

/**
 * Different kinds of filters that could be applied to the timeline events.
 */

export type WidgetEventFilter = InstanceType<
  (typeof WidgetEventFilter)[keyof Omit<typeof WidgetEventFilter, 'instanceOf'>]
>;

// FfiConverter for enum WidgetEventFilter
const FfiConverterTypeWidgetEventFilter = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = WidgetEventFilter;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new WidgetEventFilter.MessageLikeWithType({
            eventType: FfiConverterString.read(from),
          });
        case 2:
          return new WidgetEventFilter.RoomMessageWithMsgtype({
            msgtype: FfiConverterString.read(from),
          });
        case 3:
          return new WidgetEventFilter.StateWithType({
            eventType: FfiConverterString.read(from),
          });
        case 4:
          return new WidgetEventFilter.StateWithTypeAndStateKey({
            eventType: FfiConverterString.read(from),
            stateKey: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case WidgetEventFilter_Tags.MessageLikeWithType: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        case WidgetEventFilter_Tags.RoomMessageWithMsgtype: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msgtype, into);
          return;
        }
        case WidgetEventFilter_Tags.StateWithType: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        case WidgetEventFilter_Tags.StateWithTypeAndStateKey: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          FfiConverterString.write(inner.stateKey, into);
          return;
        }
        default:
          // Throwing from here means that WidgetEventFilter_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case WidgetEventFilter_Tags.MessageLikeWithType: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        case WidgetEventFilter_Tags.RoomMessageWithMsgtype: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.msgtype);
          return size;
        }
        case WidgetEventFilter_Tags.StateWithType: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        case WidgetEventFilter_Tags.StateWithTypeAndStateKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.eventType);
          size += FfiConverterString.allocationSize(inner.stateKey);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, /*i32*/number>
const FfiConverterMapStringInt32 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterInt32
);

// FfiConverter for Map<string, /*i64*/bigint>
const FfiConverterMapStringInt64 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterInt64
);

// FfiConverter for Map<string, Receipt>
const FfiConverterMapStringTypeReceipt = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeReceipt
);

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

export interface ClientInterface {
  /**
   * Aborts an existing OIDC login operation that might have been cancelled,
   * failed etc.
   */
  abortOidcAuth(
    authorizationData: OidcAuthorizationDataInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Get the content of the event of the given type out of the account data
   * store.
   *
   * It will be returned as a JSON string.
   */
  accountData(
    eventType: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  accountUrl(
    action: AccountManagementAction | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  /**
   * Find all sliding sync versions that are available.
   *
   * Be careful: This method may hit the store and will send new requests for
   * each call. It can be costly to call it repeatedly.
   *
   * If `.well-known` or `/versions` is unreachable, it will simply move
   * potential sliding sync versions aside. No error will be reported.
   */
  availableSlidingSyncVersions(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<SlidingSyncVersion>>;
  /**
   * Sends a request to retrieve the avatar URL. Will fill the cache used by
   * [`Self::cached_avatar_url`] on success.
   */
  avatarUrl(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string | undefined>;
  /**
   * Waits until an at least partially synced room is received, and returns
   * it.
   *
   * **Note: this function will loop endlessly until either it finds the room
   * or an externally set timeout happens.**
   */
  awaitRoomRemoteEcho(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomInterface>;
  /**
   * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
   */
  cachedAvatarUrl() /*throws*/ : string | undefined;
  /**
   * Lets the user know whether this is an `m.login.password` based
   * auth and if the account can actually be deactivated
   */
  canDeactivateAccount(): boolean;
  createRoom(
    request: CreateRoomParameters,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * Creates a new room alias associated with the provided room id.
   */
  createRoomAlias(
    roomAlias: string,
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Login using JWT
   * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
   * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
   */
  customLoginWithJwt(
    jwt: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Deactivate this account definitively.
   * Similarly to `encryption::reset_identity` this
   * will only work with password-based authentication (`m.login.password`)
   *
   * # Arguments
   *
   * * `auth_data` - This request uses the [User-Interactive Authentication
   * API][uiaa]. The first request needs to set this to `None` and will
   * always fail and the same request needs to be made but this time with
   * some `auth_data` provided.
   */
  deactivateAccount(
    authData: AuthData | undefined,
    eraseData: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Deletes a pusher of given pusher ids
   */
  deletePusher(
    identifiers: PusherIdentifiers,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  deviceId() /*throws*/ : string;
  displayName(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string>;
  /**
   * Enables or disables all the room send queues at once.
   *
   * When connectivity is lost on a device, it is recommended to disable the
   * room sending queues.
   *
   * This can be controlled for individual rooms, using
   * [`Room::enable_send_queue`].
   */
  enableAllSendQueues(
    enable: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  encryption(): EncryptionInterface;
  getDmRoom(userId: string) /*throws*/ : RoomInterface | undefined;
  getMediaContent(
    mediaSource: MediaSourceInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ArrayBuffer>;
  getMediaFile(
    mediaSource: MediaSourceInterface,
    filename: string | undefined,
    mimeType: string,
    useCache: boolean,
    tempDir: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<MediaFileHandleInterface>;
  getMediaThumbnail(
    mediaSource: MediaSourceInterface,
    width: /*u64*/ bigint,
    height: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ArrayBuffer>;
  getNotificationSettings(): NotificationSettingsInterface;
  getProfile(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<UserProfile>;
  getRecentlyVisitedRooms(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<string>>;
  /**
   * Given a room alias, get the preview of a room, to interact with it.
   */
  getRoomPreviewFromRoomAlias(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomPreviewInterface>;
  /**
   * Given a room id, get the preview of a room, to interact with it.
   *
   * The list of `via_servers` must be a list of servers that know
   * about the room and can resolve it, and that may appear as a `via`
   * parameter in e.g. a permalink URL. This list can be empty.
   */
  getRoomPreviewFromRoomId(
    roomId: string,
    viaServers: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomPreviewInterface>;
  getSessionVerificationController(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<SessionVerificationControllerInterface>;
  /**
   * Allows generic GET requests to be made through the SDKs internal HTTP
   * client
   */
  getUrl(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * The homeserver this client is configured to use.
   */
  homeserver(): string;
  /**
   * Information about login options for the client's homeserver.
   */
  homeserverLoginDetails(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<HomeserverLoginDetailsInterface>;
  ignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  ignoredUsers(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<string>>;
  /**
   * Checks if a room alias is not in use yet.
   *
   * Returns:
   * - `Ok(true)` if the room alias is available.
   * - `Ok(false)` if it's not (the resolve alias request returned a `404`
   * status code).
   * - An `Err` otherwise.
   */
  isRoomAliasAvailable(
    alias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Join a room by its ID.
   *
   * Use this method when the homeserver already knows of the given room ID.
   * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
   * server names for the homeserver to find the room.
   */
  joinRoomById(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomInterface>;
  /**
   * Join a room by its ID or alias.
   *
   * When supplying the room's ID, you can also supply a list of server names
   * for the homeserver to find the room. Typically these server names
   * come from a permalink's `via` parameters, or from resolving a room's
   * alias into an ID.
   */
  joinRoomByIdOrAlias(
    roomIdOrAlias: string,
    serverNames: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomInterface>;
  /**
   * Knock on a room to join it using its ID or alias.
   */
  knock(
    roomIdOrAlias: string,
    reason: string | undefined,
    serverNames: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomInterface>;
  /**
   * Login using a username and password.
   */
  login(
    username: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Login using an email and password.
   */
  loginWithEmail(
    email: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Completes the OIDC login process.
   */
  loginWithOidcCallback(
    authorizationData: OidcAuthorizationDataInterface,
    callbackUrl: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Log out the current user. This method returns an optional URL that
   * should be presented to the user to complete logout (in the case of
   * Session having been authenticated using OIDC).
   */
  logout(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string | undefined>;
  notificationClient(
    processSetup: NotificationProcessSetup,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<NotificationClientInterface>;
  removeAvatar(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Empty the server version and unstable features cache.
   *
   * Since the SDK caches server capabilities (versions and unstable
   * features), it's possible to have a stale entry in the cache. This
   * functions makes it possible to force reset it.
   */
  resetServerCapabilities(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Resolves the given room alias to a room ID (and a list of servers), if
   * possible.
   */
  resolveRoomAlias(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ResolvedRoomAlias | undefined>;
  /**
   * Restores the client from a `Session`.
   */
  restoreSession(
    session: Session,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Checks if a room alias exists in the current homeserver.
   */
  roomAliasExists(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  roomDirectorySearch(): RoomDirectorySearchInterface;
  rooms(): Array<RoomInterface>;
  searchUsers(
    searchTerm: string,
    limit: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SearchUsersResults>;
  /**
   * The URL of the server.
   *
   * Not to be confused with the `Self::homeserver`. `server` is usually
   * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
   * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
   * homeserver (at the time of writing — 2024-08-28).
   *
   * This value is optional depending on how the `Client` has been built.
   * If it's been built from a homeserver URL directly, we don't know the
   * server. However, if the `Client` has been built from a server URL or
   * name, then the homeserver has been discovered, and we know both.
   */
  server(): string | undefined;
  session() /*throws*/ : Session;
  /**
   * Set the given account data content for the given event type.
   *
   * It should be supplied as a JSON string.
   */
  setAccountData(
    eventType: string,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  setDelegate(
    delegate: ClientDelegate | undefined
  ): TaskHandleInterface | undefined;
  setDisplayName(
    name: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Registers a pusher with given parameters
   */
  setPusher(
    identifiers: PusherIdentifiers,
    kind: PusherKind,
    appDisplayName: string,
    deviceDisplayName: string,
    profileTag: string | undefined,
    lang: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * The sliding sync version.
   */
  slidingSyncVersion(): SlidingSyncVersion;
  /**
   * Returns a handler to start the SSO login process.
   */
  startSsoLogin(
    redirectUrl: string,
    idpId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SsoHandlerInterface>;
  subscribeToIgnoredUsers(listener: IgnoredUsersListener): TaskHandleInterface;
  /**
   * Subscribe to the global enablement status of the send queue, at the
   * client-wide level.
   *
   * The given listener will be immediately called with the initial value of
   * the enablement status.
   */
  subscribeToSendQueueStatus(
    listener: SendQueueRoomErrorListener
  ): TaskHandleInterface;
  syncService(): SyncServiceBuilderInterface;
  trackRecentlyVisitedRoom(
    room: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  unignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  uploadMedia(
    mimeType: string,
    data: ArrayBuffer,
    progressWatcher: ProgressWatcher | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * Requests the URL needed for opening a web view using OIDC. Once the web
   * view has succeeded, call `login_with_oidc_callback` with the callback it
   * returns. If a failure occurs and a callback isn't available, make sure
   * to call `abort_oidc_auth` to inform the client of this.
   */
  urlForOidc(
    oidcConfiguration: OidcConfiguration,
    prompt: OidcPrompt,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<OidcAuthorizationDataInterface>;
  userId() /*throws*/ : string;
  /**
   * The server name part of the current user ID
   */
  userIdServerName() /*throws*/ : string;
}

export class Client extends UniffiAbstractObject implements ClientInterface {
  readonly [uniffiTypeNameSymbol] = 'Client';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeClientObjectFactory.bless(pointer);
  }

  /**
   * Aborts an existing OIDC login operation that might have been cancelled,
   * failed etc.
   */
  public async abortOidcAuth(
    authorizationData: OidcAuthorizationDataInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeOidcAuthorizationData.lower(authorizationData)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the content of the event of the given type out of the account data
   * store.
   *
   * It will be returned as a JSON string.
   */
  public async accountData(
    eventType: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_account_data(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventType)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async accountUrl(
    action: AccountManagementAction | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_account_url(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeAccountManagementAction.lower(action)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Find all sliding sync versions that are available.
   *
   * Be careful: This method may hit the store and will send new requests for
   * each call. It can be costly to call it repeatedly.
   *
   * If `.well-known` or `/versions` is unreachable, it will simply move
   * potential sliding sync versions aside. No error will be reported.
   */
  public async availableSlidingSyncVersions(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<SlidingSyncVersion>> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeSlidingSyncVersion.lift.bind(
          FfiConverterArrayTypeSlidingSyncVersion
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sends a request to retrieve the avatar URL. Will fill the cache used by
   * [`Self::cached_avatar_url`] on success.
   */
  public async avatarUrl(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Waits until an at least partially synced room is received, and returns
   * it.
   *
   * **Note: this function will loop endlessly until either it finds the room
   * or an externally set timeout happens.**
   */
  public async awaitRoomRemoteEcho(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
   */
  public cachedAvatarUrl(): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Lets the user know whether this is an `m.login.password` based
   * auth and if the account can actually be deactivated
   */
  public canDeactivateAccount(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async createRoom(
    request: CreateRoomParameters,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_create_room(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeCreateRoomParameters.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Creates a new room alias associated with the provided room id.
   */
  public async createRoomAlias(
    roomAlias: string,
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_create_room_alias(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomAlias),
            FfiConverterString.lower(roomId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Login using JWT
   * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
   * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
   */
  public async customLoginWithJwt(
    jwt: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(jwt),
            FfiConverterOptionalString.lower(initialDeviceName),
            FfiConverterOptionalString.lower(deviceId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Deactivate this account definitively.
   * Similarly to `encryption::reset_identity` this
   * will only work with password-based authentication (`m.login.password`)
   *
   * # Arguments
   *
   * * `auth_data` - This request uses the [User-Interactive Authentication
   * API][uiaa]. The first request needs to set this to `None` and will
   * always fail and the same request needs to be made but this time with
   * some `auth_data` provided.
   */
  public async deactivateAccount(
    authData: AuthData | undefined,
    eraseData: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeAuthData.lower(authData),
            FfiConverterBool.lower(eraseData)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Deletes a pusher of given pusher ids
   */
  public async deletePusher(
    identifiers: PusherIdentifiers,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypePusherIdentifiers.lower(identifiers)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public deviceId(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_device_id(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async displayName(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_display_name(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Enables or disables all the room send queues at once.
   *
   * When connectivity is lost on a device, it is recommended to disable the
   * room sending queues.
   *
   * This can be controlled for individual rooms, using
   * [`Room::enable_send_queue`].
   */
  public async enableAllSendQueues(
    enable: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enable)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public encryption(): EncryptionInterface {
    return FfiConverterTypeEncryption.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_encryption(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getDmRoom(userId: string): RoomInterface | undefined /*throws*/ {
    return FfiConverterOptionalTypeRoom.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async getMediaContent(
    mediaSource: MediaSourceInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ArrayBuffer> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMediaSource.lower(mediaSource)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(
          FfiConverterArrayBuffer
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getMediaFile(
    mediaSource: MediaSourceInterface,
    filename: string | undefined,
    mimeType: string,
    useCache: boolean,
    tempDir: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<MediaFileHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMediaSource.lower(mediaSource),
            FfiConverterOptionalString.lower(filename),
            FfiConverterString.lower(mimeType),
            FfiConverterBool.lower(useCache),
            FfiConverterOptionalString.lower(tempDir)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeMediaFileHandle.lift.bind(
          FfiConverterTypeMediaFileHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getMediaThumbnail(
    mediaSource: MediaSourceInterface,
    width: /*u64*/ bigint,
    height: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ArrayBuffer> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMediaSource.lower(mediaSource),
            FfiConverterUInt64.lower(width),
            FfiConverterUInt64.lower(height)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(
          FfiConverterArrayBuffer
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public getNotificationSettings(): NotificationSettingsInterface {
    return FfiConverterTypeNotificationSettings.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async getProfile(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<UserProfile> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_profile(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeUserProfile.lift.bind(
          FfiConverterTypeUserProfile
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getRecentlyVisitedRooms(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<string>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayString.lift.bind(
          FfiConverterArrayString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Given a room alias, get the preview of a room, to interact with it.
   */
  public async getRoomPreviewFromRoomAlias(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomPreviewInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomAlias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomPreview.lift.bind(
          FfiConverterTypeRoomPreview
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Given a room id, get the preview of a room, to interact with it.
   *
   * The list of `via_servers` must be a list of servers that know
   * about the room and can resolve it, and that may appear as a `via`
   * parameter in e.g. a permalink URL. This list can be empty.
   */
  public async getRoomPreviewFromRoomId(
    roomId: string,
    viaServers: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomPreviewInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterArrayString.lower(viaServers)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomPreview.lift.bind(
          FfiConverterTypeRoomPreview
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getSessionVerificationController(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<SessionVerificationControllerInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeSessionVerificationController.lift.bind(
          FfiConverterTypeSessionVerificationController
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Allows generic GET requests to be made through the SDKs internal HTTP
   * client
   */
  public async getUrl(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_url(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The homeserver this client is configured to use.
   */
  public homeserver(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_homeserver(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Information about login options for the client's homeserver.
   */
  public async homeserverLoginDetails(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<HomeserverLoginDetailsInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeHomeserverLoginDetails.lift.bind(
          FfiConverterTypeHomeserverLoginDetails
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async ignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async ignoredUsers(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<string>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayString.lift.bind(
          FfiConverterArrayString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Checks if a room alias is not in use yet.
   *
   * Returns:
   * - `Ok(true)` if the room alias is available.
   * - `Ok(false)` if it's not (the resolve alias request returned a `404`
   * status code).
   * - An `Err` otherwise.
   */
  public async isRoomAliasAvailable(
    alias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(alias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Join a room by its ID.
   *
   * Use this method when the homeserver already knows of the given room ID.
   * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
   * server names for the homeserver to find the room.
   */
  public async joinRoomById(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Join a room by its ID or alias.
   *
   * When supplying the room's ID, you can also supply a list of server names
   * for the homeserver to find the room. Typically these server names
   * come from a permalink's `via` parameters, or from resolving a room's
   * alias into an ID.
   */
  public async joinRoomByIdOrAlias(
    roomIdOrAlias: string,
    serverNames: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomIdOrAlias),
            FfiConverterArrayString.lower(serverNames)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Knock on a room to join it using its ID or alias.
   */
  public async knock(
    roomIdOrAlias: string,
    reason: string | undefined,
    serverNames: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_knock(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomIdOrAlias),
            FfiConverterOptionalString.lower(reason),
            FfiConverterArrayString.lower(serverNames)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Login using a username and password.
   */
  public async login(
    username: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_login(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(username),
            FfiConverterString.lower(password),
            FfiConverterOptionalString.lower(initialDeviceName),
            FfiConverterOptionalString.lower(deviceId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Login using an email and password.
   */
  public async loginWithEmail(
    email: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(email),
            FfiConverterString.lower(password),
            FfiConverterOptionalString.lower(initialDeviceName),
            FfiConverterOptionalString.lower(deviceId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Completes the OIDC login process.
   */
  public async loginWithOidcCallback(
    authorizationData: OidcAuthorizationDataInterface,
    callbackUrl: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeOidcAuthorizationData.lower(authorizationData),
            FfiConverterString.lower(callbackUrl)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeOidcError.lift.bind(
          FfiConverterTypeOidcError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Log out the current user. This method returns an optional URL that
   * should be presented to the user to complete logout (in the case of
   * Session having been authenticated using OIDC).
   */
  public async logout(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_logout(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async notificationClient(
    processSetup: NotificationProcessSetup,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<NotificationClientInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_notification_client(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeNotificationProcessSetup.lower(processSetup)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeNotificationClient.lift.bind(
          FfiConverterTypeNotificationClient
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async removeAvatar(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Empty the server version and unstable features cache.
   *
   * Since the SDK caches server capabilities (versions and unstable
   * features), it's possible to have a stale entry in the cache. This
   * functions makes it possible to force reset it.
   */
  public async resetServerCapabilities(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_reset_server_capabilities(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Resolves the given room alias to a room ID (and a list of servers), if
   * possible.
   */
  public async resolveRoomAlias(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ResolvedRoomAlias | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomAlias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeResolvedRoomAlias.lift.bind(
          FfiConverterOptionalTypeResolvedRoomAlias
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Restores the client from a `Session`.
   */
  public async restoreSession(
    session: Session,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_restore_session(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeSession.lower(session)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Checks if a room alias exists in the current homeserver.
   */
  public async roomAliasExists(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomAlias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public roomDirectorySearch(): RoomDirectorySearchInterface {
    return FfiConverterTypeRoomDirectorySearch.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public rooms(): Array<RoomInterface> {
    return FfiConverterArrayTypeRoom.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_rooms(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async searchUsers(
    searchTerm: string,
    limit: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SearchUsersResults> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_search_users(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(searchTerm),
            FfiConverterUInt64.lower(limit)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSearchUsersResults.lift.bind(
          FfiConverterTypeSearchUsersResults
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The URL of the server.
   *
   * Not to be confused with the `Self::homeserver`. `server` is usually
   * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
   * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
   * homeserver (at the time of writing — 2024-08-28).
   *
   * This value is optional depending on how the `Client` has been built.
   * If it's been built from a homeserver URL directly, we don't know the
   * server. However, if the `Client` has been built from a server URL or
   * name, then the homeserver has been discovered, and we know both.
   */
  public server(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_server(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public session(): Session /*throws*/ {
    return FfiConverterTypeSession.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_session(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the given account data content for the given event type.
   *
   * It should be supplied as a JSON string.
   */
  public async setAccountData(
    eventType: string,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventType),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public setDelegate(
    delegate: ClientDelegate | undefined
  ): TaskHandleInterface | undefined {
    return FfiConverterOptionalTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeClientDelegate.lower(delegate),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async setDisplayName(
    name: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(name)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Registers a pusher with given parameters
   */
  public async setPusher(
    identifiers: PusherIdentifiers,
    kind: PusherKind,
    appDisplayName: string,
    deviceDisplayName: string,
    profileTag: string | undefined,
    lang: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypePusherIdentifiers.lower(identifiers),
            FfiConverterTypePusherKind.lower(kind),
            FfiConverterString.lower(appDisplayName),
            FfiConverterString.lower(deviceDisplayName),
            FfiConverterOptionalString.lower(profileTag),
            FfiConverterString.lower(lang)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The sliding sync version.
   */
  public slidingSyncVersion(): SlidingSyncVersion {
    return FfiConverterTypeSlidingSyncVersion.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns a handler to start the SSO login process.
   */
  public async startSsoLogin(
    redirectUrl: string,
    idpId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SsoHandlerInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(redirectUrl),
            FfiConverterOptionalString.lower(idpId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeSsoHandler.lift.bind(
          FfiConverterTypeSsoHandler
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSsoError.lift.bind(
          FfiConverterTypeSsoError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public subscribeToIgnoredUsers(
    listener: IgnoredUsersListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeIgnoredUsersListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe to the global enablement status of the send queue, at the
   * client-wide level.
   *
   * The given listener will be immediately called with the initial value of
   * the enablement status.
   */
  public subscribeToSendQueueStatus(
    listener: SendQueueRoomErrorListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeSendQueueRoomErrorListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public syncService(): SyncServiceBuilderInterface {
    return FfiConverterTypeSyncServiceBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_sync_service(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async trackRecentlyVisitedRoom(
    room: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(room)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async unignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(mimeType),
            FfiConverterArrayBuffer.lower(data)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async uploadMedia(
    mimeType: string,
    data: ArrayBuffer,
    progressWatcher: ProgressWatcher | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_upload_media(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(mimeType),
            FfiConverterArrayBuffer.lower(data),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Requests the URL needed for opening a web view using OIDC. Once the web
   * view has succeeded, call `login_with_oidc_callback` with the callback it
   * returns. If a failure occurs and a callback isn't available, make sure
   * to call `abort_oidc_auth` to inform the client of this.
   */
  public async urlForOidc(
    oidcConfiguration: OidcConfiguration,
    prompt: OidcPrompt,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<OidcAuthorizationDataInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeOidcConfiguration.lower(oidcConfiguration),
            FfiConverterTypeOidcPrompt.lower(prompt)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeOidcAuthorizationData.lift.bind(
          FfiConverterTypeOidcAuthorizationData
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeOidcError.lift.bind(
          FfiConverterTypeOidcError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public userId(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_user_id(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * The server name part of the current user ID
   */
  public userIdServerName(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeClientObjectFactory.pointer(this);
      uniffiTypeClientObjectFactory.freePointer(pointer);
      uniffiTypeClientObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Client {
    return uniffiTypeClientObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeClientObjectFactory: UniffiObjectFactory<ClientInterface> = {
  create(pointer: UnsafeMutableRawPointer): ClientInterface {
    const instance = Object.create(Client.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Client';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_client_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: ClientInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: ClientInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_client(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_client(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is ClientInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Client';
  },
};
// FfiConverter for ClientInterface
const FfiConverterTypeClient = new FfiConverterObject(
  uniffiTypeClientObjectFactory
);

export interface ClientBuilderInterface {
  addRootCertificates(certificates: Array<ArrayBuffer>): ClientBuilderInterface;
  /**
   * Automatically create a backup version if no backup exists.
   */
  autoEnableBackups(autoEnableBackups: boolean): ClientBuilderInterface;
  autoEnableCrossSigning(
    autoEnableCrossSigning: boolean
  ): ClientBuilderInterface;
  /**
   * Select a strategy to download room keys from the backup. By default
   * we download after a decryption failure.
   *
   * Take a look at the [`BackupDownloadStrategy`] enum for more options.
   */
  backupDownloadStrategy(
    backupDownloadStrategy: BackupDownloadStrategy
  ): ClientBuilderInterface;
  build(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<ClientInterface>;
  /**
   * Finish the building of the client and attempt to log in using the
   * provided [`QrCodeData`].
   *
   * This method will build the client and immediately attempt to log the
   * client in using the provided [`QrCodeData`] using the login
   * mechanism described in [MSC4108]. As such this methods requires OIDC
   * support as well as sliding sync support.
   *
   * The usage of the progress_listener is required to transfer the
   * [`CheckCode`] to the existing client.
   *
   * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
   */
  buildWithQrCode(
    qrCodeData: QrCodeDataInterface,
    oidcConfiguration: OidcConfiguration,
    progressListener: QrLoginProgressListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ClientInterface>;
  crossProcessStoreLocksHolderName(holderName: string): ClientBuilderInterface;
  disableAutomaticTokenRefresh(): ClientBuilderInterface;
  /**
   * Don't trust any system root certificates, only trust the certificates
   * provided through
   * [`add_root_certificates`][ClientBuilder::add_root_certificates].
   */
  disableBuiltInRootCertificates(): ClientBuilderInterface;
  disableSslVerification(): ClientBuilderInterface;
  enableOidcRefreshLock(): ClientBuilderInterface;
  homeserverUrl(url: string): ClientBuilderInterface;
  passphrase(passphrase: string | undefined): ClientBuilderInterface;
  proxy(url: string): ClientBuilderInterface;
  /**
   * Add a default request config to this client.
   */
  requestConfig(config: RequestConfig): ClientBuilderInterface;
  /**
   * Set the trust requirement to be used when decrypting events.
   */
  roomDecryptionTrustRequirement(
    trustRequirement: TrustRequirement
  ): ClientBuilderInterface;
  /**
   * Set the strategy to be used for picking recipient devices when sending
   * an encrypted message.
   */
  roomKeyRecipientStrategy(strategy: CollectStrategy): ClientBuilderInterface;
  serverName(serverName: string): ClientBuilderInterface;
  serverNameOrHomeserverUrl(serverNameOrUrl: string): ClientBuilderInterface;
  /**
   * Sets the paths that the client will use to store its data and caches.
   * Both paths **must** be unique per session as the SDK stores aren't
   * capable of handling multiple users, however it is valid to use the
   * same path for both stores on a single session.
   *
   * Leaving this unset tells the client to use an in-memory data store.
   */
  sessionPaths(dataPath: string, cachePath: string): ClientBuilderInterface;
  setSessionDelegate(
    sessionDelegate: ClientSessionDelegate
  ): ClientBuilderInterface;
  slidingSyncVersionBuilder(
    versionBuilder: SlidingSyncVersionBuilder
  ): ClientBuilderInterface;
  /**
   * Whether to use the event cache persistent storage or not.
   *
   * This is a temporary feature flag, for testing the event cache's
   * persistent storage. Follow new developments in https://github.com/matrix-org/matrix-rust-sdk/issues/3280.
   *
   * This is disabled by default. When disabled, a one-time cleanup is
   * performed when creating the client, and it will clear all the events
   * previously stored in the event cache.
   *
   * When enabled, it will attempt to store events in the event cache as
   * they're received, and reuse them when reconstructing timelines.
   */
  useEventCachePersistentStorage(value: boolean): ClientBuilderInterface;
  userAgent(userAgent: string): ClientBuilderInterface;
  username(username: string): ClientBuilderInterface;
}

export class ClientBuilder
  extends UniffiAbstractObject
  implements ClientBuilderInterface
{
  readonly [uniffiTypeNameSymbol] = 'ClientBuilder';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeClientBuilderObjectFactory.bless(pointer);
  }

  public addRootCertificates(
    certificates: Array<ArrayBuffer>
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterArrayArrayBuffer.lower(certificates),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Automatically create a backup version if no backup exists.
   */
  public autoEnableBackups(autoEnableBackups: boolean): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterBool.lower(autoEnableBackups),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public autoEnableCrossSigning(
    autoEnableCrossSigning: boolean
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterBool.lower(autoEnableCrossSigning),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Select a strategy to download room keys from the backup. By default
   * we download after a decryption failure.
   *
   * Take a look at the [`BackupDownloadStrategy`] enum for more options.
   */
  public backupDownloadStrategy(
    backupDownloadStrategy: BackupDownloadStrategy
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeBackupDownloadStrategy.lower(
              backupDownloadStrategy
            ),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async build(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<ClientInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeClient.lift.bind(FfiConverterTypeClient),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientBuildError.lift.bind(
          FfiConverterTypeClientBuildError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Finish the building of the client and attempt to log in using the
   * provided [`QrCodeData`].
   *
   * This method will build the client and immediately attempt to log the
   * client in using the provided [`QrCodeData`] using the login
   * mechanism described in [MSC4108]. As such this methods requires OIDC
   * support as well as sliding sync support.
   *
   * The usage of the progress_listener is required to transfer the
   * [`CheckCode`] to the existing client.
   *
   * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
   */
  public async buildWithQrCode(
    qrCodeData: QrCodeDataInterface,
    oidcConfiguration: OidcConfiguration,
    progressListener: QrLoginProgressListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ClientInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build_with_qr_code(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeQrCodeData.lower(qrCodeData),
            FfiConverterTypeOidcConfiguration.lower(oidcConfiguration),
            FfiConverterTypeQrLoginProgressListener.lower(progressListener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeClient.lift.bind(FfiConverterTypeClient),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeHumanQrLoginError.lift.bind(
          FfiConverterTypeHumanQrLoginError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public crossProcessStoreLocksHolderName(
    holderName: string
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(holderName),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public disableAutomaticTokenRefresh(): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Don't trust any system root certificates, only trust the certificates
   * provided through
   * [`add_root_certificates`][ClientBuilder::add_root_certificates].
   */
  public disableBuiltInRootCertificates(): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public disableSslVerification(): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public enableOidcRefreshLock(): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public homeserverUrl(url: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public passphrase(passphrase: string | undefined): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_passphrase(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(passphrase),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public proxy(url: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add a default request config to this client.
   */
  public requestConfig(config: RequestConfig): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeRequestConfig.lower(config),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the trust requirement to be used when decrypting events.
   */
  public roomDecryptionTrustRequirement(
    trustRequirement: TrustRequirement
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_decryption_trust_requirement(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeTrustRequirement.lower(trustRequirement),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the strategy to be used for picking recipient devices when sending
   * an encrypted message.
   */
  public roomKeyRecipientStrategy(
    strategy: CollectStrategy
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeCollectStrategy.lower(strategy),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public serverName(serverName: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(serverName),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public serverNameOrHomeserverUrl(
    serverNameOrUrl: string
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(serverNameOrUrl),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Sets the paths that the client will use to store its data and caches.
   * Both paths **must** be unique per session as the SDK stores aren't
   * capable of handling multiple users, however it is valid to use the
   * same path for both stores on a single session.
   *
   * Leaving this unset tells the client to use an in-memory data store.
   */
  public sessionPaths(
    dataPath: string,
    cachePath: string
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_paths(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(dataPath),
            FfiConverterString.lower(cachePath),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setSessionDelegate(
    sessionDelegate: ClientSessionDelegate
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeClientSessionDelegate.lower(sessionDelegate),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public slidingSyncVersionBuilder(
    versionBuilder: SlidingSyncVersionBuilder
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeSlidingSyncVersionBuilder.lower(versionBuilder),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether to use the event cache persistent storage or not.
   *
   * This is a temporary feature flag, for testing the event cache's
   * persistent storage. Follow new developments in https://github.com/matrix-org/matrix-rust-sdk/issues/3280.
   *
   * This is disabled by default. When disabled, a one-time cleanup is
   * performed when creating the client, and it will clear all the events
   * previously stored in the event cache.
   *
   * When enabled, it will attempt to store events in the event cache as
   * they're received, and reuse them when reconstructing timelines.
   */
  public useEventCachePersistentStorage(
    value: boolean
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_use_event_cache_persistent_storage(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterBool.lower(value),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public userAgent(userAgent: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(userAgent),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public username(username: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(username),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeClientBuilderObjectFactory.pointer(this);
      uniffiTypeClientBuilderObjectFactory.freePointer(pointer);
      uniffiTypeClientBuilderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ClientBuilder {
    return uniffiTypeClientBuilderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeClientBuilderObjectFactory: UniffiObjectFactory<ClientBuilderInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ClientBuilderInterface {
      const instance = Object.create(ClientBuilder.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ClientBuilder';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_clientbuilder_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ClientBuilderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ClientBuilderInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_clientbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ClientBuilderInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ClientBuilder'
      );
    },
  };
// FfiConverter for ClientBuilderInterface
const FfiConverterTypeClientBuilder = new FfiConverterObject(
  uniffiTypeClientBuilderObjectFactory
);

export interface EncryptionInterface {
  /**
   * Does a backup exist on the server?
   *
   * Because the homeserver doesn't notify us about changes to the backup
   * version, the [`BackupState`] and its listener are a bit crippled.
   * The `BackupState::Unknown` state might mean there is no backup at all or
   * a backup exists but we don't have access to it.
   *
   * Therefore it is necessary to poll the server for an answer every time
   * you want to differentiate between those two states.
   */
  backupExistsOnServer(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  backupState(): BackupState;
  backupStateListener(listener: BackupStateListener): TaskHandleInterface;
  /**
   * Get the public curve25519 key of our own device in base64. This is
   * usually what is called the identity key of the device.
   */
  curve25519Key(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined>;
  disableRecovery(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Get the public ed25519 key of our own device. This is usually what is
   * called the fingerprint of the device.
   */
  ed25519Key(asyncOpts_?: { signal: AbortSignal }): Promise<string | undefined>;
  enableBackups(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  enableRecovery(
    waitForBackupsToUpload: boolean,
    passphrase: string | undefined,
    progressListener: EnableRecoveryProgressListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  isLastDevice(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  recover(
    recoveryKey: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  recoverAndReset(
    oldRecoveryKey: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  recoveryState(): RecoveryState;
  recoveryStateListener(listener: RecoveryStateListener): TaskHandleInterface;
  /**
   * Completely reset the current user's crypto identity: reset the cross
   * signing keys, delete the existing backup and recovery key.
   */
  resetIdentity(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<IdentityResetHandleInterface | undefined>;
  resetRecoveryKey(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string>;
  /**
   * Get the E2EE identity of a user.
   *
   * This method always tries to fetch the identity from the store, which we
   * only have if the user is tracked, meaning that we are both members
   * of the same encrypted room. If no user is found locally, a request will
   * be made to the homeserver.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user that the identity belongs to.
   *
   * Returns a `UserIdentity` if one is found. Returns an error if there
   * was an issue with the crypto store or with the request to the
   * homeserver.
   *
   * This will always return `None` if the client hasn't been logged in.
   */
  userIdentity(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<UserIdentityInterface | undefined>;
  verificationState(): VerificationState;
  verificationStateListener(
    listener: VerificationStateListener
  ): TaskHandleInterface;
  waitForBackupUploadSteadyState(
    progressListener: BackupSteadyStateListener | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Waits for end-to-end encryption initialization tasks to finish, if any
   * was running in the background.
   */
  waitForE2eeInitializationTasks(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void>;
}

export class Encryption
  extends UniffiAbstractObject
  implements EncryptionInterface
{
  readonly [uniffiTypeNameSymbol] = 'Encryption';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeEncryptionObjectFactory.bless(pointer);
  }

  /**
   * Does a backup exist on the server?
   *
   * Because the homeserver doesn't notify us about changes to the backup
   * version, the [`BackupState`] and its listener are a bit crippled.
   * The `BackupState::Unknown` state might mean there is no backup at all or
   * a backup exists but we don't have access to it.
   *
   * Therefore it is necessary to poll the server for an answer every time
   * you want to differentiate between those two states.
   */
  public async backupExistsOnServer(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public backupState(): BackupState {
    return FfiConverterTypeBackupState.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public backupStateListener(
    listener: BackupStateListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterTypeBackupStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the public curve25519 key of our own device in base64. This is
   * usually what is called the identity key of the device.
   */
  public async curve25519Key(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async disableRecovery(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the public ed25519 key of our own device. This is usually what is
   * called the fingerprint of the device.
   */
  public async ed25519Key(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async enableBackups(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async enableRecovery(
    waitForBackupsToUpload: boolean,
    passphrase: string | undefined,
    progressListener: EnableRecoveryProgressListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterBool.lower(waitForBackupsToUpload),
            FfiConverterOptionalString.lower(passphrase),
            FfiConverterTypeEnableRecoveryProgressListener.lower(
              progressListener
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async isLastDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async recover(
    recoveryKey: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recover(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterString.lower(recoveryKey)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async recoverAndReset(
    oldRecoveryKey: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterString.lower(oldRecoveryKey)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public recoveryState(): RecoveryState {
    return FfiConverterTypeRecoveryState.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public recoveryStateListener(
    listener: RecoveryStateListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterTypeRecoveryStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Completely reset the current user's crypto identity: reset the cross
   * signing keys, delete the existing backup and recovery key.
   */
  public async resetIdentity(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<IdentityResetHandleInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeIdentityResetHandle.lift.bind(
          FfiConverterOptionalTypeIdentityResetHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async resetRecoveryKey(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the E2EE identity of a user.
   *
   * This method always tries to fetch the identity from the store, which we
   * only have if the user is tracked, meaning that we are both members
   * of the same encrypted room. If no user is found locally, a request will
   * be made to the homeserver.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user that the identity belongs to.
   *
   * Returns a `UserIdentity` if one is found. Returns an error if there
   * was an issue with the crypto store or with the request to the
   * homeserver.
   *
   * This will always return `None` if the client hasn't been logged in.
   */
  public async userIdentity(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<UserIdentityInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeUserIdentity.lift.bind(
          FfiConverterOptionalTypeUserIdentity
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public verificationState(): VerificationState {
    return FfiConverterTypeVerificationState.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public verificationStateListener(
    listener: VerificationStateListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterTypeVerificationStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async waitForBackupUploadSteadyState(
    progressListener: BackupSteadyStateListener | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeBackupSteadyStateListener.lower(
              progressListener
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSteadyStateError.lift.bind(
          FfiConverterTypeSteadyStateError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Waits for end-to-end encryption initialization tasks to finish, if any
   * was running in the background.
   */
  public async waitForE2eeInitializationTasks(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeEncryptionObjectFactory.pointer(this);
      uniffiTypeEncryptionObjectFactory.freePointer(pointer);
      uniffiTypeEncryptionObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Encryption {
    return uniffiTypeEncryptionObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeEncryptionObjectFactory: UniffiObjectFactory<EncryptionInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): EncryptionInterface {
      const instance = Object.create(Encryption.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Encryption';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_encryption_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: EncryptionInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: EncryptionInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_encryption(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_encryption(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is EncryptionInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Encryption'
      );
    },
  };
// FfiConverter for EncryptionInterface
const FfiConverterTypeEncryption = new FfiConverterObject(
  uniffiTypeEncryptionObjectFactory
);

export interface HomeserverLoginDetailsInterface {
  /**
   * The sliding sync version.
   */
  slidingSyncVersion(): SlidingSyncVersion;
  /**
   * The prompts advertised by the authentication issuer for use in the login
   * URL.
   */
  supportedOidcPrompts(): Array<OidcPrompt>;
  /**
   * Whether the current homeserver supports login using OIDC.
   */
  supportsOidcLogin(): boolean;
  /**
   * Whether the current homeserver supports the password login flow.
   */
  supportsPasswordLogin(): boolean;
  /**
   * The URL of the currently configured homeserver.
   */
  url(): string;
}

export class HomeserverLoginDetails
  extends UniffiAbstractObject
  implements HomeserverLoginDetailsInterface
{
  readonly [uniffiTypeNameSymbol] = 'HomeserverLoginDetails';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeHomeserverLoginDetailsObjectFactory.bless(pointer);
  }

  /**
   * The sliding sync version.
   */
  public slidingSyncVersion(): SlidingSyncVersion {
    return FfiConverterTypeSlidingSyncVersion.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * The prompts advertised by the authentication issuer for use in the login
   * URL.
   */
  public supportedOidcPrompts(): Array<OidcPrompt> {
    return FfiConverterArrayTypeOidcPrompt.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the current homeserver supports login using OIDC.
   */
  public supportsOidcLogin(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the current homeserver supports the password login flow.
   */
  public supportsPasswordLogin(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * The URL of the currently configured homeserver.
   */
  public url(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeHomeserverLoginDetailsObjectFactory.pointer(this);
      uniffiTypeHomeserverLoginDetailsObjectFactory.freePointer(pointer);
      uniffiTypeHomeserverLoginDetailsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is HomeserverLoginDetails {
    return uniffiTypeHomeserverLoginDetailsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeHomeserverLoginDetailsObjectFactory: UniffiObjectFactory<HomeserverLoginDetailsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): HomeserverLoginDetailsInterface {
      const instance = Object.create(HomeserverLoginDetails.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'HomeserverLoginDetails';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_homeserverlogindetails_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: HomeserverLoginDetailsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: HomeserverLoginDetailsInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is HomeserverLoginDetailsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'HomeserverLoginDetails'
      );
    },
  };
// FfiConverter for HomeserverLoginDetailsInterface
const FfiConverterTypeHomeserverLoginDetails = new FfiConverterObject(
  uniffiTypeHomeserverLoginDetailsObjectFactory
);

export interface IdentityResetHandleInterface {
  /**
   * Get the underlying [`CrossSigningResetAuthType`] this identity reset
   * process is using.
   */
  authType(): CrossSigningResetAuthType;
  cancel(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * This method starts the identity reset process and
   * will go through the following steps:
   *
   * 1. Disable backing up room keys and delete the active backup
   * 2. Disable recovery and delete secret storage
   * 3. Go through the cross-signing key reset flow
   * 4. Finally, re-enable key backups only if they were enabled before
   */
  reset(
    auth: AuthData | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class IdentityResetHandle
  extends UniffiAbstractObject
  implements IdentityResetHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'IdentityResetHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeIdentityResetHandleObjectFactory.bless(pointer);
  }

  /**
   * Get the underlying [`CrossSigningResetAuthType`] this identity reset
   * process is using.
   */
  public authType(): CrossSigningResetAuthType {
    return FfiConverterTypeCrossSigningResetAuthType.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(
            uniffiTypeIdentityResetHandleObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async cancel(asyncOpts_?: { signal: AbortSignal }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(
            uniffiTypeIdentityResetHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * This method starts the identity reset process and
   * will go through the following steps:
   *
   * 1. Disable backing up room keys and delete the active backup
   * 2. Disable recovery and delete secret storage
   * 3. Go through the cross-signing key reset flow
   * 4. Finally, re-enable key backups only if they were enabled before
   */
  public async reset(
    auth: AuthData | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(
            uniffiTypeIdentityResetHandleObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeAuthData.lower(auth)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeIdentityResetHandleObjectFactory.pointer(this);
      uniffiTypeIdentityResetHandleObjectFactory.freePointer(pointer);
      uniffiTypeIdentityResetHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is IdentityResetHandle {
    return uniffiTypeIdentityResetHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeIdentityResetHandleObjectFactory: UniffiObjectFactory<IdentityResetHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): IdentityResetHandleInterface {
      const instance = Object.create(IdentityResetHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'IdentityResetHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_identityresethandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: IdentityResetHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: IdentityResetHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_identityresethandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is IdentityResetHandleInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'IdentityResetHandle'
      );
    },
  };
// FfiConverter for IdentityResetHandleInterface
const FfiConverterTypeIdentityResetHandle = new FfiConverterObject(
  uniffiTypeIdentityResetHandleObjectFactory
);

export interface InReplyToDetailsInterface {
  event(): RepliedToEventDetails;
  eventId(): string;
}

export class InReplyToDetails
  extends UniffiAbstractObject
  implements InReplyToDetailsInterface
{
  readonly [uniffiTypeNameSymbol] = 'InReplyToDetails';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeInReplyToDetailsObjectFactory.bless(pointer);
  }

  public event(): RepliedToEventDetails {
    return FfiConverterTypeRepliedToEventDetails.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(
            uniffiTypeInReplyToDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public eventId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(
            uniffiTypeInReplyToDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeInReplyToDetailsObjectFactory.pointer(this);
      uniffiTypeInReplyToDetailsObjectFactory.freePointer(pointer);
      uniffiTypeInReplyToDetailsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is InReplyToDetails {
    return uniffiTypeInReplyToDetailsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeInReplyToDetailsObjectFactory: UniffiObjectFactory<InReplyToDetailsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): InReplyToDetailsInterface {
      const instance = Object.create(InReplyToDetails.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'InReplyToDetails';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_inreplytodetails_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: InReplyToDetailsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: InReplyToDetailsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is InReplyToDetailsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'InReplyToDetails'
      );
    },
  };
// FfiConverter for InReplyToDetailsInterface
const FfiConverterTypeInReplyToDetails = new FfiConverterObject(
  uniffiTypeInReplyToDetailsObjectFactory
);

/**
 * A set of actions to perform for a knock request.
 */
export interface KnockRequestActionsInterface {
  /**
   * Accepts the knock request by inviting the user to the room.
   */
  accept(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Declines the knock request by kicking the user from the room with an
   * optional reason.
   */
  decline(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Declines the knock request by banning the user from the room with an
   * optional reason.
   */
  declineAndBan(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Marks the knock request as 'seen'.
   *
   * **IMPORTANT**: this won't update the current reference to this request,
   * a new one with the updated value should be emitted instead.
   */
  markAsSeen(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

/**
 * A set of actions to perform for a knock request.
 */
export class KnockRequestActions
  extends UniffiAbstractObject
  implements KnockRequestActionsInterface
{
  readonly [uniffiTypeNameSymbol] = 'KnockRequestActions';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeKnockRequestActionsObjectFactory.bless(pointer);
  }

  /**
   * Accepts the knock request by inviting the user to the room.
   */
  public async accept(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(
            uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Declines the knock request by kicking the user from the room with an
   * optional reason.
   */
  public async decline(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(
            uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Declines the knock request by banning the user from the room with an
   * optional reason.
   */
  public async declineAndBan(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(
            uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Marks the knock request as 'seen'.
   *
   * **IMPORTANT**: this won't update the current reference to this request,
   * a new one with the updated value should be emitted instead.
   */
  public async markAsSeen(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(
            uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeKnockRequestActionsObjectFactory.pointer(this);
      uniffiTypeKnockRequestActionsObjectFactory.freePointer(pointer);
      uniffiTypeKnockRequestActionsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is KnockRequestActions {
    return uniffiTypeKnockRequestActionsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeKnockRequestActionsObjectFactory: UniffiObjectFactory<KnockRequestActionsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): KnockRequestActionsInterface {
      const instance = Object.create(KnockRequestActions.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'KnockRequestActions';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_knockrequestactions_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: KnockRequestActionsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: KnockRequestActionsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is KnockRequestActionsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'KnockRequestActions'
      );
    },
  };
// FfiConverter for KnockRequestActionsInterface
const FfiConverterTypeKnockRequestActions = new FfiConverterObject(
  uniffiTypeKnockRequestActionsObjectFactory
);

/**
 * Wrapper to retrieve some timeline item info lazily.
 */
export interface LazyTimelineItemProviderInterface {
  /**
   * Returns some debug information for this event timeline item.
   */
  debugInfo(): EventTimelineItemDebugInfo;
  /**
   * For local echoes, return the associated send handle; returns `None` for
   * remote echoes.
   */
  getSendHandle(): SendHandleInterface | undefined;
  /**
   * Returns the shields for this event timeline item.
   */
  getShields(strict: boolean): ShieldState | undefined;
}

/**
 * Wrapper to retrieve some timeline item info lazily.
 */
export class LazyTimelineItemProvider
  extends UniffiAbstractObject
  implements LazyTimelineItemProviderInterface
{
  readonly [uniffiTypeNameSymbol] = 'LazyTimelineItemProvider';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLazyTimelineItemProviderObjectFactory.bless(pointer);
  }

  /**
   * Returns some debug information for this event timeline item.
   */
  public debugInfo(): EventTimelineItemDebugInfo {
    return FfiConverterTypeEventTimelineItemDebugInfo.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(
            uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * For local echoes, return the associated send handle; returns `None` for
   * remote echoes.
   */
  public getSendHandle(): SendHandleInterface | undefined {
    return FfiConverterOptionalTypeSendHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(
            uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns the shields for this event timeline item.
   */
  public getShields(strict: boolean): ShieldState | undefined {
    return FfiConverterOptionalTypeShieldState.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(
            uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this),
            FfiConverterBool.lower(strict),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeLazyTimelineItemProviderObjectFactory.pointer(this);
      uniffiTypeLazyTimelineItemProviderObjectFactory.freePointer(pointer);
      uniffiTypeLazyTimelineItemProviderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LazyTimelineItemProvider {
    return uniffiTypeLazyTimelineItemProviderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLazyTimelineItemProviderObjectFactory: UniffiObjectFactory<LazyTimelineItemProviderInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): LazyTimelineItemProviderInterface {
      const instance = Object.create(LazyTimelineItemProvider.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LazyTimelineItemProvider';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_lazytimelineitemprovider_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LazyTimelineItemProviderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: LazyTimelineItemProviderInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LazyTimelineItemProviderInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'LazyTimelineItemProvider'
      );
    },
  };
// FfiConverter for LazyTimelineItemProviderInterface
const FfiConverterTypeLazyTimelineItemProvider = new FfiConverterObject(
  uniffiTypeLazyTimelineItemProviderObjectFactory
);

/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
export interface MediaFileHandleInterface {
  /**
   * Get the media file's path.
   */
  path() /*throws*/ : string;
  persist(path: string) /*throws*/ : boolean;
}

/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
export class MediaFileHandle
  extends UniffiAbstractObject
  implements MediaFileHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'MediaFileHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeMediaFileHandleObjectFactory.bless(pointer);
  }

  /**
   * Get the media file's path.
   */
  public path(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(
            uniffiTypeMediaFileHandleObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public persist(path: string): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(
            uniffiTypeMediaFileHandleObjectFactory.clonePointer(this),
            FfiConverterString.lower(path),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeMediaFileHandleObjectFactory.pointer(this);
      uniffiTypeMediaFileHandleObjectFactory.freePointer(pointer);
      uniffiTypeMediaFileHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is MediaFileHandle {
    return uniffiTypeMediaFileHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeMediaFileHandleObjectFactory: UniffiObjectFactory<MediaFileHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): MediaFileHandleInterface {
      const instance = Object.create(MediaFileHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'MediaFileHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_mediafilehandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: MediaFileHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: MediaFileHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is MediaFileHandleInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'MediaFileHandle'
      );
    },
  };
// FfiConverter for MediaFileHandleInterface
const FfiConverterTypeMediaFileHandle = new FfiConverterObject(
  uniffiTypeMediaFileHandleObjectFactory
);

export interface MediaSourceInterface {
  toJson(): string;
  url(): string;
}

export class MediaSource
  extends UniffiAbstractObject
  implements MediaSourceInterface
{
  readonly [uniffiTypeNameSymbol] = 'MediaSource';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeMediaSourceObjectFactory.bless(pointer);
  }

  public static fromJson(json: string): MediaSourceInterface /*throws*/ {
    return FfiConverterTypeMediaSource.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromUrl(url: string): MediaSourceInterface /*throws*/ {
    return FfiConverterTypeMediaSource.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(
            FfiConverterString.lower(url),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toJson(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(
            uniffiTypeMediaSourceObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public url(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediasource_url(
            uniffiTypeMediaSourceObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeMediaSourceObjectFactory.pointer(this);
      uniffiTypeMediaSourceObjectFactory.freePointer(pointer);
      uniffiTypeMediaSourceObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is MediaSource {
    return uniffiTypeMediaSourceObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeMediaSourceObjectFactory: UniffiObjectFactory<MediaSourceInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): MediaSourceInterface {
      const instance = Object.create(MediaSource.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'MediaSource';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_mediasource_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: MediaSourceInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: MediaSourceInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_mediasource(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_mediasource(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is MediaSourceInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'MediaSource'
      );
    },
  };
// FfiConverter for MediaSourceInterface
const FfiConverterTypeMediaSource = new FfiConverterObject(
  uniffiTypeMediaSourceObjectFactory
);

export interface NotificationClientInterface {
  /**
   * See also documentation of
   * `MatrixNotificationClient::get_notification`.
   */
  getNotification(
    roomId: string,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<NotificationItem | undefined>;
}

export class NotificationClient
  extends UniffiAbstractObject
  implements NotificationClientInterface
{
  readonly [uniffiTypeNameSymbol] = 'NotificationClient';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNotificationClientObjectFactory.bless(pointer);
  }

  /**
   * See also documentation of
   * `MatrixNotificationClient::get_notification`.
   */
  public async getNotification(
    roomId: string,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<NotificationItem | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(
            uniffiTypeNotificationClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeNotificationItem.lift.bind(
          FfiConverterOptionalTypeNotificationItem
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNotificationClientObjectFactory.pointer(this);
      uniffiTypeNotificationClientObjectFactory.freePointer(pointer);
      uniffiTypeNotificationClientObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NotificationClient {
    return uniffiTypeNotificationClientObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNotificationClientObjectFactory: UniffiObjectFactory<NotificationClientInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NotificationClientInterface {
      const instance = Object.create(NotificationClient.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NotificationClient';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_notificationclient_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NotificationClientInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NotificationClientInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_notificationclient(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_notificationclient(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NotificationClientInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NotificationClient'
      );
    },
  };
// FfiConverter for NotificationClientInterface
const FfiConverterTypeNotificationClient = new FfiConverterObject(
  uniffiTypeNotificationClientObjectFactory
);

export interface NotificationSettingsInterface {
  /**
   * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  canHomeserverPushEncryptedEventToDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean>;
  /**
   * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  canPushEncryptedEventToDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean>;
  /**
   * Get whether some enabled keyword rules exist.
   */
  containsKeywordsRules(asyncOpts_?: { signal: AbortSignal }): Promise<boolean>;
  /**
   * Get the default room notification mode
   *
   * The mode will depend on the associated `PushRule` based on whether the
   * room is encrypted or not, and on the number of members.
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chats involving two
   * people
   */
  getDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomNotificationMode>;
  /**
   * Get the notification settings for a room.
   *
   * # Arguments
   *
   * * `room_id` - the room ID
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  getRoomNotificationSettings(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomNotificationSettings>;
  /**
   * Get all room IDs for which a user-defined rule exists.
   */
  getRoomsWithUserDefinedRules(
    enabled: boolean | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<string>>;
  /**
   * Get the user defined room notification mode
   */
  getUserDefinedRoomNotificationMode(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomNotificationMode | undefined>;
  /**
   * Get whether the `.m.rule.call` push rule is enabled
   */
  isCallEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Get whether the `.m.rule.invite_for_me` push rule is enabled
   */
  isInviteForMeEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Get whether room mentions are enabled.
   */
  isRoomMentionEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Get whether user mentions are enabled.
   */
  isUserMentionEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Restore the default notification mode for a room
   */
  restoreDefaultRoomNotificationMode(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set whether the `.m.rule.call` push rule is enabled
   */
  setCallEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set the default room notification mode
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the mode is for encrypted rooms
   * * `is_one_to_one` - whether the mode is for direct chats involving two
   * people
   * * `mode` - the new default mode
   */
  setDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    mode: RoomNotificationMode,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  setDelegate(delegate: NotificationSettingsDelegate | undefined): void;
  /**
   * Set whether the `.m.rule.invite_for_me` push rule is enabled
   */
  setInviteForMeEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set whether room mentions are enabled.
   */
  setRoomMentionEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set the notification mode for a room.
   */
  setRoomNotificationMode(
    roomId: string,
    mode: RoomNotificationMode,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set whether user mentions are enabled.
   */
  setUserMentionEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Unmute a room.
   *
   * # Arguments
   *
   * * `room_id` - the room to unmute
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  unmuteRoom(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class NotificationSettings
  extends UniffiAbstractObject
  implements NotificationSettingsInterface
{
  readonly [uniffiTypeNameSymbol] = 'NotificationSettings';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNotificationSettingsObjectFactory.bless(pointer);
  }

  /**
   * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  public async canHomeserverPushEncryptedEventToDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  public async canPushEncryptedEventToDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether some enabled keyword rules exist.
   */
  public async containsKeywordsRules(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the default room notification mode
   *
   * The mode will depend on the associated `PushRule` based on whether the
   * room is encrypted or not, and on the number of members.
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chats involving two
   * people
   */
  public async getDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomNotificationMode> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isEncrypted),
            FfiConverterBool.lower(isOneToOne)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomNotificationMode.lift.bind(
          FfiConverterTypeRoomNotificationMode
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the notification settings for a room.
   *
   * # Arguments
   *
   * * `room_id` - the room ID
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  public async getRoomNotificationSettings(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomNotificationSettings> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterBool.lower(isEncrypted),
            FfiConverterBool.lower(isOneToOne)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomNotificationSettings.lift.bind(
          FfiConverterTypeRoomNotificationSettings
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get all room IDs for which a user-defined rule exists.
   */
  public async getRoomsWithUserDefinedRules(
    enabled: boolean | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<string>> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterOptionalBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayString.lift.bind(
          FfiConverterArrayString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the user defined room notification mode
   */
  public async getUserDefinedRoomNotificationMode(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomNotificationMode | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeRoomNotificationMode.lift.bind(
          FfiConverterOptionalTypeRoomNotificationMode
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether the `.m.rule.call` push rule is enabled
   */
  public async isCallEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether the `.m.rule.invite_for_me` push rule is enabled
   */
  public async isInviteForMeEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether room mentions are enabled.
   */
  public async isRoomMentionEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether user mentions are enabled.
   */
  public async isUserMentionEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Restore the default notification mode for a room
   */
  public async restoreDefaultRoomNotificationMode(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set whether the `.m.rule.call` push rule is enabled
   */
  public async setCallEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set the default room notification mode
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the mode is for encrypted rooms
   * * `is_one_to_one` - whether the mode is for direct chats involving two
   * people
   * * `mode` - the new default mode
   */
  public async setDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    mode: RoomNotificationMode,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isEncrypted),
            FfiConverterBool.lower(isOneToOne),
            FfiConverterTypeRoomNotificationMode.lower(mode)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public setDelegate(delegate: NotificationSettingsDelegate | undefined): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(
          uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
          FfiConverterOptionalTypeNotificationSettingsDelegate.lower(delegate),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set whether the `.m.rule.invite_for_me` push rule is enabled
   */
  public async setInviteForMeEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set whether room mentions are enabled.
   */
  public async setRoomMentionEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set the notification mode for a room.
   */
  public async setRoomNotificationMode(
    roomId: string,
    mode: RoomNotificationMode,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterTypeRoomNotificationMode.lower(mode)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set whether user mentions are enabled.
   */
  public async setUserMentionEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Unmute a room.
   *
   * # Arguments
   *
   * * `room_id` - the room to unmute
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  public async unmuteRoom(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterBool.lower(isEncrypted),
            FfiConverterBool.lower(isOneToOne)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNotificationSettingsObjectFactory.pointer(this);
      uniffiTypeNotificationSettingsObjectFactory.freePointer(pointer);
      uniffiTypeNotificationSettingsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NotificationSettings {
    return uniffiTypeNotificationSettingsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNotificationSettingsObjectFactory: UniffiObjectFactory<NotificationSettingsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NotificationSettingsInterface {
      const instance = Object.create(NotificationSettings.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NotificationSettings';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_notificationsettings_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NotificationSettingsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NotificationSettingsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_notificationsettings(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NotificationSettingsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NotificationSettings'
      );
    },
  };
// FfiConverter for NotificationSettingsInterface
const FfiConverterTypeNotificationSettings = new FfiConverterObject(
  uniffiTypeNotificationSettingsObjectFactory
);

/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
export interface QrCodeDataInterface {}

/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
export class QrCodeData
  extends UniffiAbstractObject
  implements QrCodeDataInterface
{
  readonly [uniffiTypeNameSymbol] = 'QrCodeData';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeQrCodeDataObjectFactory.bless(pointer);
  }

  /**
   * Attempt to decode a slice of bytes into a [`QrCodeData`] object.
   *
   * The slice of bytes would generally be returned by a QR code decoder.
   */
  public static fromBytes(bytes: ArrayBuffer): QrCodeDataInterface /*throws*/ {
    return FfiConverterTypeQrCodeData.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeQrCodeDecodeError.lift.bind(
          FfiConverterTypeQrCodeDecodeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(
            FfiConverterArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeQrCodeDataObjectFactory.pointer(this);
      uniffiTypeQrCodeDataObjectFactory.freePointer(pointer);
      uniffiTypeQrCodeDataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is QrCodeData {
    return uniffiTypeQrCodeDataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeQrCodeDataObjectFactory: UniffiObjectFactory<QrCodeDataInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): QrCodeDataInterface {
      const instance = Object.create(QrCodeData.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'QrCodeData';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_qrcodedata_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: QrCodeDataInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: QrCodeDataInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_qrcodedata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is QrCodeDataInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'QrCodeData'
      );
    },
  };
// FfiConverter for QrCodeDataInterface
const FfiConverterTypeQrCodeData = new FfiConverterObject(
  uniffiTypeQrCodeDataObjectFactory
);

export interface RoomInterface {
  activeMembersCount(): /*u64*/ bigint;
  /**
   * Returns a Vec of userId's that participate in the room call.
   *
   * MatrixRTC memberships with application "m.call" and scope "m.room" are
   * considered. A user can occur twice if they join with two devices.
   * convert to a set depending if the different users are required or the
   * amount of sessions.
   *
   * The vector is ordered by oldest membership user to newest.
   */
  activeRoomCallParticipants(): Array<string>;
  alternativeAliases(): Array<string>;
  applyPowerLevelChanges(
    changes: RoomPowerLevelChanges,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  avatarUrl(): string | undefined;
  banUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  canUserBan(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserInvite(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserKick(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserPinUnpin(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserRedactOther(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserRedactOwn(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserSendMessage(
    userId: string,
    message: MessageLikeEventType,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserSendState(
    userId: string,
    stateEvent: StateEventType,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserTriggerRoomNotification(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canonicalAlias(): string | undefined;
  /**
   * Remove the `ComposerDraft` stored in the state store for this room.
   */
  clearComposerDraft(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Clear the event cache storage for the current room.
   *
   * This will remove all the information related to the event cache, in
   * memory and in the persisted storage, if enabled.
   */
  clearEventCacheStorage(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Forces the currently active room key, which is used to encrypt messages,
   * to be rotated.
   *
   * A new room key will be crated and shared with all the room members the
   * next time a message will be sent. You don't have to call this method,
   * room keys will be rotated automatically when necessary. This method is
   * still useful for debugging purposes.
   */
  discardRoomKey(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  displayName(): string | undefined;
  /**
   * Edit an event given its event id.
   *
   * Useful outside the context of a timeline, or when a timeline doesn't
   * have the full content of an event.
   */
  edit(
    eventId: string,
    newContent: RoomMessageEventContentWithoutRelationInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Enable or disable the send queue for that particular room.
   */
  enableSendQueue(enable: boolean): void;
  getPowerLevels(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomPowerLevels>;
  /**
   * Is there a non expired membership with application "m.call" and scope
   * "m.room" in this room.
   */
  hasActiveRoomCall(): boolean;
  /**
   * Returns the room heroes for this room.
   */
  heroes(): Array<RoomHero>;
  id(): string;
  /**
   * Set the local trust for the given devices to `LocalTrust::Ignored`
   * and resend messages that failed to send because said devices are
   * unverified (in response to
   * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
   * # Arguments
   *
   * * `devices` - The map of users identifiers to device identifiers
   * received in the error
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo the send error applies to
   */
  ignoreDeviceTrustAndResend(
    devices: Map<string, Array<string>>,
    sendHandle: SendHandleInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Ignores a user.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user to ignore.
   */
  ignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  inviteUserById(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  invitedMembersCount(): /*u64*/ bigint;
  /**
   * For rooms one is invited to, retrieves the room member information for
   * the user who invited the logged-in user to a room.
   */
  inviter(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMember | undefined>;
  isDirect(): boolean;
  isEncrypted() /*throws*/ : boolean;
  isPublic(): boolean;
  /**
   * Returns whether the send queue for that particular room is enabled or
   * not.
   */
  isSendQueueEnabled(): boolean;
  isSpace(): boolean;
  isTombstoned(): boolean;
  /**
   * Join this room.
   *
   * Only invited and left rooms can be joined via this method.
   */
  join(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  joinedMembersCount(): /*u64*/ bigint;
  kickUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Leave this room.
   *
   * Only invited and joined rooms can be left.
   */
  leave(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Retrieve the `ComposerDraft` stored in the state store for this room.
   */
  loadComposerDraft(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<ComposerDraft | undefined>;
  /**
   * Mark a room as read, by attaching a read receipt on the latest event.
   *
   * Note: this does NOT unset the unread flag; it's the caller's
   * responsibility to do so, if needs be.
   */
  markAsRead(
    receiptType: ReceiptType,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  matrixToEventPermalink(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  matrixToPermalink(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string>;
  member(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomMember>;
  memberAvatarUrl(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  memberDisplayName(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  members(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomMembersIteratorInterface>;
  membersNoSync(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomMembersIteratorInterface>;
  membership(): Membership;
  /**
   * A timeline instance that can be configured to only include RoomMessage
   * type events and filter those further based on their message type.
   *
   * Virtual timeline items will still be provided and the
   * `default_event_filter` will be applied before everything else.
   *
   * # Arguments
   *
   * * `internal_id_prefix` - An optional String that will be prepended to
   * all the timeline item's internal IDs, making it possible to
   * distinguish different timeline instances from each other.
   *
   * * `allowed_message_types` - A list of `RoomMessageEventMessageType` that
   * will be allowed to appear in the timeline
   */
  messageFilteredTimeline(
    internalIdPrefix: string | undefined,
    allowedMessageTypes: Array<RoomMessageEventMessageType>,
    dateDividerMode: DateDividerMode,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TimelineInterface>;
  ownUserId(): string;
  pinnedEventsTimeline(
    internalIdPrefix: string | undefined,
    maxEventsToLoad: /*u16*/ number,
    maxConcurrentRequests: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TimelineInterface>;
  /**
   * The raw name as present in the room state event.
   */
  rawName(): string | undefined;
  /**
   * Redacts an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to redact
   *
   * * `reason` - The reason for the event being redacted (optional). its
   * transaction ID (optional). If not given one is created.
   */
  redact(
    eventId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Removes the current room avatar
   */
  removeAvatar(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Reports an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to report
   *
   * * `reason` - The reason for the event being reported (optional).
   *
   * * `score` - The score to rate this content as where -100 is most
   * offensive and 0 is inoffensive (optional).
   */
  reportContent(
    eventId: string,
    score: /*i32*/ number | undefined,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  resetPowerLevels(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomPowerLevels>;
  /**
   * Return a debug representation for the internal room events data
   * structure, one line per entry in the resulting vector.
   */
  roomEventsDebugString(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<string>>;
  roomInfo(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<RoomInfo>;
  /**
   * Store the given `ComposerDraft` in the state store using the current
   * room id, as identifier.
   */
  saveComposerDraft(
    draft: ComposerDraft,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Send a call notification event in the current room.
   *
   * This is only supposed to be used in **custom** situations where the user
   * explicitly chooses to send a `m.call.notify` event to invite/notify
   * someone explicitly in unusual conditions. The default should be to
   * use `send_call_notification_if_necessary` just before a new room call is
   * created/joined.
   *
   * One example could be that the UI allows to start a call with a subset of
   * users of the room members first. And then later on the user can
   * invite more users to the call.
   */
  sendCallNotification(
    callId: string,
    application: RtcApplicationType,
    notifyType: NotifyType,
    mentions: Mentions,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * This will only send a call notification event if appropriate.
   *
   * This function is supposed to be called whenever the user creates a room
   * call. It will send a `m.call.notify` event if:
   * - there is not yet a running call.
   *
   * It will configure the notify type: ring or notify based on:
   * - is this a DM room -> ring
   * - is this a group with more than one other member -> notify
   */
  sendCallNotificationIfNeeded(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Send a raw event to the room.
   *
   * # Arguments
   *
   * * `event_type` - The type of the event to send.
   *
   * * `content` - The content of the event to send encoded as JSON string.
   */
  sendRaw(
    eventType: string,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  setIsFavourite(
    isFavourite: boolean,
    tagOrder: /*f64*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  setIsLowPriority(
    isLowPriority: boolean,
    tagOrder: /*f64*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Sets a new name to the room.
   */
  setName(
    name: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Sets a new topic in the room.
   */
  setTopic(
    topic: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set (or unset) a flag on the room to indicate that the user has
   * explicitly marked it as unread.
   */
  setUnreadFlag(
    newValue: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  subscribeToIdentityStatusChanges(
    listener: IdentityStatusChangeListener
  ): TaskHandleInterface;
  /**
   * Subscribes to requests to join this room (knock member events), using a
   * `listener` to be notified of the changes.
   *
   * The current requests to join the room will be emitted immediately
   * when subscribing, along with a [`TaskHandle`] to cancel the
   * subscription.
   */
  subscribeToKnockRequests(
    listener: KnockRequestsListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TaskHandleInterface>;
  subscribeToRoomInfoUpdates(listener: RoomInfoListener): TaskHandleInterface;
  subscribeToTypingNotifications(
    listener: TypingNotificationsListener
  ): TaskHandleInterface;
  suggestedRoleForUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomMemberRole>;
  timeline(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<TimelineInterface>;
  /**
   * Returns a timeline focused on the given event.
   *
   * Note: this timeline is independent from that returned with
   * [`Self::timeline`], and as such it is not cached.
   */
  timelineFocusedOnEvent(
    eventId: string,
    numContextEvents: /*u16*/ number,
    internalIdPrefix: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TimelineInterface>;
  topic(): string | undefined;
  typingNotice(
    isTyping: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  unbanUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  updatePowerLevelsForUsers(
    updates: Array<UserPowerLevelUpdate>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Upload and set the room's avatar.
   *
   * This will upload the data produced by the reader to the homeserver's
   * content repository, and set the room's avatar to the MXC URI for the
   * uploaded file.
   *
   * # Arguments
   *
   * * `mime_type` - The mime description of the avatar, for example
   * image/jpeg
   * * `data` - The raw data that will be uploaded to the homeserver's
   * content repository
   * * `media_info` - The media info used as avatar image info.
   */
  uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    mediaInfo: ImageInfo | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Remove verification requirements for the given users and
   * resend messages that failed to send because their identities were no
   * longer verified (in response to
   * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
   *
   * # Arguments
   *
   * * `user_ids` - The list of users identifiers received in the error
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo the send error applies to
   */
  withdrawVerificationAndResend(
    userIds: Array<string>,
    sendHandle: SendHandleInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class Room extends UniffiAbstractObject implements RoomInterface {
  readonly [uniffiTypeNameSymbol] = 'Room';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeRoomObjectFactory.bless(pointer);
  }

  public activeMembersCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns a Vec of userId's that participate in the room call.
   *
   * MatrixRTC memberships with application "m.call" and scope "m.room" are
   * considered. A user can occur twice if they join with two devices.
   * convert to a set depending if the different users are required or the
   * amount of sessions.
   *
   * The vector is ordered by oldest membership user to newest.
   */
  public activeRoomCallParticipants(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public alternativeAliases(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async applyPowerLevelChanges(
    changes: RoomPowerLevelChanges,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeRoomPowerLevelChanges.lower(changes)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public avatarUrl(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async banUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_ban_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserBan(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_ban(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserInvite(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_invite(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserKick(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_kick(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserPinUnpin(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_pin_unpin(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserRedactOther(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_other(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserRedactOwn(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_own(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserSendMessage(
    userId: string,
    message: MessageLikeEventType,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_message(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterTypeMessageLikeEventType.lower(message)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserSendState(
    userId: string,
    stateEvent: StateEventType,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_state(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterTypeStateEventType.lower(stateEvent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserTriggerRoomNotification(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_trigger_room_notification(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public canonicalAlias(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Remove the `ComposerDraft` stored in the state store for this room.
   */
  public async clearComposerDraft(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Clear the event cache storage for the current room.
   *
   * This will remove all the information related to the event cache, in
   * memory and in the persisted storage, if enabled.
   */
  public async clearEventCacheStorage(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Forces the currently active room key, which is used to encrypt messages,
   * to be rotated.
   *
   * A new room key will be crated and shared with all the room members the
   * next time a message will be sent. You don't have to call this method,
   * room keys will be rotated automatically when necessary. This method is
   * still useful for debugging purposes.
   */
  public async discardRoomKey(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  public displayName(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_display_name(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Edit an event given its event id.
   *
   * Useful outside the context of a timeline, or when a timeline doesn't
   * have the full content of an event.
   */
  public async edit(
    eventId: string,
    newContent: RoomMessageEventContentWithoutRelationInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_edit(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId),
            FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(
              newContent
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Enable or disable the send queue for that particular room.
   */
  public enableSendQueue(enable: boolean): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(
          uniffiTypeRoomObjectFactory.clonePointer(this),
          FfiConverterBool.lower(enable),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public async getPowerLevels(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomPowerLevels> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomPowerLevels.lift.bind(
          FfiConverterTypeRoomPowerLevels
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Is there a non expired membership with application "m.call" and scope
   * "m.room" in this room.
   */
  public hasActiveRoomCall(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns the room heroes for this room.
   */
  public heroes(): Array<RoomHero> {
    return FfiConverterArrayTypeRoomHero.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_heroes(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public id(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_id(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the local trust for the given devices to `LocalTrust::Ignored`
   * and resend messages that failed to send because said devices are
   * unverified (in response to
   * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
   * # Arguments
   *
   * * `devices` - The map of users identifiers to device identifiers
   * received in the error
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo the send error applies to
   */
  public async ignoreDeviceTrustAndResend(
    devices: Map<string, Array<string>>,
    sendHandle: SendHandleInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterMapStringArrayString.lower(devices),
            FfiConverterTypeSendHandle.lower(sendHandle)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Ignores a user.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user to ignore.
   */
  public async ignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async inviteUserById(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public invitedMembersCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * For rooms one is invited to, retrieves the room member information for
   * the user who invited the logged-in user to a room.
   */
  public async inviter(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMember | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_inviter(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeRoomMember.lift.bind(
          FfiConverterOptionalTypeRoomMember
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public isDirect(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_direct(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isEncrypted(): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isPublic(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_public(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns whether the send queue for that particular room is enabled or
   * not.
   */
  public isSendQueueEnabled(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isSpace(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_space(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isTombstoned(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_tombstoned(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Join this room.
   *
   * Only invited and left rooms can be joined via this method.
   */
  public async join(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_join(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public joinedMembersCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async kickUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_kick_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Leave this room.
   *
   * Only invited and joined rooms can be left.
   */
  public async leave(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_leave(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Retrieve the `ComposerDraft` stored in the state store for this room.
   */
  public async loadComposerDraft(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<ComposerDraft | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeComposerDraft.lift.bind(
          FfiConverterOptionalTypeComposerDraft
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Mark a room as read, by attaching a read receipt on the latest event.
   *
   * Note: this does NOT unset the unread flag; it's the caller's
   * responsibility to do so, if needs be.
   */
  public async markAsRead(
    receiptType: ReceiptType,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeReceiptType.lower(receiptType)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async matrixToEventPermalink(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async matrixToPermalink(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async member(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomMember> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomMember.lift.bind(
          FfiConverterTypeRoomMember
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async memberAvatarUrl(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async memberDisplayName(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async members(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMembersIteratorInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_members(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomMembersIterator.lift.bind(
          FfiConverterTypeRoomMembersIterator
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async membersNoSync(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMembersIteratorInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomMembersIterator.lift.bind(
          FfiConverterTypeRoomMembersIterator
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public membership(): Membership {
    return FfiConverterTypeMembership.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_membership(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * A timeline instance that can be configured to only include RoomMessage
   * type events and filter those further based on their message type.
   *
   * Virtual timeline items will still be provided and the
   * `default_event_filter` will be applied before everything else.
   *
   * # Arguments
   *
   * * `internal_id_prefix` - An optional String that will be prepended to
   * all the timeline item's internal IDs, making it possible to
   * distinguish different timeline instances from each other.
   *
   * * `allowed_message_types` - A list of `RoomMessageEventMessageType` that
   * will be allowed to appear in the timeline
   */
  public async messageFilteredTimeline(
    internalIdPrefix: string | undefined,
    allowedMessageTypes: Array<RoomMessageEventMessageType>,
    dateDividerMode: DateDividerMode,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TimelineInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_message_filtered_timeline(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(internalIdPrefix),
            FfiConverterArrayTypeRoomMessageEventMessageType.lower(
              allowedMessageTypes
            ),
            FfiConverterTypeDateDividerMode.lower(dateDividerMode)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTimeline.lift.bind(
          FfiConverterTypeTimeline
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public ownUserId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async pinnedEventsTimeline(
    internalIdPrefix: string | undefined,
    maxEventsToLoad: /*u16*/ number,
    maxConcurrentRequests: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TimelineInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_pinned_events_timeline(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(internalIdPrefix),
            FfiConverterUInt16.lower(maxEventsToLoad),
            FfiConverterUInt16.lower(maxConcurrentRequests)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTimeline.lift.bind(
          FfiConverterTypeTimeline
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The raw name as present in the room state event.
   */
  public rawName(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_raw_name(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Redacts an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to redact
   *
   * * `reason` - The reason for the event being redacted (optional). its
   * transaction ID (optional). If not given one is created.
   */
  public async redact(
    eventId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_redact(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Removes the current room avatar
   */
  public async removeAvatar(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Reports an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to report
   *
   * * `reason` - The reason for the event being reported (optional).
   *
   * * `score` - The score to rate this content as where -100 is most
   * offensive and 0 is inoffensive (optional).
   */
  public async reportContent(
    eventId: string,
    score: /*i32*/ number | undefined,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_report_content(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId),
            FfiConverterOptionalInt32.lower(score),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async resetPowerLevels(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomPowerLevels> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomPowerLevels.lift.bind(
          FfiConverterTypeRoomPowerLevels
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Return a debug representation for the internal room events data
   * structure, one line per entry in the resulting vector.
   */
  public async roomEventsDebugString(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<string>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayString.lift.bind(
          FfiConverterArrayString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async roomInfo(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_room_info(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomInfo.lift.bind(
          FfiConverterTypeRoomInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Store the given `ComposerDraft` in the state store using the current
   * room id, as identifier.
   */
  public async saveComposerDraft(
    draft: ComposerDraft,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeComposerDraft.lower(draft)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send a call notification event in the current room.
   *
   * This is only supposed to be used in **custom** situations where the user
   * explicitly chooses to send a `m.call.notify` event to invite/notify
   * someone explicitly in unusual conditions. The default should be to
   * use `send_call_notification_if_necessary` just before a new room call is
   * created/joined.
   *
   * One example could be that the UI allows to start a call with a subset of
   * users of the room members first. And then later on the user can
   * invite more users to the call.
   */
  public async sendCallNotification(
    callId: string,
    application: RtcApplicationType,
    notifyType: NotifyType,
    mentions: Mentions,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(callId),
            FfiConverterTypeRtcApplicationType.lower(application),
            FfiConverterTypeNotifyType.lower(notifyType),
            FfiConverterTypeMentions.lower(mentions)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * This will only send a call notification event if appropriate.
   *
   * This function is supposed to be called whenever the user creates a room
   * call. It will send a `m.call.notify` event if:
   * - there is not yet a running call.
   *
   * It will configure the notify type: ring or notify based on:
   * - is this a DM room -> ring
   * - is this a group with more than one other member -> notify
   */
  public async sendCallNotificationIfNeeded(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification_if_needed(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send a raw event to the room.
   *
   * # Arguments
   *
   * * `event_type` - The type of the event to send.
   *
   * * `content` - The content of the event to send encoded as JSON string.
   */
  public async sendRaw(
    eventType: string,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_send_raw(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventType),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async setIsFavourite(
    isFavourite: boolean,
    tagOrder: /*f64*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isFavourite),
            FfiConverterOptionalFloat64.lower(tagOrder)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async setIsLowPriority(
    isLowPriority: boolean,
    tagOrder: /*f64*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isLowPriority),
            FfiConverterOptionalFloat64.lower(tagOrder)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets a new name to the room.
   */
  public async setName(
    name: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_name(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(name)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets a new topic in the room.
   */
  public async setTopic(
    topic: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_topic(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(topic)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set (or unset) a flag on the room to indicate that the user has
   * explicitly marked it as unread.
   */
  public async setUnreadFlag(
    newValue: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterBool.lower(newValue)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public subscribeToIdentityStatusChanges(
    listener: IdentityStatusChangeListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeIdentityStatusChangeListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribes to requests to join this room (knock member events), using a
   * `listener` to be notified of the changes.
   *
   * The current requests to join the room will be emitted immediately
   * when subscribing, along with a [`TaskHandle`] to cancel the
   * subscription.
   */
  public async subscribeToKnockRequests(
    listener: KnockRequestsListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeKnockRequestsListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public subscribeToRoomInfoUpdates(
    listener: RoomInfoListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeRoomInfoListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public subscribeToTypingNotifications(
    listener: TypingNotificationsListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeTypingNotificationsListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async suggestedRoleForUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomMemberRole> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomMemberRole.lift.bind(
          FfiConverterTypeRoomMemberRole
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async timeline(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<TimelineInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_timeline(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTimeline.lift.bind(
          FfiConverterTypeTimeline
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns a timeline focused on the given event.
   *
   * Note: this timeline is independent from that returned with
   * [`Self::timeline`], and as such it is not cached.
   */
  public async timelineFocusedOnEvent(
    eventId: string,
    numContextEvents: /*u16*/ number,
    internalIdPrefix: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TimelineInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_timeline_focused_on_event(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId),
            FfiConverterUInt16.lower(numContextEvents),
            FfiConverterOptionalString.lower(internalIdPrefix)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTimeline.lift.bind(
          FfiConverterTypeTimeline
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeFocusEventError.lift.bind(
          FfiConverterTypeFocusEventError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public topic(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_topic(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async typingNotice(
    isTyping: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isTyping)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async unbanUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_unban_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async updatePowerLevelsForUsers(
    updates: Array<UserPowerLevelUpdate>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterArrayTypeUserPowerLevelUpdate.lower(updates)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Upload and set the room's avatar.
   *
   * This will upload the data produced by the reader to the homeserver's
   * content repository, and set the room's avatar to the MXC URI for the
   * uploaded file.
   *
   * # Arguments
   *
   * * `mime_type` - The mime description of the avatar, for example
   * image/jpeg
   * * `data` - The raw data that will be uploaded to the homeserver's
   * content repository
   * * `media_info` - The media info used as avatar image info.
   */
  public async uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    mediaInfo: ImageInfo | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(mimeType),
            FfiConverterArrayBuffer.lower(data),
            FfiConverterOptionalTypeImageInfo.lower(mediaInfo)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Remove verification requirements for the given users and
   * resend messages that failed to send because their identities were no
   * longer verified (in response to
   * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
   *
   * # Arguments
   *
   * * `user_ids` - The list of users identifiers received in the error
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo the send error applies to
   */
  public async withdrawVerificationAndResend(
    userIds: Array<string>,
    sendHandle: SendHandleInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(userIds),
            FfiConverterTypeSendHandle.lower(sendHandle)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomObjectFactory.pointer(this);
      uniffiTypeRoomObjectFactory.freePointer(pointer);
      uniffiTypeRoomObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Room {
    return uniffiTypeRoomObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomObjectFactory: UniffiObjectFactory<RoomInterface> = {
  create(pointer: UnsafeMutableRawPointer): RoomInterface {
    const instance = Object.create(Room.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Room';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_room_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: RoomInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: RoomInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_room(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_room(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is RoomInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Room';
  },
};
// FfiConverter for RoomInterface
const FfiConverterTypeRoom = new FfiConverterObject(
  uniffiTypeRoomObjectFactory
);

/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
export interface RoomDirectorySearchInterface {
  /**
   * Get whether the search is at the last page.
   */
  isAtLastPage(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Get the number of pages that have been loaded so far.
   */
  loadedPages(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise</*u32*/ number>;
  /**
   * Asks the server for the next page of the current search.
   */
  nextPage(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Registers a callback to receive new search results when starting a
   * search or getting new paginated results.
   */
  results(
    listener: RoomDirectorySearchEntriesListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface>;
  /**
   * Starts a filtered search for the server.
   *
   * If the `filter` is not provided it will search for all the rooms.
   * You can specify a `batch_size` to control the number of rooms to fetch
   * per request.
   *
   * If the `via_server` is not provided it will search in the current
   * homeserver by default.
   *
   * This method will clear the current search results and start a new one.
   */
  search(
    filter: string | undefined,
    batchSize: /*u32*/ number,
    viaServerName: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
export class RoomDirectorySearch
  extends UniffiAbstractObject
  implements RoomDirectorySearchInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearch';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomDirectorySearchObjectFactory.bless(pointer);
  }

  /**
   * Get whether the search is at the last page.
   */
  public async isAtLastPage(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the number of pages that have been loaded so far.
   */
  public async loadedPages(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise</*u32*/ number> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_u32,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_u32,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_u32,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_u32,
        /*liftFunc:*/ FfiConverterUInt32.lift.bind(FfiConverterUInt32),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Asks the server for the next page of the current search.
   */
  public async nextPage(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Registers a callback to receive new search results when starting a
   * search or getting new paginated results.
   */
  public async results(
    listener: RoomDirectorySearchEntriesListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this),
            FfiConverterTypeRoomDirectorySearchEntriesListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Starts a filtered search for the server.
   *
   * If the `filter` is not provided it will search for all the rooms.
   * You can specify a `batch_size` to control the number of rooms to fetch
   * per request.
   *
   * If the `via_server` is not provided it will search in the current
   * homeserver by default.
   *
   * This method will clear the current search results and start a new one.
   */
  public async search(
    filter: string | undefined,
    batchSize: /*u32*/ number,
    viaServerName: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(filter),
            FfiConverterUInt32.lower(batchSize),
            FfiConverterOptionalString.lower(viaServerName)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomDirectorySearchObjectFactory.pointer(this);
      uniffiTypeRoomDirectorySearchObjectFactory.freePointer(pointer);
      uniffiTypeRoomDirectorySearchObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomDirectorySearch {
    return uniffiTypeRoomDirectorySearchObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomDirectorySearchObjectFactory: UniffiObjectFactory<RoomDirectorySearchInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomDirectorySearchInterface {
      const instance = Object.create(RoomDirectorySearch.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomDirectorySearch';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomdirectorysearch_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomDirectorySearchInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomDirectorySearchInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomDirectorySearchInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomDirectorySearch'
      );
    },
  };
// FfiConverter for RoomDirectorySearchInterface
const FfiConverterTypeRoomDirectorySearch = new FfiConverterObject(
  uniffiTypeRoomDirectorySearchObjectFactory
);

export interface RoomListInterface {
  entriesWithDynamicAdapters(
    pageSize: /*u32*/ number,
    listener: RoomListEntriesListener
  ): RoomListEntriesWithDynamicAdaptersResultInterface;
  loadingState(
    listener: RoomListLoadingStateListener
  ) /*throws*/ : RoomListLoadingStateResult;
  room(roomId: string) /*throws*/ : RoomListItemInterface;
}

export class RoomList
  extends UniffiAbstractObject
  implements RoomListInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomList';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomListObjectFactory.bless(pointer);
  }

  public entriesWithDynamicAdapters(
    pageSize: /*u32*/ number,
    listener: RoomListEntriesListener
  ): RoomListEntriesWithDynamicAdaptersResultInterface {
    return FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(
            uniffiTypeRoomListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pageSize),
            FfiConverterTypeRoomListEntriesListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public loadingState(
    listener: RoomListLoadingStateListener
  ): RoomListLoadingStateResult /*throws*/ {
    return FfiConverterTypeRoomListLoadingStateResult.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(
            uniffiTypeRoomListObjectFactory.clonePointer(this),
            FfiConverterTypeRoomListLoadingStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public room(roomId: string): RoomListItemInterface /*throws*/ {
    return FfiConverterTypeRoomListItem.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_room(
            uniffiTypeRoomListObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomListObjectFactory.pointer(this);
      uniffiTypeRoomListObjectFactory.freePointer(pointer);
      uniffiTypeRoomListObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomList {
    return uniffiTypeRoomListObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomListObjectFactory: UniffiObjectFactory<RoomListInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomListInterface {
      const instance = Object.create(RoomList.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomList';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomlist_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomListInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomListInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlist(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlist(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomListInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'RoomList'
      );
    },
  };
// FfiConverter for RoomListInterface
const FfiConverterTypeRoomList = new FfiConverterObject(
  uniffiTypeRoomListObjectFactory
);

export interface RoomListDynamicEntriesControllerInterface {
  addOnePage(): void;
  resetToOnePage(): void;
  setFilter(kind: RoomListEntriesDynamicFilterKind): boolean;
}

export class RoomListDynamicEntriesController
  extends UniffiAbstractObject
  implements RoomListDynamicEntriesControllerInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomListDynamicEntriesController';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomListDynamicEntriesControllerObjectFactory.bless(pointer);
  }

  public addOnePage(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(
          uniffiTypeRoomListDynamicEntriesControllerObjectFactory.clonePointer(
            this
          ),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public resetToOnePage(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(
          uniffiTypeRoomListDynamicEntriesControllerObjectFactory.clonePointer(
            this
          ),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public setFilter(kind: RoomListEntriesDynamicFilterKind): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(
            uniffiTypeRoomListDynamicEntriesControllerObjectFactory.clonePointer(
              this
            ),
            FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(kind),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeRoomListDynamicEntriesControllerObjectFactory.pointer(this);
      uniffiTypeRoomListDynamicEntriesControllerObjectFactory.freePointer(
        pointer
      );
      uniffiTypeRoomListDynamicEntriesControllerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomListDynamicEntriesController {
    return uniffiTypeRoomListDynamicEntriesControllerObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeRoomListDynamicEntriesControllerObjectFactory: UniffiObjectFactory<RoomListDynamicEntriesControllerInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): RoomListDynamicEntriesControllerInterface {
      const instance = Object.create(
        RoomListDynamicEntriesController.prototype
      );
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomListDynamicEntriesController';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomlistdynamicentriescontroller_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(
      obj: RoomListDynamicEntriesControllerInterface
    ): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: RoomListDynamicEntriesControllerInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomListDynamicEntriesControllerInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomListDynamicEntriesController'
      );
    },
  };
// FfiConverter for RoomListDynamicEntriesControllerInterface
const FfiConverterTypeRoomListDynamicEntriesController = new FfiConverterObject(
  uniffiTypeRoomListDynamicEntriesControllerObjectFactory
);

export interface RoomListEntriesWithDynamicAdaptersResultInterface {
  controller(): RoomListDynamicEntriesControllerInterface;
  entriesStream(): TaskHandleInterface;
}

export class RoomListEntriesWithDynamicAdaptersResult
  extends UniffiAbstractObject
  implements RoomListEntriesWithDynamicAdaptersResultInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomListEntriesWithDynamicAdaptersResult';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.bless(
        pointer
      );
  }

  public controller(): RoomListDynamicEntriesControllerInterface {
    return FfiConverterTypeRoomListDynamicEntriesController.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(
            uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.clonePointer(
              this
            ),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public entriesStream(): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(
            uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.clonePointer(
              this
            ),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.pointer(
          this
        );
      uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.freePointer(
        pointer
      );
      uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.unbless(
        ptr
      );
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomListEntriesWithDynamicAdaptersResult {
    return uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory: UniffiObjectFactory<RoomListEntriesWithDynamicAdaptersResultInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): RoomListEntriesWithDynamicAdaptersResultInterface {
      const instance = Object.create(
        RoomListEntriesWithDynamicAdaptersResult.prototype
      );
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] =
        'RoomListEntriesWithDynamicAdaptersResult';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomlistentrieswithdynamicadaptersresult_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(
      obj: RoomListEntriesWithDynamicAdaptersResultInterface
    ): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: RoomListEntriesWithDynamicAdaptersResultInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(
      obj: any
    ): obj is RoomListEntriesWithDynamicAdaptersResultInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomListEntriesWithDynamicAdaptersResult'
      );
    },
  };
// FfiConverter for RoomListEntriesWithDynamicAdaptersResultInterface
const FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult =
  new FfiConverterObject(
    uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory
  );

export interface RoomListItemInterface {
  avatarUrl(): string | undefined;
  canonicalAlias(): string | undefined;
  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  displayName(): string | undefined;
  /**
   * Build a full `Room` FFI object, filling its associated timeline.
   *
   * An error will be returned if the room is a state different than joined
   * or if its internal timeline hasn't been initialized.
   */
  fullRoom() /*throws*/ : RoomInterface;
  id(): string;
  /**
   * Initializes the timeline for this room using the provided parameters.
   *
   * * `event_type_filter` - An optional [`TimelineEventTypeFilter`] to be
   * used to filter timeline events besides the default timeline filter. If
   * `None` is passed, only the default timeline filter will be used.
   * * `internal_id_prefix` - An optional String that will be prepended to
   * all the timeline item's internal IDs, making it possible to
   * distinguish different timeline instances from each other.
   */
  initTimeline(
    eventTypeFilter: TimelineEventTypeFilterInterface | undefined,
    internalIdPrefix: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Builds a `Room` FFI from an invited room without initializing its
   * internal timeline.
   *
   * An error will be returned if the room is a state different than invited.
   *
   * ⚠️ Holding on to this room instance after it has been joined is not
   * safe. Use `full_room` instead.
   */
  invitedRoom() /*throws*/ : RoomInterface;
  isDirect(): boolean;
  /**
   * Checks whether the room is encrypted or not.
   *
   * **Note**: this info may not be reliable if you don't set up
   * `m.room.encryption` as required state.
   */
  isEncrypted(asyncOpts_?: { signal: AbortSignal }): Promise<boolean>;
  /**
   * Checks whether the Room's timeline has been initialized before.
   */
  isTimelineInitialized(): boolean;
  latestEvent(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<EventTimelineItem | undefined>;
  /**
   * The room's current membership state.
   */
  membership(): Membership;
  /**
   * Builds a `RoomPreview` from a room list item. This is intended for
   * invited or knocked rooms.
   *
   * An error will be returned if the room is in a state other than invited
   * or knocked.
   */
  previewRoom(
    via: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomPreviewInterface>;
  roomInfo(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<RoomInfo>;
}

export class RoomListItem
  extends UniffiAbstractObject
  implements RoomListItemInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomListItem';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomListItemObjectFactory.bless(pointer);
  }

  public avatarUrl(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_avatar_url(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public canonicalAlias(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_canonical_alias(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  public displayName(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_display_name(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Build a full `Room` FFI object, filling its associated timeline.
   *
   * An error will be returned if the room is a state different than joined
   * or if its internal timeline hasn't been initialized.
   */
  public fullRoom(): RoomInterface /*throws*/ {
    return FfiConverterTypeRoom.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_full_room(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public id(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_id(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Initializes the timeline for this room using the provided parameters.
   *
   * * `event_type_filter` - An optional [`TimelineEventTypeFilter`] to be
   * used to filter timeline events besides the default timeline filter. If
   * `None` is passed, only the default timeline filter will be used.
   * * `internal_id_prefix` - An optional String that will be prepended to
   * all the timeline item's internal IDs, making it possible to
   * distinguish different timeline instances from each other.
   */
  public async initTimeline(
    eventTypeFilter: TimelineEventTypeFilterInterface | undefined,
    internalIdPrefix: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_init_timeline(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeTimelineEventTypeFilter.lower(
              eventTypeFilter
            ),
            FfiConverterOptionalString.lower(internalIdPrefix)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Builds a `Room` FFI from an invited room without initializing its
   * internal timeline.
   *
   * An error will be returned if the room is a state different than invited.
   *
   * ⚠️ Holding on to this room instance after it has been joined is not
   * safe. Use `full_room` instead.
   */
  public invitedRoom(): RoomInterface /*throws*/ {
    return FfiConverterTypeRoom.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_invited_room(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isDirect(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_direct(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Checks whether the room is encrypted or not.
   *
   * **Note**: this info may not be reliable if you don't set up
   * `m.room.encryption` as required state.
   */
  public async isEncrypted(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_encrypted(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Checks whether the Room's timeline has been initialized before.
   */
  public isTimelineInitialized(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_timeline_initialized(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async latestEvent(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<EventTimelineItem | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_latest_event(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeEventTimelineItem.lift.bind(
          FfiConverterOptionalTypeEventTimelineItem
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The room's current membership state.
   */
  public membership(): Membership {
    return FfiConverterTypeMembership.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_membership(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Builds a `RoomPreview` from a room list item. This is intended for
   * invited or knocked rooms.
   *
   * An error will be returned if the room is in a state other than invited
   * or knocked.
   */
  public async previewRoom(
    via: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomPreviewInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_preview_room(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(via)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomPreview.lift.bind(
          FfiConverterTypeRoomPreview
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async roomInfo(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistitem_room_info(
            uniffiTypeRoomListItemObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomInfo.lift.bind(
          FfiConverterTypeRoomInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomListItemObjectFactory.pointer(this);
      uniffiTypeRoomListItemObjectFactory.freePointer(pointer);
      uniffiTypeRoomListItemObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomListItem {
    return uniffiTypeRoomListItemObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomListItemObjectFactory: UniffiObjectFactory<RoomListItemInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomListItemInterface {
      const instance = Object.create(RoomListItem.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomListItem';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomlistitem_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomListItemInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomListItemInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistitem(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistitem(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomListItemInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomListItem'
      );
    },
  };
// FfiConverter for RoomListItemInterface
const FfiConverterTypeRoomListItem = new FfiConverterObject(
  uniffiTypeRoomListItemObjectFactory
);

export interface RoomListServiceInterface {
  allRooms(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomListInterface>;
  room(roomId: string) /*throws*/ : RoomListItemInterface;
  state(listener: RoomListServiceStateListener): TaskHandleInterface;
  subscribeToRooms(roomIds: Array<string>) /*throws*/ : void;
  syncIndicator(
    delayBeforeShowingInMs: /*u32*/ number,
    delayBeforeHidingInMs: /*u32*/ number,
    listener: RoomListServiceSyncIndicatorListener
  ): TaskHandleInterface;
}

export class RoomListService
  extends UniffiAbstractObject
  implements RoomListServiceInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomListService';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomListServiceObjectFactory.bless(pointer);
  }

  public async allRooms(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomListInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(
            uniffiTypeRoomListServiceObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomList.lift.bind(
          FfiConverterTypeRoomList
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public room(roomId: string): RoomListItemInterface /*throws*/ {
    return FfiConverterTypeRoomListItem.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(
            uniffiTypeRoomListServiceObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public state(listener: RoomListServiceStateListener): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(
            uniffiTypeRoomListServiceObjectFactory.clonePointer(this),
            FfiConverterTypeRoomListServiceStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public subscribeToRooms(roomIds: Array<string>): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
        FfiConverterTypeRoomListError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(
          uniffiTypeRoomListServiceObjectFactory.clonePointer(this),
          FfiConverterArrayString.lower(roomIds),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public syncIndicator(
    delayBeforeShowingInMs: /*u32*/ number,
    delayBeforeHidingInMs: /*u32*/ number,
    listener: RoomListServiceSyncIndicatorListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(
            uniffiTypeRoomListServiceObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(delayBeforeShowingInMs),
            FfiConverterUInt32.lower(delayBeforeHidingInMs),
            FfiConverterTypeRoomListServiceSyncIndicatorListener.lower(
              listener
            ),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomListServiceObjectFactory.pointer(this);
      uniffiTypeRoomListServiceObjectFactory.freePointer(pointer);
      uniffiTypeRoomListServiceObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomListService {
    return uniffiTypeRoomListServiceObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomListServiceObjectFactory: UniffiObjectFactory<RoomListServiceInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomListServiceInterface {
      const instance = Object.create(RoomListService.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomListService';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomlistservice_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomListServiceInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomListServiceInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomListServiceInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomListService'
      );
    },
  };
// FfiConverter for RoomListServiceInterface
const FfiConverterTypeRoomListService = new FfiConverterObject(
  uniffiTypeRoomListServiceObjectFactory
);

export interface RoomMembersIteratorInterface {
  len(): /*u32*/ number;
  nextChunk(chunkSize: /*u32*/ number): Array<RoomMember> | undefined;
}

export class RoomMembersIterator
  extends UniffiAbstractObject
  implements RoomMembersIteratorInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomMembersIterator';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomMembersIteratorObjectFactory.bless(pointer);
  }

  public len(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(
            uniffiTypeRoomMembersIteratorObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public nextChunk(chunkSize: /*u32*/ number): Array<RoomMember> | undefined {
    return FfiConverterOptionalArrayTypeRoomMember.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(
            uniffiTypeRoomMembersIteratorObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(chunkSize),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomMembersIteratorObjectFactory.pointer(this);
      uniffiTypeRoomMembersIteratorObjectFactory.freePointer(pointer);
      uniffiTypeRoomMembersIteratorObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomMembersIterator {
    return uniffiTypeRoomMembersIteratorObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomMembersIteratorObjectFactory: UniffiObjectFactory<RoomMembersIteratorInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomMembersIteratorInterface {
      const instance = Object.create(RoomMembersIterator.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomMembersIterator';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roommembersiterator_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomMembersIteratorInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomMembersIteratorInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomMembersIteratorInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomMembersIterator'
      );
    },
  };
// FfiConverter for RoomMembersIteratorInterface
const FfiConverterTypeRoomMembersIterator = new FfiConverterObject(
  uniffiTypeRoomMembersIteratorObjectFactory
);

export interface RoomMessageEventContentWithoutRelationInterface {
  withMentions(
    mentions: Mentions
  ): RoomMessageEventContentWithoutRelationInterface;
}

export class RoomMessageEventContentWithoutRelation
  extends UniffiAbstractObject
  implements RoomMessageEventContentWithoutRelationInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomMessageEventContentWithoutRelation';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.bless(
        pointer
      );
  }

  public withMentions(
    mentions: Mentions
  ): RoomMessageEventContentWithoutRelationInterface {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(
            uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.clonePointer(
              this
            ),
            FfiConverterTypeMentions.lower(mentions),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.pointer(
          this
        );
      uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.freePointer(
        pointer
      );
      uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.unbless(
        ptr
      );
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomMessageEventContentWithoutRelation {
    return uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory: UniffiObjectFactory<RoomMessageEventContentWithoutRelationInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): RoomMessageEventContentWithoutRelationInterface {
      const instance = Object.create(
        RoomMessageEventContentWithoutRelation.prototype
      );
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomMessageEventContentWithoutRelation';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roommessageeventcontentwithoutrelation_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(
      obj: RoomMessageEventContentWithoutRelationInterface
    ): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: RoomMessageEventContentWithoutRelationInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(
      obj: any
    ): obj is RoomMessageEventContentWithoutRelationInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomMessageEventContentWithoutRelation'
      );
    },
  };
// FfiConverter for RoomMessageEventContentWithoutRelationInterface
const FfiConverterTypeRoomMessageEventContentWithoutRelation =
  new FfiConverterObject(
    uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory
  );

/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
export interface RoomPreviewInterface {
  /**
   * Returns the room info the preview contains.
   */
  info() /*throws*/ : RoomPreviewInfo;
  /**
   * Get the user who created the invite, if any.
   */
  inviter(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMember | undefined>;
  /**
   * Leave the room if the room preview state is either joined, invited or
   * knocked.
   *
   * Will return an error otherwise.
   */
  leave(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
export class RoomPreview
  extends UniffiAbstractObject
  implements RoomPreviewInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomPreview';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomPreviewObjectFactory.bless(pointer);
  }

  /**
   * Returns the room info the preview contains.
   */
  public info(): RoomPreviewInfo /*throws*/ {
    return FfiConverterTypeRoomPreviewInfo.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_info(
            uniffiTypeRoomPreviewObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the user who created the invite, if any.
   */
  public async inviter(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMember | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(
            uniffiTypeRoomPreviewObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeRoomMember.lift.bind(
          FfiConverterOptionalTypeRoomMember
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Leave the room if the room preview state is either joined, invited or
   * knocked.
   *
   * Will return an error otherwise.
   */
  public async leave(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(
            uniffiTypeRoomPreviewObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomPreviewObjectFactory.pointer(this);
      uniffiTypeRoomPreviewObjectFactory.freePointer(pointer);
      uniffiTypeRoomPreviewObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomPreview {
    return uniffiTypeRoomPreviewObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomPreviewObjectFactory: UniffiObjectFactory<RoomPreviewInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomPreviewInterface {
      const instance = Object.create(RoomPreview.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomPreview';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roompreview_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomPreviewInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomPreviewInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roompreview(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roompreview(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomPreviewInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomPreview'
      );
    },
  };
// FfiConverter for RoomPreviewInterface
const FfiConverterTypeRoomPreview = new FfiConverterObject(
  uniffiTypeRoomPreviewObjectFactory
);

export interface SendAttachmentJoinHandleInterface {
  /**
   * Cancel the current sending task.
   *
   * A subsequent call to [`Self::join`] will return immediately.
   */
  cancel(): void;
  /**
   * Wait until the attachment has been sent.
   *
   * If the sending had been cancelled, will return immediately.
   */
  join(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

export class SendAttachmentJoinHandle
  extends UniffiAbstractObject
  implements SendAttachmentJoinHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'SendAttachmentJoinHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSendAttachmentJoinHandleObjectFactory.bless(pointer);
  }

  /**
   * Cancel the current sending task.
   *
   * A subsequent call to [`Self::join`] will return immediately.
   */
  public cancel(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(
          uniffiTypeSendAttachmentJoinHandleObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Wait until the attachment has been sent.
   *
   * If the sending had been cancelled, will return immediately.
   */
  public async join(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(
            uniffiTypeSendAttachmentJoinHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRoomError.lift.bind(
          FfiConverterTypeRoomError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeSendAttachmentJoinHandleObjectFactory.pointer(this);
      uniffiTypeSendAttachmentJoinHandleObjectFactory.freePointer(pointer);
      uniffiTypeSendAttachmentJoinHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SendAttachmentJoinHandle {
    return uniffiTypeSendAttachmentJoinHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSendAttachmentJoinHandleObjectFactory: UniffiObjectFactory<SendAttachmentJoinHandleInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): SendAttachmentJoinHandleInterface {
      const instance = Object.create(SendAttachmentJoinHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SendAttachmentJoinHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sendattachmentjoinhandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SendAttachmentJoinHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: SendAttachmentJoinHandleInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SendAttachmentJoinHandleInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SendAttachmentJoinHandle'
      );
    },
  };
// FfiConverter for SendAttachmentJoinHandleInterface
const FfiConverterTypeSendAttachmentJoinHandle = new FfiConverterObject(
  uniffiTypeSendAttachmentJoinHandleObjectFactory
);

/**
 * A handle to perform actions onto a local echo.
 */
export interface SendHandleInterface {
  /**
   * Try to abort the sending of the current event.
   *
   * If this returns `true`, then the sending could be aborted, because the
   * event hasn't been sent yet. Otherwise, if this returns `false`, the
   * event had already been sent and could not be aborted.
   *
   * This has an effect only on the first call; subsequent calls will always
   * return `false`.
   */
  abort(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<boolean>;
  /**
   * Attempt to manually resend messages that failed to send due to issues
   * that should now have been fixed.
   *
   * This is useful for example, when there's a
   * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
   * the user may have re-verified on a different device and would now
   * like to send the failed message that's waiting on this device.
   *
   * # Arguments
   *
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo that should be unwedged.
   */
  tryResend(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

/**
 * A handle to perform actions onto a local echo.
 */
export class SendHandle
  extends UniffiAbstractObject
  implements SendHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'SendHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSendHandleObjectFactory.bless(pointer);
  }

  /**
   * Try to abort the sending of the current event.
   *
   * If this returns `true`, then the sending could be aborted, because the
   * event hasn't been sent yet. Otherwise, if this returns `false`, the
   * event had already been sent and could not be aborted.
   *
   * This has an effect only on the first call; subsequent calls will always
   * return `false`.
   */
  public async abort(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(
            uniffiTypeSendHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Attempt to manually resend messages that failed to send due to issues
   * that should now have been fixed.
   *
   * This is useful for example, when there's a
   * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
   * the user may have re-verified on a different device and would now
   * like to send the failed message that's waiting on this device.
   *
   * # Arguments
   *
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo that should be unwedged.
   */
  public async tryResend(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(
            uniffiTypeSendHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSendHandleObjectFactory.pointer(this);
      uniffiTypeSendHandleObjectFactory.freePointer(pointer);
      uniffiTypeSendHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SendHandle {
    return uniffiTypeSendHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSendHandleObjectFactory: UniffiObjectFactory<SendHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SendHandleInterface {
      const instance = Object.create(SendHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SendHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sendhandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SendHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SendHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sendhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sendhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SendHandleInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'SendHandle'
      );
    },
  };
// FfiConverter for SendHandleInterface
const FfiConverterTypeSendHandle = new FfiConverterObject(
  uniffiTypeSendHandleObjectFactory
);

export interface SessionVerificationControllerInterface {
  /**
   * Accept the previously acknowledged verification request
   */
  acceptVerificationRequest(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Set this particular request as the currently active one and register for
   * events pertaining it.
   * * `sender_id` - The user requesting verification.
   * * `flow_id` - - The ID that uniquely identifies the verification flow.
   */
  acknowledgeVerificationRequest(
    senderId: string,
    flowId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Confirm that the short auth strings match on both sides.
   */
  approveVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Cancel the current verification request
   */
  cancelVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Reject the short auth string
   */
  declineVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Request verification for the current device
   */
  requestVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  setDelegate(
    delegate: SessionVerificationControllerDelegate | undefined
  ): void;
  /**
   * Transition the current verification request into a SAS verification
   * flow.
   */
  startSasVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
}

export class SessionVerificationController
  extends UniffiAbstractObject
  implements SessionVerificationControllerInterface
{
  readonly [uniffiTypeNameSymbol] = 'SessionVerificationController';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSessionVerificationControllerObjectFactory.bless(pointer);
  }

  /**
   * Accept the previously acknowledged verification request
   */
  public async acceptVerificationRequest(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set this particular request as the currently active one and register for
   * events pertaining it.
   * * `sender_id` - The user requesting verification.
   * * `flow_id` - - The ID that uniquely identifies the verification flow.
   */
  public async acknowledgeVerificationRequest(
    senderId: string,
    flowId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            ),
            FfiConverterString.lower(senderId),
            FfiConverterString.lower(flowId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Confirm that the short auth strings match on both sides.
   */
  public async approveVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Cancel the current verification request
   */
  public async cancelVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Reject the short auth string
   */
  public async declineVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Request verification for the current device
   */
  public async requestVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public setDelegate(
    delegate: SessionVerificationControllerDelegate | undefined
  ): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(
          uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
            this
          ),
          FfiConverterOptionalTypeSessionVerificationControllerDelegate.lower(
            delegate
          ),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Transition the current verification request into a SAS verification
   * flow.
   */
  public async startSasVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeSessionVerificationControllerObjectFactory.pointer(this);
      uniffiTypeSessionVerificationControllerObjectFactory.freePointer(pointer);
      uniffiTypeSessionVerificationControllerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SessionVerificationController {
    return uniffiTypeSessionVerificationControllerObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeSessionVerificationControllerObjectFactory: UniffiObjectFactory<SessionVerificationControllerInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): SessionVerificationControllerInterface {
      const instance = Object.create(SessionVerificationController.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SessionVerificationController';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sessionverificationcontroller_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(
      obj: SessionVerificationControllerInterface
    ): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: SessionVerificationControllerInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SessionVerificationControllerInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SessionVerificationController'
      );
    },
  };
// FfiConverter for SessionVerificationControllerInterface
const FfiConverterTypeSessionVerificationController = new FfiConverterObject(
  uniffiTypeSessionVerificationControllerObjectFactory
);

export interface SessionVerificationEmojiInterface {
  description(): string;
  symbol(): string;
}

export class SessionVerificationEmoji
  extends UniffiAbstractObject
  implements SessionVerificationEmojiInterface
{
  readonly [uniffiTypeNameSymbol] = 'SessionVerificationEmoji';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSessionVerificationEmojiObjectFactory.bless(pointer);
  }

  public description(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(
            uniffiTypeSessionVerificationEmojiObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public symbol(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(
            uniffiTypeSessionVerificationEmojiObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeSessionVerificationEmojiObjectFactory.pointer(this);
      uniffiTypeSessionVerificationEmojiObjectFactory.freePointer(pointer);
      uniffiTypeSessionVerificationEmojiObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SessionVerificationEmoji {
    return uniffiTypeSessionVerificationEmojiObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSessionVerificationEmojiObjectFactory: UniffiObjectFactory<SessionVerificationEmojiInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): SessionVerificationEmojiInterface {
      const instance = Object.create(SessionVerificationEmoji.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SessionVerificationEmoji';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sessionverificationemoji_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SessionVerificationEmojiInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: SessionVerificationEmojiInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SessionVerificationEmojiInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SessionVerificationEmoji'
      );
    },
  };
// FfiConverter for SessionVerificationEmojiInterface
const FfiConverterTypeSessionVerificationEmoji = new FfiConverterObject(
  uniffiTypeSessionVerificationEmojiObjectFactory
);

export interface SpanInterface {
  enter(): void;
  exit(): void;
  isNone(): boolean;
}

export class Span extends UniffiAbstractObject implements SpanInterface {
  readonly [uniffiTypeNameSymbol] = 'Span';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a span originating at the given callsite (file, line and column).
   *
   * The target should be something like a module path, and can be referenced
   * in the filter string given to `setup_tracing`. `level` and `target`
   * for a callsite are fixed at the first creation of a span for that
   * callsite and can not be changed afterwards, i.e. the level and
   * target passed for second and following creation of a span with the same
   * callsite will be ignored.
   *
   * This function leaks a little bit of memory for each unique (file +
   * line + level + target + name) it is called with. Please make sure that
   * the number of different combinations of those parameters this can be
   * called with is constant in the final executable.
   *
   * For a span to have an effect, you must `.enter()` it at the start of a
   * logical unit of work and `.exit()` it at the end of the same (including
   * on failure). Entering registers the span in thread-local storage, so
   * future calls to `log_event` on the same thread are able to attach the
   * events they create to the span, exiting unregisters it. For this to
   * work, exiting a span must be done on the same thread where it was
   * entered. It is possible to enter a span on multiple threads, in which
   * case it should also be exited on all of them individually; that is,
   * unless you *want* the span to be attached to all further events created
   * on that thread.
   */
  constructor(
    file: string,
    line: /*u32*/ number | undefined,
    level: LogLevel,
    target: string,
    name: string
  ) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_span_new(
          FfiConverterString.lower(file),
          FfiConverterOptionalUInt32.lower(line),
          FfiConverterTypeLogLevel.lower(level),
          FfiConverterString.lower(target),
          FfiConverterString.lower(name),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeSpanObjectFactory.bless(pointer);
  }

  public static current(): SpanInterface {
    return FfiConverterTypeSpan.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_span_current(
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public enter(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_span_enter(
          uniffiTypeSpanObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public exit(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_span_exit(
          uniffiTypeSpanObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public isNone(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_span_is_none(
            uniffiTypeSpanObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSpanObjectFactory.pointer(this);
      uniffiTypeSpanObjectFactory.freePointer(pointer);
      uniffiTypeSpanObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Span {
    return uniffiTypeSpanObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSpanObjectFactory: UniffiObjectFactory<SpanInterface> = {
  create(pointer: UnsafeMutableRawPointer): SpanInterface {
    const instance = Object.create(Span.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Span';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_span_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: SpanInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: SpanInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_span(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_span(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is SpanInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Span';
  },
};
// FfiConverter for SpanInterface
const FfiConverterTypeSpan = new FfiConverterObject(
  uniffiTypeSpanObjectFactory
);

/**
 * An object encapsulating the SSO login flow
 */
export interface SsoHandlerInterface {
  /**
   * Completes the SSO login process.
   */
  finish(
    callbackUrl: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Returns the URL for starting SSO authentication. The URL should be
   * opened in a web view. Once the web view succeeds, call `finish` with
   * the callback URL.
   */
  url(): string;
}

/**
 * An object encapsulating the SSO login flow
 */
export class SsoHandler
  extends UniffiAbstractObject
  implements SsoHandlerInterface
{
  readonly [uniffiTypeNameSymbol] = 'SsoHandler';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSsoHandlerObjectFactory.bless(pointer);
  }

  /**
   * Completes the SSO login process.
   */
  public async finish(
    callbackUrl: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(
            uniffiTypeSsoHandlerObjectFactory.clonePointer(this),
            FfiConverterString.lower(callbackUrl)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSsoError.lift.bind(
          FfiConverterTypeSsoError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the URL for starting SSO authentication. The URL should be
   * opened in a web view. Once the web view succeeds, call `finish` with
   * the callback URL.
   */
  public url(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(
            uniffiTypeSsoHandlerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSsoHandlerObjectFactory.pointer(this);
      uniffiTypeSsoHandlerObjectFactory.freePointer(pointer);
      uniffiTypeSsoHandlerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SsoHandler {
    return uniffiTypeSsoHandlerObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSsoHandlerObjectFactory: UniffiObjectFactory<SsoHandlerInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SsoHandlerInterface {
      const instance = Object.create(SsoHandler.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SsoHandler';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_ssohandler_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SsoHandlerInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SsoHandlerInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_ssohandler(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_ssohandler(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SsoHandlerInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'SsoHandler'
      );
    },
  };
// FfiConverter for SsoHandlerInterface
const FfiConverterTypeSsoHandler = new FfiConverterObject(
  uniffiTypeSsoHandlerObjectFactory
);

export interface SyncServiceInterface {
  roomListService(): RoomListServiceInterface;
  start(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  state(listener: SyncServiceStateObserver): TaskHandleInterface;
  stop(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

export class SyncService
  extends UniffiAbstractObject
  implements SyncServiceInterface
{
  readonly [uniffiTypeNameSymbol] = 'SyncService';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSyncServiceObjectFactory.bless(pointer);
  }

  public roomListService(): RoomListServiceInterface {
    return FfiConverterTypeRoomListService.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(
            uniffiTypeSyncServiceObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async start(asyncOpts_?: { signal: AbortSignal }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_start(
            uniffiTypeSyncServiceObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public state(listener: SyncServiceStateObserver): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_state(
            uniffiTypeSyncServiceObjectFactory.clonePointer(this),
            FfiConverterTypeSyncServiceStateObserver.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async stop(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(
            uniffiTypeSyncServiceObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSyncServiceObjectFactory.pointer(this);
      uniffiTypeSyncServiceObjectFactory.freePointer(pointer);
      uniffiTypeSyncServiceObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SyncService {
    return uniffiTypeSyncServiceObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSyncServiceObjectFactory: UniffiObjectFactory<SyncServiceInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SyncServiceInterface {
      const instance = Object.create(SyncService.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SyncService';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_syncservice_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SyncServiceInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SyncServiceInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_syncservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_syncservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SyncServiceInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SyncService'
      );
    },
  };
// FfiConverter for SyncServiceInterface
const FfiConverterTypeSyncService = new FfiConverterObject(
  uniffiTypeSyncServiceObjectFactory
);

export interface SyncServiceBuilderInterface {
  finish(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<SyncServiceInterface>;
  withCrossProcessLock(): SyncServiceBuilderInterface;
  withUtdHook(
    delegate: UnableToDecryptDelegate,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SyncServiceBuilderInterface>;
}

export class SyncServiceBuilder
  extends UniffiAbstractObject
  implements SyncServiceBuilderInterface
{
  readonly [uniffiTypeNameSymbol] = 'SyncServiceBuilder';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSyncServiceBuilderObjectFactory.bless(pointer);
  }

  public async finish(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<SyncServiceInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(
            uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeSyncService.lift.bind(
          FfiConverterTypeSyncService
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public withCrossProcessLock(): SyncServiceBuilderInterface {
    return FfiConverterTypeSyncServiceBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(
            uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async withUtdHook(
    delegate: UnableToDecryptDelegate,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SyncServiceBuilderInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_utd_hook(
            uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeUnableToDecryptDelegate.lower(delegate)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeSyncServiceBuilder.lift.bind(
          FfiConverterTypeSyncServiceBuilder
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSyncServiceBuilderObjectFactory.pointer(this);
      uniffiTypeSyncServiceBuilderObjectFactory.freePointer(pointer);
      uniffiTypeSyncServiceBuilderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SyncServiceBuilder {
    return uniffiTypeSyncServiceBuilderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSyncServiceBuilderObjectFactory: UniffiObjectFactory<SyncServiceBuilderInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SyncServiceBuilderInterface {
      const instance = Object.create(SyncServiceBuilder.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SyncServiceBuilder';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_syncservicebuilder_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SyncServiceBuilderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SyncServiceBuilderInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SyncServiceBuilderInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SyncServiceBuilder'
      );
    },
  };
// FfiConverter for SyncServiceBuilderInterface
const FfiConverterTypeSyncServiceBuilder = new FfiConverterObject(
  uniffiTypeSyncServiceBuilderObjectFactory
);

/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
export interface TaskHandleInterface {
  cancel(): void;
  /**
   * Check whether the handle is finished.
   */
  isFinished(): boolean;
}

/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
export class TaskHandle
  extends UniffiAbstractObject
  implements TaskHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'TaskHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTaskHandleObjectFactory.bless(pointer);
  }

  public cancel(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(
          uniffiTypeTaskHandleObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Check whether the handle is finished.
   */
  public isFinished(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(
            uniffiTypeTaskHandleObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTaskHandleObjectFactory.pointer(this);
      uniffiTypeTaskHandleObjectFactory.freePointer(pointer);
      uniffiTypeTaskHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TaskHandle {
    return uniffiTypeTaskHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTaskHandleObjectFactory: UniffiObjectFactory<TaskHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TaskHandleInterface {
      const instance = Object.create(TaskHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TaskHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_taskhandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TaskHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TaskHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_taskhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_taskhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TaskHandleInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'TaskHandle'
      );
    },
  };
// FfiConverter for TaskHandleInterface
const FfiConverterTypeTaskHandle = new FfiConverterObject(
  uniffiTypeTaskHandleObjectFactory
);

export interface TimelineInterface {
  addListener(
    listener: TimelineListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface>;
  createMessageContent(
    msgType: MessageType
  ): RoomMessageEventContentWithoutRelationInterface | undefined;
  createPoll(
    question: string,
    answers: Array<string>,
    maxSelections: /*u8*/ number,
    pollKind: PollKind,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Edits an event from the timeline.
   *
   * If it was a local event, this will *try* to edit it, if it was not
   * being sent already. If the event was a remote event, then it will be
   * redacted by sending an edit request to the server.
   *
   * Returns whether the edit did happen. It can only return false for
   * local events that are being processed.
   */
  edit(
    eventOrTransactionId: EventOrTransactionId,
    newContent: EditedContent,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  endPoll(pollStartEventId: string, text: string) /*throws*/ : void;
  fetchDetailsForEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  fetchMembers(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * Paginate forwards, when in focused mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  focusedPaginateForwards(
    numEvents: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Get the current timeline item for the given event ID, if any.
   *
   * Will return a remote event, *or* a local echo that has been sent but not
   * yet replaced by a remote echo.
   *
   * It's preferable to store the timeline items in the model for your UI, if
   * possible, instead of just storing IDs and coming back to the timeline
   * object to look up items.
   */
  getEventTimelineItemByEventId(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventTimelineItem>;
  /**
   * Load the reply details for the given event id.
   *
   * This will return an `InReplyToDetails` object that contains the details
   * which will either be ready or an error.
   */
  loadReplyDetails(
    eventIdStr: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<InReplyToDetailsInterface>;
  /**
   * Mark the room as read by trying to attach an *unthreaded* read receipt
   * to the latest room event.
   *
   * This works even if the latest event belongs to a thread, as a threaded
   * reply also belongs to the unthreaded timeline. No threaded receipt
   * will be sent here (see also #3123).
   */
  markAsRead(
    receiptType: ReceiptType,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Paginate backwards, whether we are in focused mode or in live mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  paginateBackwards(
    numEvents: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Adds a new pinned event by sending an updated `m.room.pinned_events`
   * event containing the new event id.
   *
   * Returns `true` if we sent the request, `false` if the event was already
   * pinned.
   */
  pinEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Redacts an event from the timeline.
   *
   * Only works for events that exist as timeline items.
   *
   * If it was a local event, this will *try* to cancel it, if it was not
   * being sent already. If the event was a remote event, then it will be
   * redacted by sending a redaction request to the server.
   *
   * Will return an error if the event couldn't be redacted.
   */
  redactEvent(
    eventOrTransactionId: EventOrTransactionId,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  retryDecryption(sessionIds: Array<string>): void;
  /**
   * Queues an event in the room's send queue so it's processed for
   * sending later.
   *
   * Returns an abort handle that allows to abort sending, if it hasn't
   * happened yet.
   */
  send(
    msg: RoomMessageEventContentWithoutRelationInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendHandleInterface>;
  sendAudio(
    url: string,
    audioInfo: AudioInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface;
  sendFile(
    url: string,
    fileInfo: FileInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface;
  sendImage(
    url: string,
    thumbnailUrl: string | undefined,
    imageInfo: ImageInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface;
  sendLocation(
    body: string,
    geoUri: string,
    description: string | undefined,
    zoomLevel: /*u8*/ number | undefined,
    assetType: AssetType | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  sendPollResponse(
    pollStartEventId: string,
    answers: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  sendReadReceipt(
    receiptType: ReceiptType,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  sendReply(
    msg: RoomMessageEventContentWithoutRelationInterface,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  sendVideo(
    url: string,
    thumbnailUrl: string | undefined,
    videoInfo: VideoInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface;
  sendVoiceMessage(
    url: string,
    audioInfo: AudioInfo,
    waveform: Array</*u16*/ number>,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface;
  subscribeToBackPaginationStatus(
    listener: PaginationStatusListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TaskHandleInterface>;
  /**
   * Toggle a reaction on an event.
   *
   * Adds or redacts a reaction based on the state of the reaction at the
   * time it is called.
   *
   * This method works both on local echoes and remote items.
   *
   * When redacting a previous reaction, the redaction reason is not set.
   *
   * Ensures that only one reaction is sent at a time to avoid race
   * conditions and spamming the homeserver with requests.
   */
  toggleReaction(
    itemId: EventOrTransactionId,
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Adds a new pinned event by sending an updated `m.room.pinned_events`
   * event without the event id we want to remove.
   *
   * Returns `true` if we sent the request, `false` if the event wasn't
   * pinned
   */
  unpinEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
}

export class Timeline
  extends UniffiAbstractObject
  implements TimelineInterface
{
  readonly [uniffiTypeNameSymbol] = 'Timeline';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineObjectFactory.bless(pointer);
  }

  public async addListener(
    listener: TimelineListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeTimelineListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public createMessageContent(
    msgType: MessageType
  ): RoomMessageEventContentWithoutRelationInterface | undefined {
    return FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeMessageType.lower(msgType),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async createPoll(
    question: string,
    answers: Array<string>,
    maxSelections: /*u8*/ number,
    pollKind: PollKind,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(question),
            FfiConverterArrayString.lower(answers),
            FfiConverterUInt8.lower(maxSelections),
            FfiConverterTypePollKind.lower(pollKind)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Edits an event from the timeline.
   *
   * If it was a local event, this will *try* to edit it, if it was not
   * being sent already. If the event was a remote event, then it will be
   * redacted by sending an edit request to the server.
   *
   * Returns whether the edit did happen. It can only return false for
   * local events that are being processed.
   */
  public async edit(
    eventOrTransactionId: EventOrTransactionId,
    newContent: EditedContent,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_edit(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeEventOrTransactionId.lower(eventOrTransactionId),
            FfiConverterTypeEditedContent.lower(newContent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public endPoll(pollStartEventId: string, text: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(
          uniffiTypeTimelineObjectFactory.clonePointer(this),
          FfiConverterString.lower(pollStartEventId),
          FfiConverterString.lower(text),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public async fetchDetailsForEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async fetchMembers(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(
            uniffiTypeTimelineObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Paginate forwards, when in focused mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  public async focusedPaginateForwards(
    numEvents: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_focused_paginate_forwards(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterUInt16.lower(numEvents)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the current timeline item for the given event ID, if any.
   *
   * Will return a remote event, *or* a local echo that has been sent but not
   * yet replaced by a remote echo.
   *
   * It's preferable to store the timeline items in the model for your UI, if
   * possible, instead of just storing IDs and coming back to the timeline
   * object to look up items.
   */
  public async getEventTimelineItemByEventId(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventTimelineItem> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeEventTimelineItem.lift.bind(
          FfiConverterTypeEventTimelineItem
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Load the reply details for the given event id.
   *
   * This will return an `InReplyToDetails` object that contains the details
   * which will either be ready or an error.
   */
  public async loadReplyDetails(
    eventIdStr: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<InReplyToDetailsInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventIdStr)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeInReplyToDetails.lift.bind(
          FfiConverterTypeInReplyToDetails
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Mark the room as read by trying to attach an *unthreaded* read receipt
   * to the latest room event.
   *
   * This works even if the latest event belongs to a thread, as a threaded
   * reply also belongs to the unthreaded timeline. No threaded receipt
   * will be sent here (see also #3123).
   */
  public async markAsRead(
    receiptType: ReceiptType,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeReceiptType.lower(receiptType)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Paginate backwards, whether we are in focused mode or in live mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  public async paginateBackwards(
    numEvents: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterUInt16.lower(numEvents)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Adds a new pinned event by sending an updated `m.room.pinned_events`
   * event containing the new event id.
   *
   * Returns `true` if we sent the request, `false` if the event was already
   * pinned.
   */
  public async pinEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Redacts an event from the timeline.
   *
   * Only works for events that exist as timeline items.
   *
   * If it was a local event, this will *try* to cancel it, if it was not
   * being sent already. If the event was a remote event, then it will be
   * redacted by sending a redaction request to the server.
   *
   * Will return an error if the event couldn't be redacted.
   */
  public async redactEvent(
    eventOrTransactionId: EventOrTransactionId,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeEventOrTransactionId.lower(eventOrTransactionId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public retryDecryption(sessionIds: Array<string>): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(
          uniffiTypeTimelineObjectFactory.clonePointer(this),
          FfiConverterArrayString.lower(sessionIds),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Queues an event in the room's send queue so it's processed for
   * sending later.
   *
   * Returns an abort handle that allows to abort sending, if it hasn't
   * happened yet.
   */
  public async send(
    msg: RoomMessageEventContentWithoutRelationInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeSendHandle.lift.bind(
          FfiConverterTypeSendHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public sendAudio(
    url: string,
    audioInfo: AudioInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterTypeAudioInfo.lower(audioInfo),
            FfiConverterOptionalString.lower(caption),
            FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            FfiConverterBool.lower(useSendQueue),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sendFile(
    url: string,
    fileInfo: FileInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterTypeFileInfo.lower(fileInfo),
            FfiConverterOptionalString.lower(caption),
            FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            FfiConverterBool.lower(useSendQueue),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sendImage(
    url: string,
    thumbnailUrl: string | undefined,
    imageInfo: ImageInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterOptionalString.lower(thumbnailUrl),
            FfiConverterTypeImageInfo.lower(imageInfo),
            FfiConverterOptionalString.lower(caption),
            FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            FfiConverterBool.lower(useSendQueue),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async sendLocation(
    body: string,
    geoUri: string,
    description: string | undefined,
    zoomLevel: /*u8*/ number | undefined,
    assetType: AssetType | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(body),
            FfiConverterString.lower(geoUri),
            FfiConverterOptionalString.lower(description),
            FfiConverterOptionalUInt8.lower(zoomLevel),
            FfiConverterOptionalTypeAssetType.lower(assetType)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sendPollResponse(
    pollStartEventId: string,
    answers: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(pollStartEventId),
            FfiConverterArrayString.lower(answers)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sendReadReceipt(
    receiptType: ReceiptType,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeReceiptType.lower(receiptType),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sendReply(
    msg: RoomMessageEventContentWithoutRelationInterface,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public sendVideo(
    url: string,
    thumbnailUrl: string | undefined,
    videoInfo: VideoInfo,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterOptionalString.lower(thumbnailUrl),
            FfiConverterTypeVideoInfo.lower(videoInfo),
            FfiConverterOptionalString.lower(caption),
            FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            FfiConverterBool.lower(useSendQueue),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sendVoiceMessage(
    url: string,
    audioInfo: AudioInfo,
    waveform: Array</*u16*/ number>,
    caption: string | undefined,
    formattedCaption: FormattedBody | undefined,
    progressWatcher: ProgressWatcher | undefined,
    useSendQueue: boolean
  ): SendAttachmentJoinHandleInterface {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterTypeAudioInfo.lower(audioInfo),
            FfiConverterArrayUInt16.lower(waveform),
            FfiConverterOptionalString.lower(caption),
            FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            FfiConverterBool.lower(useSendQueue),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async subscribeToBackPaginationStatus(
    listener: PaginationStatusListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypePaginationStatusListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Toggle a reaction on an event.
   *
   * Adds or redacts a reaction based on the state of the reaction at the
   * time it is called.
   *
   * This method works both on local echoes and remote items.
   *
   * When redacting a previous reaction, the redaction reason is not set.
   *
   * Ensures that only one reaction is sent at a time to avoid race
   * conditions and spamming the homeserver with requests.
   */
  public async toggleReaction(
    itemId: EventOrTransactionId,
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeEventOrTransactionId.lower(itemId),
            FfiConverterString.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Adds a new pinned event by sending an updated `m.room.pinned_events`
   * event without the event id we want to remove.
   *
   * Returns `true` if we sent the request, `false` if the event wasn't
   * pinned
   */
  public async unpinEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTimelineObjectFactory.pointer(this);
      uniffiTypeTimelineObjectFactory.freePointer(pointer);
      uniffiTypeTimelineObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Timeline {
    return uniffiTypeTimelineObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineObjectFactory: UniffiObjectFactory<TimelineInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineInterface {
      const instance = Object.create(Timeline.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Timeline';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timeline_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TimelineInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timeline(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timeline(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Timeline'
      );
    },
  };
// FfiConverter for TimelineInterface
const FfiConverterTypeTimeline = new FfiConverterObject(
  uniffiTypeTimelineObjectFactory
);

export interface TimelineDiffInterface {
  append(): Array<TimelineItemInterface> | undefined;
  change(): TimelineChange;
  insert(): InsertData | undefined;
  pushBack(): TimelineItemInterface | undefined;
  pushFront(): TimelineItemInterface | undefined;
  remove(): /*u32*/ number | undefined;
  reset(): Array<TimelineItemInterface> | undefined;
  set(): SetData | undefined;
  truncate(): /*u32*/ number | undefined;
}

export class TimelineDiff
  extends UniffiAbstractObject
  implements TimelineDiffInterface
{
  readonly [uniffiTypeNameSymbol] = 'TimelineDiff';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineDiffObjectFactory.bless(pointer);
  }

  public append(): Array<TimelineItemInterface> | undefined {
    return FfiConverterOptionalArrayTypeTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_append(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public change(): TimelineChange {
    return FfiConverterTypeTimelineChange.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_change(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insert(): InsertData | undefined {
    return FfiConverterOptionalTypeInsertData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_insert(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public pushBack(): TimelineItemInterface | undefined {
    return FfiConverterOptionalTypeTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_back(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public pushFront(): TimelineItemInterface | undefined {
    return FfiConverterOptionalTypeTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_front(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public remove(): /*u32*/ number | undefined {
    return FfiConverterOptionalUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_remove(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public reset(): Array<TimelineItemInterface> | undefined {
    return FfiConverterOptionalArrayTypeTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_reset(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public set(): SetData | undefined {
    return FfiConverterOptionalTypeSetData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_set(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public truncate(): /*u32*/ number | undefined {
    return FfiConverterOptionalUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_truncate(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTimelineDiffObjectFactory.pointer(this);
      uniffiTypeTimelineDiffObjectFactory.freePointer(pointer);
      uniffiTypeTimelineDiffObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TimelineDiff {
    return uniffiTypeTimelineDiffObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineDiffObjectFactory: UniffiObjectFactory<TimelineDiffInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineDiffInterface {
      const instance = Object.create(TimelineDiff.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TimelineDiff';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timelinediff_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineDiffInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TimelineDiffInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelinediff(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelinediff(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineDiffInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'TimelineDiff'
      );
    },
  };
// FfiConverter for TimelineDiffInterface
const FfiConverterTypeTimelineDiff = new FfiConverterObject(
  uniffiTypeTimelineDiffObjectFactory
);

export interface TimelineEventInterface {
  eventId(): string;
  eventType() /*throws*/ : TimelineEventType;
  senderId(): string;
  timestamp(): /*u64*/ bigint;
}

export class TimelineEvent
  extends UniffiAbstractObject
  implements TimelineEventInterface
{
  readonly [uniffiTypeNameSymbol] = 'TimelineEvent';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineEventObjectFactory.bless(pointer);
  }

  public eventId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(
            uniffiTypeTimelineEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public eventType(): TimelineEventType /*throws*/ {
    return FfiConverterTypeTimelineEventType.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(
            uniffiTypeTimelineEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public senderId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(
            uniffiTypeTimelineEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public timestamp(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(
            uniffiTypeTimelineEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTimelineEventObjectFactory.pointer(this);
      uniffiTypeTimelineEventObjectFactory.freePointer(pointer);
      uniffiTypeTimelineEventObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TimelineEvent {
    return uniffiTypeTimelineEventObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineEventObjectFactory: UniffiObjectFactory<TimelineEventInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineEventInterface {
      const instance = Object.create(TimelineEvent.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TimelineEvent';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timelineevent_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineEventInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TimelineEventInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelineevent(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelineevent(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineEventInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'TimelineEvent'
      );
    },
  };
// FfiConverter for TimelineEventInterface
const FfiConverterTypeTimelineEvent = new FfiConverterObject(
  uniffiTypeTimelineEventObjectFactory
);

export interface TimelineEventTypeFilterInterface {}

export class TimelineEventTypeFilter
  extends UniffiAbstractObject
  implements TimelineEventTypeFilterInterface
{
  readonly [uniffiTypeNameSymbol] = 'TimelineEventTypeFilter';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineEventTypeFilterObjectFactory.bless(pointer);
  }

  public static exclude(
    eventTypes: Array<FilterTimelineEventType>
  ): TimelineEventTypeFilterInterface {
    return FfiConverterTypeTimelineEventTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(
            FfiConverterArrayTypeFilterTimelineEventType.lower(eventTypes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static include(
    eventTypes: Array<FilterTimelineEventType>
  ): TimelineEventTypeFilterInterface {
    return FfiConverterTypeTimelineEventTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(
            FfiConverterArrayTypeFilterTimelineEventType.lower(eventTypes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeTimelineEventTypeFilterObjectFactory.pointer(this);
      uniffiTypeTimelineEventTypeFilterObjectFactory.freePointer(pointer);
      uniffiTypeTimelineEventTypeFilterObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TimelineEventTypeFilter {
    return uniffiTypeTimelineEventTypeFilterObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineEventTypeFilterObjectFactory: UniffiObjectFactory<TimelineEventTypeFilterInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineEventTypeFilterInterface {
      const instance = Object.create(TimelineEventTypeFilter.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TimelineEventTypeFilter';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timelineeventtypefilter_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineEventTypeFilterInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: TimelineEventTypeFilterInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineEventTypeFilterInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'TimelineEventTypeFilter'
      );
    },
  };
// FfiConverter for TimelineEventTypeFilterInterface
const FfiConverterTypeTimelineEventTypeFilter = new FfiConverterObject(
  uniffiTypeTimelineEventTypeFilterObjectFactory
);

export interface TimelineItemInterface {
  asEvent(): EventTimelineItem | undefined;
  asVirtual(): VirtualTimelineItem | undefined;
  fmtDebug(): string;
  /**
   * An opaque unique identifier for this timeline item.
   */
  uniqueId(): TimelineUniqueId;
}

export class TimelineItem
  extends UniffiAbstractObject
  implements TimelineItemInterface
{
  readonly [uniffiTypeNameSymbol] = 'TimelineItem';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineItemObjectFactory.bless(pointer);
  }

  public asEvent(): EventTimelineItem | undefined {
    return FfiConverterOptionalTypeEventTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(
            uniffiTypeTimelineItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asVirtual(): VirtualTimelineItem | undefined {
    return FfiConverterOptionalTypeVirtualTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(
            uniffiTypeTimelineItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public fmtDebug(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(
            uniffiTypeTimelineItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * An opaque unique identifier for this timeline item.
   */
  public uniqueId(): TimelineUniqueId {
    return FfiConverterTypeTimelineUniqueId.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(
            uniffiTypeTimelineItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTimelineItemObjectFactory.pointer(this);
      uniffiTypeTimelineItemObjectFactory.freePointer(pointer);
      uniffiTypeTimelineItemObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TimelineItem {
    return uniffiTypeTimelineItemObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineItemObjectFactory: UniffiObjectFactory<TimelineItemInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineItemInterface {
      const instance = Object.create(TimelineItem.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TimelineItem';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timelineitem_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineItemInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TimelineItemInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelineitem(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelineitem(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineItemInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'TimelineItem'
      );
    },
  };
// FfiConverter for TimelineItemInterface
const FfiConverterTypeTimelineItem = new FfiConverterObject(
  uniffiTypeTimelineItemObjectFactory
);

export interface UnreadNotificationsCountInterface {
  hasNotifications(): boolean;
  highlightCount(): /*u32*/ number;
  notificationCount(): /*u32*/ number;
}

export class UnreadNotificationsCount
  extends UniffiAbstractObject
  implements UnreadNotificationsCountInterface
{
  readonly [uniffiTypeNameSymbol] = 'UnreadNotificationsCount';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUnreadNotificationsCountObjectFactory.bless(pointer);
  }

  public hasNotifications(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(
            uniffiTypeUnreadNotificationsCountObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public highlightCount(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(
            uniffiTypeUnreadNotificationsCountObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public notificationCount(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(
            uniffiTypeUnreadNotificationsCountObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeUnreadNotificationsCountObjectFactory.pointer(this);
      uniffiTypeUnreadNotificationsCountObjectFactory.freePointer(pointer);
      uniffiTypeUnreadNotificationsCountObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UnreadNotificationsCount {
    return uniffiTypeUnreadNotificationsCountObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUnreadNotificationsCountObjectFactory: UniffiObjectFactory<UnreadNotificationsCountInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): UnreadNotificationsCountInterface {
      const instance = Object.create(UnreadNotificationsCount.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'UnreadNotificationsCount';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_unreadnotificationscount_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: UnreadNotificationsCountInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: UnreadNotificationsCountInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is UnreadNotificationsCountInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'UnreadNotificationsCount'
      );
    },
  };
// FfiConverter for UnreadNotificationsCountInterface
const FfiConverterTypeUnreadNotificationsCount = new FfiConverterObject(
  uniffiTypeUnreadNotificationsCountObjectFactory
);

/**
 * The E2EE identity of a user.
 */
export interface UserIdentityInterface {
  /**
   * Is the user identity considered to be verified.
   *
   * If the identity belongs to another user, our own user identity needs to
   * be verified as well for the identity to be considered to be verified.
   */
  isVerified(): boolean;
  /**
   * Get the public part of the Master key of this user identity.
   *
   * The public part of the Master key is usually used to uniquely identify
   * the identity.
   *
   * Returns None if the master key does not actually contain any keys.
   */
  masterKey(): string | undefined;
  /**
   * Remember this identity, ensuring it does not result in a pin violation.
   *
   * When we first see a user, we assume their cryptographic identity has not
   * been tampered with by the homeserver or another entity with
   * man-in-the-middle capabilities. We remember this identity and call this
   * action "pinning".
   *
   * If the identity presented for the user changes later on, the newly
   * presented identity is considered to be in "pin violation". This
   * method explicitly accepts the new identity, allowing it to replace
   * the previously pinned one and bringing it out of pin violation.
   *
   * UIs should display a warning to the user when encountering an identity
   * which is not verified and is in pin violation.
   */
  pin(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

/**
 * The E2EE identity of a user.
 */
export class UserIdentity
  extends UniffiAbstractObject
  implements UserIdentityInterface
{
  readonly [uniffiTypeNameSymbol] = 'UserIdentity';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUserIdentityObjectFactory.bless(pointer);
  }

  /**
   * Is the user identity considered to be verified.
   *
   * If the identity belongs to another user, our own user identity needs to
   * be verified as well for the identity to be considered to be verified.
   */
  public isVerified(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(
            uniffiTypeUserIdentityObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the public part of the Master key of this user identity.
   *
   * The public part of the Master key is usually used to uniquely identify
   * the identity.
   *
   * Returns None if the master key does not actually contain any keys.
   */
  public masterKey(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(
            uniffiTypeUserIdentityObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Remember this identity, ensuring it does not result in a pin violation.
   *
   * When we first see a user, we assume their cryptographic identity has not
   * been tampered with by the homeserver or another entity with
   * man-in-the-middle capabilities. We remember this identity and call this
   * action "pinning".
   *
   * If the identity presented for the user changes later on, the newly
   * presented identity is considered to be in "pin violation". This
   * method explicitly accepts the new identity, allowing it to replace
   * the previously pinned one and bringing it out of pin violation.
   *
   * UIs should display a warning to the user when encountering an identity
   * which is not verified and is in pin violation.
   */
  public async pin(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(
            uniffiTypeUserIdentityObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeUserIdentityObjectFactory.pointer(this);
      uniffiTypeUserIdentityObjectFactory.freePointer(pointer);
      uniffiTypeUserIdentityObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UserIdentity {
    return uniffiTypeUserIdentityObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUserIdentityObjectFactory: UniffiObjectFactory<UserIdentityInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): UserIdentityInterface {
      const instance = Object.create(UserIdentity.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'UserIdentity';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_useridentity_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: UserIdentityInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: UserIdentityInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_useridentity(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_useridentity(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is UserIdentityInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'UserIdentity'
      );
    },
  };
// FfiConverter for UserIdentityInterface
const FfiConverterTypeUserIdentity = new FfiConverterObject(
  uniffiTypeUserIdentityObjectFactory
);

/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
export interface WidgetDriverInterface {
  run(
    room: RoomInterface,
    capabilitiesProvider: WidgetCapabilitiesProvider,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
}

/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
export class WidgetDriver
  extends UniffiAbstractObject
  implements WidgetDriverInterface
{
  readonly [uniffiTypeNameSymbol] = 'WidgetDriver';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeWidgetDriverObjectFactory.bless(pointer);
  }

  public async run(
    room: RoomInterface,
    capabilitiesProvider: WidgetCapabilitiesProvider,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(
            uniffiTypeWidgetDriverObjectFactory.clonePointer(this),
            FfiConverterTypeRoom.lower(room),
            FfiConverterTypeWidgetCapabilitiesProvider.lower(
              capabilitiesProvider
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeWidgetDriverObjectFactory.pointer(this);
      uniffiTypeWidgetDriverObjectFactory.freePointer(pointer);
      uniffiTypeWidgetDriverObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is WidgetDriver {
    return uniffiTypeWidgetDriverObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeWidgetDriverObjectFactory: UniffiObjectFactory<WidgetDriverInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): WidgetDriverInterface {
      const instance = Object.create(WidgetDriver.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'WidgetDriver';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_widgetdriver_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: WidgetDriverInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: WidgetDriverInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_widgetdriver(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is WidgetDriverInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'WidgetDriver'
      );
    },
  };
// FfiConverter for WidgetDriverInterface
const FfiConverterTypeWidgetDriver = new FfiConverterObject(
  uniffiTypeWidgetDriverObjectFactory
);

/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
export interface WidgetDriverHandleInterface {
  /**
   * Receive a message from the widget driver.
   *
   * The message must be passed on to the widget.
   *
   * Returns `None` if the widget driver is no longer running.
   */
  recv(asyncOpts_?: { signal: AbortSignal }): Promise<string | undefined>;
  /**
   *
   * Returns `false` if the widget driver is no longer running.
   */
  send(msg: string, asyncOpts_?: { signal: AbortSignal }): Promise<boolean>;
}

/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
export class WidgetDriverHandle
  extends UniffiAbstractObject
  implements WidgetDriverHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'WidgetDriverHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeWidgetDriverHandleObjectFactory.bless(pointer);
  }

  /**
   * Receive a message from the widget driver.
   *
   * The message must be passed on to the widget.
   *
   * Returns `None` if the widget driver is no longer running.
   */
  public async recv(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(
            uniffiTypeWidgetDriverHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   *
   * Returns `false` if the widget driver is no longer running.
   */
  public async send(
    msg: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(
            uniffiTypeWidgetDriverHandleObjectFactory.clonePointer(this),
            FfiConverterString.lower(msg)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeWidgetDriverHandleObjectFactory.pointer(this);
      uniffiTypeWidgetDriverHandleObjectFactory.freePointer(pointer);
      uniffiTypeWidgetDriverHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is WidgetDriverHandle {
    return uniffiTypeWidgetDriverHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeWidgetDriverHandleObjectFactory: UniffiObjectFactory<WidgetDriverHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): WidgetDriverHandleInterface {
      const instance = Object.create(WidgetDriverHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'WidgetDriverHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_widgetdriverhandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: WidgetDriverHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: WidgetDriverHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is WidgetDriverHandleInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'WidgetDriverHandle'
      );
    },
  };
// FfiConverter for WidgetDriverHandleInterface
const FfiConverterTypeWidgetDriverHandle = new FfiConverterObject(
  uniffiTypeWidgetDriverHandleObjectFactory
);

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for BackupSteadyStateListener | undefined
const FfiConverterOptionalTypeBackupSteadyStateListener =
  new FfiConverterOptional(FfiConverterTypeBackupSteadyStateListener);

// FfiConverter for ClientDelegate | undefined
const FfiConverterOptionalTypeClientDelegate = new FfiConverterOptional(
  FfiConverterTypeClientDelegate
);

// FfiConverter for NotificationSettingsDelegate | undefined
const FfiConverterOptionalTypeNotificationSettingsDelegate =
  new FfiConverterOptional(FfiConverterTypeNotificationSettingsDelegate);

// FfiConverter for ProgressWatcher | undefined
const FfiConverterOptionalTypeProgressWatcher = new FfiConverterOptional(
  FfiConverterTypeProgressWatcher
);

// FfiConverter for SessionVerificationControllerDelegate | undefined
const FfiConverterOptionalTypeSessionVerificationControllerDelegate =
  new FfiConverterOptional(
    FfiConverterTypeSessionVerificationControllerDelegate
  );

// FfiConverter for UniffiDuration | undefined
const FfiConverterOptionalDuration = new FfiConverterOptional(
  FfiConverterDuration
);

// FfiConverter for EventItemOrigin | undefined
const FfiConverterOptionalTypeEventItemOrigin = new FfiConverterOptional(
  FfiConverterTypeEventItemOrigin
);

// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(
  FfiConverterFloat64
);

// FfiConverter for /*i32*/number | undefined
const FfiConverterOptionalInt32 = new FfiConverterOptional(FfiConverterInt32);

// FfiConverter for AudioInfo | undefined
const FfiConverterOptionalTypeAudioInfo = new FfiConverterOptional(
  FfiConverterTypeAudioInfo
);

// FfiConverter for ComposerDraft | undefined
const FfiConverterOptionalTypeComposerDraft = new FfiConverterOptional(
  FfiConverterTypeComposerDraft
);

// FfiConverter for ElementCallWellKnown | undefined
const FfiConverterOptionalTypeElementCallWellKnown = new FfiConverterOptional(
  FfiConverterTypeElementCallWellKnown
);

// FfiConverter for EventTimelineItem | undefined
const FfiConverterOptionalTypeEventTimelineItem = new FfiConverterOptional(
  FfiConverterTypeEventTimelineItem
);

// FfiConverter for FileInfo | undefined
const FfiConverterOptionalTypeFileInfo = new FfiConverterOptional(
  FfiConverterTypeFileInfo
);

// FfiConverter for FormattedBody | undefined
const FfiConverterOptionalTypeFormattedBody = new FfiConverterOptional(
  FfiConverterTypeFormattedBody
);

// FfiConverter for ImageInfo | undefined
const FfiConverterOptionalTypeImageInfo = new FfiConverterOptional(
  FfiConverterTypeImageInfo
);

// FfiConverter for InsertData | undefined
const FfiConverterOptionalTypeInsertData = new FfiConverterOptional(
  FfiConverterTypeInsertData
);

// FfiConverter for MatrixEntity | undefined
const FfiConverterOptionalTypeMatrixEntity = new FfiConverterOptional(
  FfiConverterTypeMatrixEntity
);

// FfiConverter for Mentions | undefined
const FfiConverterOptionalTypeMentions = new FfiConverterOptional(
  FfiConverterTypeMentions
);

// FfiConverter for NotificationItem | undefined
const FfiConverterOptionalTypeNotificationItem = new FfiConverterOptional(
  FfiConverterTypeNotificationItem
);

// FfiConverter for NotificationPowerLevels | undefined
const FfiConverterOptionalTypeNotificationPowerLevels =
  new FfiConverterOptional(FfiConverterTypeNotificationPowerLevels);

// FfiConverter for PowerLevels | undefined
const FfiConverterOptionalTypePowerLevels = new FfiConverterOptional(
  FfiConverterTypePowerLevels
);

// FfiConverter for ResolvedRoomAlias | undefined
const FfiConverterOptionalTypeResolvedRoomAlias = new FfiConverterOptional(
  FfiConverterTypeResolvedRoomAlias
);

// FfiConverter for RoomMember | undefined
const FfiConverterOptionalTypeRoomMember = new FfiConverterOptional(
  FfiConverterTypeRoomMember
);

// FfiConverter for SetData | undefined
const FfiConverterOptionalTypeSetData = new FfiConverterOptional(
  FfiConverterTypeSetData
);

// FfiConverter for ThumbnailInfo | undefined
const FfiConverterOptionalTypeThumbnailInfo = new FfiConverterOptional(
  FfiConverterTypeThumbnailInfo
);

// FfiConverter for TracingFileConfiguration | undefined
const FfiConverterOptionalTypeTracingFileConfiguration =
  new FfiConverterOptional(FfiConverterTypeTracingFileConfiguration);

// FfiConverter for UnstableAudioDetailsContent | undefined
const FfiConverterOptionalTypeUnstableAudioDetailsContent =
  new FfiConverterOptional(FfiConverterTypeUnstableAudioDetailsContent);

// FfiConverter for UnstableVoiceContent | undefined
const FfiConverterOptionalTypeUnstableVoiceContent = new FfiConverterOptional(
  FfiConverterTypeUnstableVoiceContent
);

// FfiConverter for VideoInfo | undefined
const FfiConverterOptionalTypeVideoInfo = new FfiConverterOptional(
  FfiConverterTypeVideoInfo
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for /*u8*/number | undefined
const FfiConverterOptionalUInt8 = new FfiConverterOptional(FfiConverterUInt8);

// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer = new FfiConverterArray(
  FfiConverterArrayBuffer
);

// FfiConverter for Array<IdentityStatusChange>
const FfiConverterArrayTypeIdentityStatusChange = new FfiConverterArray(
  FfiConverterTypeIdentityStatusChange
);

// FfiConverter for Array<KnockRequest>
const FfiConverterArrayTypeKnockRequest = new FfiConverterArray(
  FfiConverterTypeKnockRequest
);

// FfiConverter for Array<PollAnswer>
const FfiConverterArrayTypePollAnswer = new FfiConverterArray(
  FfiConverterTypePollAnswer
);

// FfiConverter for Array<Reaction>
const FfiConverterArrayTypeReaction = new FfiConverterArray(
  FfiConverterTypeReaction
);

// FfiConverter for Array<ReactionSenderData>
const FfiConverterArrayTypeReactionSenderData = new FfiConverterArray(
  FfiConverterTypeReactionSenderData
);

// FfiConverter for Array<RoomDescription>
const FfiConverterArrayTypeRoomDescription = new FfiConverterArray(
  FfiConverterTypeRoomDescription
);

// FfiConverter for Array<RoomHero>
const FfiConverterArrayTypeRoomHero = new FfiConverterArray(
  FfiConverterTypeRoomHero
);

// FfiConverter for Array<RoomMember>
const FfiConverterArrayTypeRoomMember = new FfiConverterArray(
  FfiConverterTypeRoomMember
);

// FfiConverter for Array<UserPowerLevelUpdate>
const FfiConverterArrayTypeUserPowerLevelUpdate = new FfiConverterArray(
  FfiConverterTypeUserPowerLevelUpdate
);

// FfiConverter for Array<UserProfile>
const FfiConverterArrayTypeUserProfile = new FfiConverterArray(
  FfiConverterTypeUserProfile
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array</*u16*/number>
const FfiConverterArrayUInt16 = new FfiConverterArray(FfiConverterUInt16);

// FfiConverter for Map<string, Array<string>>
const FfiConverterMapStringArrayString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterArrayString
);

// FfiConverter for AccountManagementAction | undefined
const FfiConverterOptionalTypeAccountManagementAction =
  new FfiConverterOptional(FfiConverterTypeAccountManagementAction);

// FfiConverter for AssetType | undefined
const FfiConverterOptionalTypeAssetType = new FfiConverterOptional(
  FfiConverterTypeAssetType
);

// FfiConverter for AuthData | undefined
const FfiConverterOptionalTypeAuthData = new FfiConverterOptional(
  FfiConverterTypeAuthData
);

// FfiConverter for EventSendState | undefined
const FfiConverterOptionalTypeEventSendState = new FfiConverterOptional(
  FfiConverterTypeEventSendState
);

// FfiConverter for JoinRule | undefined
const FfiConverterOptionalTypeJoinRule = new FfiConverterOptional(
  FfiConverterTypeJoinRule
);

// FfiConverter for Membership | undefined
const FfiConverterOptionalTypeMembership = new FfiConverterOptional(
  FfiConverterTypeMembership
);

// FfiConverter for MembershipChange | undefined
const FfiConverterOptionalTypeMembershipChange = new FfiConverterOptional(
  FfiConverterTypeMembershipChange
);

// FfiConverter for PublicRoomJoinRule | undefined
const FfiConverterOptionalTypePublicRoomJoinRule = new FfiConverterOptional(
  FfiConverterTypePublicRoomJoinRule
);

// FfiConverter for PushFormat | undefined
const FfiConverterOptionalTypePushFormat = new FfiConverterOptional(
  FfiConverterTypePushFormat
);

// FfiConverter for RoomNotificationMode | undefined
const FfiConverterOptionalTypeRoomNotificationMode = new FfiConverterOptional(
  FfiConverterTypeRoomNotificationMode
);

// FfiConverter for ShieldState | undefined
const FfiConverterOptionalTypeShieldState = new FfiConverterOptional(
  FfiConverterTypeShieldState
);

// FfiConverter for VirtualTimelineItem | undefined
const FfiConverterOptionalTypeVirtualTimelineItem = new FfiConverterOptional(
  FfiConverterTypeVirtualTimelineItem
);

// FfiConverter for Map<string, /*i64*/bigint> | undefined
const FfiConverterOptionalMapStringInt64 = new FfiConverterOptional(
  FfiConverterMapStringInt64
);

// FfiConverter for IdentityResetHandleInterface | undefined
const FfiConverterOptionalTypeIdentityResetHandle = new FfiConverterOptional(
  FfiConverterTypeIdentityResetHandle
);

// FfiConverter for InReplyToDetailsInterface | undefined
const FfiConverterOptionalTypeInReplyToDetails = new FfiConverterOptional(
  FfiConverterTypeInReplyToDetails
);

// FfiConverter for MediaSourceInterface | undefined
const FfiConverterOptionalTypeMediaSource = new FfiConverterOptional(
  FfiConverterTypeMediaSource
);

// FfiConverter for RoomInterface | undefined
const FfiConverterOptionalTypeRoom = new FfiConverterOptional(
  FfiConverterTypeRoom
);

// FfiConverter for RoomMessageEventContentWithoutRelationInterface | undefined
const FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation =
  new FfiConverterOptional(
    FfiConverterTypeRoomMessageEventContentWithoutRelation
  );

// FfiConverter for SendHandleInterface | undefined
const FfiConverterOptionalTypeSendHandle = new FfiConverterOptional(
  FfiConverterTypeSendHandle
);

// FfiConverter for TaskHandleInterface | undefined
const FfiConverterOptionalTypeTaskHandle = new FfiConverterOptional(
  FfiConverterTypeTaskHandle
);

// FfiConverter for TimelineEventTypeFilterInterface | undefined
const FfiConverterOptionalTypeTimelineEventTypeFilter =
  new FfiConverterOptional(FfiConverterTypeTimelineEventTypeFilter);

// FfiConverter for TimelineItemInterface | undefined
const FfiConverterOptionalTypeTimelineItem = new FfiConverterOptional(
  FfiConverterTypeTimelineItem
);

// FfiConverter for UserIdentityInterface | undefined
const FfiConverterOptionalTypeUserIdentity = new FfiConverterOptional(
  FfiConverterTypeUserIdentity
);

// FfiConverter for Array<RoomHero> | undefined
const FfiConverterOptionalArrayTypeRoomHero = new FfiConverterOptional(
  FfiConverterArrayTypeRoomHero
);

// FfiConverter for Array<RoomMember> | undefined
const FfiConverterOptionalArrayTypeRoomMember = new FfiConverterOptional(
  FfiConverterArrayTypeRoomMember
);

// FfiConverter for Array<string> | undefined
const FfiConverterOptionalArrayString = new FfiConverterOptional(
  FfiConverterArrayString
);

// FfiConverter for Array<AllowRule>
const FfiConverterArrayTypeAllowRule = new FfiConverterArray(
  FfiConverterTypeAllowRule
);

// FfiConverter for Array<FilterTimelineEventType>
const FfiConverterArrayTypeFilterTimelineEventType = new FfiConverterArray(
  FfiConverterTypeFilterTimelineEventType
);

// FfiConverter for Array<Membership>
const FfiConverterArrayTypeMembership = new FfiConverterArray(
  FfiConverterTypeMembership
);

// FfiConverter for Array<OidcPrompt>
const FfiConverterArrayTypeOidcPrompt = new FfiConverterArray(
  FfiConverterTypeOidcPrompt
);

// FfiConverter for Array<RoomDirectorySearchEntryUpdate>
const FfiConverterArrayTypeRoomDirectorySearchEntryUpdate =
  new FfiConverterArray(FfiConverterTypeRoomDirectorySearchEntryUpdate);

// FfiConverter for Array<RoomListEntriesDynamicFilterKind>
const FfiConverterArrayTypeRoomListEntriesDynamicFilterKind =
  new FfiConverterArray(FfiConverterTypeRoomListEntriesDynamicFilterKind);

// FfiConverter for Array<RoomListEntriesUpdate>
const FfiConverterArrayTypeRoomListEntriesUpdate = new FfiConverterArray(
  FfiConverterTypeRoomListEntriesUpdate
);

// FfiConverter for Array<RoomMessageEventMessageType>
const FfiConverterArrayTypeRoomMessageEventMessageType = new FfiConverterArray(
  FfiConverterTypeRoomMessageEventMessageType
);

// FfiConverter for Array<SlidingSyncVersion>
const FfiConverterArrayTypeSlidingSyncVersion = new FfiConverterArray(
  FfiConverterTypeSlidingSyncVersion
);

// FfiConverter for Array<WidgetEventFilter>
const FfiConverterArrayTypeWidgetEventFilter = new FfiConverterArray(
  FfiConverterTypeWidgetEventFilter
);

// FfiConverter for Array<RoomInterface>
const FfiConverterArrayTypeRoom = new FfiConverterArray(FfiConverterTypeRoom);

// FfiConverter for Array<RoomListItemInterface>
const FfiConverterArrayTypeRoomListItem = new FfiConverterArray(
  FfiConverterTypeRoomListItem
);

// FfiConverter for Array<SessionVerificationEmojiInterface>
const FfiConverterArrayTypeSessionVerificationEmoji = new FfiConverterArray(
  FfiConverterTypeSessionVerificationEmoji
);

// FfiConverter for Array<TimelineDiffInterface>
const FfiConverterArrayTypeTimelineDiff = new FfiConverterArray(
  FfiConverterTypeTimelineDiff
);

// FfiConverter for Array<TimelineItemInterface>
const FfiConverterArrayTypeTimelineItem = new FfiConverterArray(
  FfiConverterTypeTimelineItem
);

// FfiConverter for Array<TimelineItemInterface> | undefined
const FfiConverterOptionalArrayTypeTimelineItem = new FfiConverterOptional(
  FfiConverterArrayTypeTimelineItem
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_matrix_sdk_ffi_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message() !==
    1366
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit() !==
    49747
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id() !==
    15808
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url() !==
    6844
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions() !==
    30181
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid() !==
    54845
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_log_event() !==
    62286
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_log_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known() !==
    21379
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver() !==
    34206
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink() !==
    13776
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink() !==
    46473
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html() !==
    37203
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote() !==
    8938
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown() !==
    58385
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote() !==
    20152
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new() !==
    57839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget() !==
    4988
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from() !==
    49710
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name() !==
    65010
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha() !==
    4038
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_setup_tracing() !==
    45018
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_setup_tracing'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role() !==
    61777
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level() !==
    48532
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth() !==
    6754
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_account_data() !==
    50433
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_account_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_account_url() !==
    42373
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_account_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions() !==
    35296
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url() !==
    27867
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo() !==
    18126
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url() !==
    58990
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account() !==
    39890
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_create_room() !==
    52700
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_create_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_create_room_alias() !==
    54261
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_create_room_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt() !==
    19710
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account() !==
    20658
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher() !==
    45990
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_device_id() !==
    44340
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_device_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_display_name() !==
    56259
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues() !==
    30834
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_encryption() !==
    9657
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_encryption'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room() !==
    5137
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content() !==
    40308
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file() !==
    52604
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail() !==
    52601
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings() !==
    6359
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_profile() !==
    60062
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_profile'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms() !==
    22399
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias() !==
    7674
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id() !==
    36348
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller() !==
    55934
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_url() !==
    50489
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_homeserver() !==
    26427
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_homeserver'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details() !==
    63487
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user() !==
    14588
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users() !==
    49620
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available() !==
    23322
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id() !==
    64032
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias() !==
    18521
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_knock() !==
    48652
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_knock'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_login() !==
    33276
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_login'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email() !==
    11789
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback() !==
    35005
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_logout() !==
    7576
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_logout'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_notification_client() !==
    37308
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_notification_client'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar() !==
    29033
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities() !==
    39651
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias() !==
    3551
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_restore_session() !==
    40455
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_restore_session'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists() !==
    20359
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search() !==
    39855
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_rooms() !==
    29558
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_rooms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_search_users() !==
    42927
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_search_users'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_server() !==
    63276
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_server'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_session() !==
    8085
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_session'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data() !==
    18256
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate() !==
    59796
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name() !==
    15292
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher() !==
    41975
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version() !==
    4957
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login() !==
    34571
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users() !==
    23285
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status() !==
    57403
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_sync_service() !==
    52812
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_sync_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room() !==
    56986
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user() !==
    8489
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar() !==
    64486
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_upload_media() !==
    51195
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_upload_media'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc() !==
    30079
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_user_id() !==
    40531
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_user_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name() !==
    57725
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates() !==
    14763
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups() !==
    44502
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing() !==
    37167
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy() !==
    11959
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build() !==
    56018
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code() !==
    51905
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name() !==
    46627
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh() !==
    43839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates() !==
    47525
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification() !==
    2334
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock() !==
    42214
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url() !==
    28347
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_passphrase() !==
    14286
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_passphrase'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy() !==
    5659
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config() !==
    58783
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement() !==
    2776
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy() !==
    41183
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name() !==
    29096
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url() !==
    30022
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths() !==
    54230
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate() !==
    8576
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder() !==
    39381
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_use_event_cache_persistent_storage() !==
    58836
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_use_event_cache_persistent_storage'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent() !==
    13719
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username() !==
    45302
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server() !==
    45490
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state() !==
    51049
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener() !==
    14246
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key() !==
    58425
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery() !==
    18699
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key() !==
    11864
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups() !==
    55446
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery() !==
    64351
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device() !==
    27955
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recover() !==
    33712
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_recover'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset() !==
    12902
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state() !==
    54051
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener() !==
    36612
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity() !==
    13780
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key() !==
    20380
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity() !==
    20644
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state() !==
    29114
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener() !==
    59806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state() !==
    37503
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks() !==
    41585
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version() !==
    36573
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts() !==
    63396
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login() !==
    46090
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login() !==
    33501
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url() !==
    61326
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type() !==
    43501
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel() !==
    57622
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset() !==
    11997
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event() !==
    51792
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id() !==
    5876
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept() !==
    25656
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline() !==
    65054
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban() !==
    26242
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen() !==
    36036
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info() !==
    55450
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle() !==
    46057
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields() !==
    12518
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path() !==
    16357
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist() !==
    12883
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json() !==
    23306
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediasource_url() !==
    62692
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_mediasource_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification() !==
    2524
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device() !==
    37323
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device() !==
    21251
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules() !==
    60025
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode() !==
    36211
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings() !==
    55295
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules() !==
    19849
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode() !==
    18228
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled() !==
    12210
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled() !==
    533
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled() !==
    13304
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled() !==
    49857
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode() !==
    35399
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled() !==
    16823
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode() !==
    9426
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate() !==
    57636
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled() !==
    11988
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled() !==
    31650
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode() !==
    4135
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled() !==
    56594
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room() !==
    47580
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count() !==
    61905
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants() !==
    41533
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases() !==
    28555
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes() !==
    44206
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url() !==
    34637
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_ban_user() !==
    35046
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_ban_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban() !==
    64711
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite() !==
    62459
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick() !==
    12773
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin() !==
    8341
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other() !==
    13274
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own() !==
    57442
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message() !==
    36743
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state() !==
    19062
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification() !==
    18832
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias() !==
    19786
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft() !==
    39667
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage() !==
    13838
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key() !==
    18081
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_display_name() !==
    64194
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_edit() !==
    61956
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_edit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue() !==
    23914
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels() !==
    54094
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call() !==
    33588
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_heroes() !==
    22313
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_heroes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_id() !==
    61990
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend() !==
    39984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user() !==
    62239
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id() !==
    41133
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count() !==
    1023
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_inviter() !==
    49874
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_inviter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_direct() !==
    16947
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_direct'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted() !==
    55158
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_public() !==
    7336
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_public'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled() !==
    36591
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_space() !==
    16919
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_space'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned() !==
    49186
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_join() !==
    9240
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_join'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count() !==
    55835
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_kick_user() !==
    28600
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_kick_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_leave() !==
    63688
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_leave'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft() !==
    38115
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read() !==
    16004
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink() !==
    36705
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink() !==
    47781
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member() !==
    48980
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_member'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url() !==
    29492
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name() !==
    33206
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_members() !==
    42691
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_members'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync() !==
    3255
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_membership() !==
    26065
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_membership'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_message_filtered_timeline() !==
    32258
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_message_filtered_timeline'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id() !==
    39510
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_pinned_events_timeline() !==
    29596
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_pinned_events_timeline'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_raw_name() !==
    15453
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_raw_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_redact() !==
    45810
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_redact'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar() !==
    7230
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_report_content() !==
    16529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_report_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels() !==
    63622
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string() !==
    37832
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_room_info() !==
    41146
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_room_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft() !==
    62232
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification() !==
    43366
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed() !==
    53551
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_send_raw() !==
    20486
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_send_raw'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite() !==
    64403
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority() !==
    48070
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_name() !==
    52127
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_topic() !==
    5576
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_topic'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag() !==
    2381
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes() !==
    14290
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests() !==
    30649
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates() !==
    48209
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications() !==
    38524
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user() !==
    47787
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_timeline() !==
    701
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_timeline'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_timeline_focused_on_event() !==
    27319
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_timeline_focused_on_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_topic() !==
    59745
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_topic'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice() !==
    28642
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_unban_user() !==
    1803
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_unban_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users() !==
    52057
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar() !==
    19069
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend() !==
    33485
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page() !==
    34221
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages() !==
    2923
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page() !==
    29305
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results() !==
    30207
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search() !==
    24438
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters() !==
    36097
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state() !==
    21585
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_room() !==
    8801
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlist_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page() !==
    47748
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page() !==
    61352
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter() !==
    61202
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller() !==
    36258
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream() !==
    56632
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_avatar_url() !==
    39097
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_avatar_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_canonical_alias() !==
    63300
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_canonical_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_display_name() !==
    8651
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_full_room() !==
    17298
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_full_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_id() !==
    41176
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_init_timeline() !==
    61817
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_init_timeline'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_invited_room() !==
    44344
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_invited_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_direct() !==
    46873
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_direct'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_encrypted() !==
    65150
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_encrypted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_timeline_initialized() !==
    46855
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_timeline_initialized'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_latest_event() !==
    38259
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_latest_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_membership() !==
    1596
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_membership'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_preview_room() !==
    32277
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_preview_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_room_info() !==
    32985
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_room_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms() !==
    49704
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room() !==
    5185
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state() !==
    64650
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms() !==
    59765
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator() !==
    16821
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len() !==
    39835
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk() !==
    23186
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions() !==
    8867
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_info() !==
    9145
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roompreview_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter() !==
    1297
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave() !==
    5096
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel() !==
    62384
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join() !==
    1903
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort() !==
    11570
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend() !==
    28691
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request() !==
    53466
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request() !==
    37982
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification() !==
    27140
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification() !==
    32994
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification() !==
    64345
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_verification() !==
    17229
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate() !==
    42324
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification() !==
    16328
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description() !==
    21346
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol() !==
    46075
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_span_enter() !==
    8900
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_span_enter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_span_exit() !==
    47924
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_span_exit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_span_is_none() !==
    33327
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_span_is_none'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish() !==
    64706
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url() !==
    10889
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service() !==
    26426
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_start() !==
    16010
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservice_start'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_state() !==
    61806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservice_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop() !==
    23138
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish() !==
    22814
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock() !==
    56326
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_utd_hook() !==
    9029
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_utd_hook'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel() !==
    9124
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished() !==
    29008
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener() !==
    18746
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content() !==
    21811
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll() !==
    37925
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_edit() !==
    42189
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_edit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll() !==
    61329
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event() !==
    54068
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members() !==
    37994
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_focused_paginate_forwards() !==
    51003
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_focused_paginate_forwards'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id() !==
    33999
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details() !==
    54225
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read() !==
    16621
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards() !==
    65175
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event() !==
    41687
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event() !==
    48707
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption() !==
    21112
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send() !==
    9553
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio() !==
    43163
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file() !==
    37925
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image() !==
    45681
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location() !==
    47400
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response() !==
    7453
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt() !==
    37532
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply() !==
    64747
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video() !==
    22670
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message() !==
    58509
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status() !==
    46161
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction() !==
    29303
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event() !==
    52414
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append() !==
    8453
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change() !==
    4562
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert() !==
    26630
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back() !==
    53464
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front() !==
    42084
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove() !==
    74
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset() !==
    34118
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set() !==
    13334
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate() !==
    34040
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id() !==
    11088
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type() !==
    12922
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id() !==
    18142
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp() !==
    58123
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event() !==
    6106
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual() !==
    50960
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug() !==
    38094
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id() !==
    39945
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications() !==
    33024
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count() !==
    35997
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count() !==
    35655
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified() !==
    61954
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key() !==
    4041
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin() !==
    62925
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run() !==
    7519
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv() !==
    2662
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send() !==
    18689
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new() !==
    27991
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json() !==
    10564
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url() !==
    11983
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes() !==
    32675
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_span_current() !==
    53698
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_span_current'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_span_new() !==
    14105
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_span_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude() !==
    53805
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include() !==
    25498
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update() !==
    12849
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update() !==
    41052
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error() !==
    26350
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_refresh_tokens() !==
    16325
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_refresh_tokens'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain() !==
    43954
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain() !==
    53223
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update() !==
    13538
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call() !==
    57311
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call() !==
    47519
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call() !==
    10077
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change() !==
    51708
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update() !==
    29884
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress() !==
    41133
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update() !==
    9758
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update() !==
    64575
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update() !==
    41968
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call() !==
    44934
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update() !==
    12576
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update() !==
    23169
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update() !==
    24823
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update() !==
    36937
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error() !==
    38224
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request() !==
    3417
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request() !==
    3733
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification() !==
    56833
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data() !==
    30840
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail() !==
    32164
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel() !==
    3367
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish() !==
    37905
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update() !==
    62231
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update() !==
    30147
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call() !==
    64299
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd() !==
    61791
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update() !==
    38998
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities() !==
    12846
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities'
    );
  }

  uniffiCallbackInterfaceBackupStateListener.register();
  uniffiCallbackInterfaceBackupSteadyStateListener.register();
  uniffiCallbackInterfaceClientDelegate.register();
  uniffiCallbackInterfaceClientSessionDelegate.register();
  uniffiCallbackInterfaceEnableRecoveryProgressListener.register();
  uniffiCallbackInterfaceIdentityStatusChangeListener.register();
  uniffiCallbackInterfaceIgnoredUsersListener.register();
  uniffiCallbackInterfaceKnockRequestsListener.register();
  uniffiCallbackInterfaceNotificationSettingsDelegate.register();
  uniffiCallbackInterfacePaginationStatusListener.register();
  uniffiCallbackInterfaceProgressWatcher.register();
  uniffiCallbackInterfaceQrLoginProgressListener.register();
  uniffiCallbackInterfaceRecoveryStateListener.register();
  uniffiCallbackInterfaceRoomDirectorySearchEntriesListener.register();
  uniffiCallbackInterfaceRoomInfoListener.register();
  uniffiCallbackInterfaceRoomListEntriesListener.register();
  uniffiCallbackInterfaceRoomListLoadingStateListener.register();
  uniffiCallbackInterfaceRoomListServiceStateListener.register();
  uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.register();
  uniffiCallbackInterfaceSendQueueRoomErrorListener.register();
  uniffiCallbackInterfaceSessionVerificationControllerDelegate.register();
  uniffiCallbackInterfaceSyncServiceStateObserver.register();
  uniffiCallbackInterfaceTimelineListener.register();
  uniffiCallbackInterfaceTypingNotificationsListener.register();
  uniffiCallbackInterfaceUnableToDecryptDelegate.register();
  uniffiCallbackInterfaceVerificationStateListener.register();
  uniffiCallbackInterfaceWidgetCapabilitiesProvider.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAccountManagementAction,
    FfiConverterTypeAllowRule,
    FfiConverterTypeAssetType,
    FfiConverterTypeAudioInfo,
    FfiConverterTypeAudioMessageContent,
    FfiConverterTypeAuthData,
    FfiConverterTypeAuthDataPasswordDetails,
    FfiConverterTypeBackupState,
    FfiConverterTypeBackupUploadState,
    FfiConverterTypeClient,
    FfiConverterTypeClientBuilder,
    FfiConverterTypeClientProperties,
    FfiConverterTypeComposerDraft,
    FfiConverterTypeComposerDraftType,
    FfiConverterTypeCreateRoomParameters,
    FfiConverterTypeCrossSigningResetAuthType,
    FfiConverterTypeDateDividerMode,
    FfiConverterTypeEditedContent,
    FfiConverterTypeElementCallWellKnown,
    FfiConverterTypeElementWellKnown,
    FfiConverterTypeEmoteMessageContent,
    FfiConverterTypeEnableRecoveryProgress,
    FfiConverterTypeEncryptedMessage,
    FfiConverterTypeEncryption,
    FfiConverterTypeEncryptionSystem,
    FfiConverterTypeEventOrTransactionId,
    FfiConverterTypeEventSendState,
    FfiConverterTypeEventTimelineItem,
    FfiConverterTypeEventTimelineItemDebugInfo,
    FfiConverterTypeFileInfo,
    FfiConverterTypeFileMessageContent,
    FfiConverterTypeFilterTimelineEventType,
    FfiConverterTypeFormattedBody,
    FfiConverterTypeHomeserverLoginDetails,
    FfiConverterTypeHttpPusherData,
    FfiConverterTypeIdentityResetHandle,
    FfiConverterTypeIdentityStatusChange,
    FfiConverterTypeImageInfo,
    FfiConverterTypeImageMessageContent,
    FfiConverterTypeInReplyToDetails,
    FfiConverterTypeInsertData,
    FfiConverterTypeJoinRule,
    FfiConverterTypeKnockRequest,
    FfiConverterTypeKnockRequestActions,
    FfiConverterTypeLazyTimelineItemProvider,
    FfiConverterTypeLocationContent,
    FfiConverterTypeLogLevel,
    FfiConverterTypeMatrixEntity,
    FfiConverterTypeMatrixId,
    FfiConverterTypeMediaFileHandle,
    FfiConverterTypeMediaSource,
    FfiConverterTypeMembership,
    FfiConverterTypeMembershipChange,
    FfiConverterTypeMembershipState,
    FfiConverterTypeMentions,
    FfiConverterTypeMessageContent,
    FfiConverterTypeMessageFormat,
    FfiConverterTypeMessageLikeEventContent,
    FfiConverterTypeMessageLikeEventType,
    FfiConverterTypeMessageType,
    FfiConverterTypeNoticeMessageContent,
    FfiConverterTypeNotificationClient,
    FfiConverterTypeNotificationEvent,
    FfiConverterTypeNotificationItem,
    FfiConverterTypeNotificationPowerLevels,
    FfiConverterTypeNotificationProcessSetup,
    FfiConverterTypeNotificationRoomInfo,
    FfiConverterTypeNotificationSenderInfo,
    FfiConverterTypeNotificationSettings,
    FfiConverterTypeNotifyType,
    FfiConverterTypeOidcConfiguration,
    FfiConverterTypeOidcCrossSigningResetInfo,
    FfiConverterTypeOidcPrompt,
    FfiConverterTypeOtherState,
    FfiConverterTypePollAnswer,
    FfiConverterTypePollData,
    FfiConverterTypePollKind,
    FfiConverterTypePowerLevels,
    FfiConverterTypeProfileDetails,
    FfiConverterTypePublicRoomJoinRule,
    FfiConverterTypePushFormat,
    FfiConverterTypePusherIdentifiers,
    FfiConverterTypePusherKind,
    FfiConverterTypeQrCodeData,
    FfiConverterTypeQrLoginProgress,
    FfiConverterTypeQueueWedgeError,
    FfiConverterTypeReaction,
    FfiConverterTypeReactionSenderData,
    FfiConverterTypeReceipt,
    FfiConverterTypeReceiptType,
    FfiConverterTypeRecoveryState,
    FfiConverterTypeRepliedToEventDetails,
    FfiConverterTypeRequestConfig,
    FfiConverterTypeResolvedRoomAlias,
    FfiConverterTypeRoom,
    FfiConverterTypeRoomDescription,
    FfiConverterTypeRoomDirectorySearch,
    FfiConverterTypeRoomDirectorySearchEntriesResult,
    FfiConverterTypeRoomDirectorySearchEntryUpdate,
    FfiConverterTypeRoomHero,
    FfiConverterTypeRoomInfo,
    FfiConverterTypeRoomList,
    FfiConverterTypeRoomListDynamicEntriesController,
    FfiConverterTypeRoomListEntriesDynamicFilterKind,
    FfiConverterTypeRoomListEntriesUpdate,
    FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult,
    FfiConverterTypeRoomListFilterCategory,
    FfiConverterTypeRoomListItem,
    FfiConverterTypeRoomListLoadingState,
    FfiConverterTypeRoomListLoadingStateResult,
    FfiConverterTypeRoomListService,
    FfiConverterTypeRoomListServiceState,
    FfiConverterTypeRoomListServiceSyncIndicator,
    FfiConverterTypeRoomMember,
    FfiConverterTypeRoomMembersIterator,
    FfiConverterTypeRoomMessageEventContentWithoutRelation,
    FfiConverterTypeRoomMessageEventMessageType,
    FfiConverterTypeRoomNotificationMode,
    FfiConverterTypeRoomNotificationSettings,
    FfiConverterTypeRoomPowerLevels,
    FfiConverterTypeRoomPreset,
    FfiConverterTypeRoomPreview,
    FfiConverterTypeRoomPreviewInfo,
    FfiConverterTypeRoomType,
    FfiConverterTypeRoomVisibility,
    FfiConverterTypeRtcApplicationType,
    FfiConverterTypeSearchUsersResults,
    FfiConverterTypeSendAttachmentJoinHandle,
    FfiConverterTypeSendHandle,
    FfiConverterTypeSession,
    FfiConverterTypeSessionVerificationController,
    FfiConverterTypeSessionVerificationData,
    FfiConverterTypeSessionVerificationEmoji,
    FfiConverterTypeSessionVerificationRequestDetails,
    FfiConverterTypeSetData,
    FfiConverterTypeShieldState,
    FfiConverterTypeSlidingSyncVersion,
    FfiConverterTypeSlidingSyncVersionBuilder,
    FfiConverterTypeSpan,
    FfiConverterTypeSsoHandler,
    FfiConverterTypeStateEventContent,
    FfiConverterTypeStateEventType,
    FfiConverterTypeSyncService,
    FfiConverterTypeSyncServiceBuilder,
    FfiConverterTypeSyncServiceState,
    FfiConverterTypeTaskHandle,
    FfiConverterTypeTextMessageContent,
    FfiConverterTypeThumbnailInfo,
    FfiConverterTypeTimeline,
    FfiConverterTypeTimelineChange,
    FfiConverterTypeTimelineDiff,
    FfiConverterTypeTimelineEvent,
    FfiConverterTypeTimelineEventType,
    FfiConverterTypeTimelineEventTypeFilter,
    FfiConverterTypeTimelineItem,
    FfiConverterTypeTimelineItemContent,
    FfiConverterTypeTimelineUniqueId,
    FfiConverterTypeTracingConfiguration,
    FfiConverterTypeTracingFileConfiguration,
    FfiConverterTypeTransmissionProgress,
    FfiConverterTypeUnableToDecryptInfo,
    FfiConverterTypeUnreadNotificationsCount,
    FfiConverterTypeUnstableAudioDetailsContent,
    FfiConverterTypeUnstableVoiceContent,
    FfiConverterTypeUserIdentity,
    FfiConverterTypeUserPowerLevelUpdate,
    FfiConverterTypeUserProfile,
    FfiConverterTypeVerificationState,
    FfiConverterTypeVideoInfo,
    FfiConverterTypeVideoMessageContent,
    FfiConverterTypeVirtualElementCallWidgetOptions,
    FfiConverterTypeVirtualTimelineItem,
    FfiConverterTypeWidgetCapabilities,
    FfiConverterTypeWidgetDriver,
    FfiConverterTypeWidgetDriverAndHandle,
    FfiConverterTypeWidgetDriverHandle,
    FfiConverterTypeWidgetEventFilter,
    FfiConverterTypeWidgetSettings,
  },
});
