// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceAccountDataListener,
  type UniffiVTableCallbackInterfaceBackupStateListener,
  type UniffiVTableCallbackInterfaceBackupSteadyStateListener,
  type UniffiVTableCallbackInterfaceClientDelegate,
  type UniffiVTableCallbackInterfaceClientSessionDelegate,
  type UniffiVTableCallbackInterfaceEnableRecoveryProgressListener,
  type UniffiVTableCallbackInterfaceIdentityStatusChangeListener,
  type UniffiVTableCallbackInterfaceIgnoredUsersListener,
  type UniffiVTableCallbackInterfaceKnockRequestsListener,
  type UniffiVTableCallbackInterfaceLiveLocationShareListener,
  type UniffiVTableCallbackInterfaceMediaPreviewConfigListener,
  type UniffiVTableCallbackInterfaceNotificationSettingsDelegate,
  type UniffiVTableCallbackInterfacePaginationStatusListener,
  type UniffiVTableCallbackInterfaceProgressWatcher,
  type UniffiVTableCallbackInterfaceQrLoginProgressListener,
  type UniffiVTableCallbackInterfaceRecoveryStateListener,
  type UniffiVTableCallbackInterfaceRoomAccountDataListener,
  type UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener,
  type UniffiVTableCallbackInterfaceRoomInfoListener,
  type UniffiVTableCallbackInterfaceRoomListEntriesListener,
  type UniffiVTableCallbackInterfaceRoomListLoadingStateListener,
  type UniffiVTableCallbackInterfaceRoomListServiceStateListener,
  type UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener,
  type UniffiVTableCallbackInterfaceSendQueueRoomErrorListener,
  type UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate,
  type UniffiVTableCallbackInterfaceSyncServiceStateObserver,
  type UniffiVTableCallbackInterfaceTimelineListener,
  type UniffiVTableCallbackInterfaceTypingNotificationsListener,
  type UniffiVTableCallbackInterfaceUnableToDecryptDelegate,
  type UniffiVTableCallbackInterfaceVerificationStateListener,
  type UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider,
} from './matrix_sdk_ffi-ffi';
import {
  type OAuthAuthorizationDataInterface,
  type RoomPowerLevelChanges,
  BackupDownloadStrategy,
  RoomMemberRole,
  RoomPaginationStatus,
} from './matrix_sdk';
import { type MediaRetentionPolicy, EncryptionState } from './matrix_sdk_base';
import { ShieldStateCode } from './matrix_sdk_common';
import {
  CollectStrategy,
  IdentityState,
  TrustRequirement,
  UtdCause,
} from './matrix_sdk_crypto';
import { EventItemOrigin, RoomPinnedEventsChange } from './matrix_sdk_ui';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiDuration,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterDuration,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt64,
  FfiConverterUInt8,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCall,
  uniffiTraitInterfaceCallWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
import uniffiMatrixSdkModule from './matrix_sdk';
import uniffiMatrixSdkBaseModule from './matrix_sdk_base';
import uniffiMatrixSdkCommonModule from './matrix_sdk_common';
import uniffiMatrixSdkCryptoModule from './matrix_sdk_crypto';
import uniffiMatrixSdkUiModule from './matrix_sdk_ui';
const {
  FfiConverterTypeBackupDownloadStrategy,
  FfiConverterTypeOAuthAuthorizationData,
  FfiConverterTypeRoomMemberRole,
  FfiConverterTypeRoomPaginationStatus,
  FfiConverterTypeRoomPowerLevelChanges,
} = uniffiMatrixSdkModule.converters;
const {
  FfiConverterTypeEncryptionState,
  FfiConverterTypeMediaRetentionPolicy,
} = uniffiMatrixSdkBaseModule.converters;
const { FfiConverterTypeShieldStateCode } =
  uniffiMatrixSdkCommonModule.converters;
const {
  FfiConverterTypeCollectStrategy,
  FfiConverterTypeIdentityState,
  FfiConverterTypeTrustRequirement,
  FfiConverterTypeUtdCause,
} = uniffiMatrixSdkCryptoModule.converters;
const {
  FfiConverterTypeEventItemOrigin,
  FfiConverterTypeRoomPinnedEventsChange,
} = uniffiMatrixSdkUiModule.converters;
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Creates a [`RoomMessageEventContentWithoutRelation`] given a
 * [`MessageContent`] value.
 */
export function contentWithoutRelationFromMessage(
  message: MessageContent
): RoomMessageEventContentWithoutRelationInterface /*throws*/ {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(
          FfiConverterTypeMessageContent.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Create a caption edit.
 *
 * If no `formatted_caption` is provided, then it's assumed the `caption`
 * represents valid Markdown that can be used as the formatted caption.
 */
export function createCaptionEdit(
  caption: string | undefined,
  formattedCaption: FormattedBody | undefined,
  mentions: Mentions | undefined
): EditedContent {
  return FfiConverterTypeEditedContent.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(
          FfiConverterOptionalString.lower(caption),
          FfiConverterOptionalTypeFormattedBody.lower(formattedCaption),
          FfiConverterOptionalTypeMentions.lower(mentions),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Set the global enablement level for the Sentry layer (after the logs have
 * been set up).
 */
export function enableSentryLogging(enabled: boolean): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_enable_sentry_logging(
        FfiConverterBool.lower(enabled),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
export function genTransactionId(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Create the actual url that can be used to setup the WebView or IFrame
 * that contains the widget.
 *
 * # Arguments
 * * `widget_settings` - The widget settings to generate the url for.
 * * `room` - A Matrix room which is used to query the logged in username
 * * `props` - Properties from the client that can be used by a widget to adapt
 * to the client. e.g. language, font-scale...
 */
export async function generateWebviewUrl(
  widgetSettings: WidgetSettings,
  room: RoomInterface,
  props: ClientProperties,
  asyncOpts_?: { signal: AbortSignal }
): Promise<string> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(
          FfiConverterTypeWidgetSettings.lower(widgetSettings),
          FfiConverterTypeRoom.lower(room),
          FfiConverterTypeClientProperties.lower(props)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeParseError.lift.bind(
        FfiConverterTypeParseError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * The Capabilities required to run a element call widget.
 *
 * This is intended to be used in combination with: `acquire_capabilities` of
 * the `CapabilitiesProvider`.
 *
 * `acquire_capabilities` can simply return the `WidgetCapabilities` from this
 * function. Even if there are non intersecting permissions to what the widget
 * requested.
 *
 * Editing and extending the capabilities from this function is also possible,
 * but should only be done as temporal workarounds until this function is
 * adjusted
 */
export function getElementCallRequiredPermissions(
  ownUserId: string,
  ownDeviceId: string
): WidgetCapabilities {
  return FfiConverterTypeWidgetCapabilities.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(
          FfiConverterString.lower(ownUserId),
          FfiConverterString.lower(ownDeviceId),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Sets up logs and the tokio runtime for the current application.
 *
 * If `use_lightweight_tokio_runtime` is set to true, this will set up a
 * lightweight tokio runtime, for processes that have memory limitations (like
 * the NSE process on iOS). Otherwise, this can remain false, in which case a
 * multithreaded tokio runtime will be set up.
 */
export function initPlatform(
  config: TracingConfiguration,
  useLightweightTokioRuntime: boolean
): void /*throws*/ {
  uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeClientError.lift.bind(
      FfiConverterTypeClientError
    ),
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_init_platform(
        FfiConverterTypeTracingConfiguration.lower(config),
        FfiConverterBool.lower(useLightweightTokioRuntime),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
/**
 * Verifies the passed `String` matches the expected room alias format:
 *
 * This means it's lowercase, with no whitespace chars, has a single leading
 * `#` char and a single `:` separator between the local and domain parts, and
 * the local part only contains characters that can't be percent encoded.
 */
export function isRoomAliasFormatValid(alias: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(
          FfiConverterString.lower(alias),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Log an event.
 *
 * The target should be something like a module path, and can be referenced in
 * the filter string given to `setup_tracing`. `level` and `target` for a
 * callsite are fixed at the first `log_event` call for that callsite and can
 * not be changed afterwards, i.e. the level and target passed for second and
 * following `log_event`s with the same callsite will be ignored.
 *
 * This function leaks a little bit of memory for each unique (file + line +
 * level + target) it is called with. Please make sure that the number of
 * different combinations of those parameters this can be called with is
 * constant in the final executable.
 */
export function logEvent(
  file: string,
  line: /*u32*/ number | undefined,
  level: LogLevel,
  target: string,
  message: string
): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_log_event(
        FfiConverterString.lower(file),
        FfiConverterOptionalUInt32.lower(line),
        FfiConverterTypeLogLevel.lower(level),
        FfiConverterString.lower(target),
        FfiConverterString.lower(message),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
/**
 * Helper function to parse a string into a ElementWellKnown struct
 */
export function makeElementWellKnown(
  string: string
): ElementWellKnown /*throws*/ {
  return FfiConverterTypeElementWellKnown.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_make_element_well_known(
          FfiConverterString.lower(string),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function makeWidgetDriver(
  settings: WidgetSettings
): WidgetDriverAndHandle /*throws*/ {
  return FfiConverterTypeWidgetDriverAndHandle.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeParseError.lift.bind(
        FfiConverterTypeParseError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(
          FfiConverterTypeWidgetSettings.lower(settings),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generates a `matrix.to` permalink to the given room alias.
 */
export function matrixToRoomAliasPermalink(
  roomAlias: string
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(
          FfiConverterString.lower(roomAlias),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generates a `matrix.to` permalink to the given userID.
 */
export function matrixToUserPermalink(userId: string): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(
          FfiConverterString.lower(userId),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentFromHtml(
  body: string,
  htmlBody: string
): RoomMessageEventContentWithoutRelationInterface {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(
          FfiConverterString.lower(body),
          FfiConverterString.lower(htmlBody),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentFromHtmlAsEmote(
  body: string,
  htmlBody: string
): RoomMessageEventContentWithoutRelationInterface {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(
          FfiConverterString.lower(body),
          FfiConverterString.lower(htmlBody),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentFromMarkdown(
  md: string
): RoomMessageEventContentWithoutRelationInterface {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
          FfiConverterString.lower(md),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentFromMarkdownAsEmote(
  md: string
): RoomMessageEventContentWithoutRelationInterface {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(
          FfiConverterString.lower(md),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function messageEventContentNew(
  msgtype: MessageType
): RoomMessageEventContentWithoutRelationInterface /*throws*/ {
  return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeClientError.lift.bind(
        FfiConverterTypeClientError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(
          FfiConverterTypeMessageType.lower(msgtype),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * `WidgetSettings` are usually created from a state event.
 * (currently unimplemented)
 *
 * In some cases the client wants to create custom `WidgetSettings`
 * for specific rooms based on other conditions.
 * This function returns a `WidgetSettings` object which can be used
 * to setup a widget using `run_client_widget_api`
 * and to generate the correct url for the widget.
 *
 * # Arguments
 *
 * * `props` - A struct containing the configuration parameters for a element
 * call widget.
 */
export function newVirtualElementCallWidget(
  props: VirtualElementCallWidgetOptions
): WidgetSettings /*throws*/ {
  return FfiConverterTypeWidgetSettings.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeParseError.lift.bind(
        FfiConverterTypeParseError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(
          FfiConverterTypeVirtualElementCallWidgetOptions.lower(props),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Parse a matrix entity from a given URI, be it either
 * a `matrix.to` link or a `matrix:` URI
 */
export function parseMatrixEntityFrom(uri: string): MatrixEntity | undefined {
  return FfiConverterOptionalTypeMatrixEntity.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(
          FfiConverterString.lower(uri),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Transforms a Room's display name into a valid room alias name.
 */
export function roomAliasNameFromRoomDisplayName(roomName: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(
          FfiConverterString.lower(roomName),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function sdkGitSha(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function suggestedPowerLevelForRole(
  role: RoomMemberRole
): /*i64*/ bigint {
  return FfiConverterInt64.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(
          FfiConverterTypeRoomMemberRole.lower(role),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function suggestedRoleForPowerLevel(
  powerLevel: /*i64*/ bigint
): RoomMemberRole {
  return FfiConverterTypeRoomMemberRole.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(
          FfiConverterInt64.lower(powerLevel),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

/**
 * A listener for changes of global account data events.
 */
export interface AccountDataListener {
  /**
   * Called when a global account data event has changed.
   */
  onChange(event: AccountDataEvent): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceAccountDataListener: {
  vtable: UniffiVTableCallbackInterfaceAccountDataListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onChange: (uniffiHandle: bigint, event: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeAccountDataListener.lift(uniffiHandle);
        return jsCallback.onChange(
          FfiConverterTypeAccountDataEvent.lift(event)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // AccountDataListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeAccountDataListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_accountdatalistener(
      uniffiCallbackInterfaceAccountDataListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeAccountDataListener =
  new FfiConverterCallback<AccountDataListener>();

export interface BackupStateListener {
  onUpdate(status: BackupState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBackupStateListener: {
  vtable: UniffiVTableCallbackInterfaceBackupStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeBackupStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(FfiConverterTypeBackupState.lift(status));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // BackupStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeBackupStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(
      uniffiCallbackInterfaceBackupStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeBackupStateListener =
  new FfiConverterCallback<BackupStateListener>();

export interface BackupSteadyStateListener {
  onUpdate(status: BackupUploadState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBackupSteadyStateListener: {
  vtable: UniffiVTableCallbackInterfaceBackupSteadyStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeBackupSteadyStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeBackupUploadState.lift(status)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // BackupSteadyStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeBackupSteadyStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(
      uniffiCallbackInterfaceBackupSteadyStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeBackupSteadyStateListener =
  new FfiConverterCallback<BackupSteadyStateListener>();

export interface ClientDelegate {
  didReceiveAuthError(isSoftLogout: boolean): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceClientDelegate: {
  vtable: UniffiVTableCallbackInterfaceClientDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    didReceiveAuthError: (uniffiHandle: bigint, isSoftLogout: number) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeClientDelegate.lift(uniffiHandle);
        return jsCallback.didReceiveAuthError(
          FfiConverterBool.lift(isSoftLogout)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // ClientDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeClientDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(
      uniffiCallbackInterfaceClientDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeClientDelegate =
  new FfiConverterCallback<ClientDelegate>();

export interface ClientSessionDelegate {
  retrieveSessionFromKeychain(userId: string) /*throws*/ : Session;
  saveSessionInKeychain(session: Session): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceClientSessionDelegate: {
  vtable: UniffiVTableCallbackInterfaceClientSessionDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    retrieveSessionFromKeychain: (uniffiHandle: bigint, userId: Uint8Array) => {
      const uniffiMakeCall = (): Session => {
        const jsCallback =
          FfiConverterTypeClientSessionDelegate.lift(uniffiHandle);
        return jsCallback.retrieveSessionFromKeychain(
          FfiConverterString.lift(userId)
        );
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterTypeSession.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ClientError.instanceOf,
        /*lowerError:*/ FfiConverterTypeClientError.lower.bind(
          FfiConverterTypeClientError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    saveSessionInKeychain: (uniffiHandle: bigint, session: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeClientSessionDelegate.lift(uniffiHandle);
        return jsCallback.saveSessionInKeychain(
          FfiConverterTypeSession.lift(session)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // ClientSessionDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeClientSessionDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(
      uniffiCallbackInterfaceClientSessionDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeClientSessionDelegate =
  new FfiConverterCallback<ClientSessionDelegate>();

export interface EnableRecoveryProgressListener {
  onUpdate(status: EnableRecoveryProgress): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEnableRecoveryProgressListener: {
  vtable: UniffiVTableCallbackInterfaceEnableRecoveryProgressListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeEnableRecoveryProgressListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeEnableRecoveryProgress.lift(status)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // EnableRecoveryProgressListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeEnableRecoveryProgressListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(
      uniffiCallbackInterfaceEnableRecoveryProgressListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeEnableRecoveryProgressListener =
  new FfiConverterCallback<EnableRecoveryProgressListener>();

export interface IdentityStatusChangeListener {
  call(identityStatusChange: Array<IdentityStatusChange>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceIdentityStatusChangeListener: {
  vtable: UniffiVTableCallbackInterfaceIdentityStatusChangeListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, identityStatusChange: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeIdentityStatusChangeListener.lift(uniffiHandle);
        return jsCallback.call(
          FfiConverterArrayTypeIdentityStatusChange.lift(identityStatusChange)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // IdentityStatusChangeListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeIdentityStatusChangeListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(
      uniffiCallbackInterfaceIdentityStatusChangeListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeIdentityStatusChangeListener =
  new FfiConverterCallback<IdentityStatusChangeListener>();

export interface IgnoredUsersListener {
  call(ignoredUserIds: Array<string>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceIgnoredUsersListener: {
  vtable: UniffiVTableCallbackInterfaceIgnoredUsersListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, ignoredUserIds: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeIgnoredUsersListener.lift(uniffiHandle);
        return jsCallback.call(FfiConverterArrayString.lift(ignoredUserIds));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // IgnoredUsersListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeIgnoredUsersListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(
      uniffiCallbackInterfaceIgnoredUsersListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeIgnoredUsersListener =
  new FfiConverterCallback<IgnoredUsersListener>();

/**
 * A listener for receiving new requests to a join a room.
 */
export interface KnockRequestsListener {
  call(joinRequests: Array<KnockRequest>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceKnockRequestsListener: {
  vtable: UniffiVTableCallbackInterfaceKnockRequestsListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, joinRequests: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeKnockRequestsListener.lift(uniffiHandle);
        return jsCallback.call(
          FfiConverterArrayTypeKnockRequest.lift(joinRequests)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // KnockRequestsListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeKnockRequestsListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(
      uniffiCallbackInterfaceKnockRequestsListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeKnockRequestsListener =
  new FfiConverterCallback<KnockRequestsListener>();

/**
 * A listener for receiving new live location shares in a room.
 */
export interface LiveLocationShareListener {
  call(liveLocationShares: Array<LiveLocationShare>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLiveLocationShareListener: {
  vtable: UniffiVTableCallbackInterfaceLiveLocationShareListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, liveLocationShares: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeLiveLocationShareListener.lift(uniffiHandle);
        return jsCallback.call(
          FfiConverterArrayTypeLiveLocationShare.lift(liveLocationShares)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // LiveLocationShareListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeLiveLocationShareListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_livelocationsharelistener(
      uniffiCallbackInterfaceLiveLocationShareListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeLiveLocationShareListener =
  new FfiConverterCallback<LiveLocationShareListener>();

export interface MediaPreviewConfigListener {
  onChange(mediaPreviewConfig: MediaPreviewConfig | undefined): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceMediaPreviewConfigListener: {
  vtable: UniffiVTableCallbackInterfaceMediaPreviewConfigListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onChange: (uniffiHandle: bigint, mediaPreviewConfig: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeMediaPreviewConfigListener.lift(uniffiHandle);
        return jsCallback.onChange(
          FfiConverterOptionalTypeMediaPreviewConfig.lift(mediaPreviewConfig)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // MediaPreviewConfigListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeMediaPreviewConfigListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_mediapreviewconfiglistener(
      uniffiCallbackInterfaceMediaPreviewConfigListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeMediaPreviewConfigListener =
  new FfiConverterCallback<MediaPreviewConfigListener>();

/**
 * Delegate to notify of changes in push rules
 */
export interface NotificationSettingsDelegate {
  settingsDidChange(): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceNotificationSettingsDelegate: {
  vtable: UniffiVTableCallbackInterfaceNotificationSettingsDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    settingsDidChange: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeNotificationSettingsDelegate.lift(uniffiHandle);
        return jsCallback.settingsDidChange();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // NotificationSettingsDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeNotificationSettingsDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(
      uniffiCallbackInterfaceNotificationSettingsDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeNotificationSettingsDelegate =
  new FfiConverterCallback<NotificationSettingsDelegate>();

export interface PaginationStatusListener {
  onUpdate(status: RoomPaginationStatus): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePaginationStatusListener: {
  vtable: UniffiVTableCallbackInterfacePaginationStatusListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypePaginationStatusListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeRoomPaginationStatus.lift(status)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // PaginationStatusListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypePaginationStatusListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(
      uniffiCallbackInterfacePaginationStatusListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypePaginationStatusListener =
  new FfiConverterCallback<PaginationStatusListener>();

export interface ProgressWatcher {
  transmissionProgress(progress: TransmissionProgress): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceProgressWatcher: {
  vtable: UniffiVTableCallbackInterfaceProgressWatcher;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    transmissionProgress: (uniffiHandle: bigint, progress: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeProgressWatcher.lift(uniffiHandle);
        return jsCallback.transmissionProgress(
          FfiConverterTypeTransmissionProgress.lift(progress)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // ProgressWatcher: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeProgressWatcher.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(
      uniffiCallbackInterfaceProgressWatcher.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeProgressWatcher =
  new FfiConverterCallback<ProgressWatcher>();

export interface QrLoginProgressListener {
  onUpdate(state: QrLoginProgress): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceQrLoginProgressListener: {
  vtable: UniffiVTableCallbackInterfaceQrLoginProgressListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, state: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeQrLoginProgressListener.lift(uniffiHandle);
        return jsCallback.onUpdate(FfiConverterTypeQrLoginProgress.lift(state));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // QrLoginProgressListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeQrLoginProgressListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(
      uniffiCallbackInterfaceQrLoginProgressListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeQrLoginProgressListener =
  new FfiConverterCallback<QrLoginProgressListener>();

export interface RecoveryStateListener {
  onUpdate(status: RecoveryState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRecoveryStateListener: {
  vtable: UniffiVTableCallbackInterfaceRecoveryStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRecoveryStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(FfiConverterTypeRecoveryState.lift(status));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RecoveryStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRecoveryStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(
      uniffiCallbackInterfaceRecoveryStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRecoveryStateListener =
  new FfiConverterCallback<RecoveryStateListener>();

/**
 * A listener for changes of room account data events.
 */
export interface RoomAccountDataListener {
  /**
   * Called when a room account data event was changed.
   */
  onChange(event: RoomAccountDataEvent, roomId: string): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomAccountDataListener: {
  vtable: UniffiVTableCallbackInterfaceRoomAccountDataListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onChange: (uniffiHandle: bigint, event: Uint8Array, roomId: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomAccountDataListener.lift(uniffiHandle);
        return jsCallback.onChange(
          FfiConverterTypeRoomAccountDataEvent.lift(event),
          FfiConverterString.lift(roomId)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomAccountDataListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomAccountDataListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomaccountdatalistener(
      uniffiCallbackInterfaceRoomAccountDataListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomAccountDataListener =
  new FfiConverterCallback<RoomAccountDataListener>();

export interface RoomDirectorySearchEntriesListener {
  onUpdate(roomEntriesUpdate: Array<RoomDirectorySearchEntryUpdate>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomDirectorySearchEntriesListener: {
  vtable: UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, roomEntriesUpdate: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomDirectorySearchEntriesListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterArrayTypeRoomDirectorySearchEntryUpdate.lift(
            roomEntriesUpdate
          )
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomDirectorySearchEntriesListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomDirectorySearchEntriesListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(
      uniffiCallbackInterfaceRoomDirectorySearchEntriesListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomDirectorySearchEntriesListener =
  new FfiConverterCallback<RoomDirectorySearchEntriesListener>();

export interface RoomInfoListener {
  call(roomInfo: RoomInfo): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomInfoListener: {
  vtable: UniffiVTableCallbackInterfaceRoomInfoListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, roomInfo: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeRoomInfoListener.lift(uniffiHandle);
        return jsCallback.call(FfiConverterTypeRoomInfo.lift(roomInfo));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomInfoListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomInfoListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(
      uniffiCallbackInterfaceRoomInfoListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomInfoListener =
  new FfiConverterCallback<RoomInfoListener>();

export interface RoomListEntriesListener {
  onUpdate(roomEntriesUpdate: Array<RoomListEntriesUpdate>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListEntriesListener: {
  vtable: UniffiVTableCallbackInterfaceRoomListEntriesListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, roomEntriesUpdate: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomListEntriesListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterArrayTypeRoomListEntriesUpdate.lift(roomEntriesUpdate)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomListEntriesListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomListEntriesListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(
      uniffiCallbackInterfaceRoomListEntriesListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListEntriesListener =
  new FfiConverterCallback<RoomListEntriesListener>();

export interface RoomListLoadingStateListener {
  onUpdate(state: RoomListLoadingState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListLoadingStateListener: {
  vtable: UniffiVTableCallbackInterfaceRoomListLoadingStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, state: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomListLoadingStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeRoomListLoadingState.lift(state)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomListLoadingStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomListLoadingStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(
      uniffiCallbackInterfaceRoomListLoadingStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListLoadingStateListener =
  new FfiConverterCallback<RoomListLoadingStateListener>();

export interface RoomListServiceStateListener {
  onUpdate(state: RoomListServiceState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListServiceStateListener: {
  vtable: UniffiVTableCallbackInterfaceRoomListServiceStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, state: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomListServiceStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeRoomListServiceState.lift(state)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomListServiceStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomListServiceStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(
      uniffiCallbackInterfaceRoomListServiceStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListServiceStateListener =
  new FfiConverterCallback<RoomListServiceStateListener>();

export interface RoomListServiceSyncIndicatorListener {
  onUpdate(syncIndicator: RoomListServiceSyncIndicator): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener: {
  vtable: UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, syncIndicator: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeRoomListServiceSyncIndicatorListener.lift(
            uniffiHandle
          );
        return jsCallback.onUpdate(
          FfiConverterTypeRoomListServiceSyncIndicator.lift(syncIndicator)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RoomListServiceSyncIndicatorListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRoomListServiceSyncIndicatorListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(
      uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListServiceSyncIndicatorListener =
  new FfiConverterCallback<RoomListServiceSyncIndicatorListener>();

/**
 * A listener to the global (client-wide) error reporter of the send queue.
 */
export interface SendQueueRoomErrorListener {
  /**
   * Called every time the send queue has ran into an error for a given room,
   * which will disable the send queue for that particular room.
   */
  onError(roomId: string, error: ClientError): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSendQueueRoomErrorListener: {
  vtable: UniffiVTableCallbackInterfaceSendQueueRoomErrorListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onError: (uniffiHandle: bigint, roomId: Uint8Array, error: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSendQueueRoomErrorListener.lift(uniffiHandle);
        return jsCallback.onError(
          FfiConverterString.lift(roomId),
          FfiConverterTypeClientError.lift(error)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // SendQueueRoomErrorListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeSendQueueRoomErrorListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(
      uniffiCallbackInterfaceSendQueueRoomErrorListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeSendQueueRoomErrorListener =
  new FfiConverterCallback<SendQueueRoomErrorListener>();

export interface SessionVerificationControllerDelegate {
  didReceiveVerificationRequest(
    details: SessionVerificationRequestDetails
  ): void;
  didAcceptVerificationRequest(): void;
  didStartSasVerification(): void;
  didReceiveVerificationData(data: SessionVerificationData): void;
  didFail(): void;
  didCancel(): void;
  didFinish(): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSessionVerificationControllerDelegate: {
  vtable: UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    didReceiveVerificationRequest: (
      uniffiHandle: bigint,
      details: Uint8Array
    ) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didReceiveVerificationRequest(
          FfiConverterTypeSessionVerificationRequestDetails.lift(details)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didAcceptVerificationRequest: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didAcceptVerificationRequest();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didStartSasVerification: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didStartSasVerification();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didReceiveVerificationData: (uniffiHandle: bigint, data: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didReceiveVerificationData(
          FfiConverterTypeSessionVerificationData.lift(data)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didFail: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didFail();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didCancel: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didCancel();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    didFinish: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSessionVerificationControllerDelegate.lift(
            uniffiHandle
          );
        return jsCallback.didFinish();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // SessionVerificationControllerDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeSessionVerificationControllerDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(
      uniffiCallbackInterfaceSessionVerificationControllerDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeSessionVerificationControllerDelegate =
  new FfiConverterCallback<SessionVerificationControllerDelegate>();

export interface SyncServiceStateObserver {
  onUpdate(state: SyncServiceState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSyncServiceStateObserver: {
  vtable: UniffiVTableCallbackInterfaceSyncServiceStateObserver;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, state: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeSyncServiceStateObserver.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeSyncServiceState.lift(state)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // SyncServiceStateObserver: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeSyncServiceStateObserver.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(
      uniffiCallbackInterfaceSyncServiceStateObserver.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeSyncServiceStateObserver =
  new FfiConverterCallback<SyncServiceStateObserver>();

export interface TimelineListener {
  onUpdate(diff: Array<TimelineDiffInterface>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceTimelineListener: {
  vtable: UniffiVTableCallbackInterfaceTimelineListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, diff: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeTimelineListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterArrayTypeTimelineDiff.lift(diff)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // TimelineListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeTimelineListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(
      uniffiCallbackInterfaceTimelineListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeTimelineListener =
  new FfiConverterCallback<TimelineListener>();

export interface TypingNotificationsListener {
  call(typingUserIds: Array<string>): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceTypingNotificationsListener: {
  vtable: UniffiVTableCallbackInterfaceTypingNotificationsListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    call: (uniffiHandle: bigint, typingUserIds: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeTypingNotificationsListener.lift(uniffiHandle);
        return jsCallback.call(FfiConverterArrayString.lift(typingUserIds));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // TypingNotificationsListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeTypingNotificationsListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(
      uniffiCallbackInterfaceTypingNotificationsListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeTypingNotificationsListener =
  new FfiConverterCallback<TypingNotificationsListener>();

export interface UnableToDecryptDelegate {
  onUtd(info: UnableToDecryptInfo): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceUnableToDecryptDelegate: {
  vtable: UniffiVTableCallbackInterfaceUnableToDecryptDelegate;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUtd: (uniffiHandle: bigint, info: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeUnableToDecryptDelegate.lift(uniffiHandle);
        return jsCallback.onUtd(FfiConverterTypeUnableToDecryptInfo.lift(info));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // UnableToDecryptDelegate: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeUnableToDecryptDelegate.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(
      uniffiCallbackInterfaceUnableToDecryptDelegate.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeUnableToDecryptDelegate =
  new FfiConverterCallback<UnableToDecryptDelegate>();

export interface VerificationStateListener {
  onUpdate(status: VerificationState): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceVerificationStateListener: {
  vtable: UniffiVTableCallbackInterfaceVerificationStateListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUpdate: (uniffiHandle: bigint, status: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeVerificationStateListener.lift(uniffiHandle);
        return jsCallback.onUpdate(
          FfiConverterTypeVerificationState.lift(status)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // VerificationStateListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeVerificationStateListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(
      uniffiCallbackInterfaceVerificationStateListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeVerificationStateListener =
  new FfiConverterCallback<VerificationStateListener>();

export interface WidgetCapabilitiesProvider {
  acquireCapabilities(capabilities: WidgetCapabilities): WidgetCapabilities;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceWidgetCapabilitiesProvider: {
  vtable: UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    acquireCapabilities: (uniffiHandle: bigint, capabilities: Uint8Array) => {
      const uniffiMakeCall = (): WidgetCapabilities => {
        const jsCallback =
          FfiConverterTypeWidgetCapabilitiesProvider.lift(uniffiHandle);
        return jsCallback.acquireCapabilities(
          FfiConverterTypeWidgetCapabilities.lift(capabilities)
        );
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterTypeWidgetCapabilities.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // WidgetCapabilitiesProvider: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeWidgetCapabilitiesProvider.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(
      uniffiCallbackInterfaceWidgetCapabilitiesProvider.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeWidgetCapabilitiesProvider =
  new FfiConverterCallback<WidgetCapabilitiesProvider>();

export type AudioInfo = {
  duration: UniffiDuration | undefined;
  size: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
};

/**
 * Generated factory for {@link AudioInfo} record objects.
 */
export const AudioInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<AudioInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AudioInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AudioInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AudioInfo>,
  });
})();

const FfiConverterTypeAudioInfo = (() => {
  type TypeName = AudioInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        duration: FfiConverterOptionalDuration.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalDuration.write(value.duration, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalString.write(value.mimetype, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalDuration.allocationSize(value.duration) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalString.allocationSize(value.mimetype)
      );
    }
  }
  return new FFIConverter();
})();

export type AudioMessageContent = {
  /**
   * The computed filename, for use in a client.
   */
  filename: string;
  caption: string | undefined;
  formattedCaption: FormattedBody | undefined;
  source: MediaSourceInterface;
  info: AudioInfo | undefined;
  audio: UnstableAudioDetailsContent | undefined;
  voice: UnstableVoiceContent | undefined;
};

/**
 * Generated factory for {@link AudioMessageContent} record objects.
 */
export const AudioMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<AudioMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AudioMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AudioMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AudioMessageContent>,
  });
})();

const FfiConverterTypeAudioMessageContent = (() => {
  type TypeName = AudioMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filename: FfiConverterString.read(from),
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeAudioInfo.read(from),
        audio: FfiConverterOptionalTypeUnstableAudioDetailsContent.read(from),
        voice: FfiConverterOptionalTypeUnstableVoiceContent.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filename, into);
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeAudioInfo.write(value.info, into);
      FfiConverterOptionalTypeUnstableAudioDetailsContent.write(
        value.audio,
        into
      );
      FfiConverterOptionalTypeUnstableVoiceContent.write(value.voice, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filename) +
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeAudioInfo.allocationSize(value.info) +
        FfiConverterOptionalTypeUnstableAudioDetailsContent.allocationSize(
          value.audio
        ) +
        FfiConverterOptionalTypeUnstableVoiceContent.allocationSize(value.voice)
      );
    }
  }
  return new FFIConverter();
})();

export type AuthDataPasswordDetails = {
  /**
   * One of the user's identifiers.
   */
  identifier: string;
  /**
   * The plaintext password.
   */
  password: string;
};

/**
 * Generated factory for {@link AuthDataPasswordDetails} record objects.
 */
export const AuthDataPasswordDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      AuthDataPasswordDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AuthDataPasswordDetails}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AuthDataPasswordDetails}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<AuthDataPasswordDetails>,
  });
})();

const FfiConverterTypeAuthDataPasswordDetails = (() => {
  type TypeName = AuthDataPasswordDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        identifier: FfiConverterString.read(from),
        password: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.identifier, into);
      FfiConverterString.write(value.password, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.identifier) +
        FfiConverterString.allocationSize(value.password)
      );
    }
  }
  return new FFIConverter();
})();

export type ClientProperties = {
  /**
   * The client_id provides the widget with the option to behave differently
   * for different clients. e.g org.example.ios.
   */
  clientId: string;
  /**
   * The language tag the client is set to e.g. en-us. (Undefined and invalid
   * becomes: `en-US`)
   */
  languageTag: string | undefined;
  /**
   * A string describing the theme (dark, light) or org.example.dark.
   * (default: `light`)
   */
  theme: string | undefined;
};

/**
 * Generated factory for {@link ClientProperties} record objects.
 */
export const ClientProperties = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ClientProperties, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClientProperties}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ClientProperties}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClientProperties>,
  });
})();

const FfiConverterTypeClientProperties = (() => {
  type TypeName = ClientProperties;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        clientId: FfiConverterString.read(from),
        languageTag: FfiConverterOptionalString.read(from),
        theme: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.clientId, into);
      FfiConverterOptionalString.write(value.languageTag, into);
      FfiConverterOptionalString.write(value.theme, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.clientId) +
        FfiConverterOptionalString.allocationSize(value.languageTag) +
        FfiConverterOptionalString.allocationSize(value.theme)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Current draft of the composer for the room.
 */
export type ComposerDraft = {
  /**
   * The draft content in plain text.
   */
  plainText: string;
  /**
   * If the message is formatted in HTML, the HTML representation of the
   * message.
   */
  htmlText: string | undefined;
  /**
   * The type of draft.
   */
  draftType: ComposerDraftType;
};

/**
 * Generated factory for {@link ComposerDraft} record objects.
 */
export const ComposerDraft = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ComposerDraft, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ComposerDraft}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ComposerDraft}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ComposerDraft>,
  });
})();

const FfiConverterTypeComposerDraft = (() => {
  type TypeName = ComposerDraft;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        plainText: FfiConverterString.read(from),
        htmlText: FfiConverterOptionalString.read(from),
        draftType: FfiConverterTypeComposerDraftType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.plainText, into);
      FfiConverterOptionalString.write(value.htmlText, into);
      FfiConverterTypeComposerDraftType.write(value.draftType, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.plainText) +
        FfiConverterOptionalString.allocationSize(value.htmlText) +
        FfiConverterTypeComposerDraftType.allocationSize(value.draftType)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Like [`SimplePushRule`], but with an additional `conditions` field.
 */
export type ConditionalPushRule = {
  /**
   * Actions to determine if and how a notification is delivered for events
   * matching this rule.
   */
  actions: Array<Action>;
  /**
   * Whether this is a default rule, or has been set explicitly.
   */
  default_: boolean;
  /**
   * Whether the push rule is enabled or not.
   */
  enabled: boolean;
  /**
   * The ID of this rule.
   */
  ruleId: string;
  /**
   * The conditions that must hold true for an event in order for a rule to
   * be applied to an event.
   *
   * A rule with no conditions always matches.
   */
  conditions: Array<PushCondition>;
};

/**
 * Generated factory for {@link ConditionalPushRule} record objects.
 */
export const ConditionalPushRule = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ConditionalPushRule, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ConditionalPushRule}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ConditionalPushRule}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ConditionalPushRule>,
  });
})();

const FfiConverterTypeConditionalPushRule = (() => {
  type TypeName = ConditionalPushRule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        actions: FfiConverterArrayTypeAction.read(from),
        default_: FfiConverterBool.read(from),
        enabled: FfiConverterBool.read(from),
        ruleId: FfiConverterString.read(from),
        conditions: FfiConverterArrayTypePushCondition.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeAction.write(value.actions, into);
      FfiConverterBool.write(value.default_, into);
      FfiConverterBool.write(value.enabled, into);
      FfiConverterString.write(value.ruleId, into);
      FfiConverterArrayTypePushCondition.write(value.conditions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeAction.allocationSize(value.actions) +
        FfiConverterBool.allocationSize(value.default_) +
        FfiConverterBool.allocationSize(value.enabled) +
        FfiConverterString.allocationSize(value.ruleId) +
        FfiConverterArrayTypePushCondition.allocationSize(value.conditions)
      );
    }
  }
  return new FFIConverter();
})();

export type CreateRoomParameters = {
  name: string | undefined;
  topic: string | undefined;
  isEncrypted: boolean;
  isDirect: boolean;
  visibility: RoomVisibility;
  preset: RoomPreset;
  invite: Array<string> | undefined;
  avatar: string | undefined;
  powerLevelContentOverride: PowerLevels | undefined;
  joinRuleOverride: JoinRule | undefined;
  historyVisibilityOverride: RoomHistoryVisibility | undefined;
  canonicalAlias: string | undefined;
};

/**
 * Generated factory for {@link CreateRoomParameters} record objects.
 */
export const CreateRoomParameters = (() => {
  const defaults = () => ({
    topic: undefined,
    isDirect: false,
    invite: undefined,
    avatar: undefined,
    powerLevelContentOverride: undefined,
    joinRuleOverride: undefined,
    historyVisibilityOverride: undefined,
    canonicalAlias: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      CreateRoomParameters,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CreateRoomParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CreateRoomParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CreateRoomParameters>,
  });
})();

const FfiConverterTypeCreateRoomParameters = (() => {
  type TypeName = CreateRoomParameters;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        isEncrypted: FfiConverterBool.read(from),
        isDirect: FfiConverterBool.read(from),
        visibility: FfiConverterTypeRoomVisibility.read(from),
        preset: FfiConverterTypeRoomPreset.read(from),
        invite: FfiConverterOptionalArrayString.read(from),
        avatar: FfiConverterOptionalString.read(from),
        powerLevelContentOverride:
          FfiConverterOptionalTypePowerLevels.read(from),
        joinRuleOverride: FfiConverterOptionalTypeJoinRule.read(from),
        historyVisibilityOverride:
          FfiConverterOptionalTypeRoomHistoryVisibility.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterBool.write(value.isEncrypted, into);
      FfiConverterBool.write(value.isDirect, into);
      FfiConverterTypeRoomVisibility.write(value.visibility, into);
      FfiConverterTypeRoomPreset.write(value.preset, into);
      FfiConverterOptionalArrayString.write(value.invite, into);
      FfiConverterOptionalString.write(value.avatar, into);
      FfiConverterOptionalTypePowerLevels.write(
        value.powerLevelContentOverride,
        into
      );
      FfiConverterOptionalTypeJoinRule.write(value.joinRuleOverride, into);
      FfiConverterOptionalTypeRoomHistoryVisibility.write(
        value.historyVisibilityOverride,
        into
      );
      FfiConverterOptionalString.write(value.canonicalAlias, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterBool.allocationSize(value.isEncrypted) +
        FfiConverterBool.allocationSize(value.isDirect) +
        FfiConverterTypeRoomVisibility.allocationSize(value.visibility) +
        FfiConverterTypeRoomPreset.allocationSize(value.preset) +
        FfiConverterOptionalArrayString.allocationSize(value.invite) +
        FfiConverterOptionalString.allocationSize(value.avatar) +
        FfiConverterOptionalTypePowerLevels.allocationSize(
          value.powerLevelContentOverride
        ) +
        FfiConverterOptionalTypeJoinRule.allocationSize(
          value.joinRuleOverride
        ) +
        FfiConverterOptionalTypeRoomHistoryVisibility.allocationSize(
          value.historyVisibilityOverride
        ) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Well-known settings specific to ElementCall
 */
export type ElementCallWellKnown = {
  widgetUrl: string;
};

/**
 * Generated factory for {@link ElementCallWellKnown} record objects.
 */
export const ElementCallWellKnown = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ElementCallWellKnown,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ElementCallWellKnown}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ElementCallWellKnown}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ElementCallWellKnown>,
  });
})();

const FfiConverterTypeElementCallWellKnown = (() => {
  type TypeName = ElementCallWellKnown;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        widgetUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.widgetUrl, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.widgetUrl);
    }
  }
  return new FFIConverter();
})();

/**
 * Element specific well-known settings
 */
export type ElementWellKnown = {
  call: ElementCallWellKnown | undefined;
  registrationHelperUrl: string | undefined;
};

/**
 * Generated factory for {@link ElementWellKnown} record objects.
 */
export const ElementWellKnown = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ElementWellKnown, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ElementWellKnown}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ElementWellKnown}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ElementWellKnown>,
  });
})();

const FfiConverterTypeElementWellKnown = (() => {
  type TypeName = ElementWellKnown;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        call: FfiConverterOptionalTypeElementCallWellKnown.read(from),
        registrationHelperUrl: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeElementCallWellKnown.write(value.call, into);
      FfiConverterOptionalString.write(value.registrationHelperUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeElementCallWellKnown.allocationSize(
          value.call
        ) +
        FfiConverterOptionalString.allocationSize(value.registrationHelperUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type EmoteMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
};

/**
 * Generated factory for {@link EmoteMessageContent} record objects.
 */
export const EmoteMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EmoteMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmoteMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EmoteMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmoteMessageContent>,
  });
})();

const FfiConverterTypeEmoteMessageContent = (() => {
  type TypeName = EmoteMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted)
      );
    }
  }
  return new FFIConverter();
})();

export type EventTimelineItem = {
  /**
   * Indicates that an event is remote.
   */
  isRemote: boolean;
  eventOrTransactionId: EventOrTransactionId;
  sender: string;
  senderProfile: ProfileDetails;
  isOwn: boolean;
  isEditable: boolean;
  content: TimelineItemContent;
  timestamp: Timestamp;
  localSendState: EventSendState | undefined;
  localCreatedAt: /*u64*/ bigint | undefined;
  readReceipts: Map<string, Receipt>;
  origin: EventItemOrigin | undefined;
  canBeRepliedTo: boolean;
  lazyProvider: LazyTimelineItemProviderInterface;
};

/**
 * Generated factory for {@link EventTimelineItem} record objects.
 */
export const EventTimelineItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EventTimelineItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EventTimelineItem}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EventTimelineItem}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EventTimelineItem>,
  });
})();

const FfiConverterTypeEventTimelineItem = (() => {
  type TypeName = EventTimelineItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        isRemote: FfiConverterBool.read(from),
        eventOrTransactionId: FfiConverterTypeEventOrTransactionId.read(from),
        sender: FfiConverterString.read(from),
        senderProfile: FfiConverterTypeProfileDetails.read(from),
        isOwn: FfiConverterBool.read(from),
        isEditable: FfiConverterBool.read(from),
        content: FfiConverterTypeTimelineItemContent.read(from),
        timestamp: FfiConverterTypeTimestamp.read(from),
        localSendState: FfiConverterOptionalTypeEventSendState.read(from),
        localCreatedAt: FfiConverterOptionalUInt64.read(from),
        readReceipts: FfiConverterMapStringTypeReceipt.read(from),
        origin: FfiConverterOptionalTypeEventItemOrigin.read(from),
        canBeRepliedTo: FfiConverterBool.read(from),
        lazyProvider: FfiConverterTypeLazyTimelineItemProvider.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.isRemote, into);
      FfiConverterTypeEventOrTransactionId.write(
        value.eventOrTransactionId,
        into
      );
      FfiConverterString.write(value.sender, into);
      FfiConverterTypeProfileDetails.write(value.senderProfile, into);
      FfiConverterBool.write(value.isOwn, into);
      FfiConverterBool.write(value.isEditable, into);
      FfiConverterTypeTimelineItemContent.write(value.content, into);
      FfiConverterTypeTimestamp.write(value.timestamp, into);
      FfiConverterOptionalTypeEventSendState.write(value.localSendState, into);
      FfiConverterOptionalUInt64.write(value.localCreatedAt, into);
      FfiConverterMapStringTypeReceipt.write(value.readReceipts, into);
      FfiConverterOptionalTypeEventItemOrigin.write(value.origin, into);
      FfiConverterBool.write(value.canBeRepliedTo, into);
      FfiConverterTypeLazyTimelineItemProvider.write(value.lazyProvider, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.isRemote) +
        FfiConverterTypeEventOrTransactionId.allocationSize(
          value.eventOrTransactionId
        ) +
        FfiConverterString.allocationSize(value.sender) +
        FfiConverterTypeProfileDetails.allocationSize(value.senderProfile) +
        FfiConverterBool.allocationSize(value.isOwn) +
        FfiConverterBool.allocationSize(value.isEditable) +
        FfiConverterTypeTimelineItemContent.allocationSize(value.content) +
        FfiConverterTypeTimestamp.allocationSize(value.timestamp) +
        FfiConverterOptionalTypeEventSendState.allocationSize(
          value.localSendState
        ) +
        FfiConverterOptionalUInt64.allocationSize(value.localCreatedAt) +
        FfiConverterMapStringTypeReceipt.allocationSize(value.readReceipts) +
        FfiConverterOptionalTypeEventItemOrigin.allocationSize(value.origin) +
        FfiConverterBool.allocationSize(value.canBeRepliedTo) +
        FfiConverterTypeLazyTimelineItemProvider.allocationSize(
          value.lazyProvider
        )
      );
    }
  }
  return new FFIConverter();
})();

export type EventTimelineItemDebugInfo = {
  model: string;
  originalJson: string | undefined;
  latestEditJson: string | undefined;
};

/**
 * Generated factory for {@link EventTimelineItemDebugInfo} record objects.
 */
export const EventTimelineItemDebugInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      EventTimelineItemDebugInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EventTimelineItemDebugInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EventTimelineItemDebugInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<EventTimelineItemDebugInfo>,
  });
})();

const FfiConverterTypeEventTimelineItemDebugInfo = (() => {
  type TypeName = EventTimelineItemDebugInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        model: FfiConverterString.read(from),
        originalJson: FfiConverterOptionalString.read(from),
        latestEditJson: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.model, into);
      FfiConverterOptionalString.write(value.originalJson, into);
      FfiConverterOptionalString.write(value.latestEditJson, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.model) +
        FfiConverterOptionalString.allocationSize(value.originalJson) +
        FfiConverterOptionalString.allocationSize(value.latestEditJson)
      );
    }
  }
  return new FFIConverter();
})();

export type FileInfo = {
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
  thumbnailInfo: ThumbnailInfo | undefined;
  thumbnailSource: MediaSourceInterface | undefined;
};

/**
 * Generated factory for {@link FileInfo} record objects.
 */
export const FileInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FileInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FileInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FileInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FileInfo>,
  });
})();

const FfiConverterTypeFileInfo = (() => {
  type TypeName = FileInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
        thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
      FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalTypeThumbnailInfo.allocationSize(
          value.thumbnailInfo
        ) +
        FfiConverterOptionalTypeMediaSource.allocationSize(
          value.thumbnailSource
        )
      );
    }
  }
  return new FFIConverter();
})();

export type FileMessageContent = {
  /**
   * The computed filename, for use in a client.
   */
  filename: string;
  caption: string | undefined;
  formattedCaption: FormattedBody | undefined;
  source: MediaSourceInterface;
  info: FileInfo | undefined;
};

/**
 * Generated factory for {@link FileMessageContent} record objects.
 */
export const FileMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FileMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FileMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FileMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FileMessageContent>,
  });
})();

const FfiConverterTypeFileMessageContent = (() => {
  type TypeName = FileMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filename: FfiConverterString.read(from),
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeFileInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filename, into);
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeFileInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filename) +
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeFileInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

export type FormattedBody = {
  format: MessageFormat;
  body: string;
};

/**
 * Generated factory for {@link FormattedBody} record objects.
 */
export const FormattedBody = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FormattedBody, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FormattedBody}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FormattedBody}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FormattedBody>,
  });
})();

const FfiConverterTypeFormattedBody = (() => {
  type TypeName = FormattedBody;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        format: FfiConverterTypeMessageFormat.read(from),
        body: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMessageFormat.write(value.format, into);
      FfiConverterString.write(value.body, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMessageFormat.allocationSize(value.format) +
        FfiConverterString.allocationSize(value.body)
      );
    }
  }
  return new FFIConverter();
})();

export type GalleryMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
  itemtypes: Array<GalleryItemType>;
};

/**
 * Generated factory for {@link GalleryMessageContent} record objects.
 */
export const GalleryMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      GalleryMessageContent,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GalleryMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GalleryMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GalleryMessageContent>,
  });
})();

const FfiConverterTypeGalleryMessageContent = (() => {
  type TypeName = GalleryMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
        itemtypes: FfiConverterArrayTypeGalleryItemType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
      FfiConverterArrayTypeGalleryItemType.write(value.itemtypes, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted) +
        FfiConverterArrayTypeGalleryItemType.allocationSize(value.itemtypes)
      );
    }
  }
  return new FFIConverter();
})();

export type GalleryUploadParameters = {
  /**
   * Optional non-formatted caption, for clients that support it.
   */
  caption: string | undefined;
  /**
   * Optional HTML-formatted caption, for clients that support it.
   */
  formattedCaption: FormattedBody | undefined;
  /**
   * Optional intentional mentions to be sent with the gallery.
   */
  mentions: Mentions | undefined;
  /**
   * Optional parameters for sending the media as (threaded) reply.
   */
  replyParams: ReplyParameters | undefined;
};

/**
 * Generated factory for {@link GalleryUploadParameters} record objects.
 */
export const GalleryUploadParameters = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      GalleryUploadParameters,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GalleryUploadParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GalleryUploadParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<GalleryUploadParameters>,
  });
})();

const FfiConverterTypeGalleryUploadParameters = (() => {
  type TypeName = GalleryUploadParameters;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        mentions: FfiConverterOptionalTypeMentions.read(from),
        replyParams: FfiConverterOptionalTypeReplyParameters.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterOptionalTypeMentions.write(value.mentions, into);
      FfiConverterOptionalTypeReplyParameters.write(value.replyParams, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterOptionalTypeMentions.allocationSize(value.mentions) +
        FfiConverterOptionalTypeReplyParameters.allocationSize(
          value.replyParams
        )
      );
    }
  }
  return new FFIConverter();
})();

export type HttpPusherData = {
  url: string;
  format: PushFormat | undefined;
  defaultPayload: string | undefined;
};

/**
 * Generated factory for {@link HttpPusherData} record objects.
 */
export const HttpPusherData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<HttpPusherData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link HttpPusherData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link HttpPusherData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<HttpPusherData>,
  });
})();

const FfiConverterTypeHttpPusherData = (() => {
  type TypeName = HttpPusherData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        url: FfiConverterString.read(from),
        format: FfiConverterOptionalTypePushFormat.read(from),
        defaultPayload: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.url, into);
      FfiConverterOptionalTypePushFormat.write(value.format, into);
      FfiConverterOptionalString.write(value.defaultPayload, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.url) +
        FfiConverterOptionalTypePushFormat.allocationSize(value.format) +
        FfiConverterOptionalString.allocationSize(value.defaultPayload)
      );
    }
  }
  return new FFIConverter();
})();

export type IdentityStatusChange = {
  /**
   * The user ID of the user whose identity status changed
   */
  userId: string;
  /**
   * The new state of the identity of the user.
   */
  changedTo: IdentityState;
};

/**
 * Generated factory for {@link IdentityStatusChange} record objects.
 */
export const IdentityStatusChange = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      IdentityStatusChange,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link IdentityStatusChange}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link IdentityStatusChange}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<IdentityStatusChange>,
  });
})();

const FfiConverterTypeIdentityStatusChange = (() => {
  type TypeName = IdentityStatusChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        changedTo: FfiConverterTypeIdentityState.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterTypeIdentityState.write(value.changedTo, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterTypeIdentityState.allocationSize(value.changedTo)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Details about an ignored user.
 *
 * This is currently empty.
 */
export type IgnoredUser = {};

/**
 * Generated factory for {@link IgnoredUser} record objects.
 */
export const IgnoredUser = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<IgnoredUser, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link IgnoredUser}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link IgnoredUser}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<IgnoredUser>,
  });
})();

const FfiConverterTypeIgnoredUser = (() => {
  type TypeName = IgnoredUser;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type ImageInfo = {
  height: /*u64*/ bigint | undefined;
  width: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
  thumbnailInfo: ThumbnailInfo | undefined;
  thumbnailSource: MediaSourceInterface | undefined;
  blurhash: string | undefined;
  isAnimated: boolean | undefined;
};

/**
 * Generated factory for {@link ImageInfo} record objects.
 */
export const ImageInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ImageInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ImageInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ImageInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ImageInfo>,
  });
})();

const FfiConverterTypeImageInfo = (() => {
  type TypeName = ImageInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        height: FfiConverterOptionalUInt64.read(from),
        width: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
        thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
        blurhash: FfiConverterOptionalString.read(from),
        isAnimated: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.height, into);
      FfiConverterOptionalUInt64.write(value.width, into);
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
      FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
      FfiConverterOptionalString.write(value.blurhash, into);
      FfiConverterOptionalBool.write(value.isAnimated, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.height) +
        FfiConverterOptionalUInt64.allocationSize(value.width) +
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalTypeThumbnailInfo.allocationSize(
          value.thumbnailInfo
        ) +
        FfiConverterOptionalTypeMediaSource.allocationSize(
          value.thumbnailSource
        ) +
        FfiConverterOptionalString.allocationSize(value.blurhash) +
        FfiConverterOptionalBool.allocationSize(value.isAnimated)
      );
    }
  }
  return new FFIConverter();
})();

export type ImageMessageContent = {
  /**
   * The computed filename, for use in a client.
   */
  filename: string;
  caption: string | undefined;
  formattedCaption: FormattedBody | undefined;
  source: MediaSourceInterface;
  info: ImageInfo | undefined;
};

/**
 * Generated factory for {@link ImageMessageContent} record objects.
 */
export const ImageMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ImageMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ImageMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ImageMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ImageMessageContent>,
  });
})();

const FfiConverterTypeImageMessageContent = (() => {
  type TypeName = ImageMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filename: FfiConverterString.read(from),
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeImageInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filename, into);
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeImageInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filename) +
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeImageInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

export type InsertData = {
  index: /*u32*/ number;
  item: TimelineItemInterface;
};

/**
 * Generated factory for {@link InsertData} record objects.
 */
export const InsertData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<InsertData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link InsertData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link InsertData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<InsertData>,
  });
})();

const FfiConverterTypeInsertData = (() => {
  type TypeName = InsertData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        index: FfiConverterUInt32.read(from),
        item: FfiConverterTypeTimelineItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.index, into);
      FfiConverterTypeTimelineItem.write(value.item, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.index) +
        FfiConverterTypeTimelineItem.allocationSize(value.item)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * An FFI representation of a request to join a room.
 */
export type KnockRequest = {
  /**
   * The event id of the event that contains the `knock` membership change.
   */
  eventId: string;
  /**
   * The user id of the user who's requesting to join the room.
   */
  userId: string;
  /**
   * The room id of the room whose access was requested.
   */
  roomId: string;
  /**
   * The optional display name of the user who's requesting to join the room.
   */
  displayName: string | undefined;
  /**
   * The optional avatar url of the user who's requesting to join the room.
   */
  avatarUrl: string | undefined;
  /**
   * An optional reason why the user wants join the room.
   */
  reason: string | undefined;
  /**
   * The timestamp when this request was created.
   */
  timestamp: /*u64*/ bigint | undefined;
  /**
   * Whether the knock request has been marked as `seen` so it can be
   * filtered by the client.
   */
  isSeen: boolean;
  /**
   * A set of actions to perform for this knock request.
   */
  actions: KnockRequestActionsInterface;
};

/**
 * Generated factory for {@link KnockRequest} record objects.
 */
export const KnockRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<KnockRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link KnockRequest}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link KnockRequest}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<KnockRequest>,
  });
})();

const FfiConverterTypeKnockRequest = (() => {
  type TypeName = KnockRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        eventId: FfiConverterString.read(from),
        userId: FfiConverterString.read(from),
        roomId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        reason: FfiConverterOptionalString.read(from),
        timestamp: FfiConverterOptionalUInt64.read(from),
        isSeen: FfiConverterBool.read(from),
        actions: FfiConverterTypeKnockRequestActions.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.eventId, into);
      FfiConverterString.write(value.userId, into);
      FfiConverterString.write(value.roomId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterOptionalString.write(value.reason, into);
      FfiConverterOptionalUInt64.write(value.timestamp, into);
      FfiConverterBool.write(value.isSeen, into);
      FfiConverterTypeKnockRequestActions.write(value.actions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.eventId) +
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterOptionalString.allocationSize(value.reason) +
        FfiConverterOptionalUInt64.allocationSize(value.timestamp) +
        FfiConverterBool.allocationSize(value.isSeen) +
        FfiConverterTypeKnockRequestActions.allocationSize(value.actions)
      );
    }
  }
  return new FFIConverter();
})();

export type LastLocation = {
  /**
   * The most recent location content of the user.
   */
  location: LocationContent;
  /**
   * A timestamp in milliseconds since Unix Epoch on that day in local
   * time.
   */
  ts: /*u64*/ bigint;
};

/**
 * Generated factory for {@link LastLocation} record objects.
 */
export const LastLocation = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LastLocation, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LastLocation}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LastLocation}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LastLocation>,
  });
})();

const FfiConverterTypeLastLocation = (() => {
  type TypeName = LastLocation;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        location: FfiConverterTypeLocationContent.read(from),
        ts: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLocationContent.write(value.location, into);
      FfiConverterUInt64.write(value.ts, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLocationContent.allocationSize(value.location) +
        FfiConverterUInt64.allocationSize(value.ts)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Details of a users live location share.
 */
export type LiveLocationShare = {
  /**
   * The user's last known location.
   */
  lastLocation: LastLocation;
  /**
   * The live status of the live location share.
   */
  isLive: boolean;
  /**
   * The user ID of the person sharing their live location.
   */
  userId: string;
};

/**
 * Generated factory for {@link LiveLocationShare} record objects.
 */
export const LiveLocationShare = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LiveLocationShare, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LiveLocationShare}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LiveLocationShare}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LiveLocationShare>,
  });
})();

const FfiConverterTypeLiveLocationShare = (() => {
  type TypeName = LiveLocationShare;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lastLocation: FfiConverterTypeLastLocation.read(from),
        isLive: FfiConverterBool.read(from),
        userId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLastLocation.write(value.lastLocation, into);
      FfiConverterBool.write(value.isLive, into);
      FfiConverterString.write(value.userId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLastLocation.allocationSize(value.lastLocation) +
        FfiConverterBool.allocationSize(value.isLive) +
        FfiConverterString.allocationSize(value.userId)
      );
    }
  }
  return new FFIConverter();
})();

export type LocationContent = {
  body: string;
  geoUri: string;
  description: string | undefined;
  zoomLevel: /*u8*/ number | undefined;
  asset: AssetType | undefined;
};

/**
 * Generated factory for {@link LocationContent} record objects.
 */
export const LocationContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LocationContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LocationContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LocationContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LocationContent>,
  });
})();

const FfiConverterTypeLocationContent = (() => {
  type TypeName = LocationContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        geoUri: FfiConverterString.read(from),
        description: FfiConverterOptionalString.read(from),
        zoomLevel: FfiConverterOptionalUInt8.read(from),
        asset: FfiConverterOptionalTypeAssetType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterString.write(value.geoUri, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalUInt8.write(value.zoomLevel, into);
      FfiConverterOptionalTypeAssetType.write(value.asset, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterString.allocationSize(value.geoUri) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalUInt8.allocationSize(value.zoomLevel) +
        FfiConverterOptionalTypeAssetType.allocationSize(value.asset)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A Matrix entity that can be a room, room alias, user, or event, and a list
 * of via servers.
 */
export type MatrixEntity = {
  id: MatrixId;
  via: Array<string>;
};

/**
 * Generated factory for {@link MatrixEntity} record objects.
 */
export const MatrixEntity = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MatrixEntity, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MatrixEntity}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MatrixEntity}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MatrixEntity>,
  });
})();

const FfiConverterTypeMatrixEntity = (() => {
  type TypeName = MatrixEntity;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeMatrixId.read(from),
        via: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMatrixId.write(value.id, into);
      FfiConverterArrayString.write(value.via, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMatrixId.allocationSize(value.id) +
        FfiConverterArrayString.allocationSize(value.via)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The content of an `m.media_preview_config` event.
 *
 * Is also the content of the unstable
 * `io.element.msc4278.media_preview_config`.
 */
export type MediaPreviewConfig = {
  /**
   * The media previews setting for the user.
   */
  mediaPreviews: MediaPreviews;
  /**
   * The invite avatars setting for the user.
   */
  inviteAvatars: InviteAvatars;
};

/**
 * Generated factory for {@link MediaPreviewConfig} record objects.
 */
export const MediaPreviewConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MediaPreviewConfig, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MediaPreviewConfig}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MediaPreviewConfig}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MediaPreviewConfig>,
  });
})();

const FfiConverterTypeMediaPreviewConfig = (() => {
  type TypeName = MediaPreviewConfig;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        mediaPreviews: FfiConverterTypeMediaPreviews.read(from),
        inviteAvatars: FfiConverterTypeInviteAvatars.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMediaPreviews.write(value.mediaPreviews, into);
      FfiConverterTypeInviteAvatars.write(value.inviteAvatars, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMediaPreviews.allocationSize(value.mediaPreviews) +
        FfiConverterTypeInviteAvatars.allocationSize(value.inviteAvatars)
      );
    }
  }
  return new FFIConverter();
})();

export type Mentions = {
  userIds: Array<string>;
  room: boolean;
};

/**
 * Generated factory for {@link Mentions} record objects.
 */
export const Mentions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Mentions, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Mentions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Mentions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Mentions>,
  });
})();

const FfiConverterTypeMentions = (() => {
  type TypeName = Mentions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userIds: FfiConverterArrayString.read(from),
        room: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.userIds, into);
      FfiConverterBool.write(value.room, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayString.allocationSize(value.userIds) +
        FfiConverterBool.allocationSize(value.room)
      );
    }
  }
  return new FFIConverter();
})();

export type MessageContent = {
  msgType: MessageType;
  body: string;
  isEdited: boolean;
  mentions: Mentions | undefined;
};

/**
 * Generated factory for {@link MessageContent} record objects.
 */
export const MessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MessageContent>,
  });
})();

const FfiConverterTypeMessageContent = (() => {
  type TypeName = MessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        msgType: FfiConverterTypeMessageType.read(from),
        body: FfiConverterString.read(from),
        isEdited: FfiConverterBool.read(from),
        mentions: FfiConverterOptionalTypeMentions.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMessageType.write(value.msgType, into);
      FfiConverterString.write(value.body, into);
      FfiConverterBool.write(value.isEdited, into);
      FfiConverterOptionalTypeMentions.write(value.mentions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMessageType.allocationSize(value.msgType) +
        FfiConverterString.allocationSize(value.body) +
        FfiConverterBool.allocationSize(value.isEdited) +
        FfiConverterOptionalTypeMentions.allocationSize(value.mentions)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A special kind of [`super::TimelineItemContent`] that groups together
 * different room message types with their respective reactions and thread
 * information.
 */
export type MsgLikeContent = {
  kind: MsgLikeKind;
  reactions: Array<Reaction>;
  /**
   * The event this message is replying to, if any.
   */
  inReplyTo: InReplyToDetailsInterface | undefined;
  /**
   * Event ID of the thread root, if this is a message in a thread.
   */
  threadRoot: string | undefined;
  /**
   * Details about the thread this message is the root of.
   */
  threadSummary: ThreadSummaryInterface | undefined;
};

/**
 * Generated factory for {@link MsgLikeContent} record objects.
 */
export const MsgLikeContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MsgLikeContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MsgLikeContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MsgLikeContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MsgLikeContent>,
  });
})();

const FfiConverterTypeMsgLikeContent = (() => {
  type TypeName = MsgLikeContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        kind: FfiConverterTypeMsgLikeKind.read(from),
        reactions: FfiConverterArrayTypeReaction.read(from),
        inReplyTo: FfiConverterOptionalTypeInReplyToDetails.read(from),
        threadRoot: FfiConverterOptionalString.read(from),
        threadSummary: FfiConverterOptionalTypeThreadSummary.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeMsgLikeKind.write(value.kind, into);
      FfiConverterArrayTypeReaction.write(value.reactions, into);
      FfiConverterOptionalTypeInReplyToDetails.write(value.inReplyTo, into);
      FfiConverterOptionalString.write(value.threadRoot, into);
      FfiConverterOptionalTypeThreadSummary.write(value.threadSummary, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeMsgLikeKind.allocationSize(value.kind) +
        FfiConverterArrayTypeReaction.allocationSize(value.reactions) +
        FfiConverterOptionalTypeInReplyToDetails.allocationSize(
          value.inReplyTo
        ) +
        FfiConverterOptionalString.allocationSize(value.threadRoot) +
        FfiConverterOptionalTypeThreadSummary.allocationSize(
          value.threadSummary
        )
      );
    }
  }
  return new FFIConverter();
})();

export type NoticeMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
};

/**
 * Generated factory for {@link NoticeMessageContent} record objects.
 */
export const NoticeMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NoticeMessageContent,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NoticeMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NoticeMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NoticeMessageContent>,
  });
})();

const FfiConverterTypeNoticeMessageContent = (() => {
  type TypeName = NoticeMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted)
      );
    }
  }
  return new FFIConverter();
})();

export type NotificationItem = {
  event: NotificationEvent;
  senderInfo: NotificationSenderInfo;
  roomInfo: NotificationRoomInfo;
  /**
   * Is the notification supposed to be at the "noisy" level?
   * Can be `None` if we couldn't determine this, because we lacked
   * information to create a push context.
   */
  isNoisy: boolean | undefined;
  hasMention: boolean | undefined;
  threadId: string | undefined;
};

/**
 * Generated factory for {@link NotificationItem} record objects.
 */
export const NotificationItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<NotificationItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationItem}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NotificationItem}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NotificationItem>,
  });
})();

const FfiConverterTypeNotificationItem = (() => {
  type TypeName = NotificationItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        event: FfiConverterTypeNotificationEvent.read(from),
        senderInfo: FfiConverterTypeNotificationSenderInfo.read(from),
        roomInfo: FfiConverterTypeNotificationRoomInfo.read(from),
        isNoisy: FfiConverterOptionalBool.read(from),
        hasMention: FfiConverterOptionalBool.read(from),
        threadId: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeNotificationEvent.write(value.event, into);
      FfiConverterTypeNotificationSenderInfo.write(value.senderInfo, into);
      FfiConverterTypeNotificationRoomInfo.write(value.roomInfo, into);
      FfiConverterOptionalBool.write(value.isNoisy, into);
      FfiConverterOptionalBool.write(value.hasMention, into);
      FfiConverterOptionalString.write(value.threadId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeNotificationEvent.allocationSize(value.event) +
        FfiConverterTypeNotificationSenderInfo.allocationSize(
          value.senderInfo
        ) +
        FfiConverterTypeNotificationRoomInfo.allocationSize(value.roomInfo) +
        FfiConverterOptionalBool.allocationSize(value.isNoisy) +
        FfiConverterOptionalBool.allocationSize(value.hasMention) +
        FfiConverterOptionalString.allocationSize(value.threadId)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A request for notification items grouped by their room.
 */
export type NotificationItemsRequest = {
  roomId: string;
  eventIds: Array<string>;
};

/**
 * Generated factory for {@link NotificationItemsRequest} record objects.
 */
export const NotificationItemsRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NotificationItemsRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationItemsRequest}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NotificationItemsRequest}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<NotificationItemsRequest>,
  });
})();

const FfiConverterTypeNotificationItemsRequest = (() => {
  type TypeName = NotificationItemsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        eventIds: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterArrayString.write(value.eventIds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterArrayString.allocationSize(value.eventIds)
      );
    }
  }
  return new FFIConverter();
})();

export type NotificationPowerLevels = {
  room: /*i32*/ number;
};

/**
 * Generated factory for {@link NotificationPowerLevels} record objects.
 */
export const NotificationPowerLevels = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NotificationPowerLevels,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NotificationPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<NotificationPowerLevels>,
  });
})();

const FfiConverterTypeNotificationPowerLevels = (() => {
  type TypeName = NotificationPowerLevels;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        room: FfiConverterInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt32.write(value.room, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterInt32.allocationSize(value.room);
    }
  }
  return new FFIConverter();
})();

export type NotificationRoomInfo = {
  displayName: string;
  avatarUrl: string | undefined;
  canonicalAlias: string | undefined;
  joinRule: JoinRule | undefined;
  joinedMembersCount: /*u64*/ bigint;
  isEncrypted: boolean | undefined;
  isDirect: boolean;
  isPublic: boolean;
};

/**
 * Generated factory for {@link NotificationRoomInfo} record objects.
 */
export const NotificationRoomInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NotificationRoomInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationRoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NotificationRoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NotificationRoomInfo>,
  });
})();

const FfiConverterTypeNotificationRoomInfo = (() => {
  type TypeName = NotificationRoomInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        displayName: FfiConverterString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
        joinRule: FfiConverterOptionalTypeJoinRule.read(from),
        joinedMembersCount: FfiConverterUInt64.read(from),
        isEncrypted: FfiConverterOptionalBool.read(from),
        isDirect: FfiConverterBool.read(from),
        isPublic: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
      FfiConverterOptionalTypeJoinRule.write(value.joinRule, into);
      FfiConverterUInt64.write(value.joinedMembersCount, into);
      FfiConverterOptionalBool.write(value.isEncrypted, into);
      FfiConverterBool.write(value.isDirect, into);
      FfiConverterBool.write(value.isPublic, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
        FfiConverterOptionalTypeJoinRule.allocationSize(value.joinRule) +
        FfiConverterUInt64.allocationSize(value.joinedMembersCount) +
        FfiConverterOptionalBool.allocationSize(value.isEncrypted) +
        FfiConverterBool.allocationSize(value.isDirect) +
        FfiConverterBool.allocationSize(value.isPublic)
      );
    }
  }
  return new FFIConverter();
})();

export type NotificationSenderInfo = {
  displayName: string | undefined;
  avatarUrl: string | undefined;
  isNameAmbiguous: boolean;
};

/**
 * Generated factory for {@link NotificationSenderInfo} record objects.
 */
export const NotificationSenderInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NotificationSenderInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NotificationSenderInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NotificationSenderInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<NotificationSenderInfo>,
  });
})();

const FfiConverterTypeNotificationSenderInfo = (() => {
  type TypeName = NotificationSenderInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        isNameAmbiguous: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterBool.write(value.isNameAmbiguous, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterBool.allocationSize(value.isNameAmbiguous)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The configuration to use when authenticating with OIDC.
 */
export type OidcConfiguration = {
  /**
   * The name of the client that will be shown during OIDC authentication.
   */
  clientName: string | undefined;
  /**
   * The redirect URI that will be used when OIDC authentication is
   * successful.
   */
  redirectUri: string;
  /**
   * A URI that contains information about the client.
   */
  clientUri: string;
  /**
   * A URI that contains the client's logo.
   */
  logoUri: string | undefined;
  /**
   * A URI that contains the client's terms of service.
   */
  tosUri: string | undefined;
  /**
   * A URI that contains the client's privacy policy.
   */
  policyUri: string | undefined;
  /**
   * Pre-configured registrations for use with homeservers that don't support
   * dynamic client registration.
   *
   * The keys of the map should be the URLs of the homeservers, but keys
   * using `issuer` URLs are also supported.
   */
  staticRegistrations: Map<string, string>;
};

/**
 * Generated factory for {@link OidcConfiguration} record objects.
 */
export const OidcConfiguration = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<OidcConfiguration, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link OidcConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link OidcConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<OidcConfiguration>,
  });
})();

const FfiConverterTypeOidcConfiguration = (() => {
  type TypeName = OidcConfiguration;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        clientName: FfiConverterOptionalString.read(from),
        redirectUri: FfiConverterString.read(from),
        clientUri: FfiConverterString.read(from),
        logoUri: FfiConverterOptionalString.read(from),
        tosUri: FfiConverterOptionalString.read(from),
        policyUri: FfiConverterOptionalString.read(from),
        staticRegistrations: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.clientName, into);
      FfiConverterString.write(value.redirectUri, into);
      FfiConverterString.write(value.clientUri, into);
      FfiConverterOptionalString.write(value.logoUri, into);
      FfiConverterOptionalString.write(value.tosUri, into);
      FfiConverterOptionalString.write(value.policyUri, into);
      FfiConverterMapStringString.write(value.staticRegistrations, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.clientName) +
        FfiConverterString.allocationSize(value.redirectUri) +
        FfiConverterString.allocationSize(value.clientUri) +
        FfiConverterOptionalString.allocationSize(value.logoUri) +
        FfiConverterOptionalString.allocationSize(value.tosUri) +
        FfiConverterOptionalString.allocationSize(value.policyUri) +
        FfiConverterMapStringString.allocationSize(value.staticRegistrations)
      );
    }
  }
  return new FFIConverter();
})();

export type OidcCrossSigningResetInfo = {
  /**
   * The URL where the user can approve the reset of the cross-signing keys.
   */
  approvalUrl: string;
};

/**
 * Generated factory for {@link OidcCrossSigningResetInfo} record objects.
 */
export const OidcCrossSigningResetInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      OidcCrossSigningResetInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link OidcCrossSigningResetInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link OidcCrossSigningResetInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<OidcCrossSigningResetInfo>,
  });
})();

const FfiConverterTypeOidcCrossSigningResetInfo = (() => {
  type TypeName = OidcCrossSigningResetInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        approvalUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.approvalUrl, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.approvalUrl);
    }
  }
  return new FFIConverter();
})();

/**
 * A passphrase from which a key is to be derived.
 */
export type PassPhrase = {
  /**
   * The algorithm to use to generate the key from the passphrase.
   *
   * Must be `m.pbkdf2`.
   */
  algorithm: KeyDerivationAlgorithm;
  /**
   * The salt used in PBKDF2.
   */
  salt: string;
  /**
   * The number of iterations to use in PBKDF2.
   */
  iterations: /*u64*/ bigint;
  /**
   * The number of bits to generate for the key.
   *
   * Defaults to 256
   */
  bits: /*u64*/ bigint;
};

/**
 * Generated factory for {@link PassPhrase} record objects.
 */
export const PassPhrase = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PassPhrase, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PassPhrase}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PassPhrase}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PassPhrase>,
  });
})();

const FfiConverterTypePassPhrase = (() => {
  type TypeName = PassPhrase;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        algorithm: FfiConverterTypeKeyDerivationAlgorithm.read(from),
        salt: FfiConverterString.read(from),
        iterations: FfiConverterUInt64.read(from),
        bits: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeKeyDerivationAlgorithm.write(value.algorithm, into);
      FfiConverterString.write(value.salt, into);
      FfiConverterUInt64.write(value.iterations, into);
      FfiConverterUInt64.write(value.bits, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeKeyDerivationAlgorithm.allocationSize(value.algorithm) +
        FfiConverterString.allocationSize(value.salt) +
        FfiConverterUInt64.allocationSize(value.iterations) +
        FfiConverterUInt64.allocationSize(value.bits)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Like [`SimplePushRule`], but with an additional `pattern`` field.
 */
export type PatternedPushRule = {
  /**
   * Actions to determine if and how a notification is delivered for events
   * matching this rule.
   */
  actions: Array<Action>;
  /**
   * Whether this is a default rule, or has been set explicitly.
   */
  default_: boolean;
  /**
   * Whether the push rule is enabled or not.
   */
  enabled: boolean;
  /**
   * The ID of this rule.
   */
  ruleId: string;
  /**
   * The glob-style pattern to match against.
   */
  pattern: string;
};

/**
 * Generated factory for {@link PatternedPushRule} record objects.
 */
export const PatternedPushRule = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PatternedPushRule, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PatternedPushRule}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PatternedPushRule}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PatternedPushRule>,
  });
})();

const FfiConverterTypePatternedPushRule = (() => {
  type TypeName = PatternedPushRule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        actions: FfiConverterArrayTypeAction.read(from),
        default_: FfiConverterBool.read(from),
        enabled: FfiConverterBool.read(from),
        ruleId: FfiConverterString.read(from),
        pattern: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeAction.write(value.actions, into);
      FfiConverterBool.write(value.default_, into);
      FfiConverterBool.write(value.enabled, into);
      FfiConverterString.write(value.ruleId, into);
      FfiConverterString.write(value.pattern, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeAction.allocationSize(value.actions) +
        FfiConverterBool.allocationSize(value.default_) +
        FfiConverterBool.allocationSize(value.enabled) +
        FfiConverterString.allocationSize(value.ruleId) +
        FfiConverterString.allocationSize(value.pattern)
      );
    }
  }
  return new FFIConverter();
})();

export type PollAnswer = {
  id: string;
  text: string;
};

/**
 * Generated factory for {@link PollAnswer} record objects.
 */
export const PollAnswer = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PollAnswer, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PollAnswer}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PollAnswer}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PollAnswer>,
  });
})();

const FfiConverterTypePollAnswer = (() => {
  type TypeName = PollAnswer;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        text: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.text, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.text)
      );
    }
  }
  return new FFIConverter();
})();

export type PollData = {
  question: string;
  answers: Array<string>;
  maxSelections: /*u8*/ number;
  pollKind: PollKind;
};

/**
 * Generated factory for {@link PollData} record objects.
 */
export const PollData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PollData, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PollData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PollData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PollData>,
  });
})();

const FfiConverterTypePollData = (() => {
  type TypeName = PollData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        question: FfiConverterString.read(from),
        answers: FfiConverterArrayString.read(from),
        maxSelections: FfiConverterUInt8.read(from),
        pollKind: FfiConverterTypePollKind.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.question, into);
      FfiConverterArrayString.write(value.answers, into);
      FfiConverterUInt8.write(value.maxSelections, into);
      FfiConverterTypePollKind.write(value.pollKind, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.question) +
        FfiConverterArrayString.allocationSize(value.answers) +
        FfiConverterUInt8.allocationSize(value.maxSelections) +
        FfiConverterTypePollKind.allocationSize(value.pollKind)
      );
    }
  }
  return new FFIConverter();
})();

export type PowerLevels = {
  usersDefault: /*i32*/ number | undefined;
  eventsDefault: /*i32*/ number | undefined;
  stateDefault: /*i32*/ number | undefined;
  ban: /*i32*/ number | undefined;
  kick: /*i32*/ number | undefined;
  redact: /*i32*/ number | undefined;
  invite: /*i32*/ number | undefined;
  notifications: NotificationPowerLevels | undefined;
  users: Map<string, /*i32*/ number>;
  events: Map<string, /*i32*/ number>;
};

/**
 * Generated factory for {@link PowerLevels} record objects.
 */
export const PowerLevels = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PowerLevels, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PowerLevels>,
  });
})();

const FfiConverterTypePowerLevels = (() => {
  type TypeName = PowerLevels;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        usersDefault: FfiConverterOptionalInt32.read(from),
        eventsDefault: FfiConverterOptionalInt32.read(from),
        stateDefault: FfiConverterOptionalInt32.read(from),
        ban: FfiConverterOptionalInt32.read(from),
        kick: FfiConverterOptionalInt32.read(from),
        redact: FfiConverterOptionalInt32.read(from),
        invite: FfiConverterOptionalInt32.read(from),
        notifications:
          FfiConverterOptionalTypeNotificationPowerLevels.read(from),
        users: FfiConverterMapStringInt32.read(from),
        events: FfiConverterMapStringInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt32.write(value.usersDefault, into);
      FfiConverterOptionalInt32.write(value.eventsDefault, into);
      FfiConverterOptionalInt32.write(value.stateDefault, into);
      FfiConverterOptionalInt32.write(value.ban, into);
      FfiConverterOptionalInt32.write(value.kick, into);
      FfiConverterOptionalInt32.write(value.redact, into);
      FfiConverterOptionalInt32.write(value.invite, into);
      FfiConverterOptionalTypeNotificationPowerLevels.write(
        value.notifications,
        into
      );
      FfiConverterMapStringInt32.write(value.users, into);
      FfiConverterMapStringInt32.write(value.events, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt32.allocationSize(value.usersDefault) +
        FfiConverterOptionalInt32.allocationSize(value.eventsDefault) +
        FfiConverterOptionalInt32.allocationSize(value.stateDefault) +
        FfiConverterOptionalInt32.allocationSize(value.ban) +
        FfiConverterOptionalInt32.allocationSize(value.kick) +
        FfiConverterOptionalInt32.allocationSize(value.redact) +
        FfiConverterOptionalInt32.allocationSize(value.invite) +
        FfiConverterOptionalTypeNotificationPowerLevels.allocationSize(
          value.notifications
        ) +
        FfiConverterMapStringInt32.allocationSize(value.users) +
        FfiConverterMapStringInt32.allocationSize(value.events)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * When a room A is tombstoned, it is replaced by a room B. The room A is the
 * predecessor of B, and B is the successor of A. This type holds information
 * about the predecessor room. See [`Room::predecessor_room`].
 *
 * To know the predecessor of a room, the [`m.room.create`] state event must
 * have been received.
 *
 * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
 */
export type PredecessorRoom = {
  /**
   * The ID of the replacement room.
   */
  roomId: string;
  /**
   * The event ID of the last known event in the predecesssor room.
   */
  lastEventId: string;
};

/**
 * Generated factory for {@link PredecessorRoom} record objects.
 */
export const PredecessorRoom = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PredecessorRoom, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PredecessorRoom}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PredecessorRoom}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PredecessorRoom>,
  });
})();

const FfiConverterTypePredecessorRoom = (() => {
  type TypeName = PredecessorRoom;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        lastEventId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterString.write(value.lastEventId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterString.allocationSize(value.lastEventId)
      );
    }
  }
  return new FFIConverter();
})();

export type PusherIdentifiers = {
  pushkey: string;
  appId: string;
};

/**
 * Generated factory for {@link PusherIdentifiers} record objects.
 */
export const PusherIdentifiers = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PusherIdentifiers, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PusherIdentifiers}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PusherIdentifiers}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PusherIdentifiers>,
  });
})();

const FfiConverterTypePusherIdentifiers = (() => {
  type TypeName = PusherIdentifiers;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        pushkey: FfiConverterString.read(from),
        appId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.pushkey, into);
      FfiConverterString.write(value.appId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.pushkey) +
        FfiConverterString.allocationSize(value.appId)
      );
    }
  }
  return new FFIConverter();
})();

export type Reaction = {
  key: string;
  senders: Array<ReactionSenderData>;
};

/**
 * Generated factory for {@link Reaction} record objects.
 */
export const Reaction = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Reaction, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Reaction}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Reaction}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Reaction>,
  });
})();

const FfiConverterTypeReaction = (() => {
  type TypeName = Reaction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterString.read(from),
        senders: FfiConverterArrayTypeReactionSenderData.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.key, into);
      FfiConverterArrayTypeReactionSenderData.write(value.senders, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.key) +
        FfiConverterArrayTypeReactionSenderData.allocationSize(value.senders)
      );
    }
  }
  return new FFIConverter();
})();

export type ReactionSenderData = {
  senderId: string;
  timestamp: Timestamp;
};

/**
 * Generated factory for {@link ReactionSenderData} record objects.
 */
export const ReactionSenderData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ReactionSenderData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReactionSenderData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReactionSenderData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReactionSenderData>,
  });
})();

const FfiConverterTypeReactionSenderData = (() => {
  type TypeName = ReactionSenderData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        senderId: FfiConverterString.read(from),
        timestamp: FfiConverterTypeTimestamp.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.senderId, into);
      FfiConverterTypeTimestamp.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.senderId) +
        FfiConverterTypeTimestamp.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

export type Receipt = {
  timestamp: Timestamp | undefined;
};

/**
 * Generated factory for {@link Receipt} record objects.
 */
export const Receipt = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Receipt, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Receipt}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Receipt}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Receipt>,
  });
})();

const FfiConverterTypeReceipt = (() => {
  type TypeName = Receipt;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        timestamp: FfiConverterOptionalTypeTimestamp.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeTimestamp.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalTypeTimestamp.allocationSize(value.timestamp);
    }
  }
  return new FFIConverter();
})();

export type ReplyParameters = {
  /**
   * The ID of the event to reply to.
   */
  eventId: string;
  /**
   * Whether to enforce a thread relation.
   */
  enforceThread: boolean;
  /**
   * If enforcing a threaded relation, whether the message is a reply on a
   * thread.
   */
  replyWithinThread: boolean;
};

/**
 * Generated factory for {@link ReplyParameters} record objects.
 */
export const ReplyParameters = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ReplyParameters, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReplyParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReplyParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReplyParameters>,
  });
})();

const FfiConverterTypeReplyParameters = (() => {
  type TypeName = ReplyParameters;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        eventId: FfiConverterString.read(from),
        enforceThread: FfiConverterBool.read(from),
        replyWithinThread: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.eventId, into);
      FfiConverterBool.write(value.enforceThread, into);
      FfiConverterBool.write(value.replyWithinThread, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.eventId) +
        FfiConverterBool.allocationSize(value.enforceThread) +
        FfiConverterBool.allocationSize(value.replyWithinThread)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The config to use for HTTP requests by default in this client.
 */
export type RequestConfig = {
  /**
   * Max number of retries.
   */
  retryLimit: /*u64*/ bigint | undefined;
  /**
   * Timeout for a request in milliseconds.
   */
  timeout: /*u64*/ bigint | undefined;
  /**
   * Max number of concurrent requests. No value means no limits.
   */
  maxConcurrentRequests: /*u64*/ bigint | undefined;
  /**
   * Base delay between retries.
   */
  maxRetryTime: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link RequestConfig} record objects.
 */
export const RequestConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RequestConfig, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RequestConfig}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RequestConfig}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RequestConfig>,
  });
})();

const FfiConverterTypeRequestConfig = (() => {
  type TypeName = RequestConfig;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        retryLimit: FfiConverterOptionalUInt64.read(from),
        timeout: FfiConverterOptionalUInt64.read(from),
        maxConcurrentRequests: FfiConverterOptionalUInt64.read(from),
        maxRetryTime: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.retryLimit, into);
      FfiConverterOptionalUInt64.write(value.timeout, into);
      FfiConverterOptionalUInt64.write(value.maxConcurrentRequests, into);
      FfiConverterOptionalUInt64.write(value.maxRetryTime, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.retryLimit) +
        FfiConverterOptionalUInt64.allocationSize(value.timeout) +
        FfiConverterOptionalUInt64.allocationSize(value.maxConcurrentRequests) +
        FfiConverterOptionalUInt64.allocationSize(value.maxRetryTime)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Information about a room, that was resolved from a room alias.
 */
export type ResolvedRoomAlias = {
  /**
   * The room ID that the alias resolved to.
   */
  roomId: string;
  /**
   * A list of servers that can be used to find the room by its room ID.
   */
  servers: Array<string>;
};

/**
 * Generated factory for {@link ResolvedRoomAlias} record objects.
 */
export const ResolvedRoomAlias = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ResolvedRoomAlias, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ResolvedRoomAlias}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ResolvedRoomAlias}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ResolvedRoomAlias>,
  });
})();

const FfiConverterTypeResolvedRoomAlias = (() => {
  type TypeName = ResolvedRoomAlias;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        servers: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterArrayString.write(value.servers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterArrayString.allocationSize(value.servers)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomDescription = {
  roomId: string;
  name: string | undefined;
  topic: string | undefined;
  alias: string | undefined;
  avatarUrl: string | undefined;
  joinRule: PublicRoomJoinRule | undefined;
  isWorldReadable: boolean;
  joinedMembers: /*u64*/ bigint;
};

/**
 * Generated factory for {@link RoomDescription} record objects.
 */
export const RoomDescription = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomDescription, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomDescription}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomDescription}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomDescription>,
  });
})();

const FfiConverterTypeRoomDescription = (() => {
  type TypeName = RoomDescription;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        alias: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        joinRule: FfiConverterOptionalTypePublicRoomJoinRule.read(from),
        isWorldReadable: FfiConverterBool.read(from),
        joinedMembers: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterOptionalString.write(value.alias, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterOptionalTypePublicRoomJoinRule.write(value.joinRule, into);
      FfiConverterBool.write(value.isWorldReadable, into);
      FfiConverterUInt64.write(value.joinedMembers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterOptionalString.allocationSize(value.alias) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterOptionalTypePublicRoomJoinRule.allocationSize(
          value.joinRule
        ) +
        FfiConverterBool.allocationSize(value.isWorldReadable) +
        FfiConverterUInt64.allocationSize(value.joinedMembers)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomDirectorySearchEntriesResult = {
  entriesStream: TaskHandleInterface;
};

/**
 * Generated factory for {@link RoomDirectorySearchEntriesResult} record objects.
 */
export const RoomDirectorySearchEntriesResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RoomDirectorySearchEntriesResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomDirectorySearchEntriesResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomDirectorySearchEntriesResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomDirectorySearchEntriesResult>,
  });
})();

const FfiConverterTypeRoomDirectorySearchEntriesResult = (() => {
  type TypeName = RoomDirectorySearchEntriesResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        entriesStream: FfiConverterTypeTaskHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeTaskHandle.write(value.entriesStream, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeTaskHandle.allocationSize(value.entriesStream);
    }
  }
  return new FFIConverter();
})();

/**
 * Information about a member considered to be a room hero.
 */
export type RoomHero = {
  /**
   * The user ID of the hero.
   */
  userId: string;
  /**
   * The display name of the hero.
   */
  displayName: string | undefined;
  /**
   * The avatar URL of the hero.
   */
  avatarUrl: string | undefined;
};

/**
 * Generated factory for {@link RoomHero} record objects.
 */
export const RoomHero = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomHero, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomHero}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomHero}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomHero>,
  });
})();

const FfiConverterTypeRoomHero = (() => {
  type TypeName = RoomHero;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomInfo = {
  id: string;
  encryptionState: EncryptionState;
  creator: string | undefined;
  /**
   * The room's name from the room state event if received from sync, or one
   * that's been computed otherwise.
   */
  displayName: string | undefined;
  /**
   * Room name as defined by the room state event only.
   */
  rawName: string | undefined;
  topic: string | undefined;
  avatarUrl: string | undefined;
  isDirect: boolean;
  isPublic: boolean;
  isSpace: boolean;
  /**
   * If present, it means the room has been archived/upgraded.
   */
  successorRoom: SuccessorRoom | undefined;
  isFavourite: boolean;
  canonicalAlias: string | undefined;
  alternativeAliases: Array<string>;
  membership: Membership;
  /**
   * Member who invited the current user to a room that's in the invited
   * state.
   *
   * Can be missing if the room membership invite event is missing from the
   * store.
   */
  inviter: RoomMember | undefined;
  heroes: Array<RoomHero>;
  activeMembersCount: /*u64*/ bigint;
  invitedMembersCount: /*u64*/ bigint;
  joinedMembersCount: /*u64*/ bigint;
  userPowerLevels: Map<string, /*i64*/ bigint>;
  highlightCount: /*u64*/ bigint;
  notificationCount: /*u64*/ bigint;
  cachedUserDefinedNotificationMode: RoomNotificationMode | undefined;
  hasRoomCall: boolean;
  activeRoomCallParticipants: Array<string>;
  /**
   * Whether this room has been explicitly marked as unread
   */
  isMarkedUnread: boolean;
  /**
   * "Interesting" messages received in that room, independently of the
   * notification settings.
   */
  numUnreadMessages: /*u64*/ bigint;
  /**
   * Events that will notify the user, according to their
   * notification settings.
   */
  numUnreadNotifications: /*u64*/ bigint;
  /**
   * Events causing mentions/highlights for the user, according to their
   * notification settings.
   */
  numUnreadMentions: /*u64*/ bigint;
  /**
   * The currently pinned event ids.
   */
  pinnedEventIds: Array<string>;
  /**
   * The join rule for this room, if known.
   */
  joinRule: JoinRule | undefined;
  /**
   * The history visibility for this room, if known.
   */
  historyVisibility: RoomHistoryVisibility;
};

/**
 * Generated factory for {@link RoomInfo} record objects.
 */
export const RoomInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomInfo>,
  });
})();

const FfiConverterTypeRoomInfo = (() => {
  type TypeName = RoomInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        encryptionState: FfiConverterTypeEncryptionState.read(from),
        creator: FfiConverterOptionalString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        rawName: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        isDirect: FfiConverterBool.read(from),
        isPublic: FfiConverterBool.read(from),
        isSpace: FfiConverterBool.read(from),
        successorRoom: FfiConverterOptionalTypeSuccessorRoom.read(from),
        isFavourite: FfiConverterBool.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
        alternativeAliases: FfiConverterArrayString.read(from),
        membership: FfiConverterTypeMembership.read(from),
        inviter: FfiConverterOptionalTypeRoomMember.read(from),
        heroes: FfiConverterArrayTypeRoomHero.read(from),
        activeMembersCount: FfiConverterUInt64.read(from),
        invitedMembersCount: FfiConverterUInt64.read(from),
        joinedMembersCount: FfiConverterUInt64.read(from),
        userPowerLevels: FfiConverterMapStringInt64.read(from),
        highlightCount: FfiConverterUInt64.read(from),
        notificationCount: FfiConverterUInt64.read(from),
        cachedUserDefinedNotificationMode:
          FfiConverterOptionalTypeRoomNotificationMode.read(from),
        hasRoomCall: FfiConverterBool.read(from),
        activeRoomCallParticipants: FfiConverterArrayString.read(from),
        isMarkedUnread: FfiConverterBool.read(from),
        numUnreadMessages: FfiConverterUInt64.read(from),
        numUnreadNotifications: FfiConverterUInt64.read(from),
        numUnreadMentions: FfiConverterUInt64.read(from),
        pinnedEventIds: FfiConverterArrayString.read(from),
        joinRule: FfiConverterOptionalTypeJoinRule.read(from),
        historyVisibility: FfiConverterTypeRoomHistoryVisibility.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterTypeEncryptionState.write(value.encryptionState, into);
      FfiConverterOptionalString.write(value.creator, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.rawName, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterBool.write(value.isDirect, into);
      FfiConverterBool.write(value.isPublic, into);
      FfiConverterBool.write(value.isSpace, into);
      FfiConverterOptionalTypeSuccessorRoom.write(value.successorRoom, into);
      FfiConverterBool.write(value.isFavourite, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
      FfiConverterArrayString.write(value.alternativeAliases, into);
      FfiConverterTypeMembership.write(value.membership, into);
      FfiConverterOptionalTypeRoomMember.write(value.inviter, into);
      FfiConverterArrayTypeRoomHero.write(value.heroes, into);
      FfiConverterUInt64.write(value.activeMembersCount, into);
      FfiConverterUInt64.write(value.invitedMembersCount, into);
      FfiConverterUInt64.write(value.joinedMembersCount, into);
      FfiConverterMapStringInt64.write(value.userPowerLevels, into);
      FfiConverterUInt64.write(value.highlightCount, into);
      FfiConverterUInt64.write(value.notificationCount, into);
      FfiConverterOptionalTypeRoomNotificationMode.write(
        value.cachedUserDefinedNotificationMode,
        into
      );
      FfiConverterBool.write(value.hasRoomCall, into);
      FfiConverterArrayString.write(value.activeRoomCallParticipants, into);
      FfiConverterBool.write(value.isMarkedUnread, into);
      FfiConverterUInt64.write(value.numUnreadMessages, into);
      FfiConverterUInt64.write(value.numUnreadNotifications, into);
      FfiConverterUInt64.write(value.numUnreadMentions, into);
      FfiConverterArrayString.write(value.pinnedEventIds, into);
      FfiConverterOptionalTypeJoinRule.write(value.joinRule, into);
      FfiConverterTypeRoomHistoryVisibility.write(
        value.historyVisibility,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterTypeEncryptionState.allocationSize(value.encryptionState) +
        FfiConverterOptionalString.allocationSize(value.creator) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.rawName) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterBool.allocationSize(value.isDirect) +
        FfiConverterBool.allocationSize(value.isPublic) +
        FfiConverterBool.allocationSize(value.isSpace) +
        FfiConverterOptionalTypeSuccessorRoom.allocationSize(
          value.successorRoom
        ) +
        FfiConverterBool.allocationSize(value.isFavourite) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
        FfiConverterArrayString.allocationSize(value.alternativeAliases) +
        FfiConverterTypeMembership.allocationSize(value.membership) +
        FfiConverterOptionalTypeRoomMember.allocationSize(value.inviter) +
        FfiConverterArrayTypeRoomHero.allocationSize(value.heroes) +
        FfiConverterUInt64.allocationSize(value.activeMembersCount) +
        FfiConverterUInt64.allocationSize(value.invitedMembersCount) +
        FfiConverterUInt64.allocationSize(value.joinedMembersCount) +
        FfiConverterMapStringInt64.allocationSize(value.userPowerLevels) +
        FfiConverterUInt64.allocationSize(value.highlightCount) +
        FfiConverterUInt64.allocationSize(value.notificationCount) +
        FfiConverterOptionalTypeRoomNotificationMode.allocationSize(
          value.cachedUserDefinedNotificationMode
        ) +
        FfiConverterBool.allocationSize(value.hasRoomCall) +
        FfiConverterArrayString.allocationSize(
          value.activeRoomCallParticipants
        ) +
        FfiConverterBool.allocationSize(value.isMarkedUnread) +
        FfiConverterUInt64.allocationSize(value.numUnreadMessages) +
        FfiConverterUInt64.allocationSize(value.numUnreadNotifications) +
        FfiConverterUInt64.allocationSize(value.numUnreadMentions) +
        FfiConverterArrayString.allocationSize(value.pinnedEventIds) +
        FfiConverterOptionalTypeJoinRule.allocationSize(value.joinRule) +
        FfiConverterTypeRoomHistoryVisibility.allocationSize(
          value.historyVisibility
        )
      );
    }
  }
  return new FFIConverter();
})();

export type RoomListLoadingStateResult = {
  state: RoomListLoadingState;
  stateStream: TaskHandleInterface;
};

/**
 * Generated factory for {@link RoomListLoadingStateResult} record objects.
 */
export const RoomListLoadingStateResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RoomListLoadingStateResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomListLoadingStateResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomListLoadingStateResult}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomListLoadingStateResult>,
  });
})();

const FfiConverterTypeRoomListLoadingStateResult = (() => {
  type TypeName = RoomListLoadingStateResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        state: FfiConverterTypeRoomListLoadingState.read(from),
        stateStream: FfiConverterTypeTaskHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRoomListLoadingState.write(value.state, into);
      FfiConverterTypeTaskHandle.write(value.stateStream, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRoomListLoadingState.allocationSize(value.state) +
        FfiConverterTypeTaskHandle.allocationSize(value.stateStream)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomMember = {
  userId: string;
  displayName: string | undefined;
  avatarUrl: string | undefined;
  membership: MembershipState;
  isNameAmbiguous: boolean;
  powerLevel: /*i64*/ bigint;
  normalizedPowerLevel: /*i64*/ bigint;
  isIgnored: boolean;
  suggestedRoleForPowerLevel: RoomMemberRole;
  membershipChangeReason: string | undefined;
};

/**
 * Generated factory for {@link RoomMember} record objects.
 */
export const RoomMember = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomMember, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomMember}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomMember}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomMember>,
  });
})();

const FfiConverterTypeRoomMember = (() => {
  type TypeName = RoomMember;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        membership: FfiConverterTypeMembershipState.read(from),
        isNameAmbiguous: FfiConverterBool.read(from),
        powerLevel: FfiConverterInt64.read(from),
        normalizedPowerLevel: FfiConverterInt64.read(from),
        isIgnored: FfiConverterBool.read(from),
        suggestedRoleForPowerLevel: FfiConverterTypeRoomMemberRole.read(from),
        membershipChangeReason: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterTypeMembershipState.write(value.membership, into);
      FfiConverterBool.write(value.isNameAmbiguous, into);
      FfiConverterInt64.write(value.powerLevel, into);
      FfiConverterInt64.write(value.normalizedPowerLevel, into);
      FfiConverterBool.write(value.isIgnored, into);
      FfiConverterTypeRoomMemberRole.write(
        value.suggestedRoleForPowerLevel,
        into
      );
      FfiConverterOptionalString.write(value.membershipChangeReason, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterTypeMembershipState.allocationSize(value.membership) +
        FfiConverterBool.allocationSize(value.isNameAmbiguous) +
        FfiConverterInt64.allocationSize(value.powerLevel) +
        FfiConverterInt64.allocationSize(value.normalizedPowerLevel) +
        FfiConverterBool.allocationSize(value.isIgnored) +
        FfiConverterTypeRoomMemberRole.allocationSize(
          value.suggestedRoleForPowerLevel
        ) +
        FfiConverterOptionalString.allocationSize(value.membershipChangeReason)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Contains the current user's room member info and the optional room member
 * info of the sender of the `m.room.member` event that this info represents.
 */
export type RoomMemberWithSenderInfo = {
  /**
   * The room member.
   */
  roomMember: RoomMember;
  /**
   * The info of the sender of the event `room_member` is based on, if
   * available.
   */
  senderInfo: RoomMember | undefined;
};

/**
 * Generated factory for {@link RoomMemberWithSenderInfo} record objects.
 */
export const RoomMemberWithSenderInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RoomMemberWithSenderInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomMemberWithSenderInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomMemberWithSenderInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomMemberWithSenderInfo>,
  });
})();

const FfiConverterTypeRoomMemberWithSenderInfo = (() => {
  type TypeName = RoomMemberWithSenderInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomMember: FfiConverterTypeRoomMember.read(from),
        senderInfo: FfiConverterOptionalTypeRoomMember.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRoomMember.write(value.roomMember, into);
      FfiConverterOptionalTypeRoomMember.write(value.senderInfo, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRoomMember.allocationSize(value.roomMember) +
        FfiConverterOptionalTypeRoomMember.allocationSize(value.senderInfo)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * `RoomNotificationSettings` represents the current settings for a `Room`
 */
export type RoomNotificationSettings = {
  /**
   * The room notification mode
   */
  mode: RoomNotificationMode;
  /**
   * Whether the mode is the default one
   */
  isDefault: boolean;
};

/**
 * Generated factory for {@link RoomNotificationSettings} record objects.
 */
export const RoomNotificationSettings = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RoomNotificationSettings,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomNotificationSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomNotificationSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RoomNotificationSettings>,
  });
})();

const FfiConverterTypeRoomNotificationSettings = (() => {
  type TypeName = RoomNotificationSettings;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        mode: FfiConverterTypeRoomNotificationMode.read(from),
        isDefault: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRoomNotificationMode.write(value.mode, into);
      FfiConverterBool.write(value.isDefault, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRoomNotificationMode.allocationSize(value.mode) +
        FfiConverterBool.allocationSize(value.isDefault)
      );
    }
  }
  return new FFIConverter();
})();

export type RoomPowerLevels = {
  /**
   * The level required to ban a user.
   */
  ban: /*i64*/ bigint;
  /**
   * The level required to invite a user.
   */
  invite: /*i64*/ bigint;
  /**
   * The level required to kick a user.
   */
  kick: /*i64*/ bigint;
  /**
   * The level required to redact an event.
   */
  redact: /*i64*/ bigint;
  /**
   * The default level required to send message events.
   */
  eventsDefault: /*i64*/ bigint;
  /**
   * The default level required to send state events.
   */
  stateDefault: /*i64*/ bigint;
  /**
   * The default power level for every user in the room.
   */
  usersDefault: /*i64*/ bigint;
  /**
   * The level required to change the room's name.
   */
  roomName: /*i64*/ bigint;
  /**
   * The level required to change the room's avatar.
   */
  roomAvatar: /*i64*/ bigint;
  /**
   * The level required to change the room's topic.
   */
  roomTopic: /*i64*/ bigint;
};

/**
 * Generated factory for {@link RoomPowerLevels} record objects.
 */
export const RoomPowerLevels = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomPowerLevels, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomPowerLevels}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPowerLevels>,
  });
})();

const FfiConverterTypeRoomPowerLevels = (() => {
  type TypeName = RoomPowerLevels;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ban: FfiConverterInt64.read(from),
        invite: FfiConverterInt64.read(from),
        kick: FfiConverterInt64.read(from),
        redact: FfiConverterInt64.read(from),
        eventsDefault: FfiConverterInt64.read(from),
        stateDefault: FfiConverterInt64.read(from),
        usersDefault: FfiConverterInt64.read(from),
        roomName: FfiConverterInt64.read(from),
        roomAvatar: FfiConverterInt64.read(from),
        roomTopic: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt64.write(value.ban, into);
      FfiConverterInt64.write(value.invite, into);
      FfiConverterInt64.write(value.kick, into);
      FfiConverterInt64.write(value.redact, into);
      FfiConverterInt64.write(value.eventsDefault, into);
      FfiConverterInt64.write(value.stateDefault, into);
      FfiConverterInt64.write(value.usersDefault, into);
      FfiConverterInt64.write(value.roomName, into);
      FfiConverterInt64.write(value.roomAvatar, into);
      FfiConverterInt64.write(value.roomTopic, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterInt64.allocationSize(value.ban) +
        FfiConverterInt64.allocationSize(value.invite) +
        FfiConverterInt64.allocationSize(value.kick) +
        FfiConverterInt64.allocationSize(value.redact) +
        FfiConverterInt64.allocationSize(value.eventsDefault) +
        FfiConverterInt64.allocationSize(value.stateDefault) +
        FfiConverterInt64.allocationSize(value.usersDefault) +
        FfiConverterInt64.allocationSize(value.roomName) +
        FfiConverterInt64.allocationSize(value.roomAvatar) +
        FfiConverterInt64.allocationSize(value.roomTopic)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The preview of a room, be it invited/joined/left, or not.
 */
export type RoomPreviewInfo = {
  /**
   * The room id for this room.
   */
  roomId: string;
  /**
   * The canonical alias for the room.
   */
  canonicalAlias: string | undefined;
  /**
   * The room's name, if set.
   */
  name: string | undefined;
  /**
   * The room's topic, if set.
   */
  topic: string | undefined;
  /**
   * The MXC URI to the room's avatar, if set.
   */
  avatarUrl: string | undefined;
  /**
   * The number of joined members.
   */
  numJoinedMembers: /*u64*/ bigint;
  /**
   * The number of active members, if known (joined + invited).
   */
  numActiveMembers: /*u64*/ bigint | undefined;
  /**
   * The room type (space, custom) or nothing, if it's a regular room.
   */
  roomType: RoomType;
  /**
   * Is the history world-readable for this room?
   */
  isHistoryWorldReadable: boolean | undefined;
  /**
   * The membership state for the current user, if known.
   */
  membership: Membership | undefined;
  /**
   * The join rule for this room (private, public, knock, etc.).
   */
  joinRule: JoinRule;
  /**
   * Whether the room is direct or not, if known.
   */
  isDirect: boolean | undefined;
  /**
   * Room heroes.
   */
  heroes: Array<RoomHero> | undefined;
};

/**
 * Generated factory for {@link RoomPreviewInfo} record objects.
 */
export const RoomPreviewInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RoomPreviewInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RoomPreviewInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RoomPreviewInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RoomPreviewInfo>,
  });
})();

const FfiConverterTypeRoomPreviewInfo = (() => {
  type TypeName = RoomPreviewInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        canonicalAlias: FfiConverterOptionalString.read(from),
        name: FfiConverterOptionalString.read(from),
        topic: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
        numJoinedMembers: FfiConverterUInt64.read(from),
        numActiveMembers: FfiConverterOptionalUInt64.read(from),
        roomType: FfiConverterTypeRoomType.read(from),
        isHistoryWorldReadable: FfiConverterOptionalBool.read(from),
        membership: FfiConverterOptionalTypeMembership.read(from),
        joinRule: FfiConverterTypeJoinRule.read(from),
        isDirect: FfiConverterOptionalBool.read(from),
        heroes: FfiConverterOptionalArrayTypeRoomHero.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterOptionalString.write(value.canonicalAlias, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.topic, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
      FfiConverterUInt64.write(value.numJoinedMembers, into);
      FfiConverterOptionalUInt64.write(value.numActiveMembers, into);
      FfiConverterTypeRoomType.write(value.roomType, into);
      FfiConverterOptionalBool.write(value.isHistoryWorldReadable, into);
      FfiConverterOptionalTypeMembership.write(value.membership, into);
      FfiConverterTypeJoinRule.write(value.joinRule, into);
      FfiConverterOptionalBool.write(value.isDirect, into);
      FfiConverterOptionalArrayTypeRoomHero.write(value.heroes, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.topic) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl) +
        FfiConverterUInt64.allocationSize(value.numJoinedMembers) +
        FfiConverterOptionalUInt64.allocationSize(value.numActiveMembers) +
        FfiConverterTypeRoomType.allocationSize(value.roomType) +
        FfiConverterOptionalBool.allocationSize(value.isHistoryWorldReadable) +
        FfiConverterOptionalTypeMembership.allocationSize(value.membership) +
        FfiConverterTypeJoinRule.allocationSize(value.joinRule) +
        FfiConverterOptionalBool.allocationSize(value.isDirect) +
        FfiConverterOptionalArrayTypeRoomHero.allocationSize(value.heroes)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A push ruleset scopes a set of rules according to some criteria.
 */
export type Ruleset = {
  /**
   * These rules configure behavior for (unencrypted) messages that match
   * certain patterns.
   */
  content: Array<PatternedPushRule>;
  /**
   * These user-configured rules are given the highest priority.
   *
   * This field is named `override_` instead of `override` because the latter
   * is a reserved keyword in Rust.
   */
  override: Array<ConditionalPushRule>;
  /**
   * These rules change the behavior of all messages for a given room.
   */
  room: Array<SimplePushRule>;
  /**
   * These rules configure notification behavior for messages from a specific
   * Matrix user ID.
   */
  sender: Array<SimplePushRule>;
  /**
   * These rules are identical to override rules, but have a lower priority
   * than `content`, `room` and `sender` rules.
   */
  underride: Array<ConditionalPushRule>;
};

/**
 * Generated factory for {@link Ruleset} record objects.
 */
export const Ruleset = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Ruleset, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Ruleset}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Ruleset}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Ruleset>,
  });
})();

const FfiConverterTypeRuleset = (() => {
  type TypeName = Ruleset;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        content: FfiConverterArrayTypePatternedPushRule.read(from),
        override: FfiConverterArrayTypeConditionalPushRule.read(from),
        room: FfiConverterArrayTypeSimplePushRule.read(from),
        sender: FfiConverterArrayTypeSimplePushRule.read(from),
        underride: FfiConverterArrayTypeConditionalPushRule.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypePatternedPushRule.write(value.content, into);
      FfiConverterArrayTypeConditionalPushRule.write(value.override, into);
      FfiConverterArrayTypeSimplePushRule.write(value.room, into);
      FfiConverterArrayTypeSimplePushRule.write(value.sender, into);
      FfiConverterArrayTypeConditionalPushRule.write(value.underride, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypePatternedPushRule.allocationSize(value.content) +
        FfiConverterArrayTypeConditionalPushRule.allocationSize(
          value.override
        ) +
        FfiConverterArrayTypeSimplePushRule.allocationSize(value.room) +
        FfiConverterArrayTypeSimplePushRule.allocationSize(value.sender) +
        FfiConverterArrayTypeConditionalPushRule.allocationSize(value.underride)
      );
    }
  }
  return new FFIConverter();
})();

export type SearchUsersResults = {
  results: Array<UserProfile>;
  limited: boolean;
};

/**
 * Generated factory for {@link SearchUsersResults} record objects.
 */
export const SearchUsersResults = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SearchUsersResults, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SearchUsersResults}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SearchUsersResults}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SearchUsersResults>,
  });
})();

const FfiConverterTypeSearchUsersResults = (() => {
  type TypeName = SearchUsersResults;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        results: FfiConverterArrayTypeUserProfile.read(from),
        limited: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeUserProfile.write(value.results, into);
      FfiConverterBool.write(value.limited, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeUserProfile.allocationSize(value.results) +
        FfiConverterBool.allocationSize(value.limited)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The key properties for the `m.secret_storage.v1.aes-hmac-sha2`` algorithm.
 */
export type SecretStorageV1AesHmacSha2Properties = {
  /**
   * The 16-byte initialization vector, encoded as base64.
   */
  iv: string | undefined;
  /**
   * The MAC, encoded as base64.
   */
  mac: string | undefined;
};

/**
 * Generated factory for {@link SecretStorageV1AesHmacSha2Properties} record objects.
 */
export const SecretStorageV1AesHmacSha2Properties = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SecretStorageV1AesHmacSha2Properties,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SecretStorageV1AesHmacSha2Properties}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SecretStorageV1AesHmacSha2Properties}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(
        defaults()
      ) as Partial<SecretStorageV1AesHmacSha2Properties>,
  });
})();

const FfiConverterTypeSecretStorageV1AesHmacSha2Properties = (() => {
  type TypeName = SecretStorageV1AesHmacSha2Properties;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        iv: FfiConverterOptionalString.read(from),
        mac: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.iv, into);
      FfiConverterOptionalString.write(value.mac, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.iv) +
        FfiConverterOptionalString.allocationSize(value.mac)
      );
    }
  }
  return new FFIConverter();
})();

export type Session = {
  /**
   * The access token used for this session.
   */
  accessToken: string;
  /**
   * The token used for [refreshing the access token], if any.
   *
   * [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
   */
  refreshToken: string | undefined;
  /**
   * The user the access token was issued for.
   */
  userId: string;
  /**
   * The ID of the client device.
   */
  deviceId: string;
  /**
   * The URL for the homeserver used for this session.
   */
  homeserverUrl: string;
  /**
   * Additional data for this session if OpenID Connect was used for
   * authentication.
   */
  oidcData: string | undefined;
  /**
   * The sliding sync version used for this session.
   */
  slidingSyncVersion: SlidingSyncVersion;
};

/**
 * Generated factory for {@link Session} record objects.
 */
export const Session = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Session, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Session}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Session}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Session>,
  });
})();

const FfiConverterTypeSession = (() => {
  type TypeName = Session;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        accessToken: FfiConverterString.read(from),
        refreshToken: FfiConverterOptionalString.read(from),
        userId: FfiConverterString.read(from),
        deviceId: FfiConverterString.read(from),
        homeserverUrl: FfiConverterString.read(from),
        oidcData: FfiConverterOptionalString.read(from),
        slidingSyncVersion: FfiConverterTypeSlidingSyncVersion.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.accessToken, into);
      FfiConverterOptionalString.write(value.refreshToken, into);
      FfiConverterString.write(value.userId, into);
      FfiConverterString.write(value.deviceId, into);
      FfiConverterString.write(value.homeserverUrl, into);
      FfiConverterOptionalString.write(value.oidcData, into);
      FfiConverterTypeSlidingSyncVersion.write(value.slidingSyncVersion, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.accessToken) +
        FfiConverterOptionalString.allocationSize(value.refreshToken) +
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterString.allocationSize(value.deviceId) +
        FfiConverterString.allocationSize(value.homeserverUrl) +
        FfiConverterOptionalString.allocationSize(value.oidcData) +
        FfiConverterTypeSlidingSyncVersion.allocationSize(
          value.slidingSyncVersion
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Details about the incoming verification request
 */
export type SessionVerificationRequestDetails = {
  senderProfile: UserProfile;
  flowId: string;
  deviceId: string;
  deviceDisplayName: string | undefined;
  /**
   * First time this device was seen in milliseconds since epoch.
   */
  firstSeenTimestamp: Timestamp;
};

/**
 * Generated factory for {@link SessionVerificationRequestDetails} record objects.
 */
export const SessionVerificationRequestDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SessionVerificationRequestDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SessionVerificationRequestDetails}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SessionVerificationRequestDetails}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<SessionVerificationRequestDetails>,
  });
})();

const FfiConverterTypeSessionVerificationRequestDetails = (() => {
  type TypeName = SessionVerificationRequestDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        senderProfile: FfiConverterTypeUserProfile.read(from),
        flowId: FfiConverterString.read(from),
        deviceId: FfiConverterString.read(from),
        deviceDisplayName: FfiConverterOptionalString.read(from),
        firstSeenTimestamp: FfiConverterTypeTimestamp.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeUserProfile.write(value.senderProfile, into);
      FfiConverterString.write(value.flowId, into);
      FfiConverterString.write(value.deviceId, into);
      FfiConverterOptionalString.write(value.deviceDisplayName, into);
      FfiConverterTypeTimestamp.write(value.firstSeenTimestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeUserProfile.allocationSize(value.senderProfile) +
        FfiConverterString.allocationSize(value.flowId) +
        FfiConverterString.allocationSize(value.deviceId) +
        FfiConverterOptionalString.allocationSize(value.deviceDisplayName) +
        FfiConverterTypeTimestamp.allocationSize(value.firstSeenTimestamp)
      );
    }
  }
  return new FFIConverter();
})();

export type SetData = {
  index: /*u32*/ number;
  item: TimelineItemInterface;
};

/**
 * Generated factory for {@link SetData} record objects.
 */
export const SetData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SetData, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SetData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SetData}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SetData>,
  });
})();

const FfiConverterTypeSetData = (() => {
  type TypeName = SetData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        index: FfiConverterUInt32.read(from),
        item: FfiConverterTypeTimelineItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.index, into);
      FfiConverterTypeTimelineItem.write(value.item, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.index) +
        FfiConverterTypeTimelineItem.allocationSize(value.item)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A push rule is a single rule that states under what conditions an event
 * should be passed onto a push gateway and how the notification should be
 * presented.
 */
export type SimplePushRule = {
  /**
   * Actions to determine if and how a notification is delivered for events
   * matching this rule.
   */
  actions: Array<Action>;
  /**
   * Whether this is a default rule, or has been set explicitly.
   */
  default_: boolean;
  /**
   * Whether the push rule is enabled or not.
   */
  enabled: boolean;
  /**
   * The ID of this rule.
   *
   * This is generally the Matrix ID of the entity that it applies to.
   */
  ruleId: string;
};

/**
 * Generated factory for {@link SimplePushRule} record objects.
 */
export const SimplePushRule = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SimplePushRule, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SimplePushRule}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SimplePushRule}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SimplePushRule>,
  });
})();

const FfiConverterTypeSimplePushRule = (() => {
  type TypeName = SimplePushRule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        actions: FfiConverterArrayTypeAction.read(from),
        default_: FfiConverterBool.read(from),
        enabled: FfiConverterBool.read(from),
        ruleId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeAction.write(value.actions, into);
      FfiConverterBool.write(value.default_, into);
      FfiConverterBool.write(value.enabled, into);
      FfiConverterString.write(value.ruleId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeAction.allocationSize(value.actions) +
        FfiConverterBool.allocationSize(value.default_) +
        FfiConverterBool.allocationSize(value.enabled) +
        FfiConverterString.allocationSize(value.ruleId)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * When a room A is tombstoned, it is replaced by a room B. The room A is the
 * predecessor of B, and B is the successor of A. This type holds information
 * about the successor room. See [`Room::successor_room`].
 *
 * A room is tombstoned if it has received a [`m.room.tombstone`] state event.
 *
 * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
 */
export type SuccessorRoom = {
  /**
   * The ID of the replacement room.
   */
  roomId: string;
  /**
   * The message explaining why the room has been tombstoned.
   */
  reason: string | undefined;
};

/**
 * Generated factory for {@link SuccessorRoom} record objects.
 */
export const SuccessorRoom = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SuccessorRoom, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SuccessorRoom}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SuccessorRoom}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SuccessorRoom>,
  });
})();

const FfiConverterTypeSuccessorRoom = (() => {
  type TypeName = SuccessorRoom;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomId: FfiConverterString.read(from),
        reason: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.roomId, into);
      FfiConverterOptionalString.write(value.reason, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.roomId) +
        FfiConverterOptionalString.allocationSize(value.reason)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Information about a tag.
 */
export type TagInfo = {
  /**
   * Value to use for lexicographically ordering rooms with this tag.
   */
  order: /*f64*/ number | undefined;
};

/**
 * Generated factory for {@link TagInfo} record objects.
 */
export const TagInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TagInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TagInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TagInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TagInfo>,
  });
})();

const FfiConverterTypeTagInfo = (() => {
  type TypeName = TagInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        order: FfiConverterOptionalFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalFloat64.write(value.order, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalFloat64.allocationSize(value.order);
    }
  }
  return new FFIConverter();
})();

export type TextMessageContent = {
  body: string;
  formatted: FormattedBody | undefined;
};

/**
 * Generated factory for {@link TextMessageContent} record objects.
 */
export const TextMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TextMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TextMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TextMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TextMessageContent>,
  });
})();

const FfiConverterTypeTextMessageContent = (() => {
  type TypeName = TextMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        body: FfiConverterString.read(from),
        formatted: FfiConverterOptionalTypeFormattedBody.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.body, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.body) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted)
      );
    }
  }
  return new FFIConverter();
})();

export type ThumbnailInfo = {
  height: /*u64*/ bigint | undefined;
  width: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link ThumbnailInfo} record objects.
 */
export const ThumbnailInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ThumbnailInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ThumbnailInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ThumbnailInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ThumbnailInfo>,
  });
})();

const FfiConverterTypeThumbnailInfo = (() => {
  type TypeName = ThumbnailInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        height: FfiConverterOptionalUInt64.read(from),
        width: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.height, into);
      FfiConverterOptionalUInt64.write(value.width, into);
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.height) +
        FfiConverterOptionalUInt64.allocationSize(value.width) +
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Various options used to configure the timeline's behavior.
 */
export type TimelineConfiguration = {
  /**
   * What should the timeline focus on?
   */
  focus: TimelineFocus;
  /**
   * How should we filter out events from the timeline?
   */
  filter: TimelineFilter;
  /**
   * An optional String that will be prepended to
   * all the timeline item's internal IDs, making it possible to
   * distinguish different timeline instances from each other.
   */
  internalIdPrefix: string | undefined;
  /**
   * How often to insert date dividers
   */
  dateDividerMode: DateDividerMode;
  /**
   * Should the read receipts and read markers be tracked for the timeline
   * items in this instance?
   *
   * As this has a non negligible performance impact, make sure to enable it
   * only when you need it.
   */
  trackReadReceipts: boolean;
  /**
   * Whether this timeline instance should report UTDs through the client's
   * delegate.
   */
  reportUtds: boolean;
};

/**
 * Generated factory for {@link TimelineConfiguration} record objects.
 */
export const TimelineConfiguration = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      TimelineConfiguration,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TimelineConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TimelineConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TimelineConfiguration>,
  });
})();

const FfiConverterTypeTimelineConfiguration = (() => {
  type TypeName = TimelineConfiguration;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        focus: FfiConverterTypeTimelineFocus.read(from),
        filter: FfiConverterTypeTimelineFilter.read(from),
        internalIdPrefix: FfiConverterOptionalString.read(from),
        dateDividerMode: FfiConverterTypeDateDividerMode.read(from),
        trackReadReceipts: FfiConverterBool.read(from),
        reportUtds: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeTimelineFocus.write(value.focus, into);
      FfiConverterTypeTimelineFilter.write(value.filter, into);
      FfiConverterOptionalString.write(value.internalIdPrefix, into);
      FfiConverterTypeDateDividerMode.write(value.dateDividerMode, into);
      FfiConverterBool.write(value.trackReadReceipts, into);
      FfiConverterBool.write(value.reportUtds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeTimelineFocus.allocationSize(value.focus) +
        FfiConverterTypeTimelineFilter.allocationSize(value.filter) +
        FfiConverterOptionalString.allocationSize(value.internalIdPrefix) +
        FfiConverterTypeDateDividerMode.allocationSize(value.dateDividerMode) +
        FfiConverterBool.allocationSize(value.trackReadReceipts) +
        FfiConverterBool.allocationSize(value.reportUtds)
      );
    }
  }
  return new FFIConverter();
})();

export type TimelineUniqueId = {
  id: string;
};

/**
 * Generated factory for {@link TimelineUniqueId} record objects.
 */
export const TimelineUniqueId = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TimelineUniqueId, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TimelineUniqueId}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TimelineUniqueId}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TimelineUniqueId>,
  });
})();

const FfiConverterTypeTimelineUniqueId = (() => {
  type TypeName = TimelineUniqueId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.id);
    }
  }
  return new FFIConverter();
})();

export type TracingConfiguration = {
  /**
   * The desired log level.
   */
  logLevel: LogLevel;
  /**
   * All the log packs, that will be set to `TRACE` when they're enabled.
   */
  traceLogPacks: Array<TraceLogPacks>;
  /**
   * Additional targets that the FFI client would like to use.
   *
   * This can include, for instance, the target names for created
   * [`crate::tracing::Span`]. These targets will use the global log level by
   * default.
   */
  extraTargets: Array<string>;
  /**
   * Whether to log to stdout, or in the logcat on Android.
   */
  writeToStdoutOrSystem: boolean;
  /**
   * If set, configures rotated log files where to write additional logs.
   */
  writeToFiles: TracingFileConfiguration | undefined;
  /**
   * If set, the Sentry DSN to use for error reporting.
   */
  sentryDsn: string | undefined;
};

/**
 * Generated factory for {@link TracingConfiguration} record objects.
 */
export const TracingConfiguration = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      TracingConfiguration,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TracingConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TracingConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TracingConfiguration>,
  });
})();

const FfiConverterTypeTracingConfiguration = (() => {
  type TypeName = TracingConfiguration;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        logLevel: FfiConverterTypeLogLevel.read(from),
        traceLogPacks: FfiConverterArrayTypeTraceLogPacks.read(from),
        extraTargets: FfiConverterArrayString.read(from),
        writeToStdoutOrSystem: FfiConverterBool.read(from),
        writeToFiles:
          FfiConverterOptionalTypeTracingFileConfiguration.read(from),
        sentryDsn: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLogLevel.write(value.logLevel, into);
      FfiConverterArrayTypeTraceLogPacks.write(value.traceLogPacks, into);
      FfiConverterArrayString.write(value.extraTargets, into);
      FfiConverterBool.write(value.writeToStdoutOrSystem, into);
      FfiConverterOptionalTypeTracingFileConfiguration.write(
        value.writeToFiles,
        into
      );
      FfiConverterOptionalString.write(value.sentryDsn, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLogLevel.allocationSize(value.logLevel) +
        FfiConverterArrayTypeTraceLogPacks.allocationSize(value.traceLogPacks) +
        FfiConverterArrayString.allocationSize(value.extraTargets) +
        FfiConverterBool.allocationSize(value.writeToStdoutOrSystem) +
        FfiConverterOptionalTypeTracingFileConfiguration.allocationSize(
          value.writeToFiles
        ) +
        FfiConverterOptionalString.allocationSize(value.sentryDsn)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Configuration to save logs to (rotated) log-files.
 */
export type TracingFileConfiguration = {
  /**
   * Base location for all the log files.
   */
  path: string;
  /**
   * Prefix for the log files' names.
   */
  filePrefix: string;
  /**
   * Optional suffix for the log file's names.
   */
  fileSuffix: string | undefined;
  /**
   * Maximum number of rotated files.
   *
   * If not set, there's no max limit, i.e. the number of log files is
   * unlimited.
   */
  maxFiles: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link TracingFileConfiguration} record objects.
 */
export const TracingFileConfiguration = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      TracingFileConfiguration,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TracingFileConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TracingFileConfiguration}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<TracingFileConfiguration>,
  });
})();

const FfiConverterTypeTracingFileConfiguration = (() => {
  type TypeName = TracingFileConfiguration;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        path: FfiConverterString.read(from),
        filePrefix: FfiConverterString.read(from),
        fileSuffix: FfiConverterOptionalString.read(from),
        maxFiles: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.path, into);
      FfiConverterString.write(value.filePrefix, into);
      FfiConverterOptionalString.write(value.fileSuffix, into);
      FfiConverterOptionalUInt64.write(value.maxFiles, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.path) +
        FfiConverterString.allocationSize(value.filePrefix) +
        FfiConverterOptionalString.allocationSize(value.fileSuffix) +
        FfiConverterOptionalUInt64.allocationSize(value.maxFiles)
      );
    }
  }
  return new FFIConverter();
})();

export type TransmissionProgress = {
  current: /*u64*/ bigint;
  total: /*u64*/ bigint;
};

/**
 * Generated factory for {@link TransmissionProgress} record objects.
 */
export const TransmissionProgress = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      TransmissionProgress,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TransmissionProgress}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TransmissionProgress}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TransmissionProgress>,
  });
})();

const FfiConverterTypeTransmissionProgress = (() => {
  type TypeName = TransmissionProgress;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        current: FfiConverterUInt64.read(from),
        total: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.current, into);
      FfiConverterUInt64.write(value.total, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.current) +
        FfiConverterUInt64.allocationSize(value.total)
      );
    }
  }
  return new FFIConverter();
})();

export type UnableToDecryptInfo = {
  /**
   * The identifier of the event that couldn't get decrypted.
   */
  eventId: string;
  /**
   * If the event could be decrypted late (that is, the event was encrypted
   * at first, but could be decrypted later on), then this indicates the
   * time it took to decrypt the event. If it is not set, this is
   * considered a definite UTD.
   *
   * If set, this is in milliseconds.
   */
  timeToDecryptMs: /*u64*/ bigint | undefined;
  /**
   * What we know about what caused this UTD. E.g. was this event sent when
   * we were not a member of this room?
   */
  cause: UtdCause;
  /**
   * The difference between the event creation time (`origin_server_ts`) and
   * the time our device was created. If negative, this event was sent
   * *before* our device was created.
   */
  eventLocalAgeMillis: /*i64*/ bigint;
  /**
   * Whether the user had verified their own identity at the point they
   * received the UTD event.
   */
  userTrustsOwnIdentity: boolean;
  /**
   * The homeserver of the user that sent the undecryptable event.
   */
  senderHomeserver: string;
  /**
   * Our local user's own homeserver, or `None` if the client is not logged
   * in.
   */
  ownHomeserver: string | undefined;
};

/**
 * Generated factory for {@link UnableToDecryptInfo} record objects.
 */
export const UnableToDecryptInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UnableToDecryptInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnableToDecryptInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UnableToDecryptInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UnableToDecryptInfo>,
  });
})();

const FfiConverterTypeUnableToDecryptInfo = (() => {
  type TypeName = UnableToDecryptInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        eventId: FfiConverterString.read(from),
        timeToDecryptMs: FfiConverterOptionalUInt64.read(from),
        cause: FfiConverterTypeUtdCause.read(from),
        eventLocalAgeMillis: FfiConverterInt64.read(from),
        userTrustsOwnIdentity: FfiConverterBool.read(from),
        senderHomeserver: FfiConverterString.read(from),
        ownHomeserver: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.eventId, into);
      FfiConverterOptionalUInt64.write(value.timeToDecryptMs, into);
      FfiConverterTypeUtdCause.write(value.cause, into);
      FfiConverterInt64.write(value.eventLocalAgeMillis, into);
      FfiConverterBool.write(value.userTrustsOwnIdentity, into);
      FfiConverterString.write(value.senderHomeserver, into);
      FfiConverterOptionalString.write(value.ownHomeserver, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.eventId) +
        FfiConverterOptionalUInt64.allocationSize(value.timeToDecryptMs) +
        FfiConverterTypeUtdCause.allocationSize(value.cause) +
        FfiConverterInt64.allocationSize(value.eventLocalAgeMillis) +
        FfiConverterBool.allocationSize(value.userTrustsOwnIdentity) +
        FfiConverterString.allocationSize(value.senderHomeserver) +
        FfiConverterOptionalString.allocationSize(value.ownHomeserver)
      );
    }
  }
  return new FFIConverter();
})();

export type UnstableAudioDetailsContent = {
  duration: UniffiDuration;
  waveform: Array</*u16*/ number>;
};

/**
 * Generated factory for {@link UnstableAudioDetailsContent} record objects.
 */
export const UnstableAudioDetailsContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UnstableAudioDetailsContent,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnstableAudioDetailsContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UnstableAudioDetailsContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<UnstableAudioDetailsContent>,
  });
})();

const FfiConverterTypeUnstableAudioDetailsContent = (() => {
  type TypeName = UnstableAudioDetailsContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        duration: FfiConverterDuration.read(from),
        waveform: FfiConverterArrayUInt16.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterDuration.write(value.duration, into);
      FfiConverterArrayUInt16.write(value.waveform, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterDuration.allocationSize(value.duration) +
        FfiConverterArrayUInt16.allocationSize(value.waveform)
      );
    }
  }
  return new FFIConverter();
})();

export type UnstableVoiceContent = {};

/**
 * Generated factory for {@link UnstableVoiceContent} record objects.
 */
export const UnstableVoiceContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UnstableVoiceContent,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnstableVoiceContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UnstableVoiceContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UnstableVoiceContent>,
  });
})();

const FfiConverterTypeUnstableVoiceContent = (() => {
  type TypeName = UnstableVoiceContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type UploadParameters = {
  /**
   * Source from which to upload data
   */
  source: UploadSource;
  /**
   * Optional non-formatted caption, for clients that support it.
   */
  caption: string | undefined;
  /**
   * Optional HTML-formatted caption, for clients that support it.
   */
  formattedCaption: FormattedBody | undefined;
  /**
   * Optional intentional mentions to be sent with the media.
   */
  mentions: Mentions | undefined;
  /**
   * Optional parameters for sending the media as (threaded) reply.
   */
  replyParams: ReplyParameters | undefined;
  /**
   * Should the media be sent with the send queue, or synchronously?
   *
   * Watching progress only works with the synchronous method, at the moment.
   */
  useSendQueue: boolean;
};

/**
 * Generated factory for {@link UploadParameters} record objects.
 */
export const UploadParameters = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UploadParameters, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UploadParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UploadParameters}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UploadParameters>,
  });
})();

const FfiConverterTypeUploadParameters = (() => {
  type TypeName = UploadParameters;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        source: FfiConverterTypeUploadSource.read(from),
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        mentions: FfiConverterOptionalTypeMentions.read(from),
        replyParams: FfiConverterOptionalTypeReplyParameters.read(from),
        useSendQueue: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeUploadSource.write(value.source, into);
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterOptionalTypeMentions.write(value.mentions, into);
      FfiConverterOptionalTypeReplyParameters.write(value.replyParams, into);
      FfiConverterBool.write(value.useSendQueue, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeUploadSource.allocationSize(value.source) +
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterOptionalTypeMentions.allocationSize(value.mentions) +
        FfiConverterOptionalTypeReplyParameters.allocationSize(
          value.replyParams
        ) +
        FfiConverterBool.allocationSize(value.useSendQueue)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * An update for a particular user's power level within the room.
 */
export type UserPowerLevelUpdate = {
  /**
   * The user ID of the user to update.
   */
  userId: string;
  /**
   * The power level to assign to the user.
   */
  powerLevel: /*i64*/ bigint;
};

/**
 * Generated factory for {@link UserPowerLevelUpdate} record objects.
 */
export const UserPowerLevelUpdate = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UserPowerLevelUpdate,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UserPowerLevelUpdate}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UserPowerLevelUpdate}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UserPowerLevelUpdate>,
  });
})();

const FfiConverterTypeUserPowerLevelUpdate = (() => {
  type TypeName = UserPowerLevelUpdate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        powerLevel: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterInt64.write(value.powerLevel, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterInt64.allocationSize(value.powerLevel)
      );
    }
  }
  return new FFIConverter();
})();

export type UserProfile = {
  userId: string;
  displayName: string | undefined;
  avatarUrl: string | undefined;
};

/**
 * Generated factory for {@link UserProfile} record objects.
 */
export const UserProfile = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UserProfile, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UserProfile}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UserProfile}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UserProfile>,
  });
})();

const FfiConverterTypeUserProfile = (() => {
  type TypeName = UserProfile;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userId: FfiConverterString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        avatarUrl: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.userId, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.avatarUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.userId) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.avatarUrl)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A user-defined tag name.
 */
export type UserTagName = {
  name: string;
};

/**
 * Generated factory for {@link UserTagName} record objects.
 */
export const UserTagName = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UserTagName, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UserTagName}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UserTagName}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UserTagName>,
  });
})();

const FfiConverterTypeUserTagName = (() => {
  type TypeName = UserTagName;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.name, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.name);
    }
  }
  return new FFIConverter();
})();

export type VideoInfo = {
  duration: UniffiDuration | undefined;
  height: /*u64*/ bigint | undefined;
  width: /*u64*/ bigint | undefined;
  mimetype: string | undefined;
  size: /*u64*/ bigint | undefined;
  thumbnailInfo: ThumbnailInfo | undefined;
  thumbnailSource: MediaSourceInterface | undefined;
  blurhash: string | undefined;
};

/**
 * Generated factory for {@link VideoInfo} record objects.
 */
export const VideoInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<VideoInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VideoInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VideoInfo}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VideoInfo>,
  });
})();

const FfiConverterTypeVideoInfo = (() => {
  type TypeName = VideoInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        duration: FfiConverterOptionalDuration.read(from),
        height: FfiConverterOptionalUInt64.read(from),
        width: FfiConverterOptionalUInt64.read(from),
        mimetype: FfiConverterOptionalString.read(from),
        size: FfiConverterOptionalUInt64.read(from),
        thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
        thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
        blurhash: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalDuration.write(value.duration, into);
      FfiConverterOptionalUInt64.write(value.height, into);
      FfiConverterOptionalUInt64.write(value.width, into);
      FfiConverterOptionalString.write(value.mimetype, into);
      FfiConverterOptionalUInt64.write(value.size, into);
      FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
      FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
      FfiConverterOptionalString.write(value.blurhash, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalDuration.allocationSize(value.duration) +
        FfiConverterOptionalUInt64.allocationSize(value.height) +
        FfiConverterOptionalUInt64.allocationSize(value.width) +
        FfiConverterOptionalString.allocationSize(value.mimetype) +
        FfiConverterOptionalUInt64.allocationSize(value.size) +
        FfiConverterOptionalTypeThumbnailInfo.allocationSize(
          value.thumbnailInfo
        ) +
        FfiConverterOptionalTypeMediaSource.allocationSize(
          value.thumbnailSource
        ) +
        FfiConverterOptionalString.allocationSize(value.blurhash)
      );
    }
  }
  return new FFIConverter();
})();

export type VideoMessageContent = {
  /**
   * The computed filename, for use in a client.
   */
  filename: string;
  caption: string | undefined;
  formattedCaption: FormattedBody | undefined;
  source: MediaSourceInterface;
  info: VideoInfo | undefined;
};

/**
 * Generated factory for {@link VideoMessageContent} record objects.
 */
export const VideoMessageContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<VideoMessageContent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VideoMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VideoMessageContent}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VideoMessageContent>,
  });
})();

const FfiConverterTypeVideoMessageContent = (() => {
  type TypeName = VideoMessageContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        filename: FfiConverterString.read(from),
        caption: FfiConverterOptionalString.read(from),
        formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
        source: FfiConverterTypeMediaSource.read(from),
        info: FfiConverterOptionalTypeVideoInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.filename, into);
      FfiConverterOptionalString.write(value.caption, into);
      FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
      FfiConverterTypeMediaSource.write(value.source, into);
      FfiConverterOptionalTypeVideoInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.filename) +
        FfiConverterOptionalString.allocationSize(value.caption) +
        FfiConverterOptionalTypeFormattedBody.allocationSize(
          value.formattedCaption
        ) +
        FfiConverterTypeMediaSource.allocationSize(value.source) +
        FfiConverterOptionalTypeVideoInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Properties to create a new virtual Element Call widget.
 */
export type VirtualElementCallWidgetOptions = {
  /**
   * The url to the Element Call app including any `/room` path if required.
   *
   * E.g. <https://call.element.io>, <https://call.element.dev>, <https://call.element.dev/room>
   */
  elementCallUrl: string;
  /**
   * The widget id.
   */
  widgetId: string;
  /**
   * The url that is used as the target for the PostMessages sent
   * by the widget (to the client).
   *
   * For a web app client this is the client url. In case of using other
   * platforms the client most likely is setup up to listen to
   * postmessages in the same webview the widget is hosted. In this case
   * the `parent_url` is set to the url of the webview with the widget. Be
   * aware that this means that the widget will receive its own postmessage
   * messages. The `matrix-widget-api` (js) ignores those so this works but
   * it might break custom implementations.
   *
   * Defaults to `element_call_url` for the non-iframe (dedicated webview)
   * usecase.
   */
  parentUrl: string | undefined;
  /**
   * Whether the branding header of Element call should be hidden.
   *
   * Default: `true`
   */
  hideHeader: boolean | undefined;
  /**
   * If set, the lobby will be skipped and the widget will join the
   * call on the `io.element.join` action.
   *
   * Default: `false`
   */
  preload: boolean | undefined;
  /**
   * The font scale which will be used inside element call.
   *
   * Default: `1`
   */
  fontScale: /*f64*/ number | undefined;
  /**
   * Whether element call should prompt the user to open in the browser or
   * the app.
   *
   * Default: `false`
   */
  appPrompt: boolean | undefined;
  /**
   * Make it not possible to get to the calls list in the webview.
   *
   * Default: `true`
   */
  confineToRoom: boolean | undefined;
  /**
   * The font to use, to adapt to the system font.
   */
  font: string | undefined;
  /**
   * The encryption system to use.
   *
   * Use `EncryptionSystem::Unencrypted` to disable encryption.
   */
  encryption: EncryptionSystem;
  /**
   * The intent of showing the call.
   * If the user wants to start a call or join an existing one.
   * Controls if the lobby is skipped or not.
   */
  intent: Intent | undefined;
  /**
   * Do not show the screenshare button.
   */
  hideScreensharing: boolean;
  /**
   * Can be used to pass a PostHog id to element call.
   */
  posthogUserId: string | undefined;
  /**
   * The host of the posthog api.
   * Supported since Element Call v0.9.0. Only used by the embedded package.
   */
  posthogApiHost: string | undefined;
  /**
   * The key for the posthog api.
   * Supported since Element Call v0.9.0. Only used by the embedded package.
   */
  posthogApiKey: string | undefined;
  /**
   * The url to use for submitting rageshakes.
   * Supported since Element Call v0.9.0. Only used by the embedded package.
   */
  rageshakeSubmitUrl: string | undefined;
  /**
   * Sentry [DSN](https://docs.sentry.io/concepts/key-terms/dsn-explainer/)
   * Supported since Element Call v0.9.0. Only used by the embedded package.
   */
  sentryDsn: string | undefined;
  /**
   * Sentry [environment](https://docs.sentry.io/concepts/key-terms/key-terms/)
   * Supported since Element Call v0.9.0. Only used by the embedded package.
   */
  sentryEnvironment: string | undefined;
  /**
   * - `false`: the webview shows a a list of devices injected by the
   * client. (used on ios & android)
   */
  controlledMediaDevices: boolean;
};

/**
 * Generated factory for {@link VirtualElementCallWidgetOptions} record objects.
 */
export const VirtualElementCallWidgetOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      VirtualElementCallWidgetOptions,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VirtualElementCallWidgetOptions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VirtualElementCallWidgetOptions}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<VirtualElementCallWidgetOptions>,
  });
})();

const FfiConverterTypeVirtualElementCallWidgetOptions = (() => {
  type TypeName = VirtualElementCallWidgetOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        elementCallUrl: FfiConverterString.read(from),
        widgetId: FfiConverterString.read(from),
        parentUrl: FfiConverterOptionalString.read(from),
        hideHeader: FfiConverterOptionalBool.read(from),
        preload: FfiConverterOptionalBool.read(from),
        fontScale: FfiConverterOptionalFloat64.read(from),
        appPrompt: FfiConverterOptionalBool.read(from),
        confineToRoom: FfiConverterOptionalBool.read(from),
        font: FfiConverterOptionalString.read(from),
        encryption: FfiConverterTypeEncryptionSystem.read(from),
        intent: FfiConverterOptionalTypeIntent.read(from),
        hideScreensharing: FfiConverterBool.read(from),
        posthogUserId: FfiConverterOptionalString.read(from),
        posthogApiHost: FfiConverterOptionalString.read(from),
        posthogApiKey: FfiConverterOptionalString.read(from),
        rageshakeSubmitUrl: FfiConverterOptionalString.read(from),
        sentryDsn: FfiConverterOptionalString.read(from),
        sentryEnvironment: FfiConverterOptionalString.read(from),
        controlledMediaDevices: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.elementCallUrl, into);
      FfiConverterString.write(value.widgetId, into);
      FfiConverterOptionalString.write(value.parentUrl, into);
      FfiConverterOptionalBool.write(value.hideHeader, into);
      FfiConverterOptionalBool.write(value.preload, into);
      FfiConverterOptionalFloat64.write(value.fontScale, into);
      FfiConverterOptionalBool.write(value.appPrompt, into);
      FfiConverterOptionalBool.write(value.confineToRoom, into);
      FfiConverterOptionalString.write(value.font, into);
      FfiConverterTypeEncryptionSystem.write(value.encryption, into);
      FfiConverterOptionalTypeIntent.write(value.intent, into);
      FfiConverterBool.write(value.hideScreensharing, into);
      FfiConverterOptionalString.write(value.posthogUserId, into);
      FfiConverterOptionalString.write(value.posthogApiHost, into);
      FfiConverterOptionalString.write(value.posthogApiKey, into);
      FfiConverterOptionalString.write(value.rageshakeSubmitUrl, into);
      FfiConverterOptionalString.write(value.sentryDsn, into);
      FfiConverterOptionalString.write(value.sentryEnvironment, into);
      FfiConverterBool.write(value.controlledMediaDevices, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.elementCallUrl) +
        FfiConverterString.allocationSize(value.widgetId) +
        FfiConverterOptionalString.allocationSize(value.parentUrl) +
        FfiConverterOptionalBool.allocationSize(value.hideHeader) +
        FfiConverterOptionalBool.allocationSize(value.preload) +
        FfiConverterOptionalFloat64.allocationSize(value.fontScale) +
        FfiConverterOptionalBool.allocationSize(value.appPrompt) +
        FfiConverterOptionalBool.allocationSize(value.confineToRoom) +
        FfiConverterOptionalString.allocationSize(value.font) +
        FfiConverterTypeEncryptionSystem.allocationSize(value.encryption) +
        FfiConverterOptionalTypeIntent.allocationSize(value.intent) +
        FfiConverterBool.allocationSize(value.hideScreensharing) +
        FfiConverterOptionalString.allocationSize(value.posthogUserId) +
        FfiConverterOptionalString.allocationSize(value.posthogApiHost) +
        FfiConverterOptionalString.allocationSize(value.posthogApiKey) +
        FfiConverterOptionalString.allocationSize(value.rageshakeSubmitUrl) +
        FfiConverterOptionalString.allocationSize(value.sentryDsn) +
        FfiConverterOptionalString.allocationSize(value.sentryEnvironment) +
        FfiConverterBool.allocationSize(value.controlledMediaDevices)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Capabilities that a widget can request from a client.
 */
export type WidgetCapabilities = {
  /**
   * Types of the messages that a widget wants to be able to fetch.
   */
  read: Array<WidgetEventFilter>;
  /**
   * Types of the messages that a widget wants to be able to send.
   */
  send: Array<WidgetEventFilter>;
  /**
   * If this capability is requested by the widget, it can not operate
   * separately from the Matrix client.
   *
   * This means clients should not offer to open the widget in a separate
   * browser/tab/webview that is not connected to the postmessage widget-api.
   */
  requiresClient: boolean;
  /**
   * This allows the widget to ask the client to update delayed events.
   */
  updateDelayedEvent: boolean;
  /**
   * This allows the widget to send events with a delay.
   */
  sendDelayedEvent: boolean;
};

/**
 * Generated factory for {@link WidgetCapabilities} record objects.
 */
export const WidgetCapabilities = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<WidgetCapabilities, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WidgetCapabilities}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WidgetCapabilities}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WidgetCapabilities>,
  });
})();

const FfiConverterTypeWidgetCapabilities = (() => {
  type TypeName = WidgetCapabilities;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        read: FfiConverterArrayTypeWidgetEventFilter.read(from),
        send: FfiConverterArrayTypeWidgetEventFilter.read(from),
        requiresClient: FfiConverterBool.read(from),
        updateDelayedEvent: FfiConverterBool.read(from),
        sendDelayedEvent: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeWidgetEventFilter.write(value.read, into);
      FfiConverterArrayTypeWidgetEventFilter.write(value.send, into);
      FfiConverterBool.write(value.requiresClient, into);
      FfiConverterBool.write(value.updateDelayedEvent, into);
      FfiConverterBool.write(value.sendDelayedEvent, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeWidgetEventFilter.allocationSize(value.read) +
        FfiConverterArrayTypeWidgetEventFilter.allocationSize(value.send) +
        FfiConverterBool.allocationSize(value.requiresClient) +
        FfiConverterBool.allocationSize(value.updateDelayedEvent) +
        FfiConverterBool.allocationSize(value.sendDelayedEvent)
      );
    }
  }
  return new FFIConverter();
})();

export type WidgetDriverAndHandle = {
  driver: WidgetDriverInterface;
  handle: WidgetDriverHandleInterface;
};

/**
 * Generated factory for {@link WidgetDriverAndHandle} record objects.
 */
export const WidgetDriverAndHandle = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      WidgetDriverAndHandle,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WidgetDriverAndHandle}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WidgetDriverAndHandle}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WidgetDriverAndHandle>,
  });
})();

const FfiConverterTypeWidgetDriverAndHandle = (() => {
  type TypeName = WidgetDriverAndHandle;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        driver: FfiConverterTypeWidgetDriver.read(from),
        handle: FfiConverterTypeWidgetDriverHandle.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeWidgetDriver.write(value.driver, into);
      FfiConverterTypeWidgetDriverHandle.write(value.handle, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeWidgetDriver.allocationSize(value.driver) +
        FfiConverterTypeWidgetDriverHandle.allocationSize(value.handle)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Information about a widget.
 */
export type WidgetSettings = {
  /**
   * Widget's unique identifier.
   */
  widgetId: string;
  /**
   * Whether or not the widget should be initialized on load message
   * (`ContentLoad` message), or upon creation/attaching of the widget to
   * the SDK's state machine that drives the API.
   */
  initAfterContentLoad: boolean;
  /**
   * This contains the url from the widget state event.
   * In this url placeholders can be used to pass information from the client
   * to the widget. Possible values are: `$widgetId`, `$parentUrl`,
   * `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
   *
   * # Examples
   *
   * e.g `http://widget.domain?username=$userId`
   * will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
   */
  rawUrl: string;
};

/**
 * Generated factory for {@link WidgetSettings} record objects.
 */
export const WidgetSettings = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<WidgetSettings, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WidgetSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WidgetSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WidgetSettings>,
  });
})();

const FfiConverterTypeWidgetSettings = (() => {
  type TypeName = WidgetSettings;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        widgetId: FfiConverterString.read(from),
        initAfterContentLoad: FfiConverterBool.read(from),
        rawUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.widgetId, into);
      FfiConverterBool.write(value.initAfterContentLoad, into);
      FfiConverterString.write(value.rawUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.widgetId) +
        FfiConverterBool.allocationSize(value.initAfterContentLoad) +
        FfiConverterString.allocationSize(value.rawUrl)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type Timestamp = /*u64*/ bigint;
// FfiConverter for Timestamp, a type alias for /*u64*/bigint.
const FfiConverterTypeTimestamp = FfiConverterUInt64;

// Enum: AccountDataEvent
export enum AccountDataEvent_Tags {
  Direct = 'Direct',
  IdentityServer = 'IdentityServer',
  IgnoredUserList = 'IgnoredUserList',
  PushRules = 'PushRules',
  SecretStorageDefaultKey = 'SecretStorageDefaultKey',
  SecretStorageKey = 'SecretStorageKey',
}
/**
 * Global account data events.
 */
export const AccountDataEvent = (() => {
  type Direct__interface = {
    tag: AccountDataEvent_Tags.Direct;
    inner: Readonly<{ map: Map<string, Array<string>> }>;
  };

  /**
   * m.direct
   */
  class Direct_ extends UniffiEnum implements Direct__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEvent';
    readonly tag = AccountDataEvent_Tags.Direct;
    readonly inner: Readonly<{ map: Map<string, Array<string>> }>;
    constructor(inner: {
      /**
       * The mapping of user ID to a list of room IDs of the direct rooms
       * for that user ID.
       */ map: Map<string, Array<string>>;
    }) {
      super('AccountDataEvent', 'Direct');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The mapping of user ID to a list of room IDs of the direct rooms
       * for that user ID.
       */ map: Map<string, Array<string>>;
    }): Direct_ {
      return new Direct_(inner);
    }

    static instanceOf(obj: any): obj is Direct_ {
      return obj.tag === AccountDataEvent_Tags.Direct;
    }
  }

  type IdentityServer__interface = {
    tag: AccountDataEvent_Tags.IdentityServer;
    inner: Readonly<{ baseUrl: string | undefined }>;
  };

  /**
   * m.identity_server
   */
  class IdentityServer_
    extends UniffiEnum
    implements IdentityServer__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEvent';
    readonly tag = AccountDataEvent_Tags.IdentityServer;
    readonly inner: Readonly<{ baseUrl: string | undefined }>;
    constructor(inner: {
      /**
       * The base URL for the identity server for client-server connections.
       */ baseUrl: string | undefined;
    }) {
      super('AccountDataEvent', 'IdentityServer');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The base URL for the identity server for client-server connections.
       */ baseUrl: string | undefined;
    }): IdentityServer_ {
      return new IdentityServer_(inner);
    }

    static instanceOf(obj: any): obj is IdentityServer_ {
      return obj.tag === AccountDataEvent_Tags.IdentityServer;
    }
  }

  type IgnoredUserList__interface = {
    tag: AccountDataEvent_Tags.IgnoredUserList;
    inner: Readonly<{ ignoredUsers: Map<string, IgnoredUser> }>;
  };

  /**
   * m.ignored_user_list
   */
  class IgnoredUserList_
    extends UniffiEnum
    implements IgnoredUserList__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEvent';
    readonly tag = AccountDataEvent_Tags.IgnoredUserList;
    readonly inner: Readonly<{ ignoredUsers: Map<string, IgnoredUser> }>;
    constructor(inner: {
      /**
       * The map of users to ignore. This is a mapping of user ID to empty
       * object.
       */ ignoredUsers: Map<string, IgnoredUser>;
    }) {
      super('AccountDataEvent', 'IgnoredUserList');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The map of users to ignore. This is a mapping of user ID to empty
       * object.
       */ ignoredUsers: Map<string, IgnoredUser>;
    }): IgnoredUserList_ {
      return new IgnoredUserList_(inner);
    }

    static instanceOf(obj: any): obj is IgnoredUserList_ {
      return obj.tag === AccountDataEvent_Tags.IgnoredUserList;
    }
  }

  type PushRules__interface = {
    tag: AccountDataEvent_Tags.PushRules;
    inner: Readonly<{ global: Ruleset }>;
  };

  /**
   * m.push_rules
   */
  class PushRules_ extends UniffiEnum implements PushRules__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEvent';
    readonly tag = AccountDataEvent_Tags.PushRules;
    readonly inner: Readonly<{ global: Ruleset }>;
    constructor(inner: {
      /**
       * The global ruleset.
       */ global: Ruleset;
    }) {
      super('AccountDataEvent', 'PushRules');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The global ruleset.
       */ global: Ruleset;
    }): PushRules_ {
      return new PushRules_(inner);
    }

    static instanceOf(obj: any): obj is PushRules_ {
      return obj.tag === AccountDataEvent_Tags.PushRules;
    }
  }

  type SecretStorageDefaultKey__interface = {
    tag: AccountDataEvent_Tags.SecretStorageDefaultKey;
    inner: Readonly<{ keyId: string }>;
  };

  /**
   * m.secret_storage.default_key
   */
  class SecretStorageDefaultKey_
    extends UniffiEnum
    implements SecretStorageDefaultKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEvent';
    readonly tag = AccountDataEvent_Tags.SecretStorageDefaultKey;
    readonly inner: Readonly<{ keyId: string }>;
    constructor(inner: {
      /**
       * The ID of the default key.
       */ keyId: string;
    }) {
      super('AccountDataEvent', 'SecretStorageDefaultKey');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The ID of the default key.
       */ keyId: string;
    }): SecretStorageDefaultKey_ {
      return new SecretStorageDefaultKey_(inner);
    }

    static instanceOf(obj: any): obj is SecretStorageDefaultKey_ {
      return obj.tag === AccountDataEvent_Tags.SecretStorageDefaultKey;
    }
  }

  type SecretStorageKey__interface = {
    tag: AccountDataEvent_Tags.SecretStorageKey;
    inner: Readonly<{
      keyId: string;
      name: string | undefined;
      algorithm: SecretStorageEncryptionAlgorithm;
      passphrase: PassPhrase | undefined;
    }>;
  };

  /**
   * m.secret_storage.key.*
   */
  class SecretStorageKey_
    extends UniffiEnum
    implements SecretStorageKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEvent';
    readonly tag = AccountDataEvent_Tags.SecretStorageKey;
    readonly inner: Readonly<{
      keyId: string;
      name: string | undefined;
      algorithm: SecretStorageEncryptionAlgorithm;
      passphrase: PassPhrase | undefined;
    }>;
    constructor(inner: {
      /**
       * The ID of the key.
       */ keyId: string;
      /**
       * The name of the key.
       */ name: string | undefined;
      /**
       * The encryption algorithm used for this key.
       *
       * Currently, only `m.secret_storage.v1.aes-hmac-sha2` is supported.
       */ algorithm: SecretStorageEncryptionAlgorithm;
      /**
       * The passphrase from which to generate the key.
       */ passphrase: PassPhrase | undefined;
    }) {
      super('AccountDataEvent', 'SecretStorageKey');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The ID of the key.
       */ keyId: string;
      /**
       * The name of the key.
       */ name: string | undefined;
      /**
       * The encryption algorithm used for this key.
       *
       * Currently, only `m.secret_storage.v1.aes-hmac-sha2` is supported.
       */ algorithm: SecretStorageEncryptionAlgorithm;
      /**
       * The passphrase from which to generate the key.
       */ passphrase: PassPhrase | undefined;
    }): SecretStorageKey_ {
      return new SecretStorageKey_(inner);
    }

    static instanceOf(obj: any): obj is SecretStorageKey_ {
      return obj.tag === AccountDataEvent_Tags.SecretStorageKey;
    }
  }

  function instanceOf(obj: any): obj is AccountDataEvent {
    return obj[uniffiTypeNameSymbol] === 'AccountDataEvent';
  }

  return Object.freeze({
    instanceOf,
    Direct: Direct_,
    IdentityServer: IdentityServer_,
    IgnoredUserList: IgnoredUserList_,
    PushRules: PushRules_,
    SecretStorageDefaultKey: SecretStorageDefaultKey_,
    SecretStorageKey: SecretStorageKey_,
  });
})();

/**
 * Global account data events.
 */

export type AccountDataEvent = InstanceType<
  (typeof AccountDataEvent)[keyof Omit<typeof AccountDataEvent, 'instanceOf'>]
>;

// FfiConverter for enum AccountDataEvent
const FfiConverterTypeAccountDataEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AccountDataEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AccountDataEvent.Direct({
            map: FfiConverterMapStringArrayString.read(from),
          });
        case 2:
          return new AccountDataEvent.IdentityServer({
            baseUrl: FfiConverterOptionalString.read(from),
          });
        case 3:
          return new AccountDataEvent.IgnoredUserList({
            ignoredUsers: FfiConverterMapStringTypeIgnoredUser.read(from),
          });
        case 4:
          return new AccountDataEvent.PushRules({
            global: FfiConverterTypeRuleset.read(from),
          });
        case 5:
          return new AccountDataEvent.SecretStorageDefaultKey({
            keyId: FfiConverterString.read(from),
          });
        case 6:
          return new AccountDataEvent.SecretStorageKey({
            keyId: FfiConverterString.read(from),
            name: FfiConverterOptionalString.read(from),
            algorithm:
              FfiConverterTypeSecretStorageEncryptionAlgorithm.read(from),
            passphrase: FfiConverterOptionalTypePassPhrase.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AccountDataEvent_Tags.Direct: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterMapStringArrayString.write(inner.map, into);
          return;
        }
        case AccountDataEvent_Tags.IdentityServer: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.baseUrl, into);
          return;
        }
        case AccountDataEvent_Tags.IgnoredUserList: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterMapStringTypeIgnoredUser.write(inner.ignoredUsers, into);
          return;
        }
        case AccountDataEvent_Tags.PushRules: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeRuleset.write(inner.global, into);
          return;
        }
        case AccountDataEvent_Tags.SecretStorageDefaultKey: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.keyId, into);
          return;
        }
        case AccountDataEvent_Tags.SecretStorageKey: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.keyId, into);
          FfiConverterOptionalString.write(inner.name, into);
          FfiConverterTypeSecretStorageEncryptionAlgorithm.write(
            inner.algorithm,
            into
          );
          FfiConverterOptionalTypePassPhrase.write(inner.passphrase, into);
          return;
        }
        default:
          // Throwing from here means that AccountDataEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AccountDataEvent_Tags.Direct: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterMapStringArrayString.allocationSize(inner.map);
          return size;
        }
        case AccountDataEvent_Tags.IdentityServer: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalString.allocationSize(inner.baseUrl);
          return size;
        }
        case AccountDataEvent_Tags.IgnoredUserList: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterMapStringTypeIgnoredUser.allocationSize(
            inner.ignoredUsers
          );
          return size;
        }
        case AccountDataEvent_Tags.PushRules: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeRuleset.allocationSize(inner.global);
          return size;
        }
        case AccountDataEvent_Tags.SecretStorageDefaultKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.keyId);
          return size;
        }
        case AccountDataEvent_Tags.SecretStorageKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.keyId);
          size += FfiConverterOptionalString.allocationSize(inner.name);
          size +=
            FfiConverterTypeSecretStorageEncryptionAlgorithm.allocationSize(
              inner.algorithm
            );
          size += FfiConverterOptionalTypePassPhrase.allocationSize(
            inner.passphrase
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: AccountDataEventType
export enum AccountDataEventType_Tags {
  Direct = 'Direct',
  IdentityServer = 'IdentityServer',
  IgnoredUserList = 'IgnoredUserList',
  PushRules = 'PushRules',
  SecretStorageDefaultKey = 'SecretStorageDefaultKey',
  SecretStorageKey = 'SecretStorageKey',
}
/**
 * Types of global account data events.
 */
export const AccountDataEventType = (() => {
  type Direct__interface = {
    tag: AccountDataEventType_Tags.Direct;
  };

  /**
   * m.direct
   */
  class Direct_ extends UniffiEnum implements Direct__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEventType';
    readonly tag = AccountDataEventType_Tags.Direct;
    constructor() {
      super('AccountDataEventType', 'Direct');
    }

    static new(): Direct_ {
      return new Direct_();
    }

    static instanceOf(obj: any): obj is Direct_ {
      return obj.tag === AccountDataEventType_Tags.Direct;
    }
  }

  type IdentityServer__interface = {
    tag: AccountDataEventType_Tags.IdentityServer;
  };

  /**
   * m.identity_server
   */
  class IdentityServer_
    extends UniffiEnum
    implements IdentityServer__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEventType';
    readonly tag = AccountDataEventType_Tags.IdentityServer;
    constructor() {
      super('AccountDataEventType', 'IdentityServer');
    }

    static new(): IdentityServer_ {
      return new IdentityServer_();
    }

    static instanceOf(obj: any): obj is IdentityServer_ {
      return obj.tag === AccountDataEventType_Tags.IdentityServer;
    }
  }

  type IgnoredUserList__interface = {
    tag: AccountDataEventType_Tags.IgnoredUserList;
  };

  /**
   * m.ignored_user_list
   */
  class IgnoredUserList_
    extends UniffiEnum
    implements IgnoredUserList__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEventType';
    readonly tag = AccountDataEventType_Tags.IgnoredUserList;
    constructor() {
      super('AccountDataEventType', 'IgnoredUserList');
    }

    static new(): IgnoredUserList_ {
      return new IgnoredUserList_();
    }

    static instanceOf(obj: any): obj is IgnoredUserList_ {
      return obj.tag === AccountDataEventType_Tags.IgnoredUserList;
    }
  }

  type PushRules__interface = {
    tag: AccountDataEventType_Tags.PushRules;
  };

  /**
   * m.push_rules
   */
  class PushRules_ extends UniffiEnum implements PushRules__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEventType';
    readonly tag = AccountDataEventType_Tags.PushRules;
    constructor() {
      super('AccountDataEventType', 'PushRules');
    }

    static new(): PushRules_ {
      return new PushRules_();
    }

    static instanceOf(obj: any): obj is PushRules_ {
      return obj.tag === AccountDataEventType_Tags.PushRules;
    }
  }

  type SecretStorageDefaultKey__interface = {
    tag: AccountDataEventType_Tags.SecretStorageDefaultKey;
  };

  /**
   * m.secret_storage.default_key
   */
  class SecretStorageDefaultKey_
    extends UniffiEnum
    implements SecretStorageDefaultKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEventType';
    readonly tag = AccountDataEventType_Tags.SecretStorageDefaultKey;
    constructor() {
      super('AccountDataEventType', 'SecretStorageDefaultKey');
    }

    static new(): SecretStorageDefaultKey_ {
      return new SecretStorageDefaultKey_();
    }

    static instanceOf(obj: any): obj is SecretStorageDefaultKey_ {
      return obj.tag === AccountDataEventType_Tags.SecretStorageDefaultKey;
    }
  }

  type SecretStorageKey__interface = {
    tag: AccountDataEventType_Tags.SecretStorageKey;
    inner: Readonly<{ keyId: string }>;
  };

  /**
   * m.secret_storage.key.*
   */
  class SecretStorageKey_
    extends UniffiEnum
    implements SecretStorageKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountDataEventType';
    readonly tag = AccountDataEventType_Tags.SecretStorageKey;
    readonly inner: Readonly<{ keyId: string }>;
    constructor(inner: { keyId: string }) {
      super('AccountDataEventType', 'SecretStorageKey');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { keyId: string }): SecretStorageKey_ {
      return new SecretStorageKey_(inner);
    }

    static instanceOf(obj: any): obj is SecretStorageKey_ {
      return obj.tag === AccountDataEventType_Tags.SecretStorageKey;
    }
  }

  function instanceOf(obj: any): obj is AccountDataEventType {
    return obj[uniffiTypeNameSymbol] === 'AccountDataEventType';
  }

  return Object.freeze({
    instanceOf,
    Direct: Direct_,
    IdentityServer: IdentityServer_,
    IgnoredUserList: IgnoredUserList_,
    PushRules: PushRules_,
    SecretStorageDefaultKey: SecretStorageDefaultKey_,
    SecretStorageKey: SecretStorageKey_,
  });
})();

/**
 * Types of global account data events.
 */

export type AccountDataEventType = InstanceType<
  (typeof AccountDataEventType)[keyof Omit<
    typeof AccountDataEventType,
    'instanceOf'
  >]
>;

// FfiConverter for enum AccountDataEventType
const FfiConverterTypeAccountDataEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AccountDataEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AccountDataEventType.Direct();
        case 2:
          return new AccountDataEventType.IdentityServer();
        case 3:
          return new AccountDataEventType.IgnoredUserList();
        case 4:
          return new AccountDataEventType.PushRules();
        case 5:
          return new AccountDataEventType.SecretStorageDefaultKey();
        case 6:
          return new AccountDataEventType.SecretStorageKey({
            keyId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AccountDataEventType_Tags.Direct: {
          ordinalConverter.write(1, into);
          return;
        }
        case AccountDataEventType_Tags.IdentityServer: {
          ordinalConverter.write(2, into);
          return;
        }
        case AccountDataEventType_Tags.IgnoredUserList: {
          ordinalConverter.write(3, into);
          return;
        }
        case AccountDataEventType_Tags.PushRules: {
          ordinalConverter.write(4, into);
          return;
        }
        case AccountDataEventType_Tags.SecretStorageDefaultKey: {
          ordinalConverter.write(5, into);
          return;
        }
        case AccountDataEventType_Tags.SecretStorageKey: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.keyId, into);
          return;
        }
        default:
          // Throwing from here means that AccountDataEventType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AccountDataEventType_Tags.Direct: {
          return ordinalConverter.allocationSize(1);
        }
        case AccountDataEventType_Tags.IdentityServer: {
          return ordinalConverter.allocationSize(2);
        }
        case AccountDataEventType_Tags.IgnoredUserList: {
          return ordinalConverter.allocationSize(3);
        }
        case AccountDataEventType_Tags.PushRules: {
          return ordinalConverter.allocationSize(4);
        }
        case AccountDataEventType_Tags.SecretStorageDefaultKey: {
          return ordinalConverter.allocationSize(5);
        }
        case AccountDataEventType_Tags.SecretStorageKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.keyId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: AccountManagementAction
export enum AccountManagementAction_Tags {
  Profile = 'Profile',
  SessionsList = 'SessionsList',
  SessionView = 'SessionView',
  SessionEnd = 'SessionEnd',
  AccountDeactivate = 'AccountDeactivate',
  CrossSigningReset = 'CrossSigningReset',
}
export const AccountManagementAction = (() => {
  type Profile__interface = {
    tag: AccountManagementAction_Tags.Profile;
  };

  class Profile_ extends UniffiEnum implements Profile__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.Profile;
    constructor() {
      super('AccountManagementAction', 'Profile');
    }

    static new(): Profile_ {
      return new Profile_();
    }

    static instanceOf(obj: any): obj is Profile_ {
      return obj.tag === AccountManagementAction_Tags.Profile;
    }
  }

  type SessionsList__interface = {
    tag: AccountManagementAction_Tags.SessionsList;
  };

  class SessionsList_ extends UniffiEnum implements SessionsList__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.SessionsList;
    constructor() {
      super('AccountManagementAction', 'SessionsList');
    }

    static new(): SessionsList_ {
      return new SessionsList_();
    }

    static instanceOf(obj: any): obj is SessionsList_ {
      return obj.tag === AccountManagementAction_Tags.SessionsList;
    }
  }

  type SessionView__interface = {
    tag: AccountManagementAction_Tags.SessionView;
    inner: Readonly<{ deviceId: string }>;
  };

  class SessionView_ extends UniffiEnum implements SessionView__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.SessionView;
    readonly inner: Readonly<{ deviceId: string }>;
    constructor(inner: { deviceId: string }) {
      super('AccountManagementAction', 'SessionView');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { deviceId: string }): SessionView_ {
      return new SessionView_(inner);
    }

    static instanceOf(obj: any): obj is SessionView_ {
      return obj.tag === AccountManagementAction_Tags.SessionView;
    }
  }

  type SessionEnd__interface = {
    tag: AccountManagementAction_Tags.SessionEnd;
    inner: Readonly<{ deviceId: string }>;
  };

  class SessionEnd_ extends UniffiEnum implements SessionEnd__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.SessionEnd;
    readonly inner: Readonly<{ deviceId: string }>;
    constructor(inner: { deviceId: string }) {
      super('AccountManagementAction', 'SessionEnd');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { deviceId: string }): SessionEnd_ {
      return new SessionEnd_(inner);
    }

    static instanceOf(obj: any): obj is SessionEnd_ {
      return obj.tag === AccountManagementAction_Tags.SessionEnd;
    }
  }

  type AccountDeactivate__interface = {
    tag: AccountManagementAction_Tags.AccountDeactivate;
  };

  class AccountDeactivate_
    extends UniffiEnum
    implements AccountDeactivate__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.AccountDeactivate;
    constructor() {
      super('AccountManagementAction', 'AccountDeactivate');
    }

    static new(): AccountDeactivate_ {
      return new AccountDeactivate_();
    }

    static instanceOf(obj: any): obj is AccountDeactivate_ {
      return obj.tag === AccountManagementAction_Tags.AccountDeactivate;
    }
  }

  type CrossSigningReset__interface = {
    tag: AccountManagementAction_Tags.CrossSigningReset;
  };

  class CrossSigningReset_
    extends UniffiEnum
    implements CrossSigningReset__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AccountManagementAction';
    readonly tag = AccountManagementAction_Tags.CrossSigningReset;
    constructor() {
      super('AccountManagementAction', 'CrossSigningReset');
    }

    static new(): CrossSigningReset_ {
      return new CrossSigningReset_();
    }

    static instanceOf(obj: any): obj is CrossSigningReset_ {
      return obj.tag === AccountManagementAction_Tags.CrossSigningReset;
    }
  }

  function instanceOf(obj: any): obj is AccountManagementAction {
    return obj[uniffiTypeNameSymbol] === 'AccountManagementAction';
  }

  return Object.freeze({
    instanceOf,
    Profile: Profile_,
    SessionsList: SessionsList_,
    SessionView: SessionView_,
    SessionEnd: SessionEnd_,
    AccountDeactivate: AccountDeactivate_,
    CrossSigningReset: CrossSigningReset_,
  });
})();

export type AccountManagementAction = InstanceType<
  (typeof AccountManagementAction)[keyof Omit<
    typeof AccountManagementAction,
    'instanceOf'
  >]
>;

// FfiConverter for enum AccountManagementAction
const FfiConverterTypeAccountManagementAction = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AccountManagementAction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AccountManagementAction.Profile();
        case 2:
          return new AccountManagementAction.SessionsList();
        case 3:
          return new AccountManagementAction.SessionView({
            deviceId: FfiConverterString.read(from),
          });
        case 4:
          return new AccountManagementAction.SessionEnd({
            deviceId: FfiConverterString.read(from),
          });
        case 5:
          return new AccountManagementAction.AccountDeactivate();
        case 6:
          return new AccountManagementAction.CrossSigningReset();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AccountManagementAction_Tags.Profile: {
          ordinalConverter.write(1, into);
          return;
        }
        case AccountManagementAction_Tags.SessionsList: {
          ordinalConverter.write(2, into);
          return;
        }
        case AccountManagementAction_Tags.SessionView: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.deviceId, into);
          return;
        }
        case AccountManagementAction_Tags.SessionEnd: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.deviceId, into);
          return;
        }
        case AccountManagementAction_Tags.AccountDeactivate: {
          ordinalConverter.write(5, into);
          return;
        }
        case AccountManagementAction_Tags.CrossSigningReset: {
          ordinalConverter.write(6, into);
          return;
        }
        default:
          // Throwing from here means that AccountManagementAction_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AccountManagementAction_Tags.Profile: {
          return ordinalConverter.allocationSize(1);
        }
        case AccountManagementAction_Tags.SessionsList: {
          return ordinalConverter.allocationSize(2);
        }
        case AccountManagementAction_Tags.SessionView: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.deviceId);
          return size;
        }
        case AccountManagementAction_Tags.SessionEnd: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.deviceId);
          return size;
        }
        case AccountManagementAction_Tags.AccountDeactivate: {
          return ordinalConverter.allocationSize(5);
        }
        case AccountManagementAction_Tags.CrossSigningReset: {
          return ordinalConverter.allocationSize(6);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Action
export enum Action_Tags {
  Notify = 'Notify',
  SetTweak = 'SetTweak',
}
/**
 * Enum representing the push notification actions for a rule.
 */
export const Action = (() => {
  type Notify__interface = {
    tag: Action_Tags.Notify;
  };

  /**
   * Causes matching events to generate a notification.
   */
  class Notify_ extends UniffiEnum implements Notify__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Action';
    readonly tag = Action_Tags.Notify;
    constructor() {
      super('Action', 'Notify');
    }

    static new(): Notify_ {
      return new Notify_();
    }

    static instanceOf(obj: any): obj is Notify_ {
      return obj.tag === Action_Tags.Notify;
    }
  }

  type SetTweak__interface = {
    tag: Action_Tags.SetTweak;
    inner: Readonly<{ value: Tweak }>;
  };

  /**
   * Sets an entry in the 'tweaks' dictionary sent to the push gateway.
   */
  class SetTweak_ extends UniffiEnum implements SetTweak__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Action';
    readonly tag = Action_Tags.SetTweak;
    readonly inner: Readonly<{ value: Tweak }>;
    constructor(inner: { value: Tweak }) {
      super('Action', 'SetTweak');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: Tweak }): SetTweak_ {
      return new SetTweak_(inner);
    }

    static instanceOf(obj: any): obj is SetTweak_ {
      return obj.tag === Action_Tags.SetTweak;
    }
  }

  function instanceOf(obj: any): obj is Action {
    return obj[uniffiTypeNameSymbol] === 'Action';
  }

  return Object.freeze({
    instanceOf,
    Notify: Notify_,
    SetTweak: SetTweak_,
  });
})();

/**
 * Enum representing the push notification actions for a rule.
 */

export type Action = InstanceType<
  (typeof Action)[keyof Omit<typeof Action, 'instanceOf'>]
>;

// FfiConverter for enum Action
const FfiConverterTypeAction = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Action;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Action.Notify();
        case 2:
          return new Action.SetTweak({
            value: FfiConverterTypeTweak.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Action_Tags.Notify: {
          ordinalConverter.write(1, into);
          return;
        }
        case Action_Tags.SetTweak: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeTweak.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that Action_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Action_Tags.Notify: {
          return ordinalConverter.allocationSize(1);
        }
        case Action_Tags.SetTweak: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeTweak.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: AllowRule
export enum AllowRule_Tags {
  RoomMembership = 'RoomMembership',
  Custom = 'Custom',
}
/**
 * An allow rule which defines a condition that allows joining a room.
 */
export const AllowRule = (() => {
  type RoomMembership__interface = {
    tag: AllowRule_Tags.RoomMembership;
    inner: Readonly<{ roomId: string }>;
  };

  /**
   * Only a member of the `room_id` Room can join the one this rule is used
   * in.
   */
  class RoomMembership_
    extends UniffiEnum
    implements RoomMembership__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AllowRule';
    readonly tag = AllowRule_Tags.RoomMembership;
    readonly inner: Readonly<{ roomId: string }>;
    constructor(inner: { roomId: string }) {
      super('AllowRule', 'RoomMembership');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomId: string }): RoomMembership_ {
      return new RoomMembership_(inner);
    }

    static instanceOf(obj: any): obj is RoomMembership_ {
      return obj.tag === AllowRule_Tags.RoomMembership;
    }
  }

  type Custom__interface = {
    tag: AllowRule_Tags.Custom;
    inner: Readonly<{ json: string }>;
  };

  /**
   * A custom allow rule implementation, containing its JSON representation
   * as a `String`.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AllowRule';
    readonly tag = AllowRule_Tags.Custom;
    readonly inner: Readonly<{ json: string }>;
    constructor(inner: { json: string }) {
      super('AllowRule', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { json: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === AllowRule_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is AllowRule {
    return obj[uniffiTypeNameSymbol] === 'AllowRule';
  }

  return Object.freeze({
    instanceOf,
    RoomMembership: RoomMembership_,
    Custom: Custom_,
  });
})();

/**
 * An allow rule which defines a condition that allows joining a room.
 */

export type AllowRule = InstanceType<
  (typeof AllowRule)[keyof Omit<typeof AllowRule, 'instanceOf'>]
>;

// FfiConverter for enum AllowRule
const FfiConverterTypeAllowRule = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AllowRule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AllowRule.RoomMembership({
            roomId: FfiConverterString.read(from),
          });
        case 2:
          return new AllowRule.Custom({ json: FfiConverterString.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AllowRule_Tags.RoomMembership: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomId, into);
          return;
        }
        case AllowRule_Tags.Custom: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.json, into);
          return;
        }
        default:
          // Throwing from here means that AllowRule_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AllowRule_Tags.RoomMembership: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.roomId);
          return size;
        }
        case AllowRule_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.json);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum AssetType {
  Sender,
  Pin,
}

const FfiConverterTypeAssetType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AssetType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return AssetType.Sender;
        case 2:
          return AssetType.Pin;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case AssetType.Sender:
          return ordinalConverter.write(1, into);
        case AssetType.Pin:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: AuthData
export enum AuthData_Tags {
  Password = 'Password',
}
export const AuthData = (() => {
  type Password__interface = {
    tag: AuthData_Tags.Password;
    inner: Readonly<{ passwordDetails: AuthDataPasswordDetails }>;
  };

  /**
   * Password-based authentication (`m.login.password`).
   */
  class Password_ extends UniffiEnum implements Password__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AuthData';
    readonly tag = AuthData_Tags.Password;
    readonly inner: Readonly<{ passwordDetails: AuthDataPasswordDetails }>;
    constructor(inner: { passwordDetails: AuthDataPasswordDetails }) {
      super('AuthData', 'Password');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { passwordDetails: AuthDataPasswordDetails }): Password_ {
      return new Password_(inner);
    }

    static instanceOf(obj: any): obj is Password_ {
      return obj.tag === AuthData_Tags.Password;
    }
  }

  function instanceOf(obj: any): obj is AuthData {
    return obj[uniffiTypeNameSymbol] === 'AuthData';
  }

  return Object.freeze({
    instanceOf,
    Password: Password_,
  });
})();

export type AuthData = InstanceType<
  (typeof AuthData)[keyof Omit<typeof AuthData, 'instanceOf'>]
>;

// FfiConverter for enum AuthData
const FfiConverterTypeAuthData = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AuthData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AuthData.Password({
            passwordDetails: FfiConverterTypeAuthDataPasswordDetails.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AuthData_Tags.Password: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeAuthDataPasswordDetails.write(
            inner.passwordDetails,
            into
          );
          return;
        }
        default:
          // Throwing from here means that AuthData_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AuthData_Tags.Password: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeAuthDataPasswordDetails.allocationSize(
            inner.passwordDetails
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum BackupState {
  Unknown,
  Creating,
  Enabling,
  Resuming,
  Enabled,
  Downloading,
  Disabling,
}

const FfiConverterTypeBackupState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BackupState.Unknown;
        case 2:
          return BackupState.Creating;
        case 3:
          return BackupState.Enabling;
        case 4:
          return BackupState.Resuming;
        case 5:
          return BackupState.Enabled;
        case 6:
          return BackupState.Downloading;
        case 7:
          return BackupState.Disabling;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BackupState.Unknown:
          return ordinalConverter.write(1, into);
        case BackupState.Creating:
          return ordinalConverter.write(2, into);
        case BackupState.Enabling:
          return ordinalConverter.write(3, into);
        case BackupState.Resuming:
          return ordinalConverter.write(4, into);
        case BackupState.Enabled:
          return ordinalConverter.write(5, into);
        case BackupState.Downloading:
          return ordinalConverter.write(6, into);
        case BackupState.Disabling:
          return ordinalConverter.write(7, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: BackupUploadState
export enum BackupUploadState_Tags {
  Waiting = 'Waiting',
  Uploading = 'Uploading',
  Error = 'Error',
  Done = 'Done',
}
export const BackupUploadState = (() => {
  type Waiting__interface = {
    tag: BackupUploadState_Tags.Waiting;
  };

  class Waiting_ extends UniffiEnum implements Waiting__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BackupUploadState';
    readonly tag = BackupUploadState_Tags.Waiting;
    constructor() {
      super('BackupUploadState', 'Waiting');
    }

    static new(): Waiting_ {
      return new Waiting_();
    }

    static instanceOf(obj: any): obj is Waiting_ {
      return obj.tag === BackupUploadState_Tags.Waiting;
    }
  }

  type Uploading__interface = {
    tag: BackupUploadState_Tags.Uploading;
    inner: Readonly<{
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }>;
  };

  class Uploading_ extends UniffiEnum implements Uploading__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BackupUploadState';
    readonly tag = BackupUploadState_Tags.Uploading;
    readonly inner: Readonly<{
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }>;
    constructor(inner: {
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }) {
      super('BackupUploadState', 'Uploading');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }): Uploading_ {
      return new Uploading_(inner);
    }

    static instanceOf(obj: any): obj is Uploading_ {
      return obj.tag === BackupUploadState_Tags.Uploading;
    }
  }

  type Error__interface = {
    tag: BackupUploadState_Tags.Error;
  };

  class Error_ extends UniffiEnum implements Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BackupUploadState';
    readonly tag = BackupUploadState_Tags.Error;
    constructor() {
      super('BackupUploadState', 'Error');
    }

    static new(): Error_ {
      return new Error_();
    }

    static instanceOf(obj: any): obj is Error_ {
      return obj.tag === BackupUploadState_Tags.Error;
    }
  }

  type Done__interface = {
    tag: BackupUploadState_Tags.Done;
  };

  class Done_ extends UniffiEnum implements Done__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'BackupUploadState';
    readonly tag = BackupUploadState_Tags.Done;
    constructor() {
      super('BackupUploadState', 'Done');
    }

    static new(): Done_ {
      return new Done_();
    }

    static instanceOf(obj: any): obj is Done_ {
      return obj.tag === BackupUploadState_Tags.Done;
    }
  }

  function instanceOf(obj: any): obj is BackupUploadState {
    return obj[uniffiTypeNameSymbol] === 'BackupUploadState';
  }

  return Object.freeze({
    instanceOf,
    Waiting: Waiting_,
    Uploading: Uploading_,
    Error: Error_,
    Done: Done_,
  });
})();

export type BackupUploadState = InstanceType<
  (typeof BackupUploadState)[keyof Omit<typeof BackupUploadState, 'instanceOf'>]
>;

// FfiConverter for enum BackupUploadState
const FfiConverterTypeBackupUploadState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BackupUploadState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new BackupUploadState.Waiting();
        case 2:
          return new BackupUploadState.Uploading({
            backedUpCount: FfiConverterUInt32.read(from),
            totalCount: FfiConverterUInt32.read(from),
          });
        case 3:
          return new BackupUploadState.Error();
        case 4:
          return new BackupUploadState.Done();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case BackupUploadState_Tags.Waiting: {
          ordinalConverter.write(1, into);
          return;
        }
        case BackupUploadState_Tags.Uploading: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.backedUpCount, into);
          FfiConverterUInt32.write(inner.totalCount, into);
          return;
        }
        case BackupUploadState_Tags.Error: {
          ordinalConverter.write(3, into);
          return;
        }
        case BackupUploadState_Tags.Done: {
          ordinalConverter.write(4, into);
          return;
        }
        default:
          // Throwing from here means that BackupUploadState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case BackupUploadState_Tags.Waiting: {
          return ordinalConverter.allocationSize(1);
        }
        case BackupUploadState_Tags.Uploading: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt32.allocationSize(inner.backedUpCount);
          size += FfiConverterUInt32.allocationSize(inner.totalCount);
          return size;
        }
        case BackupUploadState_Tags.Error: {
          return ordinalConverter.allocationSize(3);
        }
        case BackupUploadState_Tags.Done: {
          return ordinalConverter.allocationSize(4);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: ClientBuildError
export enum ClientBuildError_Tags {
  InvalidServerName = 'InvalidServerName',
  ServerUnreachable = 'ServerUnreachable',
  WellKnownLookupFailed = 'WellKnownLookupFailed',
  WellKnownDeserializationError = 'WellKnownDeserializationError',
  SlidingSync = 'SlidingSync',
  SlidingSyncVersion = 'SlidingSyncVersion',
  Sdk = 'Sdk',
  EventCache = 'EventCache',
  Generic = 'Generic',
}
export const ClientBuildError = (() => {
  class InvalidServerName extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = ClientBuildError_Tags.InvalidServerName;

    constructor(message: string) {
      super('ClientBuildError', 'InvalidServerName', message);
    }

    static instanceOf(e: any): e is InvalidServerName {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class ServerUnreachable extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = ClientBuildError_Tags.ServerUnreachable;

    constructor(message: string) {
      super('ClientBuildError', 'ServerUnreachable', message);
    }

    static instanceOf(e: any): e is ServerUnreachable {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class WellKnownLookupFailed extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = ClientBuildError_Tags.WellKnownLookupFailed;

    constructor(message: string) {
      super('ClientBuildError', 'WellKnownLookupFailed', message);
    }

    static instanceOf(e: any): e is WellKnownLookupFailed {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class WellKnownDeserializationError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = ClientBuildError_Tags.WellKnownDeserializationError;

    constructor(message: string) {
      super('ClientBuildError', 'WellKnownDeserializationError', message);
    }

    static instanceOf(e: any): e is WellKnownDeserializationError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class SlidingSync extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = ClientBuildError_Tags.SlidingSync;

    constructor(message: string) {
      super('ClientBuildError', 'SlidingSync', message);
    }

    static instanceOf(e: any): e is SlidingSync {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class SlidingSyncVersion extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = ClientBuildError_Tags.SlidingSyncVersion;

    constructor(message: string) {
      super('ClientBuildError', 'SlidingSyncVersion', message);
    }

    static instanceOf(e: any): e is SlidingSyncVersion {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  class Sdk extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = ClientBuildError_Tags.Sdk;

    constructor(message: string) {
      super('ClientBuildError', 'Sdk', message);
    }

    static instanceOf(e: any): e is Sdk {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  class EventCache extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = ClientBuildError_Tags.EventCache;

    constructor(message: string) {
      super('ClientBuildError', 'EventCache', message);
    }

    static instanceOf(e: any): e is EventCache {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ClientBuildError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = ClientBuildError_Tags.Generic;

    constructor(message: string) {
      super('ClientBuildError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is ClientBuildError {
    return (e as any)[uniffiTypeNameSymbol] === 'ClientBuildError';
  }
  return {
    InvalidServerName,
    ServerUnreachable,
    WellKnownLookupFailed,
    WellKnownDeserializationError,
    SlidingSync,
    SlidingSyncVersion,
    Sdk,
    EventCache,
    Generic,
    instanceOf,
  };
})();

// Union type for ClientBuildError error type.

export type ClientBuildError = InstanceType<
  (typeof ClientBuildError)[keyof Omit<typeof ClientBuildError, 'instanceOf'>]
>;

const FfiConverterTypeClientBuildError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = ClientBuildError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new ClientBuildError.InvalidServerName(
            FfiConverterString.read(from)
          );

        case 2:
          return new ClientBuildError.ServerUnreachable(
            FfiConverterString.read(from)
          );

        case 3:
          return new ClientBuildError.WellKnownLookupFailed(
            FfiConverterString.read(from)
          );

        case 4:
          return new ClientBuildError.WellKnownDeserializationError(
            FfiConverterString.read(from)
          );

        case 5:
          return new ClientBuildError.SlidingSync(
            FfiConverterString.read(from)
          );

        case 6:
          return new ClientBuildError.SlidingSyncVersion(
            FfiConverterString.read(from)
          );

        case 7:
          return new ClientBuildError.Sdk(FfiConverterString.read(from));

        case 8:
          return new ClientBuildError.EventCache(FfiConverterString.read(from));

        case 9:
          return new ClientBuildError.Generic(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Error type: ClientError

// Enum: ClientError
export enum ClientError_Tags {
  Generic = 'Generic',
  MatrixApi = 'MatrixApi',
}
export const ClientError = (() => {
  type Generic__interface = {
    tag: ClientError_Tags.Generic;
    inner: Readonly<{ msg: string; details: string | undefined }>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientError';
    readonly tag = ClientError_Tags.Generic;
    readonly inner: Readonly<{ msg: string; details: string | undefined }>;
    constructor(inner: { msg: string; details: string | undefined }) {
      super('ClientError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string; details: string | undefined }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === ClientError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(
      obj: Generic_
    ): Readonly<{ msg: string; details: string | undefined }> {
      return obj.inner;
    }
  }

  type MatrixApi__interface = {
    tag: ClientError_Tags.MatrixApi;
    inner: Readonly<{
      kind: ErrorKind;
      code: string;
      msg: string;
      details: string | undefined;
    }>;
  };

  class MatrixApi_ extends UniffiError implements MatrixApi__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientError';
    readonly tag = ClientError_Tags.MatrixApi;
    readonly inner: Readonly<{
      kind: ErrorKind;
      code: string;
      msg: string;
      details: string | undefined;
    }>;
    constructor(inner: {
      kind: ErrorKind;
      code: string;
      msg: string;
      details: string | undefined;
    }) {
      super('ClientError', 'MatrixApi');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      kind: ErrorKind;
      code: string;
      msg: string;
      details: string | undefined;
    }): MatrixApi_ {
      return new MatrixApi_(inner);
    }

    static instanceOf(obj: any): obj is MatrixApi_ {
      return obj.tag === ClientError_Tags.MatrixApi;
    }

    static hasInner(obj: any): obj is MatrixApi_ {
      return MatrixApi_.instanceOf(obj);
    }

    static getInner(
      obj: MatrixApi_
    ): Readonly<{
      kind: ErrorKind;
      code: string;
      msg: string;
      details: string | undefined;
    }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is ClientError {
    return obj[uniffiTypeNameSymbol] === 'ClientError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
    MatrixApi: MatrixApi_,
  });
})();

export type ClientError = InstanceType<
  (typeof ClientError)[keyof Omit<typeof ClientError, 'instanceOf'>]
>;

// FfiConverter for enum ClientError
const FfiConverterTypeClientError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ClientError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ClientError.Generic({
            msg: FfiConverterString.read(from),
            details: FfiConverterOptionalString.read(from),
          });
        case 2:
          return new ClientError.MatrixApi({
            kind: FfiConverterTypeErrorKind.read(from),
            code: FfiConverterString.read(from),
            msg: FfiConverterString.read(from),
            details: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ClientError_Tags.Generic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          FfiConverterOptionalString.write(inner.details, into);
          return;
        }
        case ClientError_Tags.MatrixApi: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeErrorKind.write(inner.kind, into);
          FfiConverterString.write(inner.code, into);
          FfiConverterString.write(inner.msg, into);
          FfiConverterOptionalString.write(inner.details, into);
          return;
        }
        default:
          // Throwing from here means that ClientError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ClientError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.msg);
          size += FfiConverterOptionalString.allocationSize(inner.details);
          return size;
        }
        case ClientError_Tags.MatrixApi: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeErrorKind.allocationSize(inner.kind);
          size += FfiConverterString.allocationSize(inner.code);
          size += FfiConverterString.allocationSize(inner.msg);
          size += FfiConverterOptionalString.allocationSize(inner.details);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum ComparisonOperator {
  /**
   * Equals
   */
  Eq,
  /**
   * Less than
   */
  Lt,
  /**
   * Greater than
   */
  Gt,
  /**
   * Greater or equal
   */
  Ge,
  /**
   * Less or equal
   */
  Le,
}

const FfiConverterTypeComparisonOperator = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ComparisonOperator;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ComparisonOperator.Eq;
        case 2:
          return ComparisonOperator.Lt;
        case 3:
          return ComparisonOperator.Gt;
        case 4:
          return ComparisonOperator.Ge;
        case 5:
          return ComparisonOperator.Le;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ComparisonOperator.Eq:
          return ordinalConverter.write(1, into);
        case ComparisonOperator.Lt:
          return ordinalConverter.write(2, into);
        case ComparisonOperator.Gt:
          return ordinalConverter.write(3, into);
        case ComparisonOperator.Ge:
          return ordinalConverter.write(4, into);
        case ComparisonOperator.Le:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ComposerDraftType
export enum ComposerDraftType_Tags {
  NewMessage = 'NewMessage',
  Reply = 'Reply',
  Edit = 'Edit',
}
/**
 * The type of draft of the composer.
 */
export const ComposerDraftType = (() => {
  type NewMessage__interface = {
    tag: ComposerDraftType_Tags.NewMessage;
  };

  /**
   * The draft is a new message.
   */
  class NewMessage_ extends UniffiEnum implements NewMessage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ComposerDraftType';
    readonly tag = ComposerDraftType_Tags.NewMessage;
    constructor() {
      super('ComposerDraftType', 'NewMessage');
    }

    static new(): NewMessage_ {
      return new NewMessage_();
    }

    static instanceOf(obj: any): obj is NewMessage_ {
      return obj.tag === ComposerDraftType_Tags.NewMessage;
    }
  }

  type Reply__interface = {
    tag: ComposerDraftType_Tags.Reply;
    inner: Readonly<{ eventId: string }>;
  };

  /**
   * The draft is a reply to an event.
   */
  class Reply_ extends UniffiEnum implements Reply__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ComposerDraftType';
    readonly tag = ComposerDraftType_Tags.Reply;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: {
      /**
       * The ID of the event being replied to.
       */ eventId: string;
    }) {
      super('ComposerDraftType', 'Reply');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The ID of the event being replied to.
       */ eventId: string;
    }): Reply_ {
      return new Reply_(inner);
    }

    static instanceOf(obj: any): obj is Reply_ {
      return obj.tag === ComposerDraftType_Tags.Reply;
    }
  }

  type Edit__interface = {
    tag: ComposerDraftType_Tags.Edit;
    inner: Readonly<{ eventId: string }>;
  };

  /**
   * The draft is an edit of an event.
   */
  class Edit_ extends UniffiEnum implements Edit__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ComposerDraftType';
    readonly tag = ComposerDraftType_Tags.Edit;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: {
      /**
       * The ID of the event being edited.
       */ eventId: string;
    }) {
      super('ComposerDraftType', 'Edit');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The ID of the event being edited.
       */ eventId: string;
    }): Edit_ {
      return new Edit_(inner);
    }

    static instanceOf(obj: any): obj is Edit_ {
      return obj.tag === ComposerDraftType_Tags.Edit;
    }
  }

  function instanceOf(obj: any): obj is ComposerDraftType {
    return obj[uniffiTypeNameSymbol] === 'ComposerDraftType';
  }

  return Object.freeze({
    instanceOf,
    NewMessage: NewMessage_,
    Reply: Reply_,
    Edit: Edit_,
  });
})();

/**
 * The type of draft of the composer.
 */

export type ComposerDraftType = InstanceType<
  (typeof ComposerDraftType)[keyof Omit<typeof ComposerDraftType, 'instanceOf'>]
>;

// FfiConverter for enum ComposerDraftType
const FfiConverterTypeComposerDraftType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ComposerDraftType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ComposerDraftType.NewMessage();
        case 2:
          return new ComposerDraftType.Reply({
            eventId: FfiConverterString.read(from),
          });
        case 3:
          return new ComposerDraftType.Edit({
            eventId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ComposerDraftType_Tags.NewMessage: {
          ordinalConverter.write(1, into);
          return;
        }
        case ComposerDraftType_Tags.Reply: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case ComposerDraftType_Tags.Edit: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        default:
          // Throwing from here means that ComposerDraftType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ComposerDraftType_Tags.NewMessage: {
          return ordinalConverter.allocationSize(1);
        }
        case ComposerDraftType_Tags.Reply: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case ComposerDraftType_Tags.Edit: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: CrossSigningResetAuthType
export enum CrossSigningResetAuthType_Tags {
  Uiaa = 'Uiaa',
  Oidc = 'Oidc',
}
export const CrossSigningResetAuthType = (() => {
  type Uiaa__interface = {
    tag: CrossSigningResetAuthType_Tags.Uiaa;
  };

  /**
   * The homeserver requires user-interactive authentication.
   */
  class Uiaa_ extends UniffiEnum implements Uiaa__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CrossSigningResetAuthType';
    readonly tag = CrossSigningResetAuthType_Tags.Uiaa;
    constructor() {
      super('CrossSigningResetAuthType', 'Uiaa');
    }

    static new(): Uiaa_ {
      return new Uiaa_();
    }

    static instanceOf(obj: any): obj is Uiaa_ {
      return obj.tag === CrossSigningResetAuthType_Tags.Uiaa;
    }
  }

  type Oidc__interface = {
    tag: CrossSigningResetAuthType_Tags.Oidc;
    inner: Readonly<{ info: OidcCrossSigningResetInfo }>;
  };

  class Oidc_ extends UniffiEnum implements Oidc__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CrossSigningResetAuthType';
    readonly tag = CrossSigningResetAuthType_Tags.Oidc;
    readonly inner: Readonly<{ info: OidcCrossSigningResetInfo }>;
    constructor(inner: { info: OidcCrossSigningResetInfo }) {
      super('CrossSigningResetAuthType', 'Oidc');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { info: OidcCrossSigningResetInfo }): Oidc_ {
      return new Oidc_(inner);
    }

    static instanceOf(obj: any): obj is Oidc_ {
      return obj.tag === CrossSigningResetAuthType_Tags.Oidc;
    }
  }

  function instanceOf(obj: any): obj is CrossSigningResetAuthType {
    return obj[uniffiTypeNameSymbol] === 'CrossSigningResetAuthType';
  }

  return Object.freeze({
    instanceOf,
    Uiaa: Uiaa_,
    Oidc: Oidc_,
  });
})();

export type CrossSigningResetAuthType = InstanceType<
  (typeof CrossSigningResetAuthType)[keyof Omit<
    typeof CrossSigningResetAuthType,
    'instanceOf'
  >]
>;

// FfiConverter for enum CrossSigningResetAuthType
const FfiConverterTypeCrossSigningResetAuthType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = CrossSigningResetAuthType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new CrossSigningResetAuthType.Uiaa();
        case 2:
          return new CrossSigningResetAuthType.Oidc({
            info: FfiConverterTypeOidcCrossSigningResetInfo.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case CrossSigningResetAuthType_Tags.Uiaa: {
          ordinalConverter.write(1, into);
          return;
        }
        case CrossSigningResetAuthType_Tags.Oidc: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeOidcCrossSigningResetInfo.write(inner.info, into);
          return;
        }
        default:
          // Throwing from here means that CrossSigningResetAuthType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case CrossSigningResetAuthType_Tags.Uiaa: {
          return ordinalConverter.allocationSize(1);
        }
        case CrossSigningResetAuthType_Tags.Oidc: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeOidcCrossSigningResetInfo.allocationSize(
            inner.info
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Changes how date dividers get inserted, either in between each day or in
 * between each month
 */
export enum DateDividerMode {
  Daily,
  Monthly,
}

const FfiConverterTypeDateDividerMode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = DateDividerMode;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return DateDividerMode.Daily;
        case 2:
          return DateDividerMode.Monthly;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case DateDividerMode.Daily:
          return ordinalConverter.write(1, into);
        case DateDividerMode.Monthly:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: EditedContent
export enum EditedContent_Tags {
  RoomMessage = 'RoomMessage',
  MediaCaption = 'MediaCaption',
  PollStart = 'PollStart',
}
export const EditedContent = (() => {
  type RoomMessage__interface = {
    tag: EditedContent_Tags.RoomMessage;
    inner: Readonly<{
      content: RoomMessageEventContentWithoutRelationInterface;
    }>;
  };

  class RoomMessage_ extends UniffiEnum implements RoomMessage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EditedContent';
    readonly tag = EditedContent_Tags.RoomMessage;
    readonly inner: Readonly<{
      content: RoomMessageEventContentWithoutRelationInterface;
    }>;
    constructor(inner: {
      content: RoomMessageEventContentWithoutRelationInterface;
    }) {
      super('EditedContent', 'RoomMessage');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      content: RoomMessageEventContentWithoutRelationInterface;
    }): RoomMessage_ {
      return new RoomMessage_(inner);
    }

    static instanceOf(obj: any): obj is RoomMessage_ {
      return obj.tag === EditedContent_Tags.RoomMessage;
    }
  }

  type MediaCaption__interface = {
    tag: EditedContent_Tags.MediaCaption;
    inner: Readonly<{
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      mentions: Mentions | undefined;
    }>;
  };

  class MediaCaption_ extends UniffiEnum implements MediaCaption__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EditedContent';
    readonly tag = EditedContent_Tags.MediaCaption;
    readonly inner: Readonly<{
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      mentions: Mentions | undefined;
    }>;
    constructor(inner: {
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      mentions: Mentions | undefined;
    }) {
      super('EditedContent', 'MediaCaption');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      mentions: Mentions | undefined;
    }): MediaCaption_ {
      return new MediaCaption_(inner);
    }

    static instanceOf(obj: any): obj is MediaCaption_ {
      return obj.tag === EditedContent_Tags.MediaCaption;
    }
  }

  type PollStart__interface = {
    tag: EditedContent_Tags.PollStart;
    inner: Readonly<{ pollData: PollData }>;
  };

  class PollStart_ extends UniffiEnum implements PollStart__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EditedContent';
    readonly tag = EditedContent_Tags.PollStart;
    readonly inner: Readonly<{ pollData: PollData }>;
    constructor(inner: { pollData: PollData }) {
      super('EditedContent', 'PollStart');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { pollData: PollData }): PollStart_ {
      return new PollStart_(inner);
    }

    static instanceOf(obj: any): obj is PollStart_ {
      return obj.tag === EditedContent_Tags.PollStart;
    }
  }

  function instanceOf(obj: any): obj is EditedContent {
    return obj[uniffiTypeNameSymbol] === 'EditedContent';
  }

  return Object.freeze({
    instanceOf,
    RoomMessage: RoomMessage_,
    MediaCaption: MediaCaption_,
    PollStart: PollStart_,
  });
})();

export type EditedContent = InstanceType<
  (typeof EditedContent)[keyof Omit<typeof EditedContent, 'instanceOf'>]
>;

// FfiConverter for enum EditedContent
const FfiConverterTypeEditedContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EditedContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EditedContent.RoomMessage({
            content:
              FfiConverterTypeRoomMessageEventContentWithoutRelation.read(from),
          });
        case 2:
          return new EditedContent.MediaCaption({
            caption: FfiConverterOptionalString.read(from),
            formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
            mentions: FfiConverterOptionalTypeMentions.read(from),
          });
        case 3:
          return new EditedContent.PollStart({
            pollData: FfiConverterTypePollData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EditedContent_Tags.RoomMessage: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeRoomMessageEventContentWithoutRelation.write(
            inner.content,
            into
          );
          return;
        }
        case EditedContent_Tags.MediaCaption: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.caption, into);
          FfiConverterOptionalTypeFormattedBody.write(
            inner.formattedCaption,
            into
          );
          FfiConverterOptionalTypeMentions.write(inner.mentions, into);
          return;
        }
        case EditedContent_Tags.PollStart: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypePollData.write(inner.pollData, into);
          return;
        }
        default:
          // Throwing from here means that EditedContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EditedContent_Tags.RoomMessage: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size +=
            FfiConverterTypeRoomMessageEventContentWithoutRelation.allocationSize(
              inner.content
            );
          return size;
        }
        case EditedContent_Tags.MediaCaption: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalString.allocationSize(inner.caption);
          size += FfiConverterOptionalTypeFormattedBody.allocationSize(
            inner.formattedCaption
          );
          size += FfiConverterOptionalTypeMentions.allocationSize(
            inner.mentions
          );
          return size;
        }
        case EditedContent_Tags.PollStart: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypePollData.allocationSize(inner.pollData);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EmbeddedEventDetails
export enum EmbeddedEventDetails_Tags {
  Unavailable = 'Unavailable',
  Pending = 'Pending',
  Ready = 'Ready',
  Error = 'Error',
}
export const EmbeddedEventDetails = (() => {
  type Unavailable__interface = {
    tag: EmbeddedEventDetails_Tags.Unavailable;
  };

  class Unavailable_ extends UniffiEnum implements Unavailable__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EmbeddedEventDetails';
    readonly tag = EmbeddedEventDetails_Tags.Unavailable;
    constructor() {
      super('EmbeddedEventDetails', 'Unavailable');
    }

    static new(): Unavailable_ {
      return new Unavailable_();
    }

    static instanceOf(obj: any): obj is Unavailable_ {
      return obj.tag === EmbeddedEventDetails_Tags.Unavailable;
    }
  }

  type Pending__interface = {
    tag: EmbeddedEventDetails_Tags.Pending;
  };

  class Pending_ extends UniffiEnum implements Pending__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EmbeddedEventDetails';
    readonly tag = EmbeddedEventDetails_Tags.Pending;
    constructor() {
      super('EmbeddedEventDetails', 'Pending');
    }

    static new(): Pending_ {
      return new Pending_();
    }

    static instanceOf(obj: any): obj is Pending_ {
      return obj.tag === EmbeddedEventDetails_Tags.Pending;
    }
  }

  type Ready__interface = {
    tag: EmbeddedEventDetails_Tags.Ready;
    inner: Readonly<{
      content: TimelineItemContent;
      sender: string;
      senderProfile: ProfileDetails;
    }>;
  };

  class Ready_ extends UniffiEnum implements Ready__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EmbeddedEventDetails';
    readonly tag = EmbeddedEventDetails_Tags.Ready;
    readonly inner: Readonly<{
      content: TimelineItemContent;
      sender: string;
      senderProfile: ProfileDetails;
    }>;
    constructor(inner: {
      content: TimelineItemContent;
      sender: string;
      senderProfile: ProfileDetails;
    }) {
      super('EmbeddedEventDetails', 'Ready');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      content: TimelineItemContent;
      sender: string;
      senderProfile: ProfileDetails;
    }): Ready_ {
      return new Ready_(inner);
    }

    static instanceOf(obj: any): obj is Ready_ {
      return obj.tag === EmbeddedEventDetails_Tags.Ready;
    }
  }

  type Error__interface = {
    tag: EmbeddedEventDetails_Tags.Error;
    inner: Readonly<{ message: string }>;
  };

  class Error_ extends UniffiEnum implements Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EmbeddedEventDetails';
    readonly tag = EmbeddedEventDetails_Tags.Error;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('EmbeddedEventDetails', 'Error');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Error_ {
      return new Error_(inner);
    }

    static instanceOf(obj: any): obj is Error_ {
      return obj.tag === EmbeddedEventDetails_Tags.Error;
    }
  }

  function instanceOf(obj: any): obj is EmbeddedEventDetails {
    return obj[uniffiTypeNameSymbol] === 'EmbeddedEventDetails';
  }

  return Object.freeze({
    instanceOf,
    Unavailable: Unavailable_,
    Pending: Pending_,
    Ready: Ready_,
    Error: Error_,
  });
})();

export type EmbeddedEventDetails = InstanceType<
  (typeof EmbeddedEventDetails)[keyof Omit<
    typeof EmbeddedEventDetails,
    'instanceOf'
  >]
>;

// FfiConverter for enum EmbeddedEventDetails
const FfiConverterTypeEmbeddedEventDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EmbeddedEventDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EmbeddedEventDetails.Unavailable();
        case 2:
          return new EmbeddedEventDetails.Pending();
        case 3:
          return new EmbeddedEventDetails.Ready({
            content: FfiConverterTypeTimelineItemContent.read(from),
            sender: FfiConverterString.read(from),
            senderProfile: FfiConverterTypeProfileDetails.read(from),
          });
        case 4:
          return new EmbeddedEventDetails.Error({
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EmbeddedEventDetails_Tags.Unavailable: {
          ordinalConverter.write(1, into);
          return;
        }
        case EmbeddedEventDetails_Tags.Pending: {
          ordinalConverter.write(2, into);
          return;
        }
        case EmbeddedEventDetails_Tags.Ready: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeTimelineItemContent.write(inner.content, into);
          FfiConverterString.write(inner.sender, into);
          FfiConverterTypeProfileDetails.write(inner.senderProfile, into);
          return;
        }
        case EmbeddedEventDetails_Tags.Error: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that EmbeddedEventDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EmbeddedEventDetails_Tags.Unavailable: {
          return ordinalConverter.allocationSize(1);
        }
        case EmbeddedEventDetails_Tags.Pending: {
          return ordinalConverter.allocationSize(2);
        }
        case EmbeddedEventDetails_Tags.Ready: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeTimelineItemContent.allocationSize(
            inner.content
          );
          size += FfiConverterString.allocationSize(inner.sender);
          size += FfiConverterTypeProfileDetails.allocationSize(
            inner.senderProfile
          );
          return size;
        }
        case EmbeddedEventDetails_Tags.Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EnableRecoveryProgress
export enum EnableRecoveryProgress_Tags {
  Starting = 'Starting',
  CreatingBackup = 'CreatingBackup',
  CreatingRecoveryKey = 'CreatingRecoveryKey',
  BackingUp = 'BackingUp',
  RoomKeyUploadError = 'RoomKeyUploadError',
  Done = 'Done',
}
export const EnableRecoveryProgress = (() => {
  type Starting__interface = {
    tag: EnableRecoveryProgress_Tags.Starting;
  };

  class Starting_ extends UniffiEnum implements Starting__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.Starting;
    constructor() {
      super('EnableRecoveryProgress', 'Starting');
    }

    static new(): Starting_ {
      return new Starting_();
    }

    static instanceOf(obj: any): obj is Starting_ {
      return obj.tag === EnableRecoveryProgress_Tags.Starting;
    }
  }

  type CreatingBackup__interface = {
    tag: EnableRecoveryProgress_Tags.CreatingBackup;
  };

  class CreatingBackup_
    extends UniffiEnum
    implements CreatingBackup__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.CreatingBackup;
    constructor() {
      super('EnableRecoveryProgress', 'CreatingBackup');
    }

    static new(): CreatingBackup_ {
      return new CreatingBackup_();
    }

    static instanceOf(obj: any): obj is CreatingBackup_ {
      return obj.tag === EnableRecoveryProgress_Tags.CreatingBackup;
    }
  }

  type CreatingRecoveryKey__interface = {
    tag: EnableRecoveryProgress_Tags.CreatingRecoveryKey;
  };

  class CreatingRecoveryKey_
    extends UniffiEnum
    implements CreatingRecoveryKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.CreatingRecoveryKey;
    constructor() {
      super('EnableRecoveryProgress', 'CreatingRecoveryKey');
    }

    static new(): CreatingRecoveryKey_ {
      return new CreatingRecoveryKey_();
    }

    static instanceOf(obj: any): obj is CreatingRecoveryKey_ {
      return obj.tag === EnableRecoveryProgress_Tags.CreatingRecoveryKey;
    }
  }

  type BackingUp__interface = {
    tag: EnableRecoveryProgress_Tags.BackingUp;
    inner: Readonly<{
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }>;
  };

  class BackingUp_ extends UniffiEnum implements BackingUp__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.BackingUp;
    readonly inner: Readonly<{
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }>;
    constructor(inner: {
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }) {
      super('EnableRecoveryProgress', 'BackingUp');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      backedUpCount: /*u32*/ number;
      totalCount: /*u32*/ number;
    }): BackingUp_ {
      return new BackingUp_(inner);
    }

    static instanceOf(obj: any): obj is BackingUp_ {
      return obj.tag === EnableRecoveryProgress_Tags.BackingUp;
    }
  }

  type RoomKeyUploadError__interface = {
    tag: EnableRecoveryProgress_Tags.RoomKeyUploadError;
  };

  class RoomKeyUploadError_
    extends UniffiEnum
    implements RoomKeyUploadError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.RoomKeyUploadError;
    constructor() {
      super('EnableRecoveryProgress', 'RoomKeyUploadError');
    }

    static new(): RoomKeyUploadError_ {
      return new RoomKeyUploadError_();
    }

    static instanceOf(obj: any): obj is RoomKeyUploadError_ {
      return obj.tag === EnableRecoveryProgress_Tags.RoomKeyUploadError;
    }
  }

  type Done__interface = {
    tag: EnableRecoveryProgress_Tags.Done;
    inner: Readonly<{ recoveryKey: string }>;
  };

  class Done_ extends UniffiEnum implements Done__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EnableRecoveryProgress';
    readonly tag = EnableRecoveryProgress_Tags.Done;
    readonly inner: Readonly<{ recoveryKey: string }>;
    constructor(inner: { recoveryKey: string }) {
      super('EnableRecoveryProgress', 'Done');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { recoveryKey: string }): Done_ {
      return new Done_(inner);
    }

    static instanceOf(obj: any): obj is Done_ {
      return obj.tag === EnableRecoveryProgress_Tags.Done;
    }
  }

  function instanceOf(obj: any): obj is EnableRecoveryProgress {
    return obj[uniffiTypeNameSymbol] === 'EnableRecoveryProgress';
  }

  return Object.freeze({
    instanceOf,
    Starting: Starting_,
    CreatingBackup: CreatingBackup_,
    CreatingRecoveryKey: CreatingRecoveryKey_,
    BackingUp: BackingUp_,
    RoomKeyUploadError: RoomKeyUploadError_,
    Done: Done_,
  });
})();

export type EnableRecoveryProgress = InstanceType<
  (typeof EnableRecoveryProgress)[keyof Omit<
    typeof EnableRecoveryProgress,
    'instanceOf'
  >]
>;

// FfiConverter for enum EnableRecoveryProgress
const FfiConverterTypeEnableRecoveryProgress = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EnableRecoveryProgress;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EnableRecoveryProgress.Starting();
        case 2:
          return new EnableRecoveryProgress.CreatingBackup();
        case 3:
          return new EnableRecoveryProgress.CreatingRecoveryKey();
        case 4:
          return new EnableRecoveryProgress.BackingUp({
            backedUpCount: FfiConverterUInt32.read(from),
            totalCount: FfiConverterUInt32.read(from),
          });
        case 5:
          return new EnableRecoveryProgress.RoomKeyUploadError();
        case 6:
          return new EnableRecoveryProgress.Done({
            recoveryKey: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EnableRecoveryProgress_Tags.Starting: {
          ordinalConverter.write(1, into);
          return;
        }
        case EnableRecoveryProgress_Tags.CreatingBackup: {
          ordinalConverter.write(2, into);
          return;
        }
        case EnableRecoveryProgress_Tags.CreatingRecoveryKey: {
          ordinalConverter.write(3, into);
          return;
        }
        case EnableRecoveryProgress_Tags.BackingUp: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.backedUpCount, into);
          FfiConverterUInt32.write(inner.totalCount, into);
          return;
        }
        case EnableRecoveryProgress_Tags.RoomKeyUploadError: {
          ordinalConverter.write(5, into);
          return;
        }
        case EnableRecoveryProgress_Tags.Done: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.recoveryKey, into);
          return;
        }
        default:
          // Throwing from here means that EnableRecoveryProgress_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EnableRecoveryProgress_Tags.Starting: {
          return ordinalConverter.allocationSize(1);
        }
        case EnableRecoveryProgress_Tags.CreatingBackup: {
          return ordinalConverter.allocationSize(2);
        }
        case EnableRecoveryProgress_Tags.CreatingRecoveryKey: {
          return ordinalConverter.allocationSize(3);
        }
        case EnableRecoveryProgress_Tags.BackingUp: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterUInt32.allocationSize(inner.backedUpCount);
          size += FfiConverterUInt32.allocationSize(inner.totalCount);
          return size;
        }
        case EnableRecoveryProgress_Tags.RoomKeyUploadError: {
          return ordinalConverter.allocationSize(5);
        }
        case EnableRecoveryProgress_Tags.Done: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.recoveryKey);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EncryptedMessage
export enum EncryptedMessage_Tags {
  OlmV1Curve25519AesSha2 = 'OlmV1Curve25519AesSha2',
  MegolmV1AesSha2 = 'MegolmV1AesSha2',
  Unknown = 'Unknown',
}
export const EncryptedMessage = (() => {
  type OlmV1Curve25519AesSha2__interface = {
    tag: EncryptedMessage_Tags.OlmV1Curve25519AesSha2;
    inner: Readonly<{ senderKey: string }>;
  };

  class OlmV1Curve25519AesSha2_
    extends UniffiEnum
    implements OlmV1Curve25519AesSha2__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptedMessage';
    readonly tag = EncryptedMessage_Tags.OlmV1Curve25519AesSha2;
    readonly inner: Readonly<{ senderKey: string }>;
    constructor(inner: {
      /**
       * The Curve25519 key of the sender.
       */ senderKey: string;
    }) {
      super('EncryptedMessage', 'OlmV1Curve25519AesSha2');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The Curve25519 key of the sender.
       */ senderKey: string;
    }): OlmV1Curve25519AesSha2_ {
      return new OlmV1Curve25519AesSha2_(inner);
    }

    static instanceOf(obj: any): obj is OlmV1Curve25519AesSha2_ {
      return obj.tag === EncryptedMessage_Tags.OlmV1Curve25519AesSha2;
    }
  }

  type MegolmV1AesSha2__interface = {
    tag: EncryptedMessage_Tags.MegolmV1AesSha2;
    inner: Readonly<{ sessionId: string; cause: UtdCause }>;
  };

  class MegolmV1AesSha2_
    extends UniffiEnum
    implements MegolmV1AesSha2__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptedMessage';
    readonly tag = EncryptedMessage_Tags.MegolmV1AesSha2;
    readonly inner: Readonly<{ sessionId: string; cause: UtdCause }>;
    constructor(inner: {
      /**
       * The ID of the session used to encrypt the message.
       */ sessionId: string;
      /**
       * What we know about what caused this UTD. E.g. was this event sent
       * when we were not a member of this room?
       */ cause: UtdCause;
    }) {
      super('EncryptedMessage', 'MegolmV1AesSha2');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The ID of the session used to encrypt the message.
       */ sessionId: string;
      /**
       * What we know about what caused this UTD. E.g. was this event sent
       * when we were not a member of this room?
       */ cause: UtdCause;
    }): MegolmV1AesSha2_ {
      return new MegolmV1AesSha2_(inner);
    }

    static instanceOf(obj: any): obj is MegolmV1AesSha2_ {
      return obj.tag === EncryptedMessage_Tags.MegolmV1AesSha2;
    }
  }

  type Unknown__interface = {
    tag: EncryptedMessage_Tags.Unknown;
  };

  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptedMessage';
    readonly tag = EncryptedMessage_Tags.Unknown;
    constructor() {
      super('EncryptedMessage', 'Unknown');
    }

    static new(): Unknown_ {
      return new Unknown_();
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === EncryptedMessage_Tags.Unknown;
    }
  }

  function instanceOf(obj: any): obj is EncryptedMessage {
    return obj[uniffiTypeNameSymbol] === 'EncryptedMessage';
  }

  return Object.freeze({
    instanceOf,
    OlmV1Curve25519AesSha2: OlmV1Curve25519AesSha2_,
    MegolmV1AesSha2: MegolmV1AesSha2_,
    Unknown: Unknown_,
  });
})();

export type EncryptedMessage = InstanceType<
  (typeof EncryptedMessage)[keyof Omit<typeof EncryptedMessage, 'instanceOf'>]
>;

// FfiConverter for enum EncryptedMessage
const FfiConverterTypeEncryptedMessage = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EncryptedMessage;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EncryptedMessage.OlmV1Curve25519AesSha2({
            senderKey: FfiConverterString.read(from),
          });
        case 2:
          return new EncryptedMessage.MegolmV1AesSha2({
            sessionId: FfiConverterString.read(from),
            cause: FfiConverterTypeUtdCause.read(from),
          });
        case 3:
          return new EncryptedMessage.Unknown();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EncryptedMessage_Tags.OlmV1Curve25519AesSha2: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.senderKey, into);
          return;
        }
        case EncryptedMessage_Tags.MegolmV1AesSha2: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.sessionId, into);
          FfiConverterTypeUtdCause.write(inner.cause, into);
          return;
        }
        case EncryptedMessage_Tags.Unknown: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that EncryptedMessage_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EncryptedMessage_Tags.OlmV1Curve25519AesSha2: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.senderKey);
          return size;
        }
        case EncryptedMessage_Tags.MegolmV1AesSha2: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.sessionId);
          size += FfiConverterTypeUtdCause.allocationSize(inner.cause);
          return size;
        }
        case EncryptedMessage_Tags.Unknown: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EncryptionSystem
export enum EncryptionSystem_Tags {
  Unencrypted = 'Unencrypted',
  PerParticipantKeys = 'PerParticipantKeys',
  SharedSecret = 'SharedSecret',
}
/**
 * Defines if a call is encrypted and which encryption system should be used.
 *
 * This controls the url parameters: `perParticipantE2EE`, `password`.
 */
export const EncryptionSystem = (() => {
  type Unencrypted__interface = {
    tag: EncryptionSystem_Tags.Unencrypted;
  };

  /**
   * Equivalent to the element call url parameter: `enableE2EE=false`
   */
  class Unencrypted_ extends UniffiEnum implements Unencrypted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptionSystem';
    readonly tag = EncryptionSystem_Tags.Unencrypted;
    constructor() {
      super('EncryptionSystem', 'Unencrypted');
    }

    static new(): Unencrypted_ {
      return new Unencrypted_();
    }

    static instanceOf(obj: any): obj is Unencrypted_ {
      return obj.tag === EncryptionSystem_Tags.Unencrypted;
    }
  }

  type PerParticipantKeys__interface = {
    tag: EncryptionSystem_Tags.PerParticipantKeys;
  };

  /**
   * Equivalent to the element call url parameter:
   * `perParticipantE2EE=true`
   */
  class PerParticipantKeys_
    extends UniffiEnum
    implements PerParticipantKeys__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptionSystem';
    readonly tag = EncryptionSystem_Tags.PerParticipantKeys;
    constructor() {
      super('EncryptionSystem', 'PerParticipantKeys');
    }

    static new(): PerParticipantKeys_ {
      return new PerParticipantKeys_();
    }

    static instanceOf(obj: any): obj is PerParticipantKeys_ {
      return obj.tag === EncryptionSystem_Tags.PerParticipantKeys;
    }
  }

  type SharedSecret__interface = {
    tag: EncryptionSystem_Tags.SharedSecret;
    inner: Readonly<{ secret: string }>;
  };

  /**
   * Equivalent to the element call url parameter:
   * `password={secret}`
   */
  class SharedSecret_ extends UniffiEnum implements SharedSecret__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EncryptionSystem';
    readonly tag = EncryptionSystem_Tags.SharedSecret;
    readonly inner: Readonly<{ secret: string }>;
    constructor(inner: {
      /**
       * The secret/password which is used in the url.
       */ secret: string;
    }) {
      super('EncryptionSystem', 'SharedSecret');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The secret/password which is used in the url.
       */ secret: string;
    }): SharedSecret_ {
      return new SharedSecret_(inner);
    }

    static instanceOf(obj: any): obj is SharedSecret_ {
      return obj.tag === EncryptionSystem_Tags.SharedSecret;
    }
  }

  function instanceOf(obj: any): obj is EncryptionSystem {
    return obj[uniffiTypeNameSymbol] === 'EncryptionSystem';
  }

  return Object.freeze({
    instanceOf,
    Unencrypted: Unencrypted_,
    PerParticipantKeys: PerParticipantKeys_,
    SharedSecret: SharedSecret_,
  });
})();

/**
 * Defines if a call is encrypted and which encryption system should be used.
 *
 * This controls the url parameters: `perParticipantE2EE`, `password`.
 */

export type EncryptionSystem = InstanceType<
  (typeof EncryptionSystem)[keyof Omit<typeof EncryptionSystem, 'instanceOf'>]
>;

// FfiConverter for enum EncryptionSystem
const FfiConverterTypeEncryptionSystem = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EncryptionSystem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EncryptionSystem.Unencrypted();
        case 2:
          return new EncryptionSystem.PerParticipantKeys();
        case 3:
          return new EncryptionSystem.SharedSecret({
            secret: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EncryptionSystem_Tags.Unencrypted: {
          ordinalConverter.write(1, into);
          return;
        }
        case EncryptionSystem_Tags.PerParticipantKeys: {
          ordinalConverter.write(2, into);
          return;
        }
        case EncryptionSystem_Tags.SharedSecret: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.secret, into);
          return;
        }
        default:
          // Throwing from here means that EncryptionSystem_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EncryptionSystem_Tags.Unencrypted: {
          return ordinalConverter.allocationSize(1);
        }
        case EncryptionSystem_Tags.PerParticipantKeys: {
          return ordinalConverter.allocationSize(2);
        }
        case EncryptionSystem_Tags.SharedSecret: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.secret);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ErrorKind
export enum ErrorKind_Tags {
  BadAlias = 'BadAlias',
  BadJson = 'BadJson',
  BadState = 'BadState',
  BadStatus = 'BadStatus',
  CannotLeaveServerNoticeRoom = 'CannotLeaveServerNoticeRoom',
  CannotOverwriteMedia = 'CannotOverwriteMedia',
  CaptchaInvalid = 'CaptchaInvalid',
  CaptchaNeeded = 'CaptchaNeeded',
  ConnectionFailed = 'ConnectionFailed',
  ConnectionTimeout = 'ConnectionTimeout',
  DuplicateAnnotation = 'DuplicateAnnotation',
  Exclusive = 'Exclusive',
  Forbidden = 'Forbidden',
  GuestAccessForbidden = 'GuestAccessForbidden',
  IncompatibleRoomVersion = 'IncompatibleRoomVersion',
  InvalidParam = 'InvalidParam',
  InvalidRoomState = 'InvalidRoomState',
  InvalidUsername = 'InvalidUsername',
  LimitExceeded = 'LimitExceeded',
  MissingParam = 'MissingParam',
  MissingToken = 'MissingToken',
  NotFound = 'NotFound',
  NotJson = 'NotJson',
  NotYetUploaded = 'NotYetUploaded',
  ResourceLimitExceeded = 'ResourceLimitExceeded',
  RoomInUse = 'RoomInUse',
  ServerNotTrusted = 'ServerNotTrusted',
  ThreepidAuthFailed = 'ThreepidAuthFailed',
  ThreepidDenied = 'ThreepidDenied',
  ThreepidInUse = 'ThreepidInUse',
  ThreepidMediumNotSupported = 'ThreepidMediumNotSupported',
  ThreepidNotFound = 'ThreepidNotFound',
  TooLarge = 'TooLarge',
  UnableToAuthorizeJoin = 'UnableToAuthorizeJoin',
  UnableToGrantJoin = 'UnableToGrantJoin',
  Unauthorized = 'Unauthorized',
  Unknown = 'Unknown',
  UnknownToken = 'UnknownToken',
  Unrecognized = 'Unrecognized',
  UnsupportedRoomVersion = 'UnsupportedRoomVersion',
  UrlNotSet = 'UrlNotSet',
  UserDeactivated = 'UserDeactivated',
  UserInUse = 'UserInUse',
  UserLocked = 'UserLocked',
  UserSuspended = 'UserSuspended',
  WeakPassword = 'WeakPassword',
  WrongRoomKeysVersion = 'WrongRoomKeysVersion',
  Custom = 'Custom',
}
export const ErrorKind = (() => {
  type BadAlias__interface = {
    tag: ErrorKind_Tags.BadAlias;
  };

  /**
   * `M_BAD_ALIAS`
   *
   * One or more [room aliases] within the `m.room.canonical_alias` event do
   * not point to the room ID for which the state event is to be sent to.
   *
   * [room aliases]: https://spec.matrix.org/latest/client-server-api/#room-aliases
   */
  class BadAlias_ extends UniffiEnum implements BadAlias__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.BadAlias;
    constructor() {
      super('ErrorKind', 'BadAlias');
    }

    static new(): BadAlias_ {
      return new BadAlias_();
    }

    static instanceOf(obj: any): obj is BadAlias_ {
      return obj.tag === ErrorKind_Tags.BadAlias;
    }
  }

  type BadJson__interface = {
    tag: ErrorKind_Tags.BadJson;
  };

  /**
   * `M_BAD_JSON`
   *
   * The request contained valid JSON, but it was malformed in some way, e.g.
   * missing required keys, invalid values for keys.
   */
  class BadJson_ extends UniffiEnum implements BadJson__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.BadJson;
    constructor() {
      super('ErrorKind', 'BadJson');
    }

    static new(): BadJson_ {
      return new BadJson_();
    }

    static instanceOf(obj: any): obj is BadJson_ {
      return obj.tag === ErrorKind_Tags.BadJson;
    }
  }

  type BadState__interface = {
    tag: ErrorKind_Tags.BadState;
  };

  /**
   * `M_BAD_STATE`
   *
   * The state change requested cannot be performed, such as attempting to
   * unban a user who is not banned.
   */
  class BadState_ extends UniffiEnum implements BadState__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.BadState;
    constructor() {
      super('ErrorKind', 'BadState');
    }

    static new(): BadState_ {
      return new BadState_();
    }

    static instanceOf(obj: any): obj is BadState_ {
      return obj.tag === ErrorKind_Tags.BadState;
    }
  }

  type BadStatus__interface = {
    tag: ErrorKind_Tags.BadStatus;
    inner: Readonly<{
      status: /*u16*/ number | undefined;
      body: string | undefined;
    }>;
  };

  /**
   * `M_BAD_STATUS`
   *
   * The application service returned a bad status.
   */
  class BadStatus_ extends UniffiEnum implements BadStatus__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.BadStatus;
    readonly inner: Readonly<{
      status: /*u16*/ number | undefined;
      body: string | undefined;
    }>;
    constructor(inner: {
      /**
       * The HTTP status code of the response.
       */ status: /*u16*/ number | undefined;
      /**
       * The body of the response.
       */ body: string | undefined;
    }) {
      super('ErrorKind', 'BadStatus');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The HTTP status code of the response.
       */ status: /*u16*/ number | undefined;
      /**
       * The body of the response.
       */ body: string | undefined;
    }): BadStatus_ {
      return new BadStatus_(inner);
    }

    static instanceOf(obj: any): obj is BadStatus_ {
      return obj.tag === ErrorKind_Tags.BadStatus;
    }
  }

  type CannotLeaveServerNoticeRoom__interface = {
    tag: ErrorKind_Tags.CannotLeaveServerNoticeRoom;
  };

  /**
   * `M_CANNOT_LEAVE_SERVER_NOTICE_ROOM`
   *
   * The user is unable to reject an invite to join the [server notices]
   * room.
   *
   * [server notices]: https://spec.matrix.org/latest/client-server-api/#server-notices
   */
  class CannotLeaveServerNoticeRoom_
    extends UniffiEnum
    implements CannotLeaveServerNoticeRoom__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.CannotLeaveServerNoticeRoom;
    constructor() {
      super('ErrorKind', 'CannotLeaveServerNoticeRoom');
    }

    static new(): CannotLeaveServerNoticeRoom_ {
      return new CannotLeaveServerNoticeRoom_();
    }

    static instanceOf(obj: any): obj is CannotLeaveServerNoticeRoom_ {
      return obj.tag === ErrorKind_Tags.CannotLeaveServerNoticeRoom;
    }
  }

  type CannotOverwriteMedia__interface = {
    tag: ErrorKind_Tags.CannotOverwriteMedia;
  };

  /**
   * `M_CANNOT_OVERWRITE_MEDIA`
   *
   * The [`create_content_async`] endpoint was called with a media ID that
   * already has content.
   *
   * [`create_content_async`]: crate::media::create_content_async
   */
  class CannotOverwriteMedia_
    extends UniffiEnum
    implements CannotOverwriteMedia__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.CannotOverwriteMedia;
    constructor() {
      super('ErrorKind', 'CannotOverwriteMedia');
    }

    static new(): CannotOverwriteMedia_ {
      return new CannotOverwriteMedia_();
    }

    static instanceOf(obj: any): obj is CannotOverwriteMedia_ {
      return obj.tag === ErrorKind_Tags.CannotOverwriteMedia;
    }
  }

  type CaptchaInvalid__interface = {
    tag: ErrorKind_Tags.CaptchaInvalid;
  };

  /**
   * `M_CAPTCHA_INVALID`
   *
   * The Captcha provided did not match what was expected.
   */
  class CaptchaInvalid_
    extends UniffiEnum
    implements CaptchaInvalid__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.CaptchaInvalid;
    constructor() {
      super('ErrorKind', 'CaptchaInvalid');
    }

    static new(): CaptchaInvalid_ {
      return new CaptchaInvalid_();
    }

    static instanceOf(obj: any): obj is CaptchaInvalid_ {
      return obj.tag === ErrorKind_Tags.CaptchaInvalid;
    }
  }

  type CaptchaNeeded__interface = {
    tag: ErrorKind_Tags.CaptchaNeeded;
  };

  /**
   * `M_CAPTCHA_NEEDED`
   *
   * A Captcha is required to complete the request.
   */
  class CaptchaNeeded_ extends UniffiEnum implements CaptchaNeeded__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.CaptchaNeeded;
    constructor() {
      super('ErrorKind', 'CaptchaNeeded');
    }

    static new(): CaptchaNeeded_ {
      return new CaptchaNeeded_();
    }

    static instanceOf(obj: any): obj is CaptchaNeeded_ {
      return obj.tag === ErrorKind_Tags.CaptchaNeeded;
    }
  }

  type ConnectionFailed__interface = {
    tag: ErrorKind_Tags.ConnectionFailed;
  };

  /**
   * `M_CONNECTION_FAILED`
   *
   * The connection to the application service failed.
   */
  class ConnectionFailed_
    extends UniffiEnum
    implements ConnectionFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.ConnectionFailed;
    constructor() {
      super('ErrorKind', 'ConnectionFailed');
    }

    static new(): ConnectionFailed_ {
      return new ConnectionFailed_();
    }

    static instanceOf(obj: any): obj is ConnectionFailed_ {
      return obj.tag === ErrorKind_Tags.ConnectionFailed;
    }
  }

  type ConnectionTimeout__interface = {
    tag: ErrorKind_Tags.ConnectionTimeout;
  };

  /**
   * `M_CONNECTION_TIMEOUT`
   *
   * The connection to the application service timed out.
   */
  class ConnectionTimeout_
    extends UniffiEnum
    implements ConnectionTimeout__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.ConnectionTimeout;
    constructor() {
      super('ErrorKind', 'ConnectionTimeout');
    }

    static new(): ConnectionTimeout_ {
      return new ConnectionTimeout_();
    }

    static instanceOf(obj: any): obj is ConnectionTimeout_ {
      return obj.tag === ErrorKind_Tags.ConnectionTimeout;
    }
  }

  type DuplicateAnnotation__interface = {
    tag: ErrorKind_Tags.DuplicateAnnotation;
  };

  /**
   * `M_DUPLICATE_ANNOTATION`
   *
   * The request is an attempt to send a [duplicate annotation].
   *
   * [duplicate annotation]: https://spec.matrix.org/latest/client-server-api/#avoiding-duplicate-annotations
   */
  class DuplicateAnnotation_
    extends UniffiEnum
    implements DuplicateAnnotation__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.DuplicateAnnotation;
    constructor() {
      super('ErrorKind', 'DuplicateAnnotation');
    }

    static new(): DuplicateAnnotation_ {
      return new DuplicateAnnotation_();
    }

    static instanceOf(obj: any): obj is DuplicateAnnotation_ {
      return obj.tag === ErrorKind_Tags.DuplicateAnnotation;
    }
  }

  type Exclusive__interface = {
    tag: ErrorKind_Tags.Exclusive;
  };

  /**
   * `M_EXCLUSIVE`
   *
   * The resource being requested is reserved by an application service, or
   * the application service making the request has not created the
   * resource.
   */
  class Exclusive_ extends UniffiEnum implements Exclusive__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.Exclusive;
    constructor() {
      super('ErrorKind', 'Exclusive');
    }

    static new(): Exclusive_ {
      return new Exclusive_();
    }

    static instanceOf(obj: any): obj is Exclusive_ {
      return obj.tag === ErrorKind_Tags.Exclusive;
    }
  }

  type Forbidden__interface = {
    tag: ErrorKind_Tags.Forbidden;
  };

  /**
   * `M_FORBIDDEN`
   *
   * Forbidden access, e.g. joining a room without permission, failed login.
   */
  class Forbidden_ extends UniffiEnum implements Forbidden__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.Forbidden;
    constructor() {
      super('ErrorKind', 'Forbidden');
    }

    static new(): Forbidden_ {
      return new Forbidden_();
    }

    static instanceOf(obj: any): obj is Forbidden_ {
      return obj.tag === ErrorKind_Tags.Forbidden;
    }
  }

  type GuestAccessForbidden__interface = {
    tag: ErrorKind_Tags.GuestAccessForbidden;
  };

  /**
   * `M_GUEST_ACCESS_FORBIDDEN`
   *
   * The room or resource does not permit [guests] to access it.
   *
   * [guests]: https://spec.matrix.org/latest/client-server-api/#guest-access
   */
  class GuestAccessForbidden_
    extends UniffiEnum
    implements GuestAccessForbidden__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.GuestAccessForbidden;
    constructor() {
      super('ErrorKind', 'GuestAccessForbidden');
    }

    static new(): GuestAccessForbidden_ {
      return new GuestAccessForbidden_();
    }

    static instanceOf(obj: any): obj is GuestAccessForbidden_ {
      return obj.tag === ErrorKind_Tags.GuestAccessForbidden;
    }
  }

  type IncompatibleRoomVersion__interface = {
    tag: ErrorKind_Tags.IncompatibleRoomVersion;
    inner: Readonly<{ roomVersion: string }>;
  };

  /**
   * `M_INCOMPATIBLE_ROOM_VERSION`
   *
   * The client attempted to join a room that has a version the server does
   * not support.
   */
  class IncompatibleRoomVersion_
    extends UniffiEnum
    implements IncompatibleRoomVersion__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.IncompatibleRoomVersion;
    readonly inner: Readonly<{ roomVersion: string }>;
    constructor(inner: {
      /**
       * The room's version.
       */ roomVersion: string;
    }) {
      super('ErrorKind', 'IncompatibleRoomVersion');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The room's version.
       */ roomVersion: string;
    }): IncompatibleRoomVersion_ {
      return new IncompatibleRoomVersion_(inner);
    }

    static instanceOf(obj: any): obj is IncompatibleRoomVersion_ {
      return obj.tag === ErrorKind_Tags.IncompatibleRoomVersion;
    }
  }

  type InvalidParam__interface = {
    tag: ErrorKind_Tags.InvalidParam;
  };

  /**
   * `M_INVALID_PARAM`
   *
   * A parameter that was specified has the wrong value. For example, the
   * server expected an integer and instead received a string.
   */
  class InvalidParam_ extends UniffiEnum implements InvalidParam__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.InvalidParam;
    constructor() {
      super('ErrorKind', 'InvalidParam');
    }

    static new(): InvalidParam_ {
      return new InvalidParam_();
    }

    static instanceOf(obj: any): obj is InvalidParam_ {
      return obj.tag === ErrorKind_Tags.InvalidParam;
    }
  }

  type InvalidRoomState__interface = {
    tag: ErrorKind_Tags.InvalidRoomState;
  };

  /**
   * `M_INVALID_ROOM_STATE`
   *
   * The initial state implied by the parameters to the [`create_room`]
   * request is invalid, e.g. the user's `power_level` is set below that
   * necessary to set the room name.
   *
   * [`create_room`]: crate::room::create_room
   */
  class InvalidRoomState_
    extends UniffiEnum
    implements InvalidRoomState__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.InvalidRoomState;
    constructor() {
      super('ErrorKind', 'InvalidRoomState');
    }

    static new(): InvalidRoomState_ {
      return new InvalidRoomState_();
    }

    static instanceOf(obj: any): obj is InvalidRoomState_ {
      return obj.tag === ErrorKind_Tags.InvalidRoomState;
    }
  }

  type InvalidUsername__interface = {
    tag: ErrorKind_Tags.InvalidUsername;
  };

  /**
   * `M_INVALID_USERNAME`
   *
   * The desired user name is not valid.
   */
  class InvalidUsername_
    extends UniffiEnum
    implements InvalidUsername__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.InvalidUsername;
    constructor() {
      super('ErrorKind', 'InvalidUsername');
    }

    static new(): InvalidUsername_ {
      return new InvalidUsername_();
    }

    static instanceOf(obj: any): obj is InvalidUsername_ {
      return obj.tag === ErrorKind_Tags.InvalidUsername;
    }
  }

  type LimitExceeded__interface = {
    tag: ErrorKind_Tags.LimitExceeded;
    inner: Readonly<{ retryAfterMs: /*u64*/ bigint | undefined }>;
  };

  /**
   * `M_LIMIT_EXCEEDED`
   *
   * The request has been refused due to [rate limiting]: too many requests
   * have been sent in a short period of time.
   *
   * [rate limiting]: https://spec.matrix.org/latest/client-server-api/#rate-limiting
   */
  class LimitExceeded_ extends UniffiEnum implements LimitExceeded__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.LimitExceeded;
    readonly inner: Readonly<{ retryAfterMs: /*u64*/ bigint | undefined }>;
    constructor(inner: {
      /**
       * How long a client should wait before they can try again.
       */ retryAfterMs: /*u64*/ bigint | undefined;
    }) {
      super('ErrorKind', 'LimitExceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * How long a client should wait before they can try again.
       */ retryAfterMs: /*u64*/ bigint | undefined;
    }): LimitExceeded_ {
      return new LimitExceeded_(inner);
    }

    static instanceOf(obj: any): obj is LimitExceeded_ {
      return obj.tag === ErrorKind_Tags.LimitExceeded;
    }
  }

  type MissingParam__interface = {
    tag: ErrorKind_Tags.MissingParam;
  };

  /**
   * `M_MISSING_PARAM`
   *
   * A required parameter was missing from the request.
   */
  class MissingParam_ extends UniffiEnum implements MissingParam__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.MissingParam;
    constructor() {
      super('ErrorKind', 'MissingParam');
    }

    static new(): MissingParam_ {
      return new MissingParam_();
    }

    static instanceOf(obj: any): obj is MissingParam_ {
      return obj.tag === ErrorKind_Tags.MissingParam;
    }
  }

  type MissingToken__interface = {
    tag: ErrorKind_Tags.MissingToken;
  };

  /**
   * `M_MISSING_TOKEN`
   *
   * No [access token] was specified for the request, but one is required.
   *
   * [access token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
   */
  class MissingToken_ extends UniffiEnum implements MissingToken__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.MissingToken;
    constructor() {
      super('ErrorKind', 'MissingToken');
    }

    static new(): MissingToken_ {
      return new MissingToken_();
    }

    static instanceOf(obj: any): obj is MissingToken_ {
      return obj.tag === ErrorKind_Tags.MissingToken;
    }
  }

  type NotFound__interface = {
    tag: ErrorKind_Tags.NotFound;
  };

  /**
   * `M_NOT_FOUND`
   *
   * No resource was found for this request.
   */
  class NotFound_ extends UniffiEnum implements NotFound__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.NotFound;
    constructor() {
      super('ErrorKind', 'NotFound');
    }

    static new(): NotFound_ {
      return new NotFound_();
    }

    static instanceOf(obj: any): obj is NotFound_ {
      return obj.tag === ErrorKind_Tags.NotFound;
    }
  }

  type NotJson__interface = {
    tag: ErrorKind_Tags.NotJson;
  };

  /**
   * `M_NOT_JSON`
   *
   * The request did not contain valid JSON.
   */
  class NotJson_ extends UniffiEnum implements NotJson__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.NotJson;
    constructor() {
      super('ErrorKind', 'NotJson');
    }

    static new(): NotJson_ {
      return new NotJson_();
    }

    static instanceOf(obj: any): obj is NotJson_ {
      return obj.tag === ErrorKind_Tags.NotJson;
    }
  }

  type NotYetUploaded__interface = {
    tag: ErrorKind_Tags.NotYetUploaded;
  };

  /**
   * `M_NOT_YET_UPLOADED`
   *
   * An `mxc:` URI generated with the [`create_mxc_uri`] endpoint was used
   * and the content is not yet available.
   *
   * [`create_mxc_uri`]: crate::media::create_mxc_uri
   */
  class NotYetUploaded_
    extends UniffiEnum
    implements NotYetUploaded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.NotYetUploaded;
    constructor() {
      super('ErrorKind', 'NotYetUploaded');
    }

    static new(): NotYetUploaded_ {
      return new NotYetUploaded_();
    }

    static instanceOf(obj: any): obj is NotYetUploaded_ {
      return obj.tag === ErrorKind_Tags.NotYetUploaded;
    }
  }

  type ResourceLimitExceeded__interface = {
    tag: ErrorKind_Tags.ResourceLimitExceeded;
    inner: Readonly<{ adminContact: string }>;
  };

  /**
   * `M_RESOURCE_LIMIT_EXCEEDED`
   *
   * The request cannot be completed because the homeserver has reached a
   * resource limit imposed on it. For example, a homeserver held in a
   * shared hosting environment may reach a resource limit if it starts
   * using too much memory or disk space.
   */
  class ResourceLimitExceeded_
    extends UniffiEnum
    implements ResourceLimitExceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.ResourceLimitExceeded;
    readonly inner: Readonly<{ adminContact: string }>;
    constructor(inner: {
      /**
       * A URI giving a contact method for the server administrator.
       */ adminContact: string;
    }) {
      super('ErrorKind', 'ResourceLimitExceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * A URI giving a contact method for the server administrator.
       */ adminContact: string;
    }): ResourceLimitExceeded_ {
      return new ResourceLimitExceeded_(inner);
    }

    static instanceOf(obj: any): obj is ResourceLimitExceeded_ {
      return obj.tag === ErrorKind_Tags.ResourceLimitExceeded;
    }
  }

  type RoomInUse__interface = {
    tag: ErrorKind_Tags.RoomInUse;
  };

  /**
   * `M_ROOM_IN_USE`
   *
   * The [room alias] specified in the [`create_room`] request is already
   * taken.
   *
   * [`create_room`]: crate::room::create_room
   * [room alias]: https://spec.matrix.org/latest/client-server-api/#room-aliases
   */
  class RoomInUse_ extends UniffiEnum implements RoomInUse__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.RoomInUse;
    constructor() {
      super('ErrorKind', 'RoomInUse');
    }

    static new(): RoomInUse_ {
      return new RoomInUse_();
    }

    static instanceOf(obj: any): obj is RoomInUse_ {
      return obj.tag === ErrorKind_Tags.RoomInUse;
    }
  }

  type ServerNotTrusted__interface = {
    tag: ErrorKind_Tags.ServerNotTrusted;
  };

  /**
   * `M_SERVER_NOT_TRUSTED`
   *
   * The client's request used a third-party server, e.g. identity server,
   * that this server does not trust.
   */
  class ServerNotTrusted_
    extends UniffiEnum
    implements ServerNotTrusted__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.ServerNotTrusted;
    constructor() {
      super('ErrorKind', 'ServerNotTrusted');
    }

    static new(): ServerNotTrusted_ {
      return new ServerNotTrusted_();
    }

    static instanceOf(obj: any): obj is ServerNotTrusted_ {
      return obj.tag === ErrorKind_Tags.ServerNotTrusted;
    }
  }

  type ThreepidAuthFailed__interface = {
    tag: ErrorKind_Tags.ThreepidAuthFailed;
  };

  /**
   * `M_THREEPID_AUTH_FAILED`
   *
   * Authentication could not be performed on the [third-party identifier].
   *
   * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
   */
  class ThreepidAuthFailed_
    extends UniffiEnum
    implements ThreepidAuthFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.ThreepidAuthFailed;
    constructor() {
      super('ErrorKind', 'ThreepidAuthFailed');
    }

    static new(): ThreepidAuthFailed_ {
      return new ThreepidAuthFailed_();
    }

    static instanceOf(obj: any): obj is ThreepidAuthFailed_ {
      return obj.tag === ErrorKind_Tags.ThreepidAuthFailed;
    }
  }

  type ThreepidDenied__interface = {
    tag: ErrorKind_Tags.ThreepidDenied;
  };

  /**
   * `M_THREEPID_DENIED`
   *
   * The server does not permit this [third-party identifier]. This may
   * happen if the server only permits, for example, email addresses from
   * a particular domain.
   *
   * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
   */
  class ThreepidDenied_
    extends UniffiEnum
    implements ThreepidDenied__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.ThreepidDenied;
    constructor() {
      super('ErrorKind', 'ThreepidDenied');
    }

    static new(): ThreepidDenied_ {
      return new ThreepidDenied_();
    }

    static instanceOf(obj: any): obj is ThreepidDenied_ {
      return obj.tag === ErrorKind_Tags.ThreepidDenied;
    }
  }

  type ThreepidInUse__interface = {
    tag: ErrorKind_Tags.ThreepidInUse;
  };

  /**
   * `M_THREEPID_IN_USE`
   *
   * The [third-party identifier] is already in use by another user.
   *
   * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
   */
  class ThreepidInUse_ extends UniffiEnum implements ThreepidInUse__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.ThreepidInUse;
    constructor() {
      super('ErrorKind', 'ThreepidInUse');
    }

    static new(): ThreepidInUse_ {
      return new ThreepidInUse_();
    }

    static instanceOf(obj: any): obj is ThreepidInUse_ {
      return obj.tag === ErrorKind_Tags.ThreepidInUse;
    }
  }

  type ThreepidMediumNotSupported__interface = {
    tag: ErrorKind_Tags.ThreepidMediumNotSupported;
  };

  /**
   * `M_THREEPID_MEDIUM_NOT_SUPPORTED`
   *
   * The homeserver does not support adding a [third-party identifier] of the
   * given medium.
   *
   * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
   */
  class ThreepidMediumNotSupported_
    extends UniffiEnum
    implements ThreepidMediumNotSupported__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.ThreepidMediumNotSupported;
    constructor() {
      super('ErrorKind', 'ThreepidMediumNotSupported');
    }

    static new(): ThreepidMediumNotSupported_ {
      return new ThreepidMediumNotSupported_();
    }

    static instanceOf(obj: any): obj is ThreepidMediumNotSupported_ {
      return obj.tag === ErrorKind_Tags.ThreepidMediumNotSupported;
    }
  }

  type ThreepidNotFound__interface = {
    tag: ErrorKind_Tags.ThreepidNotFound;
  };

  /**
   * `M_THREEPID_NOT_FOUND`
   *
   * No account matching the given [third-party identifier] could be found.
   *
   * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
   */
  class ThreepidNotFound_
    extends UniffiEnum
    implements ThreepidNotFound__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.ThreepidNotFound;
    constructor() {
      super('ErrorKind', 'ThreepidNotFound');
    }

    static new(): ThreepidNotFound_ {
      return new ThreepidNotFound_();
    }

    static instanceOf(obj: any): obj is ThreepidNotFound_ {
      return obj.tag === ErrorKind_Tags.ThreepidNotFound;
    }
  }

  type TooLarge__interface = {
    tag: ErrorKind_Tags.TooLarge;
  };

  /**
   * `M_TOO_LARGE`
   *
   * The request or entity was too large.
   */
  class TooLarge_ extends UniffiEnum implements TooLarge__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.TooLarge;
    constructor() {
      super('ErrorKind', 'TooLarge');
    }

    static new(): TooLarge_ {
      return new TooLarge_();
    }

    static instanceOf(obj: any): obj is TooLarge_ {
      return obj.tag === ErrorKind_Tags.TooLarge;
    }
  }

  type UnableToAuthorizeJoin__interface = {
    tag: ErrorKind_Tags.UnableToAuthorizeJoin;
  };

  /**
   * `M_UNABLE_TO_AUTHORISE_JOIN`
   *
   * The room is [restricted] and none of the conditions can be validated by
   * the homeserver. This can happen if the homeserver does not know
   * about any of the rooms listed as conditions, for example.
   *
   * [restricted]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
   */
  class UnableToAuthorizeJoin_
    extends UniffiEnum
    implements UnableToAuthorizeJoin__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.UnableToAuthorizeJoin;
    constructor() {
      super('ErrorKind', 'UnableToAuthorizeJoin');
    }

    static new(): UnableToAuthorizeJoin_ {
      return new UnableToAuthorizeJoin_();
    }

    static instanceOf(obj: any): obj is UnableToAuthorizeJoin_ {
      return obj.tag === ErrorKind_Tags.UnableToAuthorizeJoin;
    }
  }

  type UnableToGrantJoin__interface = {
    tag: ErrorKind_Tags.UnableToGrantJoin;
  };

  /**
   * `M_UNABLE_TO_GRANT_JOIN`
   *
   * A different server should be attempted for the join. This is typically
   * because the resident server can see that the joining user satisfies
   * one or more conditions, such as in the case of [restricted rooms],
   * but the resident server would be unable to meet the authorization
   * rules.
   *
   * [restricted rooms]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
   */
  class UnableToGrantJoin_
    extends UniffiEnum
    implements UnableToGrantJoin__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.UnableToGrantJoin;
    constructor() {
      super('ErrorKind', 'UnableToGrantJoin');
    }

    static new(): UnableToGrantJoin_ {
      return new UnableToGrantJoin_();
    }

    static instanceOf(obj: any): obj is UnableToGrantJoin_ {
      return obj.tag === ErrorKind_Tags.UnableToGrantJoin;
    }
  }

  type Unauthorized__interface = {
    tag: ErrorKind_Tags.Unauthorized;
  };

  /**
   * `M_UNAUTHORIZED`
   *
   * The request was not correctly authorized. Usually due to login failures.
   */
  class Unauthorized_ extends UniffiEnum implements Unauthorized__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.Unauthorized;
    constructor() {
      super('ErrorKind', 'Unauthorized');
    }

    static new(): Unauthorized_ {
      return new Unauthorized_();
    }

    static instanceOf(obj: any): obj is Unauthorized_ {
      return obj.tag === ErrorKind_Tags.Unauthorized;
    }
  }

  type Unknown__interface = {
    tag: ErrorKind_Tags.Unknown;
  };

  /**
   * `M_UNKNOWN`
   *
   * An unknown error has occurred.
   */
  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.Unknown;
    constructor() {
      super('ErrorKind', 'Unknown');
    }

    static new(): Unknown_ {
      return new Unknown_();
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === ErrorKind_Tags.Unknown;
    }
  }

  type UnknownToken__interface = {
    tag: ErrorKind_Tags.UnknownToken;
    inner: Readonly<{ softLogout: boolean }>;
  };

  /**
   * `M_UNKNOWN_TOKEN`
   *
   * The [access or refresh token] specified was not recognized.
   *
   * [access or refresh token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
   */
  class UnknownToken_ extends UniffiEnum implements UnknownToken__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.UnknownToken;
    readonly inner: Readonly<{ softLogout: boolean }>;
    constructor(inner: {
      /**
       * If this is `true`, the client is in a "[soft logout]" state, i.e.
       * the server requires re-authentication but the session is not
       * invalidated. The client can acquire a new access token by
       * specifying the device ID it is already using to the login API.
       *
       * [soft logout]: https://spec.matrix.org/latest/client-server-api/#soft-logout
       */ softLogout: boolean;
    }) {
      super('ErrorKind', 'UnknownToken');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * If this is `true`, the client is in a "[soft logout]" state, i.e.
       * the server requires re-authentication but the session is not
       * invalidated. The client can acquire a new access token by
       * specifying the device ID it is already using to the login API.
       *
       * [soft logout]: https://spec.matrix.org/latest/client-server-api/#soft-logout
       */ softLogout: boolean;
    }): UnknownToken_ {
      return new UnknownToken_(inner);
    }

    static instanceOf(obj: any): obj is UnknownToken_ {
      return obj.tag === ErrorKind_Tags.UnknownToken;
    }
  }

  type Unrecognized__interface = {
    tag: ErrorKind_Tags.Unrecognized;
  };

  /**
   * `M_UNRECOGNIZED`
   *
   * The server did not understand the request.
   *
   * This is expected to be returned with a 404 HTTP status code if the
   * endpoint is not implemented or a 405 HTTP status code if the
   * endpoint is implemented, but the incorrect HTTP method is used.
   */
  class Unrecognized_ extends UniffiEnum implements Unrecognized__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.Unrecognized;
    constructor() {
      super('ErrorKind', 'Unrecognized');
    }

    static new(): Unrecognized_ {
      return new Unrecognized_();
    }

    static instanceOf(obj: any): obj is Unrecognized_ {
      return obj.tag === ErrorKind_Tags.Unrecognized;
    }
  }

  type UnsupportedRoomVersion__interface = {
    tag: ErrorKind_Tags.UnsupportedRoomVersion;
  };

  /**
   * `M_UNSUPPORTED_ROOM_VERSION`
   *
   * The request to [`create_room`] used a room version that the server does
   * not support.
   *
   * [`create_room`]: crate::room::create_room
   */
  class UnsupportedRoomVersion_
    extends UniffiEnum
    implements UnsupportedRoomVersion__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.UnsupportedRoomVersion;
    constructor() {
      super('ErrorKind', 'UnsupportedRoomVersion');
    }

    static new(): UnsupportedRoomVersion_ {
      return new UnsupportedRoomVersion_();
    }

    static instanceOf(obj: any): obj is UnsupportedRoomVersion_ {
      return obj.tag === ErrorKind_Tags.UnsupportedRoomVersion;
    }
  }

  type UrlNotSet__interface = {
    tag: ErrorKind_Tags.UrlNotSet;
  };

  /**
   * `M_URL_NOT_SET`
   *
   * The application service doesn't have a URL configured.
   */
  class UrlNotSet_ extends UniffiEnum implements UrlNotSet__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.UrlNotSet;
    constructor() {
      super('ErrorKind', 'UrlNotSet');
    }

    static new(): UrlNotSet_ {
      return new UrlNotSet_();
    }

    static instanceOf(obj: any): obj is UrlNotSet_ {
      return obj.tag === ErrorKind_Tags.UrlNotSet;
    }
  }

  type UserDeactivated__interface = {
    tag: ErrorKind_Tags.UserDeactivated;
  };

  /**
   * `M_USER_DEACTIVATED`
   *
   * The user ID associated with the request has been deactivated.
   */
  class UserDeactivated_
    extends UniffiEnum
    implements UserDeactivated__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.UserDeactivated;
    constructor() {
      super('ErrorKind', 'UserDeactivated');
    }

    static new(): UserDeactivated_ {
      return new UserDeactivated_();
    }

    static instanceOf(obj: any): obj is UserDeactivated_ {
      return obj.tag === ErrorKind_Tags.UserDeactivated;
    }
  }

  type UserInUse__interface = {
    tag: ErrorKind_Tags.UserInUse;
  };

  /**
   * `M_USER_IN_USE`
   *
   * The desired user ID is already taken.
   */
  class UserInUse_ extends UniffiEnum implements UserInUse__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.UserInUse;
    constructor() {
      super('ErrorKind', 'UserInUse');
    }

    static new(): UserInUse_ {
      return new UserInUse_();
    }

    static instanceOf(obj: any): obj is UserInUse_ {
      return obj.tag === ErrorKind_Tags.UserInUse;
    }
  }

  type UserLocked__interface = {
    tag: ErrorKind_Tags.UserLocked;
  };

  /**
   * `M_USER_LOCKED`
   *
   * The account has been [locked] and cannot be used at this time.
   *
   * [locked]: https://spec.matrix.org/latest/client-server-api/#account-locking
   */
  class UserLocked_ extends UniffiEnum implements UserLocked__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.UserLocked;
    constructor() {
      super('ErrorKind', 'UserLocked');
    }

    static new(): UserLocked_ {
      return new UserLocked_();
    }

    static instanceOf(obj: any): obj is UserLocked_ {
      return obj.tag === ErrorKind_Tags.UserLocked;
    }
  }

  type UserSuspended__interface = {
    tag: ErrorKind_Tags.UserSuspended;
  };

  /**
   * `M_USER_SUSPENDED`
   *
   * The account has been [suspended] and can only be used for limited
   * actions at this time.
   *
   * [suspended]: https://spec.matrix.org/latest/client-server-api/#account-suspension
   */
  class UserSuspended_ extends UniffiEnum implements UserSuspended__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.UserSuspended;
    constructor() {
      super('ErrorKind', 'UserSuspended');
    }

    static new(): UserSuspended_ {
      return new UserSuspended_();
    }

    static instanceOf(obj: any): obj is UserSuspended_ {
      return obj.tag === ErrorKind_Tags.UserSuspended;
    }
  }

  type WeakPassword__interface = {
    tag: ErrorKind_Tags.WeakPassword;
  };

  /**
   * `M_WEAK_PASSWORD`
   *
   * The password was [rejected] by the server for being too weak.
   *
   * [rejected]: https://spec.matrix.org/latest/client-server-api/#notes-on-password-management
   */
  class WeakPassword_ extends UniffiEnum implements WeakPassword__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.WeakPassword;
    constructor() {
      super('ErrorKind', 'WeakPassword');
    }

    static new(): WeakPassword_ {
      return new WeakPassword_();
    }

    static instanceOf(obj: any): obj is WeakPassword_ {
      return obj.tag === ErrorKind_Tags.WeakPassword;
    }
  }

  type WrongRoomKeysVersion__interface = {
    tag: ErrorKind_Tags.WrongRoomKeysVersion;
    inner: Readonly<{ currentVersion: string | undefined }>;
  };

  /**
   * `M_WRONG_ROOM_KEYS_VERSION`
   *
   * The version of the [room keys backup] provided in the request does not
   * match the current backup version.
   *
   * [room keys backup]: https://spec.matrix.org/latest/client-server-api/#server-side-key-backups
   */
  class WrongRoomKeysVersion_
    extends UniffiEnum
    implements WrongRoomKeysVersion__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.WrongRoomKeysVersion;
    readonly inner: Readonly<{ currentVersion: string | undefined }>;
    constructor(inner: {
      /**
       * The currently active backup version.
       */ currentVersion: string | undefined;
    }) {
      super('ErrorKind', 'WrongRoomKeysVersion');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The currently active backup version.
       */ currentVersion: string | undefined;
    }): WrongRoomKeysVersion_ {
      return new WrongRoomKeysVersion_(inner);
    }

    static instanceOf(obj: any): obj is WrongRoomKeysVersion_ {
      return obj.tag === ErrorKind_Tags.WrongRoomKeysVersion;
    }
  }

  type Custom__interface = {
    tag: ErrorKind_Tags.Custom;
    inner: Readonly<{ errcode: string }>;
  };

  /**
   * A custom API error.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ErrorKind';
    readonly tag = ErrorKind_Tags.Custom;
    readonly inner: Readonly<{ errcode: string }>;
    constructor(inner: { errcode: string }) {
      super('ErrorKind', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { errcode: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === ErrorKind_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is ErrorKind {
    return obj[uniffiTypeNameSymbol] === 'ErrorKind';
  }

  return Object.freeze({
    instanceOf,
    BadAlias: BadAlias_,
    BadJson: BadJson_,
    BadState: BadState_,
    BadStatus: BadStatus_,
    CannotLeaveServerNoticeRoom: CannotLeaveServerNoticeRoom_,
    CannotOverwriteMedia: CannotOverwriteMedia_,
    CaptchaInvalid: CaptchaInvalid_,
    CaptchaNeeded: CaptchaNeeded_,
    ConnectionFailed: ConnectionFailed_,
    ConnectionTimeout: ConnectionTimeout_,
    DuplicateAnnotation: DuplicateAnnotation_,
    Exclusive: Exclusive_,
    Forbidden: Forbidden_,
    GuestAccessForbidden: GuestAccessForbidden_,
    IncompatibleRoomVersion: IncompatibleRoomVersion_,
    InvalidParam: InvalidParam_,
    InvalidRoomState: InvalidRoomState_,
    InvalidUsername: InvalidUsername_,
    LimitExceeded: LimitExceeded_,
    MissingParam: MissingParam_,
    MissingToken: MissingToken_,
    NotFound: NotFound_,
    NotJson: NotJson_,
    NotYetUploaded: NotYetUploaded_,
    ResourceLimitExceeded: ResourceLimitExceeded_,
    RoomInUse: RoomInUse_,
    ServerNotTrusted: ServerNotTrusted_,
    ThreepidAuthFailed: ThreepidAuthFailed_,
    ThreepidDenied: ThreepidDenied_,
    ThreepidInUse: ThreepidInUse_,
    ThreepidMediumNotSupported: ThreepidMediumNotSupported_,
    ThreepidNotFound: ThreepidNotFound_,
    TooLarge: TooLarge_,
    UnableToAuthorizeJoin: UnableToAuthorizeJoin_,
    UnableToGrantJoin: UnableToGrantJoin_,
    Unauthorized: Unauthorized_,
    Unknown: Unknown_,
    UnknownToken: UnknownToken_,
    Unrecognized: Unrecognized_,
    UnsupportedRoomVersion: UnsupportedRoomVersion_,
    UrlNotSet: UrlNotSet_,
    UserDeactivated: UserDeactivated_,
    UserInUse: UserInUse_,
    UserLocked: UserLocked_,
    UserSuspended: UserSuspended_,
    WeakPassword: WeakPassword_,
    WrongRoomKeysVersion: WrongRoomKeysVersion_,
    Custom: Custom_,
  });
})();

export type ErrorKind = InstanceType<
  (typeof ErrorKind)[keyof Omit<typeof ErrorKind, 'instanceOf'>]
>;

// FfiConverter for enum ErrorKind
const FfiConverterTypeErrorKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ErrorKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ErrorKind.BadAlias();
        case 2:
          return new ErrorKind.BadJson();
        case 3:
          return new ErrorKind.BadState();
        case 4:
          return new ErrorKind.BadStatus({
            status: FfiConverterOptionalUInt16.read(from),
            body: FfiConverterOptionalString.read(from),
          });
        case 5:
          return new ErrorKind.CannotLeaveServerNoticeRoom();
        case 6:
          return new ErrorKind.CannotOverwriteMedia();
        case 7:
          return new ErrorKind.CaptchaInvalid();
        case 8:
          return new ErrorKind.CaptchaNeeded();
        case 9:
          return new ErrorKind.ConnectionFailed();
        case 10:
          return new ErrorKind.ConnectionTimeout();
        case 11:
          return new ErrorKind.DuplicateAnnotation();
        case 12:
          return new ErrorKind.Exclusive();
        case 13:
          return new ErrorKind.Forbidden();
        case 14:
          return new ErrorKind.GuestAccessForbidden();
        case 15:
          return new ErrorKind.IncompatibleRoomVersion({
            roomVersion: FfiConverterString.read(from),
          });
        case 16:
          return new ErrorKind.InvalidParam();
        case 17:
          return new ErrorKind.InvalidRoomState();
        case 18:
          return new ErrorKind.InvalidUsername();
        case 19:
          return new ErrorKind.LimitExceeded({
            retryAfterMs: FfiConverterOptionalUInt64.read(from),
          });
        case 20:
          return new ErrorKind.MissingParam();
        case 21:
          return new ErrorKind.MissingToken();
        case 22:
          return new ErrorKind.NotFound();
        case 23:
          return new ErrorKind.NotJson();
        case 24:
          return new ErrorKind.NotYetUploaded();
        case 25:
          return new ErrorKind.ResourceLimitExceeded({
            adminContact: FfiConverterString.read(from),
          });
        case 26:
          return new ErrorKind.RoomInUse();
        case 27:
          return new ErrorKind.ServerNotTrusted();
        case 28:
          return new ErrorKind.ThreepidAuthFailed();
        case 29:
          return new ErrorKind.ThreepidDenied();
        case 30:
          return new ErrorKind.ThreepidInUse();
        case 31:
          return new ErrorKind.ThreepidMediumNotSupported();
        case 32:
          return new ErrorKind.ThreepidNotFound();
        case 33:
          return new ErrorKind.TooLarge();
        case 34:
          return new ErrorKind.UnableToAuthorizeJoin();
        case 35:
          return new ErrorKind.UnableToGrantJoin();
        case 36:
          return new ErrorKind.Unauthorized();
        case 37:
          return new ErrorKind.Unknown();
        case 38:
          return new ErrorKind.UnknownToken({
            softLogout: FfiConverterBool.read(from),
          });
        case 39:
          return new ErrorKind.Unrecognized();
        case 40:
          return new ErrorKind.UnsupportedRoomVersion();
        case 41:
          return new ErrorKind.UrlNotSet();
        case 42:
          return new ErrorKind.UserDeactivated();
        case 43:
          return new ErrorKind.UserInUse();
        case 44:
          return new ErrorKind.UserLocked();
        case 45:
          return new ErrorKind.UserSuspended();
        case 46:
          return new ErrorKind.WeakPassword();
        case 47:
          return new ErrorKind.WrongRoomKeysVersion({
            currentVersion: FfiConverterOptionalString.read(from),
          });
        case 48:
          return new ErrorKind.Custom({
            errcode: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ErrorKind_Tags.BadAlias: {
          ordinalConverter.write(1, into);
          return;
        }
        case ErrorKind_Tags.BadJson: {
          ordinalConverter.write(2, into);
          return;
        }
        case ErrorKind_Tags.BadState: {
          ordinalConverter.write(3, into);
          return;
        }
        case ErrorKind_Tags.BadStatus: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterOptionalUInt16.write(inner.status, into);
          FfiConverterOptionalString.write(inner.body, into);
          return;
        }
        case ErrorKind_Tags.CannotLeaveServerNoticeRoom: {
          ordinalConverter.write(5, into);
          return;
        }
        case ErrorKind_Tags.CannotOverwriteMedia: {
          ordinalConverter.write(6, into);
          return;
        }
        case ErrorKind_Tags.CaptchaInvalid: {
          ordinalConverter.write(7, into);
          return;
        }
        case ErrorKind_Tags.CaptchaNeeded: {
          ordinalConverter.write(8, into);
          return;
        }
        case ErrorKind_Tags.ConnectionFailed: {
          ordinalConverter.write(9, into);
          return;
        }
        case ErrorKind_Tags.ConnectionTimeout: {
          ordinalConverter.write(10, into);
          return;
        }
        case ErrorKind_Tags.DuplicateAnnotation: {
          ordinalConverter.write(11, into);
          return;
        }
        case ErrorKind_Tags.Exclusive: {
          ordinalConverter.write(12, into);
          return;
        }
        case ErrorKind_Tags.Forbidden: {
          ordinalConverter.write(13, into);
          return;
        }
        case ErrorKind_Tags.GuestAccessForbidden: {
          ordinalConverter.write(14, into);
          return;
        }
        case ErrorKind_Tags.IncompatibleRoomVersion: {
          ordinalConverter.write(15, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomVersion, into);
          return;
        }
        case ErrorKind_Tags.InvalidParam: {
          ordinalConverter.write(16, into);
          return;
        }
        case ErrorKind_Tags.InvalidRoomState: {
          ordinalConverter.write(17, into);
          return;
        }
        case ErrorKind_Tags.InvalidUsername: {
          ordinalConverter.write(18, into);
          return;
        }
        case ErrorKind_Tags.LimitExceeded: {
          ordinalConverter.write(19, into);
          const inner = value.inner;
          FfiConverterOptionalUInt64.write(inner.retryAfterMs, into);
          return;
        }
        case ErrorKind_Tags.MissingParam: {
          ordinalConverter.write(20, into);
          return;
        }
        case ErrorKind_Tags.MissingToken: {
          ordinalConverter.write(21, into);
          return;
        }
        case ErrorKind_Tags.NotFound: {
          ordinalConverter.write(22, into);
          return;
        }
        case ErrorKind_Tags.NotJson: {
          ordinalConverter.write(23, into);
          return;
        }
        case ErrorKind_Tags.NotYetUploaded: {
          ordinalConverter.write(24, into);
          return;
        }
        case ErrorKind_Tags.ResourceLimitExceeded: {
          ordinalConverter.write(25, into);
          const inner = value.inner;
          FfiConverterString.write(inner.adminContact, into);
          return;
        }
        case ErrorKind_Tags.RoomInUse: {
          ordinalConverter.write(26, into);
          return;
        }
        case ErrorKind_Tags.ServerNotTrusted: {
          ordinalConverter.write(27, into);
          return;
        }
        case ErrorKind_Tags.ThreepidAuthFailed: {
          ordinalConverter.write(28, into);
          return;
        }
        case ErrorKind_Tags.ThreepidDenied: {
          ordinalConverter.write(29, into);
          return;
        }
        case ErrorKind_Tags.ThreepidInUse: {
          ordinalConverter.write(30, into);
          return;
        }
        case ErrorKind_Tags.ThreepidMediumNotSupported: {
          ordinalConverter.write(31, into);
          return;
        }
        case ErrorKind_Tags.ThreepidNotFound: {
          ordinalConverter.write(32, into);
          return;
        }
        case ErrorKind_Tags.TooLarge: {
          ordinalConverter.write(33, into);
          return;
        }
        case ErrorKind_Tags.UnableToAuthorizeJoin: {
          ordinalConverter.write(34, into);
          return;
        }
        case ErrorKind_Tags.UnableToGrantJoin: {
          ordinalConverter.write(35, into);
          return;
        }
        case ErrorKind_Tags.Unauthorized: {
          ordinalConverter.write(36, into);
          return;
        }
        case ErrorKind_Tags.Unknown: {
          ordinalConverter.write(37, into);
          return;
        }
        case ErrorKind_Tags.UnknownToken: {
          ordinalConverter.write(38, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.softLogout, into);
          return;
        }
        case ErrorKind_Tags.Unrecognized: {
          ordinalConverter.write(39, into);
          return;
        }
        case ErrorKind_Tags.UnsupportedRoomVersion: {
          ordinalConverter.write(40, into);
          return;
        }
        case ErrorKind_Tags.UrlNotSet: {
          ordinalConverter.write(41, into);
          return;
        }
        case ErrorKind_Tags.UserDeactivated: {
          ordinalConverter.write(42, into);
          return;
        }
        case ErrorKind_Tags.UserInUse: {
          ordinalConverter.write(43, into);
          return;
        }
        case ErrorKind_Tags.UserLocked: {
          ordinalConverter.write(44, into);
          return;
        }
        case ErrorKind_Tags.UserSuspended: {
          ordinalConverter.write(45, into);
          return;
        }
        case ErrorKind_Tags.WeakPassword: {
          ordinalConverter.write(46, into);
          return;
        }
        case ErrorKind_Tags.WrongRoomKeysVersion: {
          ordinalConverter.write(47, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.currentVersion, into);
          return;
        }
        case ErrorKind_Tags.Custom: {
          ordinalConverter.write(48, into);
          const inner = value.inner;
          FfiConverterString.write(inner.errcode, into);
          return;
        }
        default:
          // Throwing from here means that ErrorKind_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ErrorKind_Tags.BadAlias: {
          return ordinalConverter.allocationSize(1);
        }
        case ErrorKind_Tags.BadJson: {
          return ordinalConverter.allocationSize(2);
        }
        case ErrorKind_Tags.BadState: {
          return ordinalConverter.allocationSize(3);
        }
        case ErrorKind_Tags.BadStatus: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterOptionalUInt16.allocationSize(inner.status);
          size += FfiConverterOptionalString.allocationSize(inner.body);
          return size;
        }
        case ErrorKind_Tags.CannotLeaveServerNoticeRoom: {
          return ordinalConverter.allocationSize(5);
        }
        case ErrorKind_Tags.CannotOverwriteMedia: {
          return ordinalConverter.allocationSize(6);
        }
        case ErrorKind_Tags.CaptchaInvalid: {
          return ordinalConverter.allocationSize(7);
        }
        case ErrorKind_Tags.CaptchaNeeded: {
          return ordinalConverter.allocationSize(8);
        }
        case ErrorKind_Tags.ConnectionFailed: {
          return ordinalConverter.allocationSize(9);
        }
        case ErrorKind_Tags.ConnectionTimeout: {
          return ordinalConverter.allocationSize(10);
        }
        case ErrorKind_Tags.DuplicateAnnotation: {
          return ordinalConverter.allocationSize(11);
        }
        case ErrorKind_Tags.Exclusive: {
          return ordinalConverter.allocationSize(12);
        }
        case ErrorKind_Tags.Forbidden: {
          return ordinalConverter.allocationSize(13);
        }
        case ErrorKind_Tags.GuestAccessForbidden: {
          return ordinalConverter.allocationSize(14);
        }
        case ErrorKind_Tags.IncompatibleRoomVersion: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(15);
          size += FfiConverterString.allocationSize(inner.roomVersion);
          return size;
        }
        case ErrorKind_Tags.InvalidParam: {
          return ordinalConverter.allocationSize(16);
        }
        case ErrorKind_Tags.InvalidRoomState: {
          return ordinalConverter.allocationSize(17);
        }
        case ErrorKind_Tags.InvalidUsername: {
          return ordinalConverter.allocationSize(18);
        }
        case ErrorKind_Tags.LimitExceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(19);
          size += FfiConverterOptionalUInt64.allocationSize(inner.retryAfterMs);
          return size;
        }
        case ErrorKind_Tags.MissingParam: {
          return ordinalConverter.allocationSize(20);
        }
        case ErrorKind_Tags.MissingToken: {
          return ordinalConverter.allocationSize(21);
        }
        case ErrorKind_Tags.NotFound: {
          return ordinalConverter.allocationSize(22);
        }
        case ErrorKind_Tags.NotJson: {
          return ordinalConverter.allocationSize(23);
        }
        case ErrorKind_Tags.NotYetUploaded: {
          return ordinalConverter.allocationSize(24);
        }
        case ErrorKind_Tags.ResourceLimitExceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(25);
          size += FfiConverterString.allocationSize(inner.adminContact);
          return size;
        }
        case ErrorKind_Tags.RoomInUse: {
          return ordinalConverter.allocationSize(26);
        }
        case ErrorKind_Tags.ServerNotTrusted: {
          return ordinalConverter.allocationSize(27);
        }
        case ErrorKind_Tags.ThreepidAuthFailed: {
          return ordinalConverter.allocationSize(28);
        }
        case ErrorKind_Tags.ThreepidDenied: {
          return ordinalConverter.allocationSize(29);
        }
        case ErrorKind_Tags.ThreepidInUse: {
          return ordinalConverter.allocationSize(30);
        }
        case ErrorKind_Tags.ThreepidMediumNotSupported: {
          return ordinalConverter.allocationSize(31);
        }
        case ErrorKind_Tags.ThreepidNotFound: {
          return ordinalConverter.allocationSize(32);
        }
        case ErrorKind_Tags.TooLarge: {
          return ordinalConverter.allocationSize(33);
        }
        case ErrorKind_Tags.UnableToAuthorizeJoin: {
          return ordinalConverter.allocationSize(34);
        }
        case ErrorKind_Tags.UnableToGrantJoin: {
          return ordinalConverter.allocationSize(35);
        }
        case ErrorKind_Tags.Unauthorized: {
          return ordinalConverter.allocationSize(36);
        }
        case ErrorKind_Tags.Unknown: {
          return ordinalConverter.allocationSize(37);
        }
        case ErrorKind_Tags.UnknownToken: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(38);
          size += FfiConverterBool.allocationSize(inner.softLogout);
          return size;
        }
        case ErrorKind_Tags.Unrecognized: {
          return ordinalConverter.allocationSize(39);
        }
        case ErrorKind_Tags.UnsupportedRoomVersion: {
          return ordinalConverter.allocationSize(40);
        }
        case ErrorKind_Tags.UrlNotSet: {
          return ordinalConverter.allocationSize(41);
        }
        case ErrorKind_Tags.UserDeactivated: {
          return ordinalConverter.allocationSize(42);
        }
        case ErrorKind_Tags.UserInUse: {
          return ordinalConverter.allocationSize(43);
        }
        case ErrorKind_Tags.UserLocked: {
          return ordinalConverter.allocationSize(44);
        }
        case ErrorKind_Tags.UserSuspended: {
          return ordinalConverter.allocationSize(45);
        }
        case ErrorKind_Tags.WeakPassword: {
          return ordinalConverter.allocationSize(46);
        }
        case ErrorKind_Tags.WrongRoomKeysVersion: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(47);
          size += FfiConverterOptionalString.allocationSize(
            inner.currentVersion
          );
          return size;
        }
        case ErrorKind_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(48);
          size += FfiConverterString.allocationSize(inner.errcode);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EventOrTransactionId
export enum EventOrTransactionId_Tags {
  EventId = 'EventId',
  TransactionId = 'TransactionId',
}
/**
 * Contains the 2 possible identifiers of an event, either it has a remote
 * event id or a local transaction id, never both or none.
 */
export const EventOrTransactionId = (() => {
  type EventId__interface = {
    tag: EventOrTransactionId_Tags.EventId;
    inner: Readonly<{ eventId: string }>;
  };

  class EventId_ extends UniffiEnum implements EventId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventOrTransactionId';
    readonly tag = EventOrTransactionId_Tags.EventId;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: { eventId: string }) {
      super('EventOrTransactionId', 'EventId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: string }): EventId_ {
      return new EventId_(inner);
    }

    static instanceOf(obj: any): obj is EventId_ {
      return obj.tag === EventOrTransactionId_Tags.EventId;
    }
  }

  type TransactionId__interface = {
    tag: EventOrTransactionId_Tags.TransactionId;
    inner: Readonly<{ transactionId: string }>;
  };

  class TransactionId_ extends UniffiEnum implements TransactionId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventOrTransactionId';
    readonly tag = EventOrTransactionId_Tags.TransactionId;
    readonly inner: Readonly<{ transactionId: string }>;
    constructor(inner: { transactionId: string }) {
      super('EventOrTransactionId', 'TransactionId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { transactionId: string }): TransactionId_ {
      return new TransactionId_(inner);
    }

    static instanceOf(obj: any): obj is TransactionId_ {
      return obj.tag === EventOrTransactionId_Tags.TransactionId;
    }
  }

  function instanceOf(obj: any): obj is EventOrTransactionId {
    return obj[uniffiTypeNameSymbol] === 'EventOrTransactionId';
  }

  return Object.freeze({
    instanceOf,
    EventId: EventId_,
    TransactionId: TransactionId_,
  });
})();

/**
 * Contains the 2 possible identifiers of an event, either it has a remote
 * event id or a local transaction id, never both or none.
 */

export type EventOrTransactionId = InstanceType<
  (typeof EventOrTransactionId)[keyof Omit<
    typeof EventOrTransactionId,
    'instanceOf'
  >]
>;

// FfiConverter for enum EventOrTransactionId
const FfiConverterTypeEventOrTransactionId = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EventOrTransactionId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EventOrTransactionId.EventId({
            eventId: FfiConverterString.read(from),
          });
        case 2:
          return new EventOrTransactionId.TransactionId({
            transactionId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EventOrTransactionId_Tags.EventId: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case EventOrTransactionId_Tags.TransactionId: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.transactionId, into);
          return;
        }
        default:
          // Throwing from here means that EventOrTransactionId_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EventOrTransactionId_Tags.EventId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case EventOrTransactionId_Tags.TransactionId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.transactionId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: EventSendState
export enum EventSendState_Tags {
  NotSentYet = 'NotSentYet',
  SendingFailed = 'SendingFailed',
  Sent = 'Sent',
}
/**
 * This type represents the send state of a local event timeline item.
 */
export const EventSendState = (() => {
  type NotSentYet__interface = {
    tag: EventSendState_Tags.NotSentYet;
  };

  /**
   * The local event has not been sent yet.
   */
  class NotSentYet_ extends UniffiEnum implements NotSentYet__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventSendState';
    readonly tag = EventSendState_Tags.NotSentYet;
    constructor() {
      super('EventSendState', 'NotSentYet');
    }

    static new(): NotSentYet_ {
      return new NotSentYet_();
    }

    static instanceOf(obj: any): obj is NotSentYet_ {
      return obj.tag === EventSendState_Tags.NotSentYet;
    }
  }

  type SendingFailed__interface = {
    tag: EventSendState_Tags.SendingFailed;
    inner: Readonly<{ error: QueueWedgeError; isRecoverable: boolean }>;
  };

  /**
   * The local event has been sent to the server, but unsuccessfully: The
   * sending has failed.
   */
  class SendingFailed_ extends UniffiEnum implements SendingFailed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventSendState';
    readonly tag = EventSendState_Tags.SendingFailed;
    readonly inner: Readonly<{
      error: QueueWedgeError;
      isRecoverable: boolean;
    }>;
    constructor(inner: {
      /**
       * The error reason, with information for the user.
       */ error: QueueWedgeError;
      /**
       * Whether the error is considered recoverable or not.
       *
       * An error that's recoverable will disable the room's send queue,
       * while an unrecoverable error will be parked, until the user
       * decides to cancel sending it.
       */ isRecoverable: boolean;
    }) {
      super('EventSendState', 'SendingFailed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The error reason, with information for the user.
       */ error: QueueWedgeError;
      /**
       * Whether the error is considered recoverable or not.
       *
       * An error that's recoverable will disable the room's send queue,
       * while an unrecoverable error will be parked, until the user
       * decides to cancel sending it.
       */ isRecoverable: boolean;
    }): SendingFailed_ {
      return new SendingFailed_(inner);
    }

    static instanceOf(obj: any): obj is SendingFailed_ {
      return obj.tag === EventSendState_Tags.SendingFailed;
    }
  }

  type Sent__interface = {
    tag: EventSendState_Tags.Sent;
    inner: Readonly<{ eventId: string }>;
  };

  /**
   * The local event has been sent successfully to the server.
   */
  class Sent_ extends UniffiEnum implements Sent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'EventSendState';
    readonly tag = EventSendState_Tags.Sent;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: { eventId: string }) {
      super('EventSendState', 'Sent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: string }): Sent_ {
      return new Sent_(inner);
    }

    static instanceOf(obj: any): obj is Sent_ {
      return obj.tag === EventSendState_Tags.Sent;
    }
  }

  function instanceOf(obj: any): obj is EventSendState {
    return obj[uniffiTypeNameSymbol] === 'EventSendState';
  }

  return Object.freeze({
    instanceOf,
    NotSentYet: NotSentYet_,
    SendingFailed: SendingFailed_,
    Sent: Sent_,
  });
})();

/**
 * This type represents the send state of a local event timeline item.
 */

export type EventSendState = InstanceType<
  (typeof EventSendState)[keyof Omit<typeof EventSendState, 'instanceOf'>]
>;

// FfiConverter for enum EventSendState
const FfiConverterTypeEventSendState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EventSendState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new EventSendState.NotSentYet();
        case 2:
          return new EventSendState.SendingFailed({
            error: FfiConverterTypeQueueWedgeError.read(from),
            isRecoverable: FfiConverterBool.read(from),
          });
        case 3:
          return new EventSendState.Sent({
            eventId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case EventSendState_Tags.NotSentYet: {
          ordinalConverter.write(1, into);
          return;
        }
        case EventSendState_Tags.SendingFailed: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeQueueWedgeError.write(inner.error, into);
          FfiConverterBool.write(inner.isRecoverable, into);
          return;
        }
        case EventSendState_Tags.Sent: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        default:
          // Throwing from here means that EventSendState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case EventSendState_Tags.NotSentYet: {
          return ordinalConverter.allocationSize(1);
        }
        case EventSendState_Tags.SendingFailed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeQueueWedgeError.allocationSize(inner.error);
          size += FfiConverterBool.allocationSize(inner.isRecoverable);
          return size;
        }
        case EventSendState_Tags.Sent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: FilterTimelineEventType
export enum FilterTimelineEventType_Tags {
  MessageLike = 'MessageLike',
  State = 'State',
}
export const FilterTimelineEventType = (() => {
  type MessageLike__interface = {
    tag: FilterTimelineEventType_Tags.MessageLike;
    inner: Readonly<{ eventType: MessageLikeEventType }>;
  };

  class MessageLike_ extends UniffiEnum implements MessageLike__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FilterTimelineEventType';
    readonly tag = FilterTimelineEventType_Tags.MessageLike;
    readonly inner: Readonly<{ eventType: MessageLikeEventType }>;
    constructor(inner: { eventType: MessageLikeEventType }) {
      super('FilterTimelineEventType', 'MessageLike');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: MessageLikeEventType }): MessageLike_ {
      return new MessageLike_(inner);
    }

    static instanceOf(obj: any): obj is MessageLike_ {
      return obj.tag === FilterTimelineEventType_Tags.MessageLike;
    }
  }

  type State__interface = {
    tag: FilterTimelineEventType_Tags.State;
    inner: Readonly<{ eventType: StateEventType }>;
  };

  class State_ extends UniffiEnum implements State__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FilterTimelineEventType';
    readonly tag = FilterTimelineEventType_Tags.State;
    readonly inner: Readonly<{ eventType: StateEventType }>;
    constructor(inner: { eventType: StateEventType }) {
      super('FilterTimelineEventType', 'State');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: StateEventType }): State_ {
      return new State_(inner);
    }

    static instanceOf(obj: any): obj is State_ {
      return obj.tag === FilterTimelineEventType_Tags.State;
    }
  }

  function instanceOf(obj: any): obj is FilterTimelineEventType {
    return obj[uniffiTypeNameSymbol] === 'FilterTimelineEventType';
  }

  return Object.freeze({
    instanceOf,
    MessageLike: MessageLike_,
    State: State_,
  });
})();

export type FilterTimelineEventType = InstanceType<
  (typeof FilterTimelineEventType)[keyof Omit<
    typeof FilterTimelineEventType,
    'instanceOf'
  >]
>;

// FfiConverter for enum FilterTimelineEventType
const FfiConverterTypeFilterTimelineEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FilterTimelineEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FilterTimelineEventType.MessageLike({
            eventType: FfiConverterTypeMessageLikeEventType.read(from),
          });
        case 2:
          return new FilterTimelineEventType.State({
            eventType: FfiConverterTypeStateEventType.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FilterTimelineEventType_Tags.MessageLike: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeMessageLikeEventType.write(inner.eventType, into);
          return;
        }
        case FilterTimelineEventType_Tags.State: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeStateEventType.write(inner.eventType, into);
          return;
        }
        default:
          // Throwing from here means that FilterTimelineEventType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FilterTimelineEventType_Tags.MessageLike: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeMessageLikeEventType.allocationSize(
            inner.eventType
          );
          return size;
        }
        case FilterTimelineEventType_Tags.State: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeStateEventType.allocationSize(
            inner.eventType
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: FocusEventError

// Enum: FocusEventError
export enum FocusEventError_Tags {
  InvalidEventId = 'InvalidEventId',
  EventNotFound = 'EventNotFound',
  Other = 'Other',
}
export const FocusEventError = (() => {
  type InvalidEventId__interface = {
    tag: FocusEventError_Tags.InvalidEventId;
    inner: Readonly<{ eventId: string; err: string }>;
  };

  class InvalidEventId_
    extends UniffiError
    implements InvalidEventId__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FocusEventError';
    readonly tag = FocusEventError_Tags.InvalidEventId;
    readonly inner: Readonly<{ eventId: string; err: string }>;
    constructor(inner: { eventId: string; err: string }) {
      super('FocusEventError', 'InvalidEventId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: string; err: string }): InvalidEventId_ {
      return new InvalidEventId_(inner);
    }

    static instanceOf(obj: any): obj is InvalidEventId_ {
      return obj.tag === FocusEventError_Tags.InvalidEventId;
    }

    static hasInner(obj: any): obj is InvalidEventId_ {
      return InvalidEventId_.instanceOf(obj);
    }

    static getInner(
      obj: InvalidEventId_
    ): Readonly<{ eventId: string; err: string }> {
      return obj.inner;
    }
  }

  type EventNotFound__interface = {
    tag: FocusEventError_Tags.EventNotFound;
    inner: Readonly<{ eventId: string }>;
  };

  class EventNotFound_ extends UniffiError implements EventNotFound__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FocusEventError';
    readonly tag = FocusEventError_Tags.EventNotFound;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: { eventId: string }) {
      super('FocusEventError', 'EventNotFound');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: string }): EventNotFound_ {
      return new EventNotFound_(inner);
    }

    static instanceOf(obj: any): obj is EventNotFound_ {
      return obj.tag === FocusEventError_Tags.EventNotFound;
    }

    static hasInner(obj: any): obj is EventNotFound_ {
      return EventNotFound_.instanceOf(obj);
    }

    static getInner(obj: EventNotFound_): Readonly<{ eventId: string }> {
      return obj.inner;
    }
  }

  type Other__interface = {
    tag: FocusEventError_Tags.Other;
    inner: Readonly<{ msg: string }>;
  };

  class Other_ extends UniffiError implements Other__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FocusEventError';
    readonly tag = FocusEventError_Tags.Other;
    readonly inner: Readonly<{ msg: string }>;
    constructor(inner: { msg: string }) {
      super('FocusEventError', 'Other');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string }): Other_ {
      return new Other_(inner);
    }

    static instanceOf(obj: any): obj is Other_ {
      return obj.tag === FocusEventError_Tags.Other;
    }

    static hasInner(obj: any): obj is Other_ {
      return Other_.instanceOf(obj);
    }

    static getInner(obj: Other_): Readonly<{ msg: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is FocusEventError {
    return obj[uniffiTypeNameSymbol] === 'FocusEventError';
  }

  return Object.freeze({
    instanceOf,
    InvalidEventId: InvalidEventId_,
    EventNotFound: EventNotFound_,
    Other: Other_,
  });
})();

export type FocusEventError = InstanceType<
  (typeof FocusEventError)[keyof Omit<typeof FocusEventError, 'instanceOf'>]
>;

// FfiConverter for enum FocusEventError
const FfiConverterTypeFocusEventError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FocusEventError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FocusEventError.InvalidEventId({
            eventId: FfiConverterString.read(from),
            err: FfiConverterString.read(from),
          });
        case 2:
          return new FocusEventError.EventNotFound({
            eventId: FfiConverterString.read(from),
          });
        case 3:
          return new FocusEventError.Other({
            msg: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FocusEventError_Tags.InvalidEventId: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          FfiConverterString.write(inner.err, into);
          return;
        }
        case FocusEventError_Tags.EventNotFound: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case FocusEventError_Tags.Other: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          return;
        }
        default:
          // Throwing from here means that FocusEventError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FocusEventError_Tags.InvalidEventId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.eventId);
          size += FfiConverterString.allocationSize(inner.err);
          return size;
        }
        case FocusEventError_Tags.EventNotFound: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case FocusEventError_Tags.Other: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.msg);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: GalleryItemInfo
export enum GalleryItemInfo_Tags {
  Audio = 'Audio',
  File = 'File',
  Image = 'Image',
  Video = 'Video',
}
export const GalleryItemInfo = (() => {
  type Audio__interface = {
    tag: GalleryItemInfo_Tags.Audio;
    inner: Readonly<{
      audioInfo: AudioInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }>;
  };

  class Audio_ extends UniffiEnum implements Audio__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GalleryItemInfo';
    readonly tag = GalleryItemInfo_Tags.Audio;
    readonly inner: Readonly<{
      audioInfo: AudioInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }>;
    constructor(inner: {
      audioInfo: AudioInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }) {
      super('GalleryItemInfo', 'Audio');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      audioInfo: AudioInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }): Audio_ {
      return new Audio_(inner);
    }

    static instanceOf(obj: any): obj is Audio_ {
      return obj.tag === GalleryItemInfo_Tags.Audio;
    }
  }

  type File__interface = {
    tag: GalleryItemInfo_Tags.File;
    inner: Readonly<{
      fileInfo: FileInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }>;
  };

  class File_ extends UniffiEnum implements File__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GalleryItemInfo';
    readonly tag = GalleryItemInfo_Tags.File;
    readonly inner: Readonly<{
      fileInfo: FileInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }>;
    constructor(inner: {
      fileInfo: FileInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }) {
      super('GalleryItemInfo', 'File');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      fileInfo: FileInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
    }): File_ {
      return new File_(inner);
    }

    static instanceOf(obj: any): obj is File_ {
      return obj.tag === GalleryItemInfo_Tags.File;
    }
  }

  type Image__interface = {
    tag: GalleryItemInfo_Tags.Image;
    inner: Readonly<{
      imageInfo: ImageInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      thumbnailPath: string | undefined;
    }>;
  };

  class Image_ extends UniffiEnum implements Image__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GalleryItemInfo';
    readonly tag = GalleryItemInfo_Tags.Image;
    readonly inner: Readonly<{
      imageInfo: ImageInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      thumbnailPath: string | undefined;
    }>;
    constructor(inner: {
      imageInfo: ImageInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      thumbnailPath: string | undefined;
    }) {
      super('GalleryItemInfo', 'Image');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      imageInfo: ImageInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      thumbnailPath: string | undefined;
    }): Image_ {
      return new Image_(inner);
    }

    static instanceOf(obj: any): obj is Image_ {
      return obj.tag === GalleryItemInfo_Tags.Image;
    }
  }

  type Video__interface = {
    tag: GalleryItemInfo_Tags.Video;
    inner: Readonly<{
      videoInfo: VideoInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      thumbnailPath: string | undefined;
    }>;
  };

  class Video_ extends UniffiEnum implements Video__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GalleryItemInfo';
    readonly tag = GalleryItemInfo_Tags.Video;
    readonly inner: Readonly<{
      videoInfo: VideoInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      thumbnailPath: string | undefined;
    }>;
    constructor(inner: {
      videoInfo: VideoInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      thumbnailPath: string | undefined;
    }) {
      super('GalleryItemInfo', 'Video');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      videoInfo: VideoInfo;
      filename: string;
      caption: string | undefined;
      formattedCaption: FormattedBody | undefined;
      thumbnailPath: string | undefined;
    }): Video_ {
      return new Video_(inner);
    }

    static instanceOf(obj: any): obj is Video_ {
      return obj.tag === GalleryItemInfo_Tags.Video;
    }
  }

  function instanceOf(obj: any): obj is GalleryItemInfo {
    return obj[uniffiTypeNameSymbol] === 'GalleryItemInfo';
  }

  return Object.freeze({
    instanceOf,
    Audio: Audio_,
    File: File_,
    Image: Image_,
    Video: Video_,
  });
})();

export type GalleryItemInfo = InstanceType<
  (typeof GalleryItemInfo)[keyof Omit<typeof GalleryItemInfo, 'instanceOf'>]
>;

// FfiConverter for enum GalleryItemInfo
const FfiConverterTypeGalleryItemInfo = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = GalleryItemInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new GalleryItemInfo.Audio({
            audioInfo: FfiConverterTypeAudioInfo.read(from),
            filename: FfiConverterString.read(from),
            caption: FfiConverterOptionalString.read(from),
            formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
          });
        case 2:
          return new GalleryItemInfo.File({
            fileInfo: FfiConverterTypeFileInfo.read(from),
            filename: FfiConverterString.read(from),
            caption: FfiConverterOptionalString.read(from),
            formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
          });
        case 3:
          return new GalleryItemInfo.Image({
            imageInfo: FfiConverterTypeImageInfo.read(from),
            filename: FfiConverterString.read(from),
            caption: FfiConverterOptionalString.read(from),
            formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
            thumbnailPath: FfiConverterOptionalString.read(from),
          });
        case 4:
          return new GalleryItemInfo.Video({
            videoInfo: FfiConverterTypeVideoInfo.read(from),
            filename: FfiConverterString.read(from),
            caption: FfiConverterOptionalString.read(from),
            formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
            thumbnailPath: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case GalleryItemInfo_Tags.Audio: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeAudioInfo.write(inner.audioInfo, into);
          FfiConverterString.write(inner.filename, into);
          FfiConverterOptionalString.write(inner.caption, into);
          FfiConverterOptionalTypeFormattedBody.write(
            inner.formattedCaption,
            into
          );
          return;
        }
        case GalleryItemInfo_Tags.File: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeFileInfo.write(inner.fileInfo, into);
          FfiConverterString.write(inner.filename, into);
          FfiConverterOptionalString.write(inner.caption, into);
          FfiConverterOptionalTypeFormattedBody.write(
            inner.formattedCaption,
            into
          );
          return;
        }
        case GalleryItemInfo_Tags.Image: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeImageInfo.write(inner.imageInfo, into);
          FfiConverterString.write(inner.filename, into);
          FfiConverterOptionalString.write(inner.caption, into);
          FfiConverterOptionalTypeFormattedBody.write(
            inner.formattedCaption,
            into
          );
          FfiConverterOptionalString.write(inner.thumbnailPath, into);
          return;
        }
        case GalleryItemInfo_Tags.Video: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeVideoInfo.write(inner.videoInfo, into);
          FfiConverterString.write(inner.filename, into);
          FfiConverterOptionalString.write(inner.caption, into);
          FfiConverterOptionalTypeFormattedBody.write(
            inner.formattedCaption,
            into
          );
          FfiConverterOptionalString.write(inner.thumbnailPath, into);
          return;
        }
        default:
          // Throwing from here means that GalleryItemInfo_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case GalleryItemInfo_Tags.Audio: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeAudioInfo.allocationSize(inner.audioInfo);
          size += FfiConverterString.allocationSize(inner.filename);
          size += FfiConverterOptionalString.allocationSize(inner.caption);
          size += FfiConverterOptionalTypeFormattedBody.allocationSize(
            inner.formattedCaption
          );
          return size;
        }
        case GalleryItemInfo_Tags.File: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeFileInfo.allocationSize(inner.fileInfo);
          size += FfiConverterString.allocationSize(inner.filename);
          size += FfiConverterOptionalString.allocationSize(inner.caption);
          size += FfiConverterOptionalTypeFormattedBody.allocationSize(
            inner.formattedCaption
          );
          return size;
        }
        case GalleryItemInfo_Tags.Image: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeImageInfo.allocationSize(inner.imageInfo);
          size += FfiConverterString.allocationSize(inner.filename);
          size += FfiConverterOptionalString.allocationSize(inner.caption);
          size += FfiConverterOptionalTypeFormattedBody.allocationSize(
            inner.formattedCaption
          );
          size += FfiConverterOptionalString.allocationSize(
            inner.thumbnailPath
          );
          return size;
        }
        case GalleryItemInfo_Tags.Video: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeVideoInfo.allocationSize(inner.videoInfo);
          size += FfiConverterString.allocationSize(inner.filename);
          size += FfiConverterOptionalString.allocationSize(inner.caption);
          size += FfiConverterOptionalTypeFormattedBody.allocationSize(
            inner.formattedCaption
          );
          size += FfiConverterOptionalString.allocationSize(
            inner.thumbnailPath
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: GalleryItemType
export enum GalleryItemType_Tags {
  Image = 'Image',
  Audio = 'Audio',
  Video = 'Video',
  File = 'File',
  Other = 'Other',
}
export const GalleryItemType = (() => {
  type Image__interface = {
    tag: GalleryItemType_Tags.Image;
    inner: Readonly<{ content: ImageMessageContent }>;
  };

  class Image_ extends UniffiEnum implements Image__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GalleryItemType';
    readonly tag = GalleryItemType_Tags.Image;
    readonly inner: Readonly<{ content: ImageMessageContent }>;
    constructor(inner: { content: ImageMessageContent }) {
      super('GalleryItemType', 'Image');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: ImageMessageContent }): Image_ {
      return new Image_(inner);
    }

    static instanceOf(obj: any): obj is Image_ {
      return obj.tag === GalleryItemType_Tags.Image;
    }
  }

  type Audio__interface = {
    tag: GalleryItemType_Tags.Audio;
    inner: Readonly<{ content: AudioMessageContent }>;
  };

  class Audio_ extends UniffiEnum implements Audio__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GalleryItemType';
    readonly tag = GalleryItemType_Tags.Audio;
    readonly inner: Readonly<{ content: AudioMessageContent }>;
    constructor(inner: { content: AudioMessageContent }) {
      super('GalleryItemType', 'Audio');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: AudioMessageContent }): Audio_ {
      return new Audio_(inner);
    }

    static instanceOf(obj: any): obj is Audio_ {
      return obj.tag === GalleryItemType_Tags.Audio;
    }
  }

  type Video__interface = {
    tag: GalleryItemType_Tags.Video;
    inner: Readonly<{ content: VideoMessageContent }>;
  };

  class Video_ extends UniffiEnum implements Video__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GalleryItemType';
    readonly tag = GalleryItemType_Tags.Video;
    readonly inner: Readonly<{ content: VideoMessageContent }>;
    constructor(inner: { content: VideoMessageContent }) {
      super('GalleryItemType', 'Video');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: VideoMessageContent }): Video_ {
      return new Video_(inner);
    }

    static instanceOf(obj: any): obj is Video_ {
      return obj.tag === GalleryItemType_Tags.Video;
    }
  }

  type File__interface = {
    tag: GalleryItemType_Tags.File;
    inner: Readonly<{ content: FileMessageContent }>;
  };

  class File_ extends UniffiEnum implements File__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GalleryItemType';
    readonly tag = GalleryItemType_Tags.File;
    readonly inner: Readonly<{ content: FileMessageContent }>;
    constructor(inner: { content: FileMessageContent }) {
      super('GalleryItemType', 'File');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: FileMessageContent }): File_ {
      return new File_(inner);
    }

    static instanceOf(obj: any): obj is File_ {
      return obj.tag === GalleryItemType_Tags.File;
    }
  }

  type Other__interface = {
    tag: GalleryItemType_Tags.Other;
    inner: Readonly<{ itemtype: string; body: string }>;
  };

  class Other_ extends UniffiEnum implements Other__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GalleryItemType';
    readonly tag = GalleryItemType_Tags.Other;
    readonly inner: Readonly<{ itemtype: string; body: string }>;
    constructor(inner: { itemtype: string; body: string }) {
      super('GalleryItemType', 'Other');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { itemtype: string; body: string }): Other_ {
      return new Other_(inner);
    }

    static instanceOf(obj: any): obj is Other_ {
      return obj.tag === GalleryItemType_Tags.Other;
    }
  }

  function instanceOf(obj: any): obj is GalleryItemType {
    return obj[uniffiTypeNameSymbol] === 'GalleryItemType';
  }

  return Object.freeze({
    instanceOf,
    Image: Image_,
    Audio: Audio_,
    Video: Video_,
    File: File_,
    Other: Other_,
  });
})();

export type GalleryItemType = InstanceType<
  (typeof GalleryItemType)[keyof Omit<typeof GalleryItemType, 'instanceOf'>]
>;

// FfiConverter for enum GalleryItemType
const FfiConverterTypeGalleryItemType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = GalleryItemType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new GalleryItemType.Image({
            content: FfiConverterTypeImageMessageContent.read(from),
          });
        case 2:
          return new GalleryItemType.Audio({
            content: FfiConverterTypeAudioMessageContent.read(from),
          });
        case 3:
          return new GalleryItemType.Video({
            content: FfiConverterTypeVideoMessageContent.read(from),
          });
        case 4:
          return new GalleryItemType.File({
            content: FfiConverterTypeFileMessageContent.read(from),
          });
        case 5:
          return new GalleryItemType.Other({
            itemtype: FfiConverterString.read(from),
            body: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case GalleryItemType_Tags.Image: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeImageMessageContent.write(inner.content, into);
          return;
        }
        case GalleryItemType_Tags.Audio: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeAudioMessageContent.write(inner.content, into);
          return;
        }
        case GalleryItemType_Tags.Video: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeVideoMessageContent.write(inner.content, into);
          return;
        }
        case GalleryItemType_Tags.File: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeFileMessageContent.write(inner.content, into);
          return;
        }
        case GalleryItemType_Tags.Other: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.itemtype, into);
          FfiConverterString.write(inner.body, into);
          return;
        }
        default:
          // Throwing from here means that GalleryItemType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case GalleryItemType_Tags.Image: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeImageMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case GalleryItemType_Tags.Audio: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeAudioMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case GalleryItemType_Tags.Video: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeVideoMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case GalleryItemType_Tags.File: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeFileMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case GalleryItemType_Tags.Other: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.itemtype);
          size += FfiConverterString.allocationSize(inner.body);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: HumanQrLoginError

// Enum: HumanQrLoginError
export enum HumanQrLoginError_Tags {
  LinkingNotSupported = 'LinkingNotSupported',
  Cancelled = 'Cancelled',
  Expired = 'Expired',
  ConnectionInsecure = 'ConnectionInsecure',
  Declined = 'Declined',
  Unknown = 'Unknown',
  SlidingSyncNotAvailable = 'SlidingSyncNotAvailable',
  OidcMetadataInvalid = 'OidcMetadataInvalid',
  OtherDeviceNotSignedIn = 'OtherDeviceNotSignedIn',
}
export const HumanQrLoginError = (() => {
  type LinkingNotSupported__interface = {
    tag: HumanQrLoginError_Tags.LinkingNotSupported;
  };

  class LinkingNotSupported_
    extends UniffiError
    implements LinkingNotSupported__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.LinkingNotSupported;
    constructor() {
      super('HumanQrLoginError', 'LinkingNotSupported');
    }

    static new(): LinkingNotSupported_ {
      return new LinkingNotSupported_();
    }

    static instanceOf(obj: any): obj is LinkingNotSupported_ {
      return obj.tag === HumanQrLoginError_Tags.LinkingNotSupported;
    }

    static hasInner(obj: any): obj is LinkingNotSupported_ {
      return false;
    }
  }

  type Cancelled__interface = {
    tag: HumanQrLoginError_Tags.Cancelled;
  };

  class Cancelled_ extends UniffiError implements Cancelled__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.Cancelled;
    constructor() {
      super('HumanQrLoginError', 'Cancelled');
    }

    static new(): Cancelled_ {
      return new Cancelled_();
    }

    static instanceOf(obj: any): obj is Cancelled_ {
      return obj.tag === HumanQrLoginError_Tags.Cancelled;
    }

    static hasInner(obj: any): obj is Cancelled_ {
      return false;
    }
  }

  type Expired__interface = {
    tag: HumanQrLoginError_Tags.Expired;
  };

  class Expired_ extends UniffiError implements Expired__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.Expired;
    constructor() {
      super('HumanQrLoginError', 'Expired');
    }

    static new(): Expired_ {
      return new Expired_();
    }

    static instanceOf(obj: any): obj is Expired_ {
      return obj.tag === HumanQrLoginError_Tags.Expired;
    }

    static hasInner(obj: any): obj is Expired_ {
      return false;
    }
  }

  type ConnectionInsecure__interface = {
    tag: HumanQrLoginError_Tags.ConnectionInsecure;
  };

  class ConnectionInsecure_
    extends UniffiError
    implements ConnectionInsecure__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.ConnectionInsecure;
    constructor() {
      super('HumanQrLoginError', 'ConnectionInsecure');
    }

    static new(): ConnectionInsecure_ {
      return new ConnectionInsecure_();
    }

    static instanceOf(obj: any): obj is ConnectionInsecure_ {
      return obj.tag === HumanQrLoginError_Tags.ConnectionInsecure;
    }

    static hasInner(obj: any): obj is ConnectionInsecure_ {
      return false;
    }
  }

  type Declined__interface = {
    tag: HumanQrLoginError_Tags.Declined;
  };

  class Declined_ extends UniffiError implements Declined__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.Declined;
    constructor() {
      super('HumanQrLoginError', 'Declined');
    }

    static new(): Declined_ {
      return new Declined_();
    }

    static instanceOf(obj: any): obj is Declined_ {
      return obj.tag === HumanQrLoginError_Tags.Declined;
    }

    static hasInner(obj: any): obj is Declined_ {
      return false;
    }
  }

  type Unknown__interface = {
    tag: HumanQrLoginError_Tags.Unknown;
  };

  class Unknown_ extends UniffiError implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.Unknown;
    constructor() {
      super('HumanQrLoginError', 'Unknown');
    }

    static new(): Unknown_ {
      return new Unknown_();
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === HumanQrLoginError_Tags.Unknown;
    }

    static hasInner(obj: any): obj is Unknown_ {
      return false;
    }
  }

  type SlidingSyncNotAvailable__interface = {
    tag: HumanQrLoginError_Tags.SlidingSyncNotAvailable;
  };

  class SlidingSyncNotAvailable_
    extends UniffiError
    implements SlidingSyncNotAvailable__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.SlidingSyncNotAvailable;
    constructor() {
      super('HumanQrLoginError', 'SlidingSyncNotAvailable');
    }

    static new(): SlidingSyncNotAvailable_ {
      return new SlidingSyncNotAvailable_();
    }

    static instanceOf(obj: any): obj is SlidingSyncNotAvailable_ {
      return obj.tag === HumanQrLoginError_Tags.SlidingSyncNotAvailable;
    }

    static hasInner(obj: any): obj is SlidingSyncNotAvailable_ {
      return false;
    }
  }

  type OidcMetadataInvalid__interface = {
    tag: HumanQrLoginError_Tags.OidcMetadataInvalid;
  };

  class OidcMetadataInvalid_
    extends UniffiError
    implements OidcMetadataInvalid__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.OidcMetadataInvalid;
    constructor() {
      super('HumanQrLoginError', 'OidcMetadataInvalid');
    }

    static new(): OidcMetadataInvalid_ {
      return new OidcMetadataInvalid_();
    }

    static instanceOf(obj: any): obj is OidcMetadataInvalid_ {
      return obj.tag === HumanQrLoginError_Tags.OidcMetadataInvalid;
    }

    static hasInner(obj: any): obj is OidcMetadataInvalid_ {
      return false;
    }
  }

  type OtherDeviceNotSignedIn__interface = {
    tag: HumanQrLoginError_Tags.OtherDeviceNotSignedIn;
  };

  class OtherDeviceNotSignedIn_
    extends UniffiError
    implements OtherDeviceNotSignedIn__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'HumanQrLoginError';
    readonly tag = HumanQrLoginError_Tags.OtherDeviceNotSignedIn;
    constructor() {
      super('HumanQrLoginError', 'OtherDeviceNotSignedIn');
    }

    static new(): OtherDeviceNotSignedIn_ {
      return new OtherDeviceNotSignedIn_();
    }

    static instanceOf(obj: any): obj is OtherDeviceNotSignedIn_ {
      return obj.tag === HumanQrLoginError_Tags.OtherDeviceNotSignedIn;
    }

    static hasInner(obj: any): obj is OtherDeviceNotSignedIn_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is HumanQrLoginError {
    return obj[uniffiTypeNameSymbol] === 'HumanQrLoginError';
  }

  return Object.freeze({
    instanceOf,
    LinkingNotSupported: LinkingNotSupported_,
    Cancelled: Cancelled_,
    Expired: Expired_,
    ConnectionInsecure: ConnectionInsecure_,
    Declined: Declined_,
    Unknown: Unknown_,
    SlidingSyncNotAvailable: SlidingSyncNotAvailable_,
    OidcMetadataInvalid: OidcMetadataInvalid_,
    OtherDeviceNotSignedIn: OtherDeviceNotSignedIn_,
  });
})();

export type HumanQrLoginError = InstanceType<
  (typeof HumanQrLoginError)[keyof Omit<typeof HumanQrLoginError, 'instanceOf'>]
>;

// FfiConverter for enum HumanQrLoginError
const FfiConverterTypeHumanQrLoginError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = HumanQrLoginError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new HumanQrLoginError.LinkingNotSupported();
        case 2:
          return new HumanQrLoginError.Cancelled();
        case 3:
          return new HumanQrLoginError.Expired();
        case 4:
          return new HumanQrLoginError.ConnectionInsecure();
        case 5:
          return new HumanQrLoginError.Declined();
        case 6:
          return new HumanQrLoginError.Unknown();
        case 7:
          return new HumanQrLoginError.SlidingSyncNotAvailable();
        case 8:
          return new HumanQrLoginError.OidcMetadataInvalid();
        case 9:
          return new HumanQrLoginError.OtherDeviceNotSignedIn();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case HumanQrLoginError_Tags.LinkingNotSupported: {
          ordinalConverter.write(1, into);
          return;
        }
        case HumanQrLoginError_Tags.Cancelled: {
          ordinalConverter.write(2, into);
          return;
        }
        case HumanQrLoginError_Tags.Expired: {
          ordinalConverter.write(3, into);
          return;
        }
        case HumanQrLoginError_Tags.ConnectionInsecure: {
          ordinalConverter.write(4, into);
          return;
        }
        case HumanQrLoginError_Tags.Declined: {
          ordinalConverter.write(5, into);
          return;
        }
        case HumanQrLoginError_Tags.Unknown: {
          ordinalConverter.write(6, into);
          return;
        }
        case HumanQrLoginError_Tags.SlidingSyncNotAvailable: {
          ordinalConverter.write(7, into);
          return;
        }
        case HumanQrLoginError_Tags.OidcMetadataInvalid: {
          ordinalConverter.write(8, into);
          return;
        }
        case HumanQrLoginError_Tags.OtherDeviceNotSignedIn: {
          ordinalConverter.write(9, into);
          return;
        }
        default:
          // Throwing from here means that HumanQrLoginError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case HumanQrLoginError_Tags.LinkingNotSupported: {
          return ordinalConverter.allocationSize(1);
        }
        case HumanQrLoginError_Tags.Cancelled: {
          return ordinalConverter.allocationSize(2);
        }
        case HumanQrLoginError_Tags.Expired: {
          return ordinalConverter.allocationSize(3);
        }
        case HumanQrLoginError_Tags.ConnectionInsecure: {
          return ordinalConverter.allocationSize(4);
        }
        case HumanQrLoginError_Tags.Declined: {
          return ordinalConverter.allocationSize(5);
        }
        case HumanQrLoginError_Tags.Unknown: {
          return ordinalConverter.allocationSize(6);
        }
        case HumanQrLoginError_Tags.SlidingSyncNotAvailable: {
          return ordinalConverter.allocationSize(7);
        }
        case HumanQrLoginError_Tags.OidcMetadataInvalid: {
          return ordinalConverter.allocationSize(8);
        }
        case HumanQrLoginError_Tags.OtherDeviceNotSignedIn: {
          return ordinalConverter.allocationSize(9);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Defines the intent of showing the call.
 *
 * This controls whether to show or skip the lobby.
 */
export enum Intent {
  /**
   * The user wants to start a call.
   */
  StartCall,
  /**
   * The user wants to join an existing call.
   */
  JoinExisting,
}

const FfiConverterTypeIntent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Intent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Intent.StartCall;
        case 2:
          return Intent.JoinExisting;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Intent.StartCall:
          return ordinalConverter.write(1, into);
        case Intent.JoinExisting:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The policy that decides if avatars should be shown in invite requests.
 */
export enum InviteAvatars {
  /**
   * Always show avatars in invite requests.
   */
  On,
  /**
   * Never show avatars in invite requests.
   */
  Off,
}

const FfiConverterTypeInviteAvatars = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = InviteAvatars;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return InviteAvatars.On;
        case 2:
          return InviteAvatars.Off;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case InviteAvatars.On:
          return ordinalConverter.write(1, into);
        case InviteAvatars.Off:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: JoinRule
export enum JoinRule_Tags {
  Public = 'Public',
  Invite = 'Invite',
  Knock = 'Knock',
  Private = 'Private',
  Restricted = 'Restricted',
  KnockRestricted = 'KnockRestricted',
  Custom = 'Custom',
}
/**
 * The rule used for users wishing to join this room.
 */
export const JoinRule = (() => {
  type Public__interface = {
    tag: JoinRule_Tags.Public;
  };

  /**
   * Anyone can join the room without any prior action.
   */
  class Public_ extends UniffiEnum implements Public__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Public;
    constructor() {
      super('JoinRule', 'Public');
    }

    static new(): Public_ {
      return new Public_();
    }

    static instanceOf(obj: any): obj is Public_ {
      return obj.tag === JoinRule_Tags.Public;
    }
  }

  type Invite__interface = {
    tag: JoinRule_Tags.Invite;
  };

  /**
   * A user who wishes to join the room must first receive an invite to the
   * room from someone already inside of the room.
   */
  class Invite_ extends UniffiEnum implements Invite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Invite;
    constructor() {
      super('JoinRule', 'Invite');
    }

    static new(): Invite_ {
      return new Invite_();
    }

    static instanceOf(obj: any): obj is Invite_ {
      return obj.tag === JoinRule_Tags.Invite;
    }
  }

  type Knock__interface = {
    tag: JoinRule_Tags.Knock;
  };

  /**
   * Users can join the room if they are invited, or they can request an
   * invite to the room.
   *
   * They can be allowed (invited) or denied (kicked/banned) access.
   */
  class Knock_ extends UniffiEnum implements Knock__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Knock;
    constructor() {
      super('JoinRule', 'Knock');
    }

    static new(): Knock_ {
      return new Knock_();
    }

    static instanceOf(obj: any): obj is Knock_ {
      return obj.tag === JoinRule_Tags.Knock;
    }
  }

  type Private__interface = {
    tag: JoinRule_Tags.Private;
  };

  /**
   * Reserved but not yet implemented by the Matrix specification.
   */
  class Private_ extends UniffiEnum implements Private__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Private;
    constructor() {
      super('JoinRule', 'Private');
    }

    static new(): Private_ {
      return new Private_();
    }

    static instanceOf(obj: any): obj is Private_ {
      return obj.tag === JoinRule_Tags.Private;
    }
  }

  type Restricted__interface = {
    tag: JoinRule_Tags.Restricted;
    inner: Readonly<{ rules: Array<AllowRule> }>;
  };

  /**
   * Users can join the room if they are invited, or if they meet any of the
   * conditions described in a set of [`AllowRule`]s.
   */
  class Restricted_ extends UniffiEnum implements Restricted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Restricted;
    readonly inner: Readonly<{ rules: Array<AllowRule> }>;
    constructor(inner: { rules: Array<AllowRule> }) {
      super('JoinRule', 'Restricted');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { rules: Array<AllowRule> }): Restricted_ {
      return new Restricted_(inner);
    }

    static instanceOf(obj: any): obj is Restricted_ {
      return obj.tag === JoinRule_Tags.Restricted;
    }
  }

  type KnockRestricted__interface = {
    tag: JoinRule_Tags.KnockRestricted;
    inner: Readonly<{ rules: Array<AllowRule> }>;
  };

  /**
   * Users can join the room if they are invited, or if they meet any of the
   * conditions described in a set of [`AllowRule`]s, or they can request
   * an invite to the room.
   */
  class KnockRestricted_
    extends UniffiEnum
    implements KnockRestricted__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.KnockRestricted;
    readonly inner: Readonly<{ rules: Array<AllowRule> }>;
    constructor(inner: { rules: Array<AllowRule> }) {
      super('JoinRule', 'KnockRestricted');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { rules: Array<AllowRule> }): KnockRestricted_ {
      return new KnockRestricted_(inner);
    }

    static instanceOf(obj: any): obj is KnockRestricted_ {
      return obj.tag === JoinRule_Tags.KnockRestricted;
    }
  }

  type Custom__interface = {
    tag: JoinRule_Tags.Custom;
    inner: Readonly<{ repr: string }>;
  };

  /**
   * A custom join rule, up for interpretation by the consumer.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JoinRule';
    readonly tag = JoinRule_Tags.Custom;
    readonly inner: Readonly<{ repr: string }>;
    constructor(inner: {
      /**
       * The string representation for this custom rule.
       */ repr: string;
    }) {
      super('JoinRule', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The string representation for this custom rule.
       */ repr: string;
    }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === JoinRule_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is JoinRule {
    return obj[uniffiTypeNameSymbol] === 'JoinRule';
  }

  return Object.freeze({
    instanceOf,
    Public: Public_,
    Invite: Invite_,
    Knock: Knock_,
    Private: Private_,
    Restricted: Restricted_,
    KnockRestricted: KnockRestricted_,
    Custom: Custom_,
  });
})();

/**
 * The rule used for users wishing to join this room.
 */

export type JoinRule = InstanceType<
  (typeof JoinRule)[keyof Omit<typeof JoinRule, 'instanceOf'>]
>;

// FfiConverter for enum JoinRule
const FfiConverterTypeJoinRule = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = JoinRule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new JoinRule.Public();
        case 2:
          return new JoinRule.Invite();
        case 3:
          return new JoinRule.Knock();
        case 4:
          return new JoinRule.Private();
        case 5:
          return new JoinRule.Restricted({
            rules: FfiConverterArrayTypeAllowRule.read(from),
          });
        case 6:
          return new JoinRule.KnockRestricted({
            rules: FfiConverterArrayTypeAllowRule.read(from),
          });
        case 7:
          return new JoinRule.Custom({ repr: FfiConverterString.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case JoinRule_Tags.Public: {
          ordinalConverter.write(1, into);
          return;
        }
        case JoinRule_Tags.Invite: {
          ordinalConverter.write(2, into);
          return;
        }
        case JoinRule_Tags.Knock: {
          ordinalConverter.write(3, into);
          return;
        }
        case JoinRule_Tags.Private: {
          ordinalConverter.write(4, into);
          return;
        }
        case JoinRule_Tags.Restricted: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterArrayTypeAllowRule.write(inner.rules, into);
          return;
        }
        case JoinRule_Tags.KnockRestricted: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterArrayTypeAllowRule.write(inner.rules, into);
          return;
        }
        case JoinRule_Tags.Custom: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.repr, into);
          return;
        }
        default:
          // Throwing from here means that JoinRule_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case JoinRule_Tags.Public: {
          return ordinalConverter.allocationSize(1);
        }
        case JoinRule_Tags.Invite: {
          return ordinalConverter.allocationSize(2);
        }
        case JoinRule_Tags.Knock: {
          return ordinalConverter.allocationSize(3);
        }
        case JoinRule_Tags.Private: {
          return ordinalConverter.allocationSize(4);
        }
        case JoinRule_Tags.Restricted: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterArrayTypeAllowRule.allocationSize(inner.rules);
          return size;
        }
        case JoinRule_Tags.KnockRestricted: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterArrayTypeAllowRule.allocationSize(inner.rules);
          return size;
        }
        case JoinRule_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.repr);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: JsonValue
export enum JsonValue_Tags {
  Null = 'Null',
  Bool = 'Bool',
  Integer = 'Integer',
  String = 'String',
}
export const JsonValue = (() => {
  type Null__interface = {
    tag: JsonValue_Tags.Null;
  };

  /**
   * Represents a `null` value.
   */
  class Null_ extends UniffiEnum implements Null__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.Null;
    constructor() {
      super('JsonValue', 'Null');
    }

    static new(): Null_ {
      return new Null_();
    }

    static instanceOf(obj: any): obj is Null_ {
      return obj.tag === JsonValue_Tags.Null;
    }
  }

  type Bool__interface = {
    tag: JsonValue_Tags.Bool;
    inner: Readonly<{ value: boolean }>;
  };

  /**
   * Represents a boolean.
   */
  class Bool_ extends UniffiEnum implements Bool__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.Bool;
    readonly inner: Readonly<{ value: boolean }>;
    constructor(inner: { value: boolean }) {
      super('JsonValue', 'Bool');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: boolean }): Bool_ {
      return new Bool_(inner);
    }

    static instanceOf(obj: any): obj is Bool_ {
      return obj.tag === JsonValue_Tags.Bool;
    }
  }

  type Integer__interface = {
    tag: JsonValue_Tags.Integer;
    inner: Readonly<{ value: /*i64*/ bigint }>;
  };

  /**
   * Represents an integer.
   */
  class Integer_ extends UniffiEnum implements Integer__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.Integer;
    readonly inner: Readonly<{ value: /*i64*/ bigint }>;
    constructor(inner: { value: /*i64*/ bigint }) {
      super('JsonValue', 'Integer');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: /*i64*/ bigint }): Integer_ {
      return new Integer_(inner);
    }

    static instanceOf(obj: any): obj is Integer_ {
      return obj.tag === JsonValue_Tags.Integer;
    }
  }

  type String__interface = {
    tag: JsonValue_Tags.String;
    inner: Readonly<{ value: string }>;
  };

  /**
   * Represents a string.
   */
  class String_ extends UniffiEnum implements String__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.String;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('JsonValue', 'String');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): String_ {
      return new String_(inner);
    }

    static instanceOf(obj: any): obj is String_ {
      return obj.tag === JsonValue_Tags.String;
    }
  }

  function instanceOf(obj: any): obj is JsonValue {
    return obj[uniffiTypeNameSymbol] === 'JsonValue';
  }

  return Object.freeze({
    instanceOf,
    Null: Null_,
    Bool: Bool_,
    Integer: Integer_,
    String: String_,
  });
})();

export type JsonValue = InstanceType<
  (typeof JsonValue)[keyof Omit<typeof JsonValue, 'instanceOf'>]
>;

// FfiConverter for enum JsonValue
const FfiConverterTypeJsonValue = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = JsonValue;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new JsonValue.Null();
        case 2:
          return new JsonValue.Bool({ value: FfiConverterBool.read(from) });
        case 3:
          return new JsonValue.Integer({ value: FfiConverterInt64.read(from) });
        case 4:
          return new JsonValue.String({ value: FfiConverterString.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case JsonValue_Tags.Null: {
          ordinalConverter.write(1, into);
          return;
        }
        case JsonValue_Tags.Bool: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.value, into);
          return;
        }
        case JsonValue_Tags.Integer: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterInt64.write(inner.value, into);
          return;
        }
        case JsonValue_Tags.String: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that JsonValue_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case JsonValue_Tags.Null: {
          return ordinalConverter.allocationSize(1);
        }
        case JsonValue_Tags.Bool: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterBool.allocationSize(inner.value);
          return size;
        }
        case JsonValue_Tags.Integer: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterInt64.allocationSize(inner.value);
          return size;
        }
        case JsonValue_Tags.String: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * A key algorithm to be used to generate a key from a passphrase.
 */
export enum KeyDerivationAlgorithm {
  /**
   * PBKDF2
   */
  Pbkfd2,
}

const FfiConverterTypeKeyDerivationAlgorithm = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = KeyDerivationAlgorithm;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return KeyDerivationAlgorithm.Pbkfd2;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case KeyDerivationAlgorithm.Pbkfd2:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum LogLevel {
  Error,
  Warn,
  Info,
  Debug,
  Trace,
}

const FfiConverterTypeLogLevel = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LogLevel;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return LogLevel.Error;
        case 2:
          return LogLevel.Warn;
        case 3:
          return LogLevel.Info;
        case 4:
          return LogLevel.Debug;
        case 5:
          return LogLevel.Trace;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case LogLevel.Error:
          return ordinalConverter.write(1, into);
        case LogLevel.Warn:
          return ordinalConverter.write(2, into);
        case LogLevel.Info:
          return ordinalConverter.write(3, into);
        case LogLevel.Debug:
          return ordinalConverter.write(4, into);
        case LogLevel.Trace:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: MatrixId
export enum MatrixId_Tags {
  Room = 'Room',
  RoomAlias = 'RoomAlias',
  User = 'User',
  EventOnRoomId = 'EventOnRoomId',
  EventOnRoomAlias = 'EventOnRoomAlias',
}
/**
 * A Matrix ID that can be a room, room alias, user, or event.
 */
export const MatrixId = (() => {
  type Room__interface = {
    tag: MatrixId_Tags.Room;
    inner: Readonly<{ id: string }>;
  };

  class Room_ extends UniffiEnum implements Room__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.Room;
    readonly inner: Readonly<{ id: string }>;
    constructor(inner: { id: string }) {
      super('MatrixId', 'Room');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { id: string }): Room_ {
      return new Room_(inner);
    }

    static instanceOf(obj: any): obj is Room_ {
      return obj.tag === MatrixId_Tags.Room;
    }
  }

  type RoomAlias__interface = {
    tag: MatrixId_Tags.RoomAlias;
    inner: Readonly<{ alias: string }>;
  };

  class RoomAlias_ extends UniffiEnum implements RoomAlias__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.RoomAlias;
    readonly inner: Readonly<{ alias: string }>;
    constructor(inner: { alias: string }) {
      super('MatrixId', 'RoomAlias');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { alias: string }): RoomAlias_ {
      return new RoomAlias_(inner);
    }

    static instanceOf(obj: any): obj is RoomAlias_ {
      return obj.tag === MatrixId_Tags.RoomAlias;
    }
  }

  type User__interface = {
    tag: MatrixId_Tags.User;
    inner: Readonly<{ id: string }>;
  };

  class User_ extends UniffiEnum implements User__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.User;
    readonly inner: Readonly<{ id: string }>;
    constructor(inner: { id: string }) {
      super('MatrixId', 'User');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { id: string }): User_ {
      return new User_(inner);
    }

    static instanceOf(obj: any): obj is User_ {
      return obj.tag === MatrixId_Tags.User;
    }
  }

  type EventOnRoomId__interface = {
    tag: MatrixId_Tags.EventOnRoomId;
    inner: Readonly<{ roomId: string; eventId: string }>;
  };

  class EventOnRoomId_ extends UniffiEnum implements EventOnRoomId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.EventOnRoomId;
    readonly inner: Readonly<{ roomId: string; eventId: string }>;
    constructor(inner: { roomId: string; eventId: string }) {
      super('MatrixId', 'EventOnRoomId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomId: string; eventId: string }): EventOnRoomId_ {
      return new EventOnRoomId_(inner);
    }

    static instanceOf(obj: any): obj is EventOnRoomId_ {
      return obj.tag === MatrixId_Tags.EventOnRoomId;
    }
  }

  type EventOnRoomAlias__interface = {
    tag: MatrixId_Tags.EventOnRoomAlias;
    inner: Readonly<{ alias: string; eventId: string }>;
  };

  class EventOnRoomAlias_
    extends UniffiEnum
    implements EventOnRoomAlias__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MatrixId';
    readonly tag = MatrixId_Tags.EventOnRoomAlias;
    readonly inner: Readonly<{ alias: string; eventId: string }>;
    constructor(inner: { alias: string; eventId: string }) {
      super('MatrixId', 'EventOnRoomAlias');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { alias: string; eventId: string }): EventOnRoomAlias_ {
      return new EventOnRoomAlias_(inner);
    }

    static instanceOf(obj: any): obj is EventOnRoomAlias_ {
      return obj.tag === MatrixId_Tags.EventOnRoomAlias;
    }
  }

  function instanceOf(obj: any): obj is MatrixId {
    return obj[uniffiTypeNameSymbol] === 'MatrixId';
  }

  return Object.freeze({
    instanceOf,
    Room: Room_,
    RoomAlias: RoomAlias_,
    User: User_,
    EventOnRoomId: EventOnRoomId_,
    EventOnRoomAlias: EventOnRoomAlias_,
  });
})();

/**
 * A Matrix ID that can be a room, room alias, user, or event.
 */

export type MatrixId = InstanceType<
  (typeof MatrixId)[keyof Omit<typeof MatrixId, 'instanceOf'>]
>;

// FfiConverter for enum MatrixId
const FfiConverterTypeMatrixId = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MatrixId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MatrixId.Room({ id: FfiConverterString.read(from) });
        case 2:
          return new MatrixId.RoomAlias({
            alias: FfiConverterString.read(from),
          });
        case 3:
          return new MatrixId.User({ id: FfiConverterString.read(from) });
        case 4:
          return new MatrixId.EventOnRoomId({
            roomId: FfiConverterString.read(from),
            eventId: FfiConverterString.read(from),
          });
        case 5:
          return new MatrixId.EventOnRoomAlias({
            alias: FfiConverterString.read(from),
            eventId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MatrixId_Tags.Room: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.id, into);
          return;
        }
        case MatrixId_Tags.RoomAlias: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.alias, into);
          return;
        }
        case MatrixId_Tags.User: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.id, into);
          return;
        }
        case MatrixId_Tags.EventOnRoomId: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomId, into);
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case MatrixId_Tags.EventOnRoomAlias: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.alias, into);
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        default:
          // Throwing from here means that MatrixId_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MatrixId_Tags.Room: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.id);
          return size;
        }
        case MatrixId_Tags.RoomAlias: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.alias);
          return size;
        }
        case MatrixId_Tags.User: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.id);
          return size;
        }
        case MatrixId_Tags.EventOnRoomId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.roomId);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case MatrixId_Tags.EventOnRoomAlias: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.alias);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: MediaInfoError
export enum MediaInfoError_Tags {
  MissingField = 'MissingField',
  InvalidField = 'InvalidField',
}
export const MediaInfoError = (() => {
  class MissingField extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'MediaInfoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = MediaInfoError_Tags.MissingField;

    constructor(message: string) {
      super('MediaInfoError', 'MissingField', message);
    }

    static instanceOf(e: any): e is MissingField {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class InvalidField extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'MediaInfoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = MediaInfoError_Tags.InvalidField;

    constructor(message: string) {
      super('MediaInfoError', 'InvalidField', message);
    }

    static instanceOf(e: any): e is InvalidField {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is MediaInfoError {
    return (e as any)[uniffiTypeNameSymbol] === 'MediaInfoError';
  }
  return {
    MissingField,
    InvalidField,
    instanceOf,
  };
})();

// Union type for MediaInfoError error type.

export type MediaInfoError = InstanceType<
  (typeof MediaInfoError)[keyof Omit<typeof MediaInfoError, 'instanceOf'>]
>;

const FfiConverterTypeMediaInfoError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = MediaInfoError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new MediaInfoError.MissingField(FfiConverterString.read(from));

        case 2:
          return new MediaInfoError.InvalidField(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

/**
 * The policy that decides if media previews should be shown in the timeline.
 */
export enum MediaPreviews {
  /**
   * Always show media previews in the timeline.
   */
  On,
  /**
   * Show media previews in the timeline only if the room is private.
   */
  Private,
  /**
   * Never show media previews in the timeline.
   */
  Off,
}

const FfiConverterTypeMediaPreviews = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MediaPreviews;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return MediaPreviews.On;
        case 2:
          return MediaPreviews.Private;
        case 3:
          return MediaPreviews.Off;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case MediaPreviews.On:
          return ordinalConverter.write(1, into);
        case MediaPreviews.Private:
          return ordinalConverter.write(2, into);
        case MediaPreviews.Off:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum Membership {
  Invited,
  Joined,
  Left,
  Knocked,
  Banned,
}

const FfiConverterTypeMembership = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Membership;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Membership.Invited;
        case 2:
          return Membership.Joined;
        case 3:
          return Membership.Left;
        case 4:
          return Membership.Knocked;
        case 5:
          return Membership.Banned;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Membership.Invited:
          return ordinalConverter.write(1, into);
        case Membership.Joined:
          return ordinalConverter.write(2, into);
        case Membership.Left:
          return ordinalConverter.write(3, into);
        case Membership.Knocked:
          return ordinalConverter.write(4, into);
        case Membership.Banned:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum MembershipChange {
  None,
  Error,
  Joined,
  Left,
  Banned,
  Unbanned,
  Kicked,
  Invited,
  KickedAndBanned,
  InvitationAccepted,
  InvitationRejected,
  InvitationRevoked,
  Knocked,
  KnockAccepted,
  KnockRetracted,
  KnockDenied,
  NotImplemented,
}

const FfiConverterTypeMembershipChange = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MembershipChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return MembershipChange.None;
        case 2:
          return MembershipChange.Error;
        case 3:
          return MembershipChange.Joined;
        case 4:
          return MembershipChange.Left;
        case 5:
          return MembershipChange.Banned;
        case 6:
          return MembershipChange.Unbanned;
        case 7:
          return MembershipChange.Kicked;
        case 8:
          return MembershipChange.Invited;
        case 9:
          return MembershipChange.KickedAndBanned;
        case 10:
          return MembershipChange.InvitationAccepted;
        case 11:
          return MembershipChange.InvitationRejected;
        case 12:
          return MembershipChange.InvitationRevoked;
        case 13:
          return MembershipChange.Knocked;
        case 14:
          return MembershipChange.KnockAccepted;
        case 15:
          return MembershipChange.KnockRetracted;
        case 16:
          return MembershipChange.KnockDenied;
        case 17:
          return MembershipChange.NotImplemented;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case MembershipChange.None:
          return ordinalConverter.write(1, into);
        case MembershipChange.Error:
          return ordinalConverter.write(2, into);
        case MembershipChange.Joined:
          return ordinalConverter.write(3, into);
        case MembershipChange.Left:
          return ordinalConverter.write(4, into);
        case MembershipChange.Banned:
          return ordinalConverter.write(5, into);
        case MembershipChange.Unbanned:
          return ordinalConverter.write(6, into);
        case MembershipChange.Kicked:
          return ordinalConverter.write(7, into);
        case MembershipChange.Invited:
          return ordinalConverter.write(8, into);
        case MembershipChange.KickedAndBanned:
          return ordinalConverter.write(9, into);
        case MembershipChange.InvitationAccepted:
          return ordinalConverter.write(10, into);
        case MembershipChange.InvitationRejected:
          return ordinalConverter.write(11, into);
        case MembershipChange.InvitationRevoked:
          return ordinalConverter.write(12, into);
        case MembershipChange.Knocked:
          return ordinalConverter.write(13, into);
        case MembershipChange.KnockAccepted:
          return ordinalConverter.write(14, into);
        case MembershipChange.KnockRetracted:
          return ordinalConverter.write(15, into);
        case MembershipChange.KnockDenied:
          return ordinalConverter.write(16, into);
        case MembershipChange.NotImplemented:
          return ordinalConverter.write(17, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: MembershipState
export enum MembershipState_Tags {
  Ban = 'Ban',
  Invite = 'Invite',
  Join = 'Join',
  Knock = 'Knock',
  Leave = 'Leave',
  Custom = 'Custom',
}
export const MembershipState = (() => {
  type Ban__interface = {
    tag: MembershipState_Tags.Ban;
  };

  /**
   * The user is banned.
   */
  class Ban_ extends UniffiEnum implements Ban__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Ban;
    constructor() {
      super('MembershipState', 'Ban');
    }

    static new(): Ban_ {
      return new Ban_();
    }

    static instanceOf(obj: any): obj is Ban_ {
      return obj.tag === MembershipState_Tags.Ban;
    }
  }

  type Invite__interface = {
    tag: MembershipState_Tags.Invite;
  };

  /**
   * The user has been invited.
   */
  class Invite_ extends UniffiEnum implements Invite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Invite;
    constructor() {
      super('MembershipState', 'Invite');
    }

    static new(): Invite_ {
      return new Invite_();
    }

    static instanceOf(obj: any): obj is Invite_ {
      return obj.tag === MembershipState_Tags.Invite;
    }
  }

  type Join__interface = {
    tag: MembershipState_Tags.Join;
  };

  /**
   * The user has joined.
   */
  class Join_ extends UniffiEnum implements Join__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Join;
    constructor() {
      super('MembershipState', 'Join');
    }

    static new(): Join_ {
      return new Join_();
    }

    static instanceOf(obj: any): obj is Join_ {
      return obj.tag === MembershipState_Tags.Join;
    }
  }

  type Knock__interface = {
    tag: MembershipState_Tags.Knock;
  };

  /**
   * The user has requested to join.
   */
  class Knock_ extends UniffiEnum implements Knock__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Knock;
    constructor() {
      super('MembershipState', 'Knock');
    }

    static new(): Knock_ {
      return new Knock_();
    }

    static instanceOf(obj: any): obj is Knock_ {
      return obj.tag === MembershipState_Tags.Knock;
    }
  }

  type Leave__interface = {
    tag: MembershipState_Tags.Leave;
  };

  /**
   * The user has left.
   */
  class Leave_ extends UniffiEnum implements Leave__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Leave;
    constructor() {
      super('MembershipState', 'Leave');
    }

    static new(): Leave_ {
      return new Leave_();
    }

    static instanceOf(obj: any): obj is Leave_ {
      return obj.tag === MembershipState_Tags.Leave;
    }
  }

  type Custom__interface = {
    tag: MembershipState_Tags.Custom;
    inner: Readonly<{ value: string }>;
  };

  /**
   * A custom membership state value.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MembershipState';
    readonly tag = MembershipState_Tags.Custom;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('MembershipState', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === MembershipState_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is MembershipState {
    return obj[uniffiTypeNameSymbol] === 'MembershipState';
  }

  return Object.freeze({
    instanceOf,
    Ban: Ban_,
    Invite: Invite_,
    Join: Join_,
    Knock: Knock_,
    Leave: Leave_,
    Custom: Custom_,
  });
})();

export type MembershipState = InstanceType<
  (typeof MembershipState)[keyof Omit<typeof MembershipState, 'instanceOf'>]
>;

// FfiConverter for enum MembershipState
const FfiConverterTypeMembershipState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MembershipState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MembershipState.Ban();
        case 2:
          return new MembershipState.Invite();
        case 3:
          return new MembershipState.Join();
        case 4:
          return new MembershipState.Knock();
        case 5:
          return new MembershipState.Leave();
        case 6:
          return new MembershipState.Custom({
            value: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MembershipState_Tags.Ban: {
          ordinalConverter.write(1, into);
          return;
        }
        case MembershipState_Tags.Invite: {
          ordinalConverter.write(2, into);
          return;
        }
        case MembershipState_Tags.Join: {
          ordinalConverter.write(3, into);
          return;
        }
        case MembershipState_Tags.Knock: {
          ordinalConverter.write(4, into);
          return;
        }
        case MembershipState_Tags.Leave: {
          ordinalConverter.write(5, into);
          return;
        }
        case MembershipState_Tags.Custom: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that MembershipState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MembershipState_Tags.Ban: {
          return ordinalConverter.allocationSize(1);
        }
        case MembershipState_Tags.Invite: {
          return ordinalConverter.allocationSize(2);
        }
        case MembershipState_Tags.Join: {
          return ordinalConverter.allocationSize(3);
        }
        case MembershipState_Tags.Knock: {
          return ordinalConverter.allocationSize(4);
        }
        case MembershipState_Tags.Leave: {
          return ordinalConverter.allocationSize(5);
        }
        case MembershipState_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: MessageFormat
export enum MessageFormat_Tags {
  Html = 'Html',
  Unknown = 'Unknown',
}
export const MessageFormat = (() => {
  type Html__interface = {
    tag: MessageFormat_Tags.Html;
  };

  class Html_ extends UniffiEnum implements Html__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageFormat';
    readonly tag = MessageFormat_Tags.Html;
    constructor() {
      super('MessageFormat', 'Html');
    }

    static new(): Html_ {
      return new Html_();
    }

    static instanceOf(obj: any): obj is Html_ {
      return obj.tag === MessageFormat_Tags.Html;
    }
  }

  type Unknown__interface = {
    tag: MessageFormat_Tags.Unknown;
    inner: Readonly<{ format: string }>;
  };

  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageFormat';
    readonly tag = MessageFormat_Tags.Unknown;
    readonly inner: Readonly<{ format: string }>;
    constructor(inner: { format: string }) {
      super('MessageFormat', 'Unknown');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { format: string }): Unknown_ {
      return new Unknown_(inner);
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === MessageFormat_Tags.Unknown;
    }
  }

  function instanceOf(obj: any): obj is MessageFormat {
    return obj[uniffiTypeNameSymbol] === 'MessageFormat';
  }

  return Object.freeze({
    instanceOf,
    Html: Html_,
    Unknown: Unknown_,
  });
})();

export type MessageFormat = InstanceType<
  (typeof MessageFormat)[keyof Omit<typeof MessageFormat, 'instanceOf'>]
>;

// FfiConverter for enum MessageFormat
const FfiConverterTypeMessageFormat = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageFormat;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MessageFormat.Html();
        case 2:
          return new MessageFormat.Unknown({
            format: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MessageFormat_Tags.Html: {
          ordinalConverter.write(1, into);
          return;
        }
        case MessageFormat_Tags.Unknown: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.format, into);
          return;
        }
        default:
          // Throwing from here means that MessageFormat_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MessageFormat_Tags.Html: {
          return ordinalConverter.allocationSize(1);
        }
        case MessageFormat_Tags.Unknown: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.format);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: MessageLikeEventContent
export enum MessageLikeEventContent_Tags {
  CallAnswer = 'CallAnswer',
  CallInvite = 'CallInvite',
  CallNotify = 'CallNotify',
  CallHangup = 'CallHangup',
  CallCandidates = 'CallCandidates',
  KeyVerificationReady = 'KeyVerificationReady',
  KeyVerificationStart = 'KeyVerificationStart',
  KeyVerificationCancel = 'KeyVerificationCancel',
  KeyVerificationAccept = 'KeyVerificationAccept',
  KeyVerificationKey = 'KeyVerificationKey',
  KeyVerificationMac = 'KeyVerificationMac',
  KeyVerificationDone = 'KeyVerificationDone',
  Poll = 'Poll',
  ReactionContent = 'ReactionContent',
  RoomEncrypted = 'RoomEncrypted',
  RoomMessage = 'RoomMessage',
  RoomRedaction = 'RoomRedaction',
  Sticker = 'Sticker',
}
export const MessageLikeEventContent = (() => {
  type CallAnswer__interface = {
    tag: MessageLikeEventContent_Tags.CallAnswer;
  };

  class CallAnswer_ extends UniffiEnum implements CallAnswer__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallAnswer;
    constructor() {
      super('MessageLikeEventContent', 'CallAnswer');
    }

    static new(): CallAnswer_ {
      return new CallAnswer_();
    }

    static instanceOf(obj: any): obj is CallAnswer_ {
      return obj.tag === MessageLikeEventContent_Tags.CallAnswer;
    }
  }

  type CallInvite__interface = {
    tag: MessageLikeEventContent_Tags.CallInvite;
  };

  class CallInvite_ extends UniffiEnum implements CallInvite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallInvite;
    constructor() {
      super('MessageLikeEventContent', 'CallInvite');
    }

    static new(): CallInvite_ {
      return new CallInvite_();
    }

    static instanceOf(obj: any): obj is CallInvite_ {
      return obj.tag === MessageLikeEventContent_Tags.CallInvite;
    }
  }

  type CallNotify__interface = {
    tag: MessageLikeEventContent_Tags.CallNotify;
    inner: Readonly<{ notifyType: NotifyType }>;
  };

  class CallNotify_ extends UniffiEnum implements CallNotify__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallNotify;
    readonly inner: Readonly<{ notifyType: NotifyType }>;
    constructor(inner: { notifyType: NotifyType }) {
      super('MessageLikeEventContent', 'CallNotify');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { notifyType: NotifyType }): CallNotify_ {
      return new CallNotify_(inner);
    }

    static instanceOf(obj: any): obj is CallNotify_ {
      return obj.tag === MessageLikeEventContent_Tags.CallNotify;
    }
  }

  type CallHangup__interface = {
    tag: MessageLikeEventContent_Tags.CallHangup;
  };

  class CallHangup_ extends UniffiEnum implements CallHangup__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallHangup;
    constructor() {
      super('MessageLikeEventContent', 'CallHangup');
    }

    static new(): CallHangup_ {
      return new CallHangup_();
    }

    static instanceOf(obj: any): obj is CallHangup_ {
      return obj.tag === MessageLikeEventContent_Tags.CallHangup;
    }
  }

  type CallCandidates__interface = {
    tag: MessageLikeEventContent_Tags.CallCandidates;
  };

  class CallCandidates_
    extends UniffiEnum
    implements CallCandidates__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.CallCandidates;
    constructor() {
      super('MessageLikeEventContent', 'CallCandidates');
    }

    static new(): CallCandidates_ {
      return new CallCandidates_();
    }

    static instanceOf(obj: any): obj is CallCandidates_ {
      return obj.tag === MessageLikeEventContent_Tags.CallCandidates;
    }
  }

  type KeyVerificationReady__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationReady;
  };

  class KeyVerificationReady_
    extends UniffiEnum
    implements KeyVerificationReady__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationReady;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationReady');
    }

    static new(): KeyVerificationReady_ {
      return new KeyVerificationReady_();
    }

    static instanceOf(obj: any): obj is KeyVerificationReady_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationReady;
    }
  }

  type KeyVerificationStart__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationStart;
  };

  class KeyVerificationStart_
    extends UniffiEnum
    implements KeyVerificationStart__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationStart;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationStart');
    }

    static new(): KeyVerificationStart_ {
      return new KeyVerificationStart_();
    }

    static instanceOf(obj: any): obj is KeyVerificationStart_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationStart;
    }
  }

  type KeyVerificationCancel__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationCancel;
  };

  class KeyVerificationCancel_
    extends UniffiEnum
    implements KeyVerificationCancel__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationCancel;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationCancel');
    }

    static new(): KeyVerificationCancel_ {
      return new KeyVerificationCancel_();
    }

    static instanceOf(obj: any): obj is KeyVerificationCancel_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationCancel;
    }
  }

  type KeyVerificationAccept__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationAccept;
  };

  class KeyVerificationAccept_
    extends UniffiEnum
    implements KeyVerificationAccept__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationAccept;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationAccept');
    }

    static new(): KeyVerificationAccept_ {
      return new KeyVerificationAccept_();
    }

    static instanceOf(obj: any): obj is KeyVerificationAccept_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationAccept;
    }
  }

  type KeyVerificationKey__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationKey;
  };

  class KeyVerificationKey_
    extends UniffiEnum
    implements KeyVerificationKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationKey;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationKey');
    }

    static new(): KeyVerificationKey_ {
      return new KeyVerificationKey_();
    }

    static instanceOf(obj: any): obj is KeyVerificationKey_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationKey;
    }
  }

  type KeyVerificationMac__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationMac;
  };

  class KeyVerificationMac_
    extends UniffiEnum
    implements KeyVerificationMac__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationMac;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationMac');
    }

    static new(): KeyVerificationMac_ {
      return new KeyVerificationMac_();
    }

    static instanceOf(obj: any): obj is KeyVerificationMac_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationMac;
    }
  }

  type KeyVerificationDone__interface = {
    tag: MessageLikeEventContent_Tags.KeyVerificationDone;
  };

  class KeyVerificationDone_
    extends UniffiEnum
    implements KeyVerificationDone__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.KeyVerificationDone;
    constructor() {
      super('MessageLikeEventContent', 'KeyVerificationDone');
    }

    static new(): KeyVerificationDone_ {
      return new KeyVerificationDone_();
    }

    static instanceOf(obj: any): obj is KeyVerificationDone_ {
      return obj.tag === MessageLikeEventContent_Tags.KeyVerificationDone;
    }
  }

  type Poll__interface = {
    tag: MessageLikeEventContent_Tags.Poll;
    inner: Readonly<{ question: string }>;
  };

  class Poll_ extends UniffiEnum implements Poll__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.Poll;
    readonly inner: Readonly<{ question: string }>;
    constructor(inner: { question: string }) {
      super('MessageLikeEventContent', 'Poll');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { question: string }): Poll_ {
      return new Poll_(inner);
    }

    static instanceOf(obj: any): obj is Poll_ {
      return obj.tag === MessageLikeEventContent_Tags.Poll;
    }
  }

  type ReactionContent__interface = {
    tag: MessageLikeEventContent_Tags.ReactionContent;
    inner: Readonly<{ relatedEventId: string }>;
  };

  class ReactionContent_
    extends UniffiEnum
    implements ReactionContent__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.ReactionContent;
    readonly inner: Readonly<{ relatedEventId: string }>;
    constructor(inner: { relatedEventId: string }) {
      super('MessageLikeEventContent', 'ReactionContent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { relatedEventId: string }): ReactionContent_ {
      return new ReactionContent_(inner);
    }

    static instanceOf(obj: any): obj is ReactionContent_ {
      return obj.tag === MessageLikeEventContent_Tags.ReactionContent;
    }
  }

  type RoomEncrypted__interface = {
    tag: MessageLikeEventContent_Tags.RoomEncrypted;
  };

  class RoomEncrypted_ extends UniffiEnum implements RoomEncrypted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.RoomEncrypted;
    constructor() {
      super('MessageLikeEventContent', 'RoomEncrypted');
    }

    static new(): RoomEncrypted_ {
      return new RoomEncrypted_();
    }

    static instanceOf(obj: any): obj is RoomEncrypted_ {
      return obj.tag === MessageLikeEventContent_Tags.RoomEncrypted;
    }
  }

  type RoomMessage__interface = {
    tag: MessageLikeEventContent_Tags.RoomMessage;
    inner: Readonly<{
      messageType: MessageType;
      inReplyToEventId: string | undefined;
    }>;
  };

  class RoomMessage_ extends UniffiEnum implements RoomMessage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.RoomMessage;
    readonly inner: Readonly<{
      messageType: MessageType;
      inReplyToEventId: string | undefined;
    }>;
    constructor(inner: {
      messageType: MessageType;
      inReplyToEventId: string | undefined;
    }) {
      super('MessageLikeEventContent', 'RoomMessage');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      messageType: MessageType;
      inReplyToEventId: string | undefined;
    }): RoomMessage_ {
      return new RoomMessage_(inner);
    }

    static instanceOf(obj: any): obj is RoomMessage_ {
      return obj.tag === MessageLikeEventContent_Tags.RoomMessage;
    }
  }

  type RoomRedaction__interface = {
    tag: MessageLikeEventContent_Tags.RoomRedaction;
    inner: Readonly<{
      redactedEventId: string | undefined;
      reason: string | undefined;
    }>;
  };

  class RoomRedaction_ extends UniffiEnum implements RoomRedaction__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.RoomRedaction;
    readonly inner: Readonly<{
      redactedEventId: string | undefined;
      reason: string | undefined;
    }>;
    constructor(inner: {
      redactedEventId: string | undefined;
      reason: string | undefined;
    }) {
      super('MessageLikeEventContent', 'RoomRedaction');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      redactedEventId: string | undefined;
      reason: string | undefined;
    }): RoomRedaction_ {
      return new RoomRedaction_(inner);
    }

    static instanceOf(obj: any): obj is RoomRedaction_ {
      return obj.tag === MessageLikeEventContent_Tags.RoomRedaction;
    }
  }

  type Sticker__interface = {
    tag: MessageLikeEventContent_Tags.Sticker;
  };

  class Sticker_ extends UniffiEnum implements Sticker__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageLikeEventContent';
    readonly tag = MessageLikeEventContent_Tags.Sticker;
    constructor() {
      super('MessageLikeEventContent', 'Sticker');
    }

    static new(): Sticker_ {
      return new Sticker_();
    }

    static instanceOf(obj: any): obj is Sticker_ {
      return obj.tag === MessageLikeEventContent_Tags.Sticker;
    }
  }

  function instanceOf(obj: any): obj is MessageLikeEventContent {
    return obj[uniffiTypeNameSymbol] === 'MessageLikeEventContent';
  }

  return Object.freeze({
    instanceOf,
    CallAnswer: CallAnswer_,
    CallInvite: CallInvite_,
    CallNotify: CallNotify_,
    CallHangup: CallHangup_,
    CallCandidates: CallCandidates_,
    KeyVerificationReady: KeyVerificationReady_,
    KeyVerificationStart: KeyVerificationStart_,
    KeyVerificationCancel: KeyVerificationCancel_,
    KeyVerificationAccept: KeyVerificationAccept_,
    KeyVerificationKey: KeyVerificationKey_,
    KeyVerificationMac: KeyVerificationMac_,
    KeyVerificationDone: KeyVerificationDone_,
    Poll: Poll_,
    ReactionContent: ReactionContent_,
    RoomEncrypted: RoomEncrypted_,
    RoomMessage: RoomMessage_,
    RoomRedaction: RoomRedaction_,
    Sticker: Sticker_,
  });
})();

export type MessageLikeEventContent = InstanceType<
  (typeof MessageLikeEventContent)[keyof Omit<
    typeof MessageLikeEventContent,
    'instanceOf'
  >]
>;

// FfiConverter for enum MessageLikeEventContent
const FfiConverterTypeMessageLikeEventContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageLikeEventContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MessageLikeEventContent.CallAnswer();
        case 2:
          return new MessageLikeEventContent.CallInvite();
        case 3:
          return new MessageLikeEventContent.CallNotify({
            notifyType: FfiConverterTypeNotifyType.read(from),
          });
        case 4:
          return new MessageLikeEventContent.CallHangup();
        case 5:
          return new MessageLikeEventContent.CallCandidates();
        case 6:
          return new MessageLikeEventContent.KeyVerificationReady();
        case 7:
          return new MessageLikeEventContent.KeyVerificationStart();
        case 8:
          return new MessageLikeEventContent.KeyVerificationCancel();
        case 9:
          return new MessageLikeEventContent.KeyVerificationAccept();
        case 10:
          return new MessageLikeEventContent.KeyVerificationKey();
        case 11:
          return new MessageLikeEventContent.KeyVerificationMac();
        case 12:
          return new MessageLikeEventContent.KeyVerificationDone();
        case 13:
          return new MessageLikeEventContent.Poll({
            question: FfiConverterString.read(from),
          });
        case 14:
          return new MessageLikeEventContent.ReactionContent({
            relatedEventId: FfiConverterString.read(from),
          });
        case 15:
          return new MessageLikeEventContent.RoomEncrypted();
        case 16:
          return new MessageLikeEventContent.RoomMessage({
            messageType: FfiConverterTypeMessageType.read(from),
            inReplyToEventId: FfiConverterOptionalString.read(from),
          });
        case 17:
          return new MessageLikeEventContent.RoomRedaction({
            redactedEventId: FfiConverterOptionalString.read(from),
            reason: FfiConverterOptionalString.read(from),
          });
        case 18:
          return new MessageLikeEventContent.Sticker();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MessageLikeEventContent_Tags.CallAnswer: {
          ordinalConverter.write(1, into);
          return;
        }
        case MessageLikeEventContent_Tags.CallInvite: {
          ordinalConverter.write(2, into);
          return;
        }
        case MessageLikeEventContent_Tags.CallNotify: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeNotifyType.write(inner.notifyType, into);
          return;
        }
        case MessageLikeEventContent_Tags.CallHangup: {
          ordinalConverter.write(4, into);
          return;
        }
        case MessageLikeEventContent_Tags.CallCandidates: {
          ordinalConverter.write(5, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationReady: {
          ordinalConverter.write(6, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationStart: {
          ordinalConverter.write(7, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationCancel: {
          ordinalConverter.write(8, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationAccept: {
          ordinalConverter.write(9, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationKey: {
          ordinalConverter.write(10, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationMac: {
          ordinalConverter.write(11, into);
          return;
        }
        case MessageLikeEventContent_Tags.KeyVerificationDone: {
          ordinalConverter.write(12, into);
          return;
        }
        case MessageLikeEventContent_Tags.Poll: {
          ordinalConverter.write(13, into);
          const inner = value.inner;
          FfiConverterString.write(inner.question, into);
          return;
        }
        case MessageLikeEventContent_Tags.ReactionContent: {
          ordinalConverter.write(14, into);
          const inner = value.inner;
          FfiConverterString.write(inner.relatedEventId, into);
          return;
        }
        case MessageLikeEventContent_Tags.RoomEncrypted: {
          ordinalConverter.write(15, into);
          return;
        }
        case MessageLikeEventContent_Tags.RoomMessage: {
          ordinalConverter.write(16, into);
          const inner = value.inner;
          FfiConverterTypeMessageType.write(inner.messageType, into);
          FfiConverterOptionalString.write(inner.inReplyToEventId, into);
          return;
        }
        case MessageLikeEventContent_Tags.RoomRedaction: {
          ordinalConverter.write(17, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.redactedEventId, into);
          FfiConverterOptionalString.write(inner.reason, into);
          return;
        }
        case MessageLikeEventContent_Tags.Sticker: {
          ordinalConverter.write(18, into);
          return;
        }
        default:
          // Throwing from here means that MessageLikeEventContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MessageLikeEventContent_Tags.CallAnswer: {
          return ordinalConverter.allocationSize(1);
        }
        case MessageLikeEventContent_Tags.CallInvite: {
          return ordinalConverter.allocationSize(2);
        }
        case MessageLikeEventContent_Tags.CallNotify: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeNotifyType.allocationSize(inner.notifyType);
          return size;
        }
        case MessageLikeEventContent_Tags.CallHangup: {
          return ordinalConverter.allocationSize(4);
        }
        case MessageLikeEventContent_Tags.CallCandidates: {
          return ordinalConverter.allocationSize(5);
        }
        case MessageLikeEventContent_Tags.KeyVerificationReady: {
          return ordinalConverter.allocationSize(6);
        }
        case MessageLikeEventContent_Tags.KeyVerificationStart: {
          return ordinalConverter.allocationSize(7);
        }
        case MessageLikeEventContent_Tags.KeyVerificationCancel: {
          return ordinalConverter.allocationSize(8);
        }
        case MessageLikeEventContent_Tags.KeyVerificationAccept: {
          return ordinalConverter.allocationSize(9);
        }
        case MessageLikeEventContent_Tags.KeyVerificationKey: {
          return ordinalConverter.allocationSize(10);
        }
        case MessageLikeEventContent_Tags.KeyVerificationMac: {
          return ordinalConverter.allocationSize(11);
        }
        case MessageLikeEventContent_Tags.KeyVerificationDone: {
          return ordinalConverter.allocationSize(12);
        }
        case MessageLikeEventContent_Tags.Poll: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(13);
          size += FfiConverterString.allocationSize(inner.question);
          return size;
        }
        case MessageLikeEventContent_Tags.ReactionContent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(14);
          size += FfiConverterString.allocationSize(inner.relatedEventId);
          return size;
        }
        case MessageLikeEventContent_Tags.RoomEncrypted: {
          return ordinalConverter.allocationSize(15);
        }
        case MessageLikeEventContent_Tags.RoomMessage: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(16);
          size += FfiConverterTypeMessageType.allocationSize(inner.messageType);
          size += FfiConverterOptionalString.allocationSize(
            inner.inReplyToEventId
          );
          return size;
        }
        case MessageLikeEventContent_Tags.RoomRedaction: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(17);
          size += FfiConverterOptionalString.allocationSize(
            inner.redactedEventId
          );
          size += FfiConverterOptionalString.allocationSize(inner.reason);
          return size;
        }
        case MessageLikeEventContent_Tags.Sticker: {
          return ordinalConverter.allocationSize(18);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum MessageLikeEventType {
  CallAnswer,
  CallCandidates,
  CallHangup,
  CallInvite,
  CallNotify,
  KeyVerificationAccept,
  KeyVerificationCancel,
  KeyVerificationDone,
  KeyVerificationKey,
  KeyVerificationMac,
  KeyVerificationReady,
  KeyVerificationStart,
  PollEnd,
  PollResponse,
  PollStart,
  Reaction,
  RoomEncrypted,
  RoomMessage,
  RoomRedaction,
  Sticker,
  UnstablePollEnd,
  UnstablePollResponse,
  UnstablePollStart,
}

const FfiConverterTypeMessageLikeEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageLikeEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return MessageLikeEventType.CallAnswer;
        case 2:
          return MessageLikeEventType.CallCandidates;
        case 3:
          return MessageLikeEventType.CallHangup;
        case 4:
          return MessageLikeEventType.CallInvite;
        case 5:
          return MessageLikeEventType.CallNotify;
        case 6:
          return MessageLikeEventType.KeyVerificationAccept;
        case 7:
          return MessageLikeEventType.KeyVerificationCancel;
        case 8:
          return MessageLikeEventType.KeyVerificationDone;
        case 9:
          return MessageLikeEventType.KeyVerificationKey;
        case 10:
          return MessageLikeEventType.KeyVerificationMac;
        case 11:
          return MessageLikeEventType.KeyVerificationReady;
        case 12:
          return MessageLikeEventType.KeyVerificationStart;
        case 13:
          return MessageLikeEventType.PollEnd;
        case 14:
          return MessageLikeEventType.PollResponse;
        case 15:
          return MessageLikeEventType.PollStart;
        case 16:
          return MessageLikeEventType.Reaction;
        case 17:
          return MessageLikeEventType.RoomEncrypted;
        case 18:
          return MessageLikeEventType.RoomMessage;
        case 19:
          return MessageLikeEventType.RoomRedaction;
        case 20:
          return MessageLikeEventType.Sticker;
        case 21:
          return MessageLikeEventType.UnstablePollEnd;
        case 22:
          return MessageLikeEventType.UnstablePollResponse;
        case 23:
          return MessageLikeEventType.UnstablePollStart;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case MessageLikeEventType.CallAnswer:
          return ordinalConverter.write(1, into);
        case MessageLikeEventType.CallCandidates:
          return ordinalConverter.write(2, into);
        case MessageLikeEventType.CallHangup:
          return ordinalConverter.write(3, into);
        case MessageLikeEventType.CallInvite:
          return ordinalConverter.write(4, into);
        case MessageLikeEventType.CallNotify:
          return ordinalConverter.write(5, into);
        case MessageLikeEventType.KeyVerificationAccept:
          return ordinalConverter.write(6, into);
        case MessageLikeEventType.KeyVerificationCancel:
          return ordinalConverter.write(7, into);
        case MessageLikeEventType.KeyVerificationDone:
          return ordinalConverter.write(8, into);
        case MessageLikeEventType.KeyVerificationKey:
          return ordinalConverter.write(9, into);
        case MessageLikeEventType.KeyVerificationMac:
          return ordinalConverter.write(10, into);
        case MessageLikeEventType.KeyVerificationReady:
          return ordinalConverter.write(11, into);
        case MessageLikeEventType.KeyVerificationStart:
          return ordinalConverter.write(12, into);
        case MessageLikeEventType.PollEnd:
          return ordinalConverter.write(13, into);
        case MessageLikeEventType.PollResponse:
          return ordinalConverter.write(14, into);
        case MessageLikeEventType.PollStart:
          return ordinalConverter.write(15, into);
        case MessageLikeEventType.Reaction:
          return ordinalConverter.write(16, into);
        case MessageLikeEventType.RoomEncrypted:
          return ordinalConverter.write(17, into);
        case MessageLikeEventType.RoomMessage:
          return ordinalConverter.write(18, into);
        case MessageLikeEventType.RoomRedaction:
          return ordinalConverter.write(19, into);
        case MessageLikeEventType.Sticker:
          return ordinalConverter.write(20, into);
        case MessageLikeEventType.UnstablePollEnd:
          return ordinalConverter.write(21, into);
        case MessageLikeEventType.UnstablePollResponse:
          return ordinalConverter.write(22, into);
        case MessageLikeEventType.UnstablePollStart:
          return ordinalConverter.write(23, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: MessageType
export enum MessageType_Tags {
  Emote = 'Emote',
  Image = 'Image',
  Audio = 'Audio',
  Video = 'Video',
  File = 'File',
  Gallery = 'Gallery',
  Notice = 'Notice',
  Text = 'Text',
  Location = 'Location',
  Other = 'Other',
}
export const MessageType = (() => {
  type Emote__interface = {
    tag: MessageType_Tags.Emote;
    inner: Readonly<{ content: EmoteMessageContent }>;
  };

  class Emote_ extends UniffiEnum implements Emote__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Emote;
    readonly inner: Readonly<{ content: EmoteMessageContent }>;
    constructor(inner: { content: EmoteMessageContent }) {
      super('MessageType', 'Emote');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: EmoteMessageContent }): Emote_ {
      return new Emote_(inner);
    }

    static instanceOf(obj: any): obj is Emote_ {
      return obj.tag === MessageType_Tags.Emote;
    }
  }

  type Image__interface = {
    tag: MessageType_Tags.Image;
    inner: Readonly<{ content: ImageMessageContent }>;
  };

  class Image_ extends UniffiEnum implements Image__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Image;
    readonly inner: Readonly<{ content: ImageMessageContent }>;
    constructor(inner: { content: ImageMessageContent }) {
      super('MessageType', 'Image');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: ImageMessageContent }): Image_ {
      return new Image_(inner);
    }

    static instanceOf(obj: any): obj is Image_ {
      return obj.tag === MessageType_Tags.Image;
    }
  }

  type Audio__interface = {
    tag: MessageType_Tags.Audio;
    inner: Readonly<{ content: AudioMessageContent }>;
  };

  class Audio_ extends UniffiEnum implements Audio__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Audio;
    readonly inner: Readonly<{ content: AudioMessageContent }>;
    constructor(inner: { content: AudioMessageContent }) {
      super('MessageType', 'Audio');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: AudioMessageContent }): Audio_ {
      return new Audio_(inner);
    }

    static instanceOf(obj: any): obj is Audio_ {
      return obj.tag === MessageType_Tags.Audio;
    }
  }

  type Video__interface = {
    tag: MessageType_Tags.Video;
    inner: Readonly<{ content: VideoMessageContent }>;
  };

  class Video_ extends UniffiEnum implements Video__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Video;
    readonly inner: Readonly<{ content: VideoMessageContent }>;
    constructor(inner: { content: VideoMessageContent }) {
      super('MessageType', 'Video');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: VideoMessageContent }): Video_ {
      return new Video_(inner);
    }

    static instanceOf(obj: any): obj is Video_ {
      return obj.tag === MessageType_Tags.Video;
    }
  }

  type File__interface = {
    tag: MessageType_Tags.File;
    inner: Readonly<{ content: FileMessageContent }>;
  };

  class File_ extends UniffiEnum implements File__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.File;
    readonly inner: Readonly<{ content: FileMessageContent }>;
    constructor(inner: { content: FileMessageContent }) {
      super('MessageType', 'File');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: FileMessageContent }): File_ {
      return new File_(inner);
    }

    static instanceOf(obj: any): obj is File_ {
      return obj.tag === MessageType_Tags.File;
    }
  }

  type Gallery__interface = {
    tag: MessageType_Tags.Gallery;
    inner: Readonly<{ content: GalleryMessageContent }>;
  };

  class Gallery_ extends UniffiEnum implements Gallery__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Gallery;
    readonly inner: Readonly<{ content: GalleryMessageContent }>;
    constructor(inner: { content: GalleryMessageContent }) {
      super('MessageType', 'Gallery');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: GalleryMessageContent }): Gallery_ {
      return new Gallery_(inner);
    }

    static instanceOf(obj: any): obj is Gallery_ {
      return obj.tag === MessageType_Tags.Gallery;
    }
  }

  type Notice__interface = {
    tag: MessageType_Tags.Notice;
    inner: Readonly<{ content: NoticeMessageContent }>;
  };

  class Notice_ extends UniffiEnum implements Notice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Notice;
    readonly inner: Readonly<{ content: NoticeMessageContent }>;
    constructor(inner: { content: NoticeMessageContent }) {
      super('MessageType', 'Notice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: NoticeMessageContent }): Notice_ {
      return new Notice_(inner);
    }

    static instanceOf(obj: any): obj is Notice_ {
      return obj.tag === MessageType_Tags.Notice;
    }
  }

  type Text__interface = {
    tag: MessageType_Tags.Text;
    inner: Readonly<{ content: TextMessageContent }>;
  };

  class Text_ extends UniffiEnum implements Text__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Text;
    readonly inner: Readonly<{ content: TextMessageContent }>;
    constructor(inner: { content: TextMessageContent }) {
      super('MessageType', 'Text');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: TextMessageContent }): Text_ {
      return new Text_(inner);
    }

    static instanceOf(obj: any): obj is Text_ {
      return obj.tag === MessageType_Tags.Text;
    }
  }

  type Location__interface = {
    tag: MessageType_Tags.Location;
    inner: Readonly<{ content: LocationContent }>;
  };

  class Location_ extends UniffiEnum implements Location__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Location;
    readonly inner: Readonly<{ content: LocationContent }>;
    constructor(inner: { content: LocationContent }) {
      super('MessageType', 'Location');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: LocationContent }): Location_ {
      return new Location_(inner);
    }

    static instanceOf(obj: any): obj is Location_ {
      return obj.tag === MessageType_Tags.Location;
    }
  }

  type Other__interface = {
    tag: MessageType_Tags.Other;
    inner: Readonly<{ msgtype: string; body: string }>;
  };

  class Other_ extends UniffiEnum implements Other__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MessageType';
    readonly tag = MessageType_Tags.Other;
    readonly inner: Readonly<{ msgtype: string; body: string }>;
    constructor(inner: { msgtype: string; body: string }) {
      super('MessageType', 'Other');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msgtype: string; body: string }): Other_ {
      return new Other_(inner);
    }

    static instanceOf(obj: any): obj is Other_ {
      return obj.tag === MessageType_Tags.Other;
    }
  }

  function instanceOf(obj: any): obj is MessageType {
    return obj[uniffiTypeNameSymbol] === 'MessageType';
  }

  return Object.freeze({
    instanceOf,
    Emote: Emote_,
    Image: Image_,
    Audio: Audio_,
    Video: Video_,
    File: File_,
    Gallery: Gallery_,
    Notice: Notice_,
    Text: Text_,
    Location: Location_,
    Other: Other_,
  });
})();

export type MessageType = InstanceType<
  (typeof MessageType)[keyof Omit<typeof MessageType, 'instanceOf'>]
>;

// FfiConverter for enum MessageType
const FfiConverterTypeMessageType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MessageType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MessageType.Emote({
            content: FfiConverterTypeEmoteMessageContent.read(from),
          });
        case 2:
          return new MessageType.Image({
            content: FfiConverterTypeImageMessageContent.read(from),
          });
        case 3:
          return new MessageType.Audio({
            content: FfiConverterTypeAudioMessageContent.read(from),
          });
        case 4:
          return new MessageType.Video({
            content: FfiConverterTypeVideoMessageContent.read(from),
          });
        case 5:
          return new MessageType.File({
            content: FfiConverterTypeFileMessageContent.read(from),
          });
        case 6:
          return new MessageType.Gallery({
            content: FfiConverterTypeGalleryMessageContent.read(from),
          });
        case 7:
          return new MessageType.Notice({
            content: FfiConverterTypeNoticeMessageContent.read(from),
          });
        case 8:
          return new MessageType.Text({
            content: FfiConverterTypeTextMessageContent.read(from),
          });
        case 9:
          return new MessageType.Location({
            content: FfiConverterTypeLocationContent.read(from),
          });
        case 10:
          return new MessageType.Other({
            msgtype: FfiConverterString.read(from),
            body: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MessageType_Tags.Emote: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeEmoteMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Image: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeImageMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Audio: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeAudioMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Video: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeVideoMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.File: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeFileMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Gallery: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeGalleryMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Notice: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeNoticeMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Text: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeTextMessageContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Location: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterTypeLocationContent.write(inner.content, into);
          return;
        }
        case MessageType_Tags.Other: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msgtype, into);
          FfiConverterString.write(inner.body, into);
          return;
        }
        default:
          // Throwing from here means that MessageType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MessageType_Tags.Emote: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeEmoteMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Image: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeImageMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Audio: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeAudioMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Video: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeVideoMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.File: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeFileMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Gallery: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeGalleryMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Notice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeNoticeMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Text: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeTextMessageContent.allocationSize(
            inner.content
          );
          return size;
        }
        case MessageType_Tags.Location: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterTypeLocationContent.allocationSize(inner.content);
          return size;
        }
        case MessageType_Tags.Other: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner.msgtype);
          size += FfiConverterString.allocationSize(inner.body);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: MsgLikeKind
export enum MsgLikeKind_Tags {
  Message = 'Message',
  Sticker = 'Sticker',
  Poll = 'Poll',
  Redacted = 'Redacted',
  UnableToDecrypt = 'UnableToDecrypt',
}
export const MsgLikeKind = (() => {
  type Message__interface = {
    tag: MsgLikeKind_Tags.Message;
    inner: Readonly<{ content: MessageContent }>;
  };

  /**
   * An `m.room.message` event or extensible event, including edits.
   */
  class Message_ extends UniffiEnum implements Message__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MsgLikeKind';
    readonly tag = MsgLikeKind_Tags.Message;
    readonly inner: Readonly<{ content: MessageContent }>;
    constructor(inner: { content: MessageContent }) {
      super('MsgLikeKind', 'Message');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: MessageContent }): Message_ {
      return new Message_(inner);
    }

    static instanceOf(obj: any): obj is Message_ {
      return obj.tag === MsgLikeKind_Tags.Message;
    }
  }

  type Sticker__interface = {
    tag: MsgLikeKind_Tags.Sticker;
    inner: Readonly<{
      body: string;
      info: ImageInfo;
      source: MediaSourceInterface;
    }>;
  };

  /**
   * An `m.sticker` event.
   */
  class Sticker_ extends UniffiEnum implements Sticker__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MsgLikeKind';
    readonly tag = MsgLikeKind_Tags.Sticker;
    readonly inner: Readonly<{
      body: string;
      info: ImageInfo;
      source: MediaSourceInterface;
    }>;
    constructor(inner: {
      body: string;
      info: ImageInfo;
      source: MediaSourceInterface;
    }) {
      super('MsgLikeKind', 'Sticker');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      body: string;
      info: ImageInfo;
      source: MediaSourceInterface;
    }): Sticker_ {
      return new Sticker_(inner);
    }

    static instanceOf(obj: any): obj is Sticker_ {
      return obj.tag === MsgLikeKind_Tags.Sticker;
    }
  }

  type Poll__interface = {
    tag: MsgLikeKind_Tags.Poll;
    inner: Readonly<{
      question: string;
      kind: PollKind;
      maxSelections: /*u64*/ bigint;
      answers: Array<PollAnswer>;
      votes: Map<string, Array<string>>;
      endTime: Timestamp | undefined;
      hasBeenEdited: boolean;
    }>;
  };

  /**
   * An `m.poll.start` event.
   */
  class Poll_ extends UniffiEnum implements Poll__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MsgLikeKind';
    readonly tag = MsgLikeKind_Tags.Poll;
    readonly inner: Readonly<{
      question: string;
      kind: PollKind;
      maxSelections: /*u64*/ bigint;
      answers: Array<PollAnswer>;
      votes: Map<string, Array<string>>;
      endTime: Timestamp | undefined;
      hasBeenEdited: boolean;
    }>;
    constructor(inner: {
      question: string;
      kind: PollKind;
      maxSelections: /*u64*/ bigint;
      answers: Array<PollAnswer>;
      votes: Map<string, Array<string>>;
      endTime: Timestamp | undefined;
      hasBeenEdited: boolean;
    }) {
      super('MsgLikeKind', 'Poll');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      question: string;
      kind: PollKind;
      maxSelections: /*u64*/ bigint;
      answers: Array<PollAnswer>;
      votes: Map<string, Array<string>>;
      endTime: Timestamp | undefined;
      hasBeenEdited: boolean;
    }): Poll_ {
      return new Poll_(inner);
    }

    static instanceOf(obj: any): obj is Poll_ {
      return obj.tag === MsgLikeKind_Tags.Poll;
    }
  }

  type Redacted__interface = {
    tag: MsgLikeKind_Tags.Redacted;
  };

  /**
   * A redacted message.
   */
  class Redacted_ extends UniffiEnum implements Redacted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MsgLikeKind';
    readonly tag = MsgLikeKind_Tags.Redacted;
    constructor() {
      super('MsgLikeKind', 'Redacted');
    }

    static new(): Redacted_ {
      return new Redacted_();
    }

    static instanceOf(obj: any): obj is Redacted_ {
      return obj.tag === MsgLikeKind_Tags.Redacted;
    }
  }

  type UnableToDecrypt__interface = {
    tag: MsgLikeKind_Tags.UnableToDecrypt;
    inner: Readonly<{ msg: EncryptedMessage }>;
  };

  /**
   * An `m.room.encrypted` event that could not be decrypted.
   */
  class UnableToDecrypt_
    extends UniffiEnum
    implements UnableToDecrypt__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MsgLikeKind';
    readonly tag = MsgLikeKind_Tags.UnableToDecrypt;
    readonly inner: Readonly<{ msg: EncryptedMessage }>;
    constructor(inner: { msg: EncryptedMessage }) {
      super('MsgLikeKind', 'UnableToDecrypt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: EncryptedMessage }): UnableToDecrypt_ {
      return new UnableToDecrypt_(inner);
    }

    static instanceOf(obj: any): obj is UnableToDecrypt_ {
      return obj.tag === MsgLikeKind_Tags.UnableToDecrypt;
    }
  }

  function instanceOf(obj: any): obj is MsgLikeKind {
    return obj[uniffiTypeNameSymbol] === 'MsgLikeKind';
  }

  return Object.freeze({
    instanceOf,
    Message: Message_,
    Sticker: Sticker_,
    Poll: Poll_,
    Redacted: Redacted_,
    UnableToDecrypt: UnableToDecrypt_,
  });
})();

export type MsgLikeKind = InstanceType<
  (typeof MsgLikeKind)[keyof Omit<typeof MsgLikeKind, 'instanceOf'>]
>;

// FfiConverter for enum MsgLikeKind
const FfiConverterTypeMsgLikeKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MsgLikeKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MsgLikeKind.Message({
            content: FfiConverterTypeMessageContent.read(from),
          });
        case 2:
          return new MsgLikeKind.Sticker({
            body: FfiConverterString.read(from),
            info: FfiConverterTypeImageInfo.read(from),
            source: FfiConverterTypeMediaSource.read(from),
          });
        case 3:
          return new MsgLikeKind.Poll({
            question: FfiConverterString.read(from),
            kind: FfiConverterTypePollKind.read(from),
            maxSelections: FfiConverterUInt64.read(from),
            answers: FfiConverterArrayTypePollAnswer.read(from),
            votes: FfiConverterMapStringArrayString.read(from),
            endTime: FfiConverterOptionalTypeTimestamp.read(from),
            hasBeenEdited: FfiConverterBool.read(from),
          });
        case 4:
          return new MsgLikeKind.Redacted();
        case 5:
          return new MsgLikeKind.UnableToDecrypt({
            msg: FfiConverterTypeEncryptedMessage.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MsgLikeKind_Tags.Message: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeMessageContent.write(inner.content, into);
          return;
        }
        case MsgLikeKind_Tags.Sticker: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.body, into);
          FfiConverterTypeImageInfo.write(inner.info, into);
          FfiConverterTypeMediaSource.write(inner.source, into);
          return;
        }
        case MsgLikeKind_Tags.Poll: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.question, into);
          FfiConverterTypePollKind.write(inner.kind, into);
          FfiConverterUInt64.write(inner.maxSelections, into);
          FfiConverterArrayTypePollAnswer.write(inner.answers, into);
          FfiConverterMapStringArrayString.write(inner.votes, into);
          FfiConverterOptionalTypeTimestamp.write(inner.endTime, into);
          FfiConverterBool.write(inner.hasBeenEdited, into);
          return;
        }
        case MsgLikeKind_Tags.Redacted: {
          ordinalConverter.write(4, into);
          return;
        }
        case MsgLikeKind_Tags.UnableToDecrypt: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeEncryptedMessage.write(inner.msg, into);
          return;
        }
        default:
          // Throwing from here means that MsgLikeKind_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MsgLikeKind_Tags.Message: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeMessageContent.allocationSize(inner.content);
          return size;
        }
        case MsgLikeKind_Tags.Sticker: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.body);
          size += FfiConverterTypeImageInfo.allocationSize(inner.info);
          size += FfiConverterTypeMediaSource.allocationSize(inner.source);
          return size;
        }
        case MsgLikeKind_Tags.Poll: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.question);
          size += FfiConverterTypePollKind.allocationSize(inner.kind);
          size += FfiConverterUInt64.allocationSize(inner.maxSelections);
          size += FfiConverterArrayTypePollAnswer.allocationSize(inner.answers);
          size += FfiConverterMapStringArrayString.allocationSize(inner.votes);
          size += FfiConverterOptionalTypeTimestamp.allocationSize(
            inner.endTime
          );
          size += FfiConverterBool.allocationSize(inner.hasBeenEdited);
          return size;
        }
        case MsgLikeKind_Tags.Redacted: {
          return ordinalConverter.allocationSize(4);
        }
        case MsgLikeKind_Tags.UnableToDecrypt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeEncryptedMessage.allocationSize(inner.msg);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: NotificationEvent
export enum NotificationEvent_Tags {
  Timeline = 'Timeline',
  Invite = 'Invite',
}
export const NotificationEvent = (() => {
  type Timeline__interface = {
    tag: NotificationEvent_Tags.Timeline;
    inner: Readonly<{ event: TimelineEventInterface }>;
  };

  class Timeline_ extends UniffiEnum implements Timeline__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationEvent';
    readonly tag = NotificationEvent_Tags.Timeline;
    readonly inner: Readonly<{ event: TimelineEventInterface }>;
    constructor(inner: { event: TimelineEventInterface }) {
      super('NotificationEvent', 'Timeline');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { event: TimelineEventInterface }): Timeline_ {
      return new Timeline_(inner);
    }

    static instanceOf(obj: any): obj is Timeline_ {
      return obj.tag === NotificationEvent_Tags.Timeline;
    }
  }

  type Invite__interface = {
    tag: NotificationEvent_Tags.Invite;
    inner: Readonly<{ sender: string }>;
  };

  class Invite_ extends UniffiEnum implements Invite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationEvent';
    readonly tag = NotificationEvent_Tags.Invite;
    readonly inner: Readonly<{ sender: string }>;
    constructor(inner: { sender: string }) {
      super('NotificationEvent', 'Invite');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { sender: string }): Invite_ {
      return new Invite_(inner);
    }

    static instanceOf(obj: any): obj is Invite_ {
      return obj.tag === NotificationEvent_Tags.Invite;
    }
  }

  function instanceOf(obj: any): obj is NotificationEvent {
    return obj[uniffiTypeNameSymbol] === 'NotificationEvent';
  }

  return Object.freeze({
    instanceOf,
    Timeline: Timeline_,
    Invite: Invite_,
  });
})();

export type NotificationEvent = InstanceType<
  (typeof NotificationEvent)[keyof Omit<typeof NotificationEvent, 'instanceOf'>]
>;

// FfiConverter for enum NotificationEvent
const FfiConverterTypeNotificationEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotificationEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new NotificationEvent.Timeline({
            event: FfiConverterTypeTimelineEvent.read(from),
          });
        case 2:
          return new NotificationEvent.Invite({
            sender: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case NotificationEvent_Tags.Timeline: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeTimelineEvent.write(inner.event, into);
          return;
        }
        case NotificationEvent_Tags.Invite: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.sender, into);
          return;
        }
        default:
          // Throwing from here means that NotificationEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case NotificationEvent_Tags.Timeline: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeTimelineEvent.allocationSize(inner.event);
          return size;
        }
        case NotificationEvent_Tags.Invite: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.sender);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: NotificationProcessSetup
export enum NotificationProcessSetup_Tags {
  MultipleProcesses = 'MultipleProcesses',
  SingleProcess = 'SingleProcess',
}
export const NotificationProcessSetup = (() => {
  type MultipleProcesses__interface = {
    tag: NotificationProcessSetup_Tags.MultipleProcesses;
  };

  class MultipleProcesses_
    extends UniffiEnum
    implements MultipleProcesses__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationProcessSetup';
    readonly tag = NotificationProcessSetup_Tags.MultipleProcesses;
    constructor() {
      super('NotificationProcessSetup', 'MultipleProcesses');
    }

    static new(): MultipleProcesses_ {
      return new MultipleProcesses_();
    }

    static instanceOf(obj: any): obj is MultipleProcesses_ {
      return obj.tag === NotificationProcessSetup_Tags.MultipleProcesses;
    }
  }

  type SingleProcess__interface = {
    tag: NotificationProcessSetup_Tags.SingleProcess;
    inner: Readonly<{ syncService: SyncServiceInterface }>;
  };

  class SingleProcess_ extends UniffiEnum implements SingleProcess__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationProcessSetup';
    readonly tag = NotificationProcessSetup_Tags.SingleProcess;
    readonly inner: Readonly<{ syncService: SyncServiceInterface }>;
    constructor(inner: { syncService: SyncServiceInterface }) {
      super('NotificationProcessSetup', 'SingleProcess');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { syncService: SyncServiceInterface }): SingleProcess_ {
      return new SingleProcess_(inner);
    }

    static instanceOf(obj: any): obj is SingleProcess_ {
      return obj.tag === NotificationProcessSetup_Tags.SingleProcess;
    }
  }

  function instanceOf(obj: any): obj is NotificationProcessSetup {
    return obj[uniffiTypeNameSymbol] === 'NotificationProcessSetup';
  }

  return Object.freeze({
    instanceOf,
    MultipleProcesses: MultipleProcesses_,
    SingleProcess: SingleProcess_,
  });
})();

export type NotificationProcessSetup = InstanceType<
  (typeof NotificationProcessSetup)[keyof Omit<
    typeof NotificationProcessSetup,
    'instanceOf'
  >]
>;

// FfiConverter for enum NotificationProcessSetup
const FfiConverterTypeNotificationProcessSetup = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotificationProcessSetup;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new NotificationProcessSetup.MultipleProcesses();
        case 2:
          return new NotificationProcessSetup.SingleProcess({
            syncService: FfiConverterTypeSyncService.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case NotificationProcessSetup_Tags.MultipleProcesses: {
          ordinalConverter.write(1, into);
          return;
        }
        case NotificationProcessSetup_Tags.SingleProcess: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeSyncService.write(inner.syncService, into);
          return;
        }
        default:
          // Throwing from here means that NotificationProcessSetup_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case NotificationProcessSetup_Tags.MultipleProcesses: {
          return ordinalConverter.allocationSize(1);
        }
        case NotificationProcessSetup_Tags.SingleProcess: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeSyncService.allocationSize(inner.syncService);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: NotificationSettingsError

// Enum: NotificationSettingsError
export enum NotificationSettingsError_Tags {
  Generic = 'Generic',
  InvalidParameter = 'InvalidParameter',
  InvalidRoomId = 'InvalidRoomId',
  RuleNotFound = 'RuleNotFound',
  UnableToAddPushRule = 'UnableToAddPushRule',
  UnableToRemovePushRule = 'UnableToRemovePushRule',
  UnableToSavePushRules = 'UnableToSavePushRules',
  UnableToUpdatePushRule = 'UnableToUpdatePushRule',
}
export const NotificationSettingsError = (() => {
  type Generic__interface = {
    tag: NotificationSettingsError_Tags.Generic;
    inner: Readonly<{ msg: string }>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.Generic;
    readonly inner: Readonly<{ msg: string }>;
    constructor(inner: { msg: string }) {
      super('NotificationSettingsError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === NotificationSettingsError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<{ msg: string }> {
      return obj.inner;
    }
  }

  type InvalidParameter__interface = {
    tag: NotificationSettingsError_Tags.InvalidParameter;
    inner: Readonly<{ msg: string }>;
  };

  /**
   * Invalid parameter.
   */
  class InvalidParameter_
    extends UniffiError
    implements InvalidParameter__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.InvalidParameter;
    readonly inner: Readonly<{ msg: string }>;
    constructor(inner: { msg: string }) {
      super('NotificationSettingsError', 'InvalidParameter');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string }): InvalidParameter_ {
      return new InvalidParameter_(inner);
    }

    static instanceOf(obj: any): obj is InvalidParameter_ {
      return obj.tag === NotificationSettingsError_Tags.InvalidParameter;
    }

    static hasInner(obj: any): obj is InvalidParameter_ {
      return InvalidParameter_.instanceOf(obj);
    }

    static getInner(obj: InvalidParameter_): Readonly<{ msg: string }> {
      return obj.inner;
    }
  }

  type InvalidRoomId__interface = {
    tag: NotificationSettingsError_Tags.InvalidRoomId;
    inner: Readonly<{ roomId: string }>;
  };

  /**
   * Invalid room id.
   */
  class InvalidRoomId_ extends UniffiError implements InvalidRoomId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.InvalidRoomId;
    readonly inner: Readonly<{ roomId: string }>;
    constructor(inner: { roomId: string }) {
      super('NotificationSettingsError', 'InvalidRoomId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomId: string }): InvalidRoomId_ {
      return new InvalidRoomId_(inner);
    }

    static instanceOf(obj: any): obj is InvalidRoomId_ {
      return obj.tag === NotificationSettingsError_Tags.InvalidRoomId;
    }

    static hasInner(obj: any): obj is InvalidRoomId_ {
      return InvalidRoomId_.instanceOf(obj);
    }

    static getInner(obj: InvalidRoomId_): Readonly<{ roomId: string }> {
      return obj.inner;
    }
  }

  type RuleNotFound__interface = {
    tag: NotificationSettingsError_Tags.RuleNotFound;
    inner: Readonly<{ ruleId: string }>;
  };

  /**
   * Rule not found
   */
  class RuleNotFound_ extends UniffiError implements RuleNotFound__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.RuleNotFound;
    readonly inner: Readonly<{ ruleId: string }>;
    constructor(inner: { ruleId: string }) {
      super('NotificationSettingsError', 'RuleNotFound');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { ruleId: string }): RuleNotFound_ {
      return new RuleNotFound_(inner);
    }

    static instanceOf(obj: any): obj is RuleNotFound_ {
      return obj.tag === NotificationSettingsError_Tags.RuleNotFound;
    }

    static hasInner(obj: any): obj is RuleNotFound_ {
      return RuleNotFound_.instanceOf(obj);
    }

    static getInner(obj: RuleNotFound_): Readonly<{ ruleId: string }> {
      return obj.inner;
    }
  }

  type UnableToAddPushRule__interface = {
    tag: NotificationSettingsError_Tags.UnableToAddPushRule;
  };

  /**
   * Unable to add push rule.
   */
  class UnableToAddPushRule_
    extends UniffiError
    implements UnableToAddPushRule__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.UnableToAddPushRule;
    constructor() {
      super('NotificationSettingsError', 'UnableToAddPushRule');
    }

    static new(): UnableToAddPushRule_ {
      return new UnableToAddPushRule_();
    }

    static instanceOf(obj: any): obj is UnableToAddPushRule_ {
      return obj.tag === NotificationSettingsError_Tags.UnableToAddPushRule;
    }

    static hasInner(obj: any): obj is UnableToAddPushRule_ {
      return false;
    }
  }

  type UnableToRemovePushRule__interface = {
    tag: NotificationSettingsError_Tags.UnableToRemovePushRule;
  };

  /**
   * Unable to remove push rule.
   */
  class UnableToRemovePushRule_
    extends UniffiError
    implements UnableToRemovePushRule__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.UnableToRemovePushRule;
    constructor() {
      super('NotificationSettingsError', 'UnableToRemovePushRule');
    }

    static new(): UnableToRemovePushRule_ {
      return new UnableToRemovePushRule_();
    }

    static instanceOf(obj: any): obj is UnableToRemovePushRule_ {
      return obj.tag === NotificationSettingsError_Tags.UnableToRemovePushRule;
    }

    static hasInner(obj: any): obj is UnableToRemovePushRule_ {
      return false;
    }
  }

  type UnableToSavePushRules__interface = {
    tag: NotificationSettingsError_Tags.UnableToSavePushRules;
  };

  /**
   * Unable to save the push rules
   */
  class UnableToSavePushRules_
    extends UniffiError
    implements UnableToSavePushRules__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.UnableToSavePushRules;
    constructor() {
      super('NotificationSettingsError', 'UnableToSavePushRules');
    }

    static new(): UnableToSavePushRules_ {
      return new UnableToSavePushRules_();
    }

    static instanceOf(obj: any): obj is UnableToSavePushRules_ {
      return obj.tag === NotificationSettingsError_Tags.UnableToSavePushRules;
    }

    static hasInner(obj: any): obj is UnableToSavePushRules_ {
      return false;
    }
  }

  type UnableToUpdatePushRule__interface = {
    tag: NotificationSettingsError_Tags.UnableToUpdatePushRule;
  };

  /**
   * Unable to update push rule.
   */
  class UnableToUpdatePushRule_
    extends UniffiError
    implements UnableToUpdatePushRule__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NotificationSettingsError';
    readonly tag = NotificationSettingsError_Tags.UnableToUpdatePushRule;
    constructor() {
      super('NotificationSettingsError', 'UnableToUpdatePushRule');
    }

    static new(): UnableToUpdatePushRule_ {
      return new UnableToUpdatePushRule_();
    }

    static instanceOf(obj: any): obj is UnableToUpdatePushRule_ {
      return obj.tag === NotificationSettingsError_Tags.UnableToUpdatePushRule;
    }

    static hasInner(obj: any): obj is UnableToUpdatePushRule_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is NotificationSettingsError {
    return obj[uniffiTypeNameSymbol] === 'NotificationSettingsError';
  }

  return Object.freeze({
    instanceOf,
    Generic: Generic_,
    InvalidParameter: InvalidParameter_,
    InvalidRoomId: InvalidRoomId_,
    RuleNotFound: RuleNotFound_,
    UnableToAddPushRule: UnableToAddPushRule_,
    UnableToRemovePushRule: UnableToRemovePushRule_,
    UnableToSavePushRules: UnableToSavePushRules_,
    UnableToUpdatePushRule: UnableToUpdatePushRule_,
  });
})();

export type NotificationSettingsError = InstanceType<
  (typeof NotificationSettingsError)[keyof Omit<
    typeof NotificationSettingsError,
    'instanceOf'
  >]
>;

// FfiConverter for enum NotificationSettingsError
const FfiConverterTypeNotificationSettingsError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotificationSettingsError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new NotificationSettingsError.Generic({
            msg: FfiConverterString.read(from),
          });
        case 2:
          return new NotificationSettingsError.InvalidParameter({
            msg: FfiConverterString.read(from),
          });
        case 3:
          return new NotificationSettingsError.InvalidRoomId({
            roomId: FfiConverterString.read(from),
          });
        case 4:
          return new NotificationSettingsError.RuleNotFound({
            ruleId: FfiConverterString.read(from),
          });
        case 5:
          return new NotificationSettingsError.UnableToAddPushRule();
        case 6:
          return new NotificationSettingsError.UnableToRemovePushRule();
        case 7:
          return new NotificationSettingsError.UnableToSavePushRules();
        case 8:
          return new NotificationSettingsError.UnableToUpdatePushRule();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case NotificationSettingsError_Tags.Generic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          return;
        }
        case NotificationSettingsError_Tags.InvalidParameter: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          return;
        }
        case NotificationSettingsError_Tags.InvalidRoomId: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomId, into);
          return;
        }
        case NotificationSettingsError_Tags.RuleNotFound: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.ruleId, into);
          return;
        }
        case NotificationSettingsError_Tags.UnableToAddPushRule: {
          ordinalConverter.write(5, into);
          return;
        }
        case NotificationSettingsError_Tags.UnableToRemovePushRule: {
          ordinalConverter.write(6, into);
          return;
        }
        case NotificationSettingsError_Tags.UnableToSavePushRules: {
          ordinalConverter.write(7, into);
          return;
        }
        case NotificationSettingsError_Tags.UnableToUpdatePushRule: {
          ordinalConverter.write(8, into);
          return;
        }
        default:
          // Throwing from here means that NotificationSettingsError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case NotificationSettingsError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.msg);
          return size;
        }
        case NotificationSettingsError_Tags.InvalidParameter: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.msg);
          return size;
        }
        case NotificationSettingsError_Tags.InvalidRoomId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.roomId);
          return size;
        }
        case NotificationSettingsError_Tags.RuleNotFound: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.ruleId);
          return size;
        }
        case NotificationSettingsError_Tags.UnableToAddPushRule: {
          return ordinalConverter.allocationSize(5);
        }
        case NotificationSettingsError_Tags.UnableToRemovePushRule: {
          return ordinalConverter.allocationSize(6);
        }
        case NotificationSettingsError_Tags.UnableToSavePushRules: {
          return ordinalConverter.allocationSize(7);
        }
        case NotificationSettingsError_Tags.UnableToUpdatePushRule: {
          return ordinalConverter.allocationSize(8);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum NotifyType {
  Ring,
  Notify,
}

const FfiConverterTypeNotifyType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NotifyType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return NotifyType.Ring;
        case 2:
          return NotifyType.Notify;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case NotifyType.Ring:
          return ordinalConverter.write(1, into);
        case NotifyType.Notify:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: OidcError
export enum OidcError_Tags {
  NotSupported = 'NotSupported',
  MetadataInvalid = 'MetadataInvalid',
  CallbackUrlInvalid = 'CallbackUrlInvalid',
  Cancelled = 'Cancelled',
  Generic = 'Generic',
}
export const OidcError = (() => {
  class NotSupported extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = OidcError_Tags.NotSupported;

    constructor(message: string) {
      super('OidcError', 'NotSupported', message);
    }

    static instanceOf(e: any): e is NotSupported {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class MetadataInvalid extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = OidcError_Tags.MetadataInvalid;

    constructor(message: string) {
      super('OidcError', 'MetadataInvalid', message);
    }

    static instanceOf(e: any): e is MetadataInvalid {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class CallbackUrlInvalid extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = OidcError_Tags.CallbackUrlInvalid;

    constructor(message: string) {
      super('OidcError', 'CallbackUrlInvalid', message);
    }

    static instanceOf(e: any): e is CallbackUrlInvalid {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class Cancelled extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = OidcError_Tags.Cancelled;

    constructor(message: string) {
      super('OidcError', 'Cancelled', message);
    }

    static instanceOf(e: any): e is Cancelled {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'OidcError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = OidcError_Tags.Generic;

    constructor(message: string) {
      super('OidcError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is OidcError {
    return (e as any)[uniffiTypeNameSymbol] === 'OidcError';
  }
  return {
    NotSupported,
    MetadataInvalid,
    CallbackUrlInvalid,
    Cancelled,
    Generic,
    instanceOf,
  };
})();

// Union type for OidcError error type.

export type OidcError = InstanceType<
  (typeof OidcError)[keyof Omit<typeof OidcError, 'instanceOf'>]
>;

const FfiConverterTypeOidcError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = OidcError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new OidcError.NotSupported(FfiConverterString.read(from));

        case 2:
          return new OidcError.MetadataInvalid(FfiConverterString.read(from));

        case 3:
          return new OidcError.CallbackUrlInvalid(
            FfiConverterString.read(from)
          );

        case 4:
          return new OidcError.Cancelled(FfiConverterString.read(from));

        case 5:
          return new OidcError.Generic(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: OidcPrompt
export enum OidcPrompt_Tags {
  Create = 'Create',
  Login = 'Login',
  Consent = 'Consent',
  Unknown = 'Unknown',
}
export const OidcPrompt = (() => {
  type Create__interface = {
    tag: OidcPrompt_Tags.Create;
  };

  /**
   * The Authorization Server should prompt the End-User to create a user
   * account.
   *
   * Defined in [Initiating User Registration via OpenID Connect](https://openid.net/specs/openid-connect-prompt-create-1_0.html).
   */
  class Create_ extends UniffiEnum implements Create__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.Create;
    constructor() {
      super('OidcPrompt', 'Create');
    }

    static new(): Create_ {
      return new Create_();
    }

    static instanceOf(obj: any): obj is Create_ {
      return obj.tag === OidcPrompt_Tags.Create;
    }
  }

  type Login__interface = {
    tag: OidcPrompt_Tags.Login;
  };

  /**
   * The Authorization Server should prompt the End-User for
   * reauthentication.
   */
  class Login_ extends UniffiEnum implements Login__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.Login;
    constructor() {
      super('OidcPrompt', 'Login');
    }

    static new(): Login_ {
      return new Login_();
    }

    static instanceOf(obj: any): obj is Login_ {
      return obj.tag === OidcPrompt_Tags.Login;
    }
  }

  type Consent__interface = {
    tag: OidcPrompt_Tags.Consent;
  };

  /**
   * The Authorization Server should prompt the End-User for consent before
   * returning information to the Client.
   */
  class Consent_ extends UniffiEnum implements Consent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.Consent;
    constructor() {
      super('OidcPrompt', 'Consent');
    }

    static new(): Consent_ {
      return new Consent_();
    }

    static instanceOf(obj: any): obj is Consent_ {
      return obj.tag === OidcPrompt_Tags.Consent;
    }
  }

  type Unknown__interface = {
    tag: OidcPrompt_Tags.Unknown;
    inner: Readonly<{ value: string }>;
  };

  /**
   * An unknown value.
   */
  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OidcPrompt';
    readonly tag = OidcPrompt_Tags.Unknown;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('OidcPrompt', 'Unknown');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Unknown_ {
      return new Unknown_(inner);
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === OidcPrompt_Tags.Unknown;
    }
  }

  function instanceOf(obj: any): obj is OidcPrompt {
    return obj[uniffiTypeNameSymbol] === 'OidcPrompt';
  }

  return Object.freeze({
    instanceOf,
    Create: Create_,
    Login: Login_,
    Consent: Consent_,
    Unknown: Unknown_,
  });
})();

export type OidcPrompt = InstanceType<
  (typeof OidcPrompt)[keyof Omit<typeof OidcPrompt, 'instanceOf'>]
>;

// FfiConverter for enum OidcPrompt
const FfiConverterTypeOidcPrompt = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = OidcPrompt;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new OidcPrompt.Create();
        case 2:
          return new OidcPrompt.Login();
        case 3:
          return new OidcPrompt.Consent();
        case 4:
          return new OidcPrompt.Unknown({
            value: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case OidcPrompt_Tags.Create: {
          ordinalConverter.write(1, into);
          return;
        }
        case OidcPrompt_Tags.Login: {
          ordinalConverter.write(2, into);
          return;
        }
        case OidcPrompt_Tags.Consent: {
          ordinalConverter.write(3, into);
          return;
        }
        case OidcPrompt_Tags.Unknown: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that OidcPrompt_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case OidcPrompt_Tags.Create: {
          return ordinalConverter.allocationSize(1);
        }
        case OidcPrompt_Tags.Login: {
          return ordinalConverter.allocationSize(2);
        }
        case OidcPrompt_Tags.Consent: {
          return ordinalConverter.allocationSize(3);
        }
        case OidcPrompt_Tags.Unknown: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: OtherState
export enum OtherState_Tags {
  PolicyRuleRoom = 'PolicyRuleRoom',
  PolicyRuleServer = 'PolicyRuleServer',
  PolicyRuleUser = 'PolicyRuleUser',
  RoomAliases = 'RoomAliases',
  RoomAvatar = 'RoomAvatar',
  RoomCanonicalAlias = 'RoomCanonicalAlias',
  RoomCreate = 'RoomCreate',
  RoomEncryption = 'RoomEncryption',
  RoomGuestAccess = 'RoomGuestAccess',
  RoomHistoryVisibility = 'RoomHistoryVisibility',
  RoomJoinRules = 'RoomJoinRules',
  RoomName = 'RoomName',
  RoomPinnedEvents = 'RoomPinnedEvents',
  RoomPowerLevels = 'RoomPowerLevels',
  RoomServerAcl = 'RoomServerAcl',
  RoomThirdPartyInvite = 'RoomThirdPartyInvite',
  RoomTombstone = 'RoomTombstone',
  RoomTopic = 'RoomTopic',
  SpaceChild = 'SpaceChild',
  SpaceParent = 'SpaceParent',
  Custom = 'Custom',
}
export const OtherState = (() => {
  type PolicyRuleRoom__interface = {
    tag: OtherState_Tags.PolicyRuleRoom;
  };

  class PolicyRuleRoom_
    extends UniffiEnum
    implements PolicyRuleRoom__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.PolicyRuleRoom;
    constructor() {
      super('OtherState', 'PolicyRuleRoom');
    }

    static new(): PolicyRuleRoom_ {
      return new PolicyRuleRoom_();
    }

    static instanceOf(obj: any): obj is PolicyRuleRoom_ {
      return obj.tag === OtherState_Tags.PolicyRuleRoom;
    }
  }

  type PolicyRuleServer__interface = {
    tag: OtherState_Tags.PolicyRuleServer;
  };

  class PolicyRuleServer_
    extends UniffiEnum
    implements PolicyRuleServer__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.PolicyRuleServer;
    constructor() {
      super('OtherState', 'PolicyRuleServer');
    }

    static new(): PolicyRuleServer_ {
      return new PolicyRuleServer_();
    }

    static instanceOf(obj: any): obj is PolicyRuleServer_ {
      return obj.tag === OtherState_Tags.PolicyRuleServer;
    }
  }

  type PolicyRuleUser__interface = {
    tag: OtherState_Tags.PolicyRuleUser;
  };

  class PolicyRuleUser_
    extends UniffiEnum
    implements PolicyRuleUser__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.PolicyRuleUser;
    constructor() {
      super('OtherState', 'PolicyRuleUser');
    }

    static new(): PolicyRuleUser_ {
      return new PolicyRuleUser_();
    }

    static instanceOf(obj: any): obj is PolicyRuleUser_ {
      return obj.tag === OtherState_Tags.PolicyRuleUser;
    }
  }

  type RoomAliases__interface = {
    tag: OtherState_Tags.RoomAliases;
  };

  class RoomAliases_ extends UniffiEnum implements RoomAliases__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomAliases;
    constructor() {
      super('OtherState', 'RoomAliases');
    }

    static new(): RoomAliases_ {
      return new RoomAliases_();
    }

    static instanceOf(obj: any): obj is RoomAliases_ {
      return obj.tag === OtherState_Tags.RoomAliases;
    }
  }

  type RoomAvatar__interface = {
    tag: OtherState_Tags.RoomAvatar;
    inner: Readonly<{ url: string | undefined }>;
  };

  class RoomAvatar_ extends UniffiEnum implements RoomAvatar__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomAvatar;
    readonly inner: Readonly<{ url: string | undefined }>;
    constructor(inner: { url: string | undefined }) {
      super('OtherState', 'RoomAvatar');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string | undefined }): RoomAvatar_ {
      return new RoomAvatar_(inner);
    }

    static instanceOf(obj: any): obj is RoomAvatar_ {
      return obj.tag === OtherState_Tags.RoomAvatar;
    }
  }

  type RoomCanonicalAlias__interface = {
    tag: OtherState_Tags.RoomCanonicalAlias;
  };

  class RoomCanonicalAlias_
    extends UniffiEnum
    implements RoomCanonicalAlias__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomCanonicalAlias;
    constructor() {
      super('OtherState', 'RoomCanonicalAlias');
    }

    static new(): RoomCanonicalAlias_ {
      return new RoomCanonicalAlias_();
    }

    static instanceOf(obj: any): obj is RoomCanonicalAlias_ {
      return obj.tag === OtherState_Tags.RoomCanonicalAlias;
    }
  }

  type RoomCreate__interface = {
    tag: OtherState_Tags.RoomCreate;
  };

  class RoomCreate_ extends UniffiEnum implements RoomCreate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomCreate;
    constructor() {
      super('OtherState', 'RoomCreate');
    }

    static new(): RoomCreate_ {
      return new RoomCreate_();
    }

    static instanceOf(obj: any): obj is RoomCreate_ {
      return obj.tag === OtherState_Tags.RoomCreate;
    }
  }

  type RoomEncryption__interface = {
    tag: OtherState_Tags.RoomEncryption;
  };

  class RoomEncryption_
    extends UniffiEnum
    implements RoomEncryption__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomEncryption;
    constructor() {
      super('OtherState', 'RoomEncryption');
    }

    static new(): RoomEncryption_ {
      return new RoomEncryption_();
    }

    static instanceOf(obj: any): obj is RoomEncryption_ {
      return obj.tag === OtherState_Tags.RoomEncryption;
    }
  }

  type RoomGuestAccess__interface = {
    tag: OtherState_Tags.RoomGuestAccess;
  };

  class RoomGuestAccess_
    extends UniffiEnum
    implements RoomGuestAccess__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomGuestAccess;
    constructor() {
      super('OtherState', 'RoomGuestAccess');
    }

    static new(): RoomGuestAccess_ {
      return new RoomGuestAccess_();
    }

    static instanceOf(obj: any): obj is RoomGuestAccess_ {
      return obj.tag === OtherState_Tags.RoomGuestAccess;
    }
  }

  type RoomHistoryVisibility__interface = {
    tag: OtherState_Tags.RoomHistoryVisibility;
  };

  class RoomHistoryVisibility_
    extends UniffiEnum
    implements RoomHistoryVisibility__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomHistoryVisibility;
    constructor() {
      super('OtherState', 'RoomHistoryVisibility');
    }

    static new(): RoomHistoryVisibility_ {
      return new RoomHistoryVisibility_();
    }

    static instanceOf(obj: any): obj is RoomHistoryVisibility_ {
      return obj.tag === OtherState_Tags.RoomHistoryVisibility;
    }
  }

  type RoomJoinRules__interface = {
    tag: OtherState_Tags.RoomJoinRules;
  };

  class RoomJoinRules_ extends UniffiEnum implements RoomJoinRules__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomJoinRules;
    constructor() {
      super('OtherState', 'RoomJoinRules');
    }

    static new(): RoomJoinRules_ {
      return new RoomJoinRules_();
    }

    static instanceOf(obj: any): obj is RoomJoinRules_ {
      return obj.tag === OtherState_Tags.RoomJoinRules;
    }
  }

  type RoomName__interface = {
    tag: OtherState_Tags.RoomName;
    inner: Readonly<{ name: string | undefined }>;
  };

  class RoomName_ extends UniffiEnum implements RoomName__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomName;
    readonly inner: Readonly<{ name: string | undefined }>;
    constructor(inner: { name: string | undefined }) {
      super('OtherState', 'RoomName');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { name: string | undefined }): RoomName_ {
      return new RoomName_(inner);
    }

    static instanceOf(obj: any): obj is RoomName_ {
      return obj.tag === OtherState_Tags.RoomName;
    }
  }

  type RoomPinnedEvents__interface = {
    tag: OtherState_Tags.RoomPinnedEvents;
    inner: Readonly<{ change: RoomPinnedEventsChange }>;
  };

  class RoomPinnedEvents_
    extends UniffiEnum
    implements RoomPinnedEvents__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomPinnedEvents;
    readonly inner: Readonly<{ change: RoomPinnedEventsChange }>;
    constructor(inner: { change: RoomPinnedEventsChange }) {
      super('OtherState', 'RoomPinnedEvents');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { change: RoomPinnedEventsChange }): RoomPinnedEvents_ {
      return new RoomPinnedEvents_(inner);
    }

    static instanceOf(obj: any): obj is RoomPinnedEvents_ {
      return obj.tag === OtherState_Tags.RoomPinnedEvents;
    }
  }

  type RoomPowerLevels__interface = {
    tag: OtherState_Tags.RoomPowerLevels;
    inner: Readonly<{
      users: Map<string, /*i64*/ bigint>;
      previous: Map<string, /*i64*/ bigint> | undefined;
    }>;
  };

  class RoomPowerLevels_
    extends UniffiEnum
    implements RoomPowerLevels__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomPowerLevels;
    readonly inner: Readonly<{
      users: Map<string, /*i64*/ bigint>;
      previous: Map<string, /*i64*/ bigint> | undefined;
    }>;
    constructor(inner: {
      users: Map<string, /*i64*/ bigint>;
      previous: Map<string, /*i64*/ bigint> | undefined;
    }) {
      super('OtherState', 'RoomPowerLevels');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      users: Map<string, /*i64*/ bigint>;
      previous: Map<string, /*i64*/ bigint> | undefined;
    }): RoomPowerLevels_ {
      return new RoomPowerLevels_(inner);
    }

    static instanceOf(obj: any): obj is RoomPowerLevels_ {
      return obj.tag === OtherState_Tags.RoomPowerLevels;
    }
  }

  type RoomServerAcl__interface = {
    tag: OtherState_Tags.RoomServerAcl;
  };

  class RoomServerAcl_ extends UniffiEnum implements RoomServerAcl__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomServerAcl;
    constructor() {
      super('OtherState', 'RoomServerAcl');
    }

    static new(): RoomServerAcl_ {
      return new RoomServerAcl_();
    }

    static instanceOf(obj: any): obj is RoomServerAcl_ {
      return obj.tag === OtherState_Tags.RoomServerAcl;
    }
  }

  type RoomThirdPartyInvite__interface = {
    tag: OtherState_Tags.RoomThirdPartyInvite;
    inner: Readonly<{ displayName: string | undefined }>;
  };

  class RoomThirdPartyInvite_
    extends UniffiEnum
    implements RoomThirdPartyInvite__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomThirdPartyInvite;
    readonly inner: Readonly<{ displayName: string | undefined }>;
    constructor(inner: { displayName: string | undefined }) {
      super('OtherState', 'RoomThirdPartyInvite');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      displayName: string | undefined;
    }): RoomThirdPartyInvite_ {
      return new RoomThirdPartyInvite_(inner);
    }

    static instanceOf(obj: any): obj is RoomThirdPartyInvite_ {
      return obj.tag === OtherState_Tags.RoomThirdPartyInvite;
    }
  }

  type RoomTombstone__interface = {
    tag: OtherState_Tags.RoomTombstone;
  };

  class RoomTombstone_ extends UniffiEnum implements RoomTombstone__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomTombstone;
    constructor() {
      super('OtherState', 'RoomTombstone');
    }

    static new(): RoomTombstone_ {
      return new RoomTombstone_();
    }

    static instanceOf(obj: any): obj is RoomTombstone_ {
      return obj.tag === OtherState_Tags.RoomTombstone;
    }
  }

  type RoomTopic__interface = {
    tag: OtherState_Tags.RoomTopic;
    inner: Readonly<{ topic: string | undefined }>;
  };

  class RoomTopic_ extends UniffiEnum implements RoomTopic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.RoomTopic;
    readonly inner: Readonly<{ topic: string | undefined }>;
    constructor(inner: { topic: string | undefined }) {
      super('OtherState', 'RoomTopic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { topic: string | undefined }): RoomTopic_ {
      return new RoomTopic_(inner);
    }

    static instanceOf(obj: any): obj is RoomTopic_ {
      return obj.tag === OtherState_Tags.RoomTopic;
    }
  }

  type SpaceChild__interface = {
    tag: OtherState_Tags.SpaceChild;
  };

  class SpaceChild_ extends UniffiEnum implements SpaceChild__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.SpaceChild;
    constructor() {
      super('OtherState', 'SpaceChild');
    }

    static new(): SpaceChild_ {
      return new SpaceChild_();
    }

    static instanceOf(obj: any): obj is SpaceChild_ {
      return obj.tag === OtherState_Tags.SpaceChild;
    }
  }

  type SpaceParent__interface = {
    tag: OtherState_Tags.SpaceParent;
  };

  class SpaceParent_ extends UniffiEnum implements SpaceParent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.SpaceParent;
    constructor() {
      super('OtherState', 'SpaceParent');
    }

    static new(): SpaceParent_ {
      return new SpaceParent_();
    }

    static instanceOf(obj: any): obj is SpaceParent_ {
      return obj.tag === OtherState_Tags.SpaceParent;
    }
  }

  type Custom__interface = {
    tag: OtherState_Tags.Custom;
    inner: Readonly<{ eventType: string }>;
  };

  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'OtherState';
    readonly tag = OtherState_Tags.Custom;
    readonly inner: Readonly<{ eventType: string }>;
    constructor(inner: { eventType: string }) {
      super('OtherState', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === OtherState_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is OtherState {
    return obj[uniffiTypeNameSymbol] === 'OtherState';
  }

  return Object.freeze({
    instanceOf,
    PolicyRuleRoom: PolicyRuleRoom_,
    PolicyRuleServer: PolicyRuleServer_,
    PolicyRuleUser: PolicyRuleUser_,
    RoomAliases: RoomAliases_,
    RoomAvatar: RoomAvatar_,
    RoomCanonicalAlias: RoomCanonicalAlias_,
    RoomCreate: RoomCreate_,
    RoomEncryption: RoomEncryption_,
    RoomGuestAccess: RoomGuestAccess_,
    RoomHistoryVisibility: RoomHistoryVisibility_,
    RoomJoinRules: RoomJoinRules_,
    RoomName: RoomName_,
    RoomPinnedEvents: RoomPinnedEvents_,
    RoomPowerLevels: RoomPowerLevels_,
    RoomServerAcl: RoomServerAcl_,
    RoomThirdPartyInvite: RoomThirdPartyInvite_,
    RoomTombstone: RoomTombstone_,
    RoomTopic: RoomTopic_,
    SpaceChild: SpaceChild_,
    SpaceParent: SpaceParent_,
    Custom: Custom_,
  });
})();

export type OtherState = InstanceType<
  (typeof OtherState)[keyof Omit<typeof OtherState, 'instanceOf'>]
>;

// FfiConverter for enum OtherState
const FfiConverterTypeOtherState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = OtherState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new OtherState.PolicyRuleRoom();
        case 2:
          return new OtherState.PolicyRuleServer();
        case 3:
          return new OtherState.PolicyRuleUser();
        case 4:
          return new OtherState.RoomAliases();
        case 5:
          return new OtherState.RoomAvatar({
            url: FfiConverterOptionalString.read(from),
          });
        case 6:
          return new OtherState.RoomCanonicalAlias();
        case 7:
          return new OtherState.RoomCreate();
        case 8:
          return new OtherState.RoomEncryption();
        case 9:
          return new OtherState.RoomGuestAccess();
        case 10:
          return new OtherState.RoomHistoryVisibility();
        case 11:
          return new OtherState.RoomJoinRules();
        case 12:
          return new OtherState.RoomName({
            name: FfiConverterOptionalString.read(from),
          });
        case 13:
          return new OtherState.RoomPinnedEvents({
            change: FfiConverterTypeRoomPinnedEventsChange.read(from),
          });
        case 14:
          return new OtherState.RoomPowerLevels({
            users: FfiConverterMapStringInt64.read(from),
            previous: FfiConverterOptionalMapStringInt64.read(from),
          });
        case 15:
          return new OtherState.RoomServerAcl();
        case 16:
          return new OtherState.RoomThirdPartyInvite({
            displayName: FfiConverterOptionalString.read(from),
          });
        case 17:
          return new OtherState.RoomTombstone();
        case 18:
          return new OtherState.RoomTopic({
            topic: FfiConverterOptionalString.read(from),
          });
        case 19:
          return new OtherState.SpaceChild();
        case 20:
          return new OtherState.SpaceParent();
        case 21:
          return new OtherState.Custom({
            eventType: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case OtherState_Tags.PolicyRuleRoom: {
          ordinalConverter.write(1, into);
          return;
        }
        case OtherState_Tags.PolicyRuleServer: {
          ordinalConverter.write(2, into);
          return;
        }
        case OtherState_Tags.PolicyRuleUser: {
          ordinalConverter.write(3, into);
          return;
        }
        case OtherState_Tags.RoomAliases: {
          ordinalConverter.write(4, into);
          return;
        }
        case OtherState_Tags.RoomAvatar: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.url, into);
          return;
        }
        case OtherState_Tags.RoomCanonicalAlias: {
          ordinalConverter.write(6, into);
          return;
        }
        case OtherState_Tags.RoomCreate: {
          ordinalConverter.write(7, into);
          return;
        }
        case OtherState_Tags.RoomEncryption: {
          ordinalConverter.write(8, into);
          return;
        }
        case OtherState_Tags.RoomGuestAccess: {
          ordinalConverter.write(9, into);
          return;
        }
        case OtherState_Tags.RoomHistoryVisibility: {
          ordinalConverter.write(10, into);
          return;
        }
        case OtherState_Tags.RoomJoinRules: {
          ordinalConverter.write(11, into);
          return;
        }
        case OtherState_Tags.RoomName: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.name, into);
          return;
        }
        case OtherState_Tags.RoomPinnedEvents: {
          ordinalConverter.write(13, into);
          const inner = value.inner;
          FfiConverterTypeRoomPinnedEventsChange.write(inner.change, into);
          return;
        }
        case OtherState_Tags.RoomPowerLevels: {
          ordinalConverter.write(14, into);
          const inner = value.inner;
          FfiConverterMapStringInt64.write(inner.users, into);
          FfiConverterOptionalMapStringInt64.write(inner.previous, into);
          return;
        }
        case OtherState_Tags.RoomServerAcl: {
          ordinalConverter.write(15, into);
          return;
        }
        case OtherState_Tags.RoomThirdPartyInvite: {
          ordinalConverter.write(16, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.displayName, into);
          return;
        }
        case OtherState_Tags.RoomTombstone: {
          ordinalConverter.write(17, into);
          return;
        }
        case OtherState_Tags.RoomTopic: {
          ordinalConverter.write(18, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.topic, into);
          return;
        }
        case OtherState_Tags.SpaceChild: {
          ordinalConverter.write(19, into);
          return;
        }
        case OtherState_Tags.SpaceParent: {
          ordinalConverter.write(20, into);
          return;
        }
        case OtherState_Tags.Custom: {
          ordinalConverter.write(21, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        default:
          // Throwing from here means that OtherState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case OtherState_Tags.PolicyRuleRoom: {
          return ordinalConverter.allocationSize(1);
        }
        case OtherState_Tags.PolicyRuleServer: {
          return ordinalConverter.allocationSize(2);
        }
        case OtherState_Tags.PolicyRuleUser: {
          return ordinalConverter.allocationSize(3);
        }
        case OtherState_Tags.RoomAliases: {
          return ordinalConverter.allocationSize(4);
        }
        case OtherState_Tags.RoomAvatar: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterOptionalString.allocationSize(inner.url);
          return size;
        }
        case OtherState_Tags.RoomCanonicalAlias: {
          return ordinalConverter.allocationSize(6);
        }
        case OtherState_Tags.RoomCreate: {
          return ordinalConverter.allocationSize(7);
        }
        case OtherState_Tags.RoomEncryption: {
          return ordinalConverter.allocationSize(8);
        }
        case OtherState_Tags.RoomGuestAccess: {
          return ordinalConverter.allocationSize(9);
        }
        case OtherState_Tags.RoomHistoryVisibility: {
          return ordinalConverter.allocationSize(10);
        }
        case OtherState_Tags.RoomJoinRules: {
          return ordinalConverter.allocationSize(11);
        }
        case OtherState_Tags.RoomName: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterOptionalString.allocationSize(inner.name);
          return size;
        }
        case OtherState_Tags.RoomPinnedEvents: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(13);
          size += FfiConverterTypeRoomPinnedEventsChange.allocationSize(
            inner.change
          );
          return size;
        }
        case OtherState_Tags.RoomPowerLevels: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(14);
          size += FfiConverterMapStringInt64.allocationSize(inner.users);
          size += FfiConverterOptionalMapStringInt64.allocationSize(
            inner.previous
          );
          return size;
        }
        case OtherState_Tags.RoomServerAcl: {
          return ordinalConverter.allocationSize(15);
        }
        case OtherState_Tags.RoomThirdPartyInvite: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(16);
          size += FfiConverterOptionalString.allocationSize(inner.displayName);
          return size;
        }
        case OtherState_Tags.RoomTombstone: {
          return ordinalConverter.allocationSize(17);
        }
        case OtherState_Tags.RoomTopic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(18);
          size += FfiConverterOptionalString.allocationSize(inner.topic);
          return size;
        }
        case OtherState_Tags.SpaceChild: {
          return ordinalConverter.allocationSize(19);
        }
        case OtherState_Tags.SpaceParent: {
          return ordinalConverter.allocationSize(20);
        }
        case OtherState_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(21);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: ParseError
export enum ParseError_Tags {
  EmptyHost = 'EmptyHost',
  IdnaError = 'IdnaError',
  InvalidPort = 'InvalidPort',
  InvalidIpv4Address = 'InvalidIpv4Address',
  InvalidIpv6Address = 'InvalidIpv6Address',
  InvalidDomainCharacter = 'InvalidDomainCharacter',
  RelativeUrlWithoutBase = 'RelativeUrlWithoutBase',
  RelativeUrlWithCannotBeABaseBase = 'RelativeUrlWithCannotBeABaseBase',
  SetHostOnCannotBeABaseUrl = 'SetHostOnCannotBeABaseUrl',
  Overflow = 'Overflow',
  Other = 'Other',
}
export const ParseError = (() => {
  class EmptyHost extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = ParseError_Tags.EmptyHost;

    constructor(message: string) {
      super('ParseError', 'EmptyHost', message);
    }

    static instanceOf(e: any): e is EmptyHost {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class IdnaError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = ParseError_Tags.IdnaError;

    constructor(message: string) {
      super('ParseError', 'IdnaError', message);
    }

    static instanceOf(e: any): e is IdnaError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class InvalidPort extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = ParseError_Tags.InvalidPort;

    constructor(message: string) {
      super('ParseError', 'InvalidPort', message);
    }

    static instanceOf(e: any): e is InvalidPort {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class InvalidIpv4Address extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = ParseError_Tags.InvalidIpv4Address;

    constructor(message: string) {
      super('ParseError', 'InvalidIpv4Address', message);
    }

    static instanceOf(e: any): e is InvalidIpv4Address {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class InvalidIpv6Address extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = ParseError_Tags.InvalidIpv6Address;

    constructor(message: string) {
      super('ParseError', 'InvalidIpv6Address', message);
    }

    static instanceOf(e: any): e is InvalidIpv6Address {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class InvalidDomainCharacter extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = ParseError_Tags.InvalidDomainCharacter;

    constructor(message: string) {
      super('ParseError', 'InvalidDomainCharacter', message);
    }

    static instanceOf(e: any): e is InvalidDomainCharacter {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  class RelativeUrlWithoutBase extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = ParseError_Tags.RelativeUrlWithoutBase;

    constructor(message: string) {
      super('ParseError', 'RelativeUrlWithoutBase', message);
    }

    static instanceOf(e: any): e is RelativeUrlWithoutBase {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  class RelativeUrlWithCannotBeABaseBase extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = ParseError_Tags.RelativeUrlWithCannotBeABaseBase;

    constructor(message: string) {
      super('ParseError', 'RelativeUrlWithCannotBeABaseBase', message);
    }

    static instanceOf(e: any): e is RelativeUrlWithCannotBeABaseBase {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  class SetHostOnCannotBeABaseUrl extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = ParseError_Tags.SetHostOnCannotBeABaseUrl;

    constructor(message: string) {
      super('ParseError', 'SetHostOnCannotBeABaseUrl', message);
    }

    static instanceOf(e: any): e is SetHostOnCannotBeABaseUrl {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }
  class Overflow extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 10;

    public readonly tag = ParseError_Tags.Overflow;

    constructor(message: string) {
      super('ParseError', 'Overflow', message);
    }

    static instanceOf(e: any): e is Overflow {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 10;
    }
  }
  class Other extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ParseError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 11;

    public readonly tag = ParseError_Tags.Other;

    constructor(message: string) {
      super('ParseError', 'Other', message);
    }

    static instanceOf(e: any): e is Other {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 11;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is ParseError {
    return (e as any)[uniffiTypeNameSymbol] === 'ParseError';
  }
  return {
    EmptyHost,
    IdnaError,
    InvalidPort,
    InvalidIpv4Address,
    InvalidIpv6Address,
    InvalidDomainCharacter,
    RelativeUrlWithoutBase,
    RelativeUrlWithCannotBeABaseBase,
    SetHostOnCannotBeABaseUrl,
    Overflow,
    Other,
    instanceOf,
  };
})();

// Union type for ParseError error type.

export type ParseError = InstanceType<
  (typeof ParseError)[keyof Omit<typeof ParseError, 'instanceOf'>]
>;

const FfiConverterTypeParseError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = ParseError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new ParseError.EmptyHost(FfiConverterString.read(from));

        case 2:
          return new ParseError.IdnaError(FfiConverterString.read(from));

        case 3:
          return new ParseError.InvalidPort(FfiConverterString.read(from));

        case 4:
          return new ParseError.InvalidIpv4Address(
            FfiConverterString.read(from)
          );

        case 5:
          return new ParseError.InvalidIpv6Address(
            FfiConverterString.read(from)
          );

        case 6:
          return new ParseError.InvalidDomainCharacter(
            FfiConverterString.read(from)
          );

        case 7:
          return new ParseError.RelativeUrlWithoutBase(
            FfiConverterString.read(from)
          );

        case 8:
          return new ParseError.RelativeUrlWithCannotBeABaseBase(
            FfiConverterString.read(from)
          );

        case 9:
          return new ParseError.SetHostOnCannotBeABaseUrl(
            FfiConverterString.read(from)
          );

        case 10:
          return new ParseError.Overflow(FfiConverterString.read(from));

        case 11:
          return new ParseError.Other(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum PollKind {
  Disclosed,
  Undisclosed,
}

const FfiConverterTypePollKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PollKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PollKind.Disclosed;
        case 2:
          return PollKind.Undisclosed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PollKind.Disclosed:
          return ordinalConverter.write(1, into);
        case PollKind.Undisclosed:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ProfileDetails
export enum ProfileDetails_Tags {
  Unavailable = 'Unavailable',
  Pending = 'Pending',
  Ready = 'Ready',
  Error = 'Error',
}
export const ProfileDetails = (() => {
  type Unavailable__interface = {
    tag: ProfileDetails_Tags.Unavailable;
  };

  class Unavailable_ extends UniffiEnum implements Unavailable__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProfileDetails';
    readonly tag = ProfileDetails_Tags.Unavailable;
    constructor() {
      super('ProfileDetails', 'Unavailable');
    }

    static new(): Unavailable_ {
      return new Unavailable_();
    }

    static instanceOf(obj: any): obj is Unavailable_ {
      return obj.tag === ProfileDetails_Tags.Unavailable;
    }
  }

  type Pending__interface = {
    tag: ProfileDetails_Tags.Pending;
  };

  class Pending_ extends UniffiEnum implements Pending__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProfileDetails';
    readonly tag = ProfileDetails_Tags.Pending;
    constructor() {
      super('ProfileDetails', 'Pending');
    }

    static new(): Pending_ {
      return new Pending_();
    }

    static instanceOf(obj: any): obj is Pending_ {
      return obj.tag === ProfileDetails_Tags.Pending;
    }
  }

  type Ready__interface = {
    tag: ProfileDetails_Tags.Ready;
    inner: Readonly<{
      displayName: string | undefined;
      displayNameAmbiguous: boolean;
      avatarUrl: string | undefined;
    }>;
  };

  class Ready_ extends UniffiEnum implements Ready__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProfileDetails';
    readonly tag = ProfileDetails_Tags.Ready;
    readonly inner: Readonly<{
      displayName: string | undefined;
      displayNameAmbiguous: boolean;
      avatarUrl: string | undefined;
    }>;
    constructor(inner: {
      displayName: string | undefined;
      displayNameAmbiguous: boolean;
      avatarUrl: string | undefined;
    }) {
      super('ProfileDetails', 'Ready');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      displayName: string | undefined;
      displayNameAmbiguous: boolean;
      avatarUrl: string | undefined;
    }): Ready_ {
      return new Ready_(inner);
    }

    static instanceOf(obj: any): obj is Ready_ {
      return obj.tag === ProfileDetails_Tags.Ready;
    }
  }

  type Error__interface = {
    tag: ProfileDetails_Tags.Error;
    inner: Readonly<{ message: string }>;
  };

  class Error_ extends UniffiEnum implements Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProfileDetails';
    readonly tag = ProfileDetails_Tags.Error;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('ProfileDetails', 'Error');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Error_ {
      return new Error_(inner);
    }

    static instanceOf(obj: any): obj is Error_ {
      return obj.tag === ProfileDetails_Tags.Error;
    }
  }

  function instanceOf(obj: any): obj is ProfileDetails {
    return obj[uniffiTypeNameSymbol] === 'ProfileDetails';
  }

  return Object.freeze({
    instanceOf,
    Unavailable: Unavailable_,
    Pending: Pending_,
    Ready: Ready_,
    Error: Error_,
  });
})();

export type ProfileDetails = InstanceType<
  (typeof ProfileDetails)[keyof Omit<typeof ProfileDetails, 'instanceOf'>]
>;

// FfiConverter for enum ProfileDetails
const FfiConverterTypeProfileDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ProfileDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ProfileDetails.Unavailable();
        case 2:
          return new ProfileDetails.Pending();
        case 3:
          return new ProfileDetails.Ready({
            displayName: FfiConverterOptionalString.read(from),
            displayNameAmbiguous: FfiConverterBool.read(from),
            avatarUrl: FfiConverterOptionalString.read(from),
          });
        case 4:
          return new ProfileDetails.Error({
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ProfileDetails_Tags.Unavailable: {
          ordinalConverter.write(1, into);
          return;
        }
        case ProfileDetails_Tags.Pending: {
          ordinalConverter.write(2, into);
          return;
        }
        case ProfileDetails_Tags.Ready: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.displayName, into);
          FfiConverterBool.write(inner.displayNameAmbiguous, into);
          FfiConverterOptionalString.write(inner.avatarUrl, into);
          return;
        }
        case ProfileDetails_Tags.Error: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that ProfileDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ProfileDetails_Tags.Unavailable: {
          return ordinalConverter.allocationSize(1);
        }
        case ProfileDetails_Tags.Pending: {
          return ordinalConverter.allocationSize(2);
        }
        case ProfileDetails_Tags.Ready: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterOptionalString.allocationSize(inner.displayName);
          size += FfiConverterBool.allocationSize(inner.displayNameAmbiguous);
          size += FfiConverterOptionalString.allocationSize(inner.avatarUrl);
          return size;
        }
        case ProfileDetails_Tags.Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum PublicRoomJoinRule {
  Public,
  Knock,
}

const FfiConverterTypePublicRoomJoinRule = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PublicRoomJoinRule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PublicRoomJoinRule.Public;
        case 2:
          return PublicRoomJoinRule.Knock;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PublicRoomJoinRule.Public:
          return ordinalConverter.write(1, into);
        case PublicRoomJoinRule.Knock:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: PushCondition
export enum PushCondition_Tags {
  EventMatch = 'EventMatch',
  ContainsDisplayName = 'ContainsDisplayName',
  RoomMemberCount = 'RoomMemberCount',
  SenderNotificationPermission = 'SenderNotificationPermission',
  EventPropertyIs = 'EventPropertyIs',
  EventPropertyContains = 'EventPropertyContains',
}
export const PushCondition = (() => {
  type EventMatch__interface = {
    tag: PushCondition_Tags.EventMatch;
    inner: Readonly<{ key: string; pattern: string }>;
  };

  /**
   * A glob pattern match on a field of the event.
   */
  class EventMatch_ extends UniffiEnum implements EventMatch__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PushCondition';
    readonly tag = PushCondition_Tags.EventMatch;
    readonly inner: Readonly<{ key: string; pattern: string }>;
    constructor(inner: {
      /**
       * The [dot-separated path] of the property of the event to match.
       *
       * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
       */ key: string;
      /**
       * The glob-style pattern to match against.
       *
       * Patterns with no special glob characters should be treated as having
       * asterisks prepended and appended when testing the condition.
       */ pattern: string;
    }) {
      super('PushCondition', 'EventMatch');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The [dot-separated path] of the property of the event to match.
       *
       * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
       */ key: string;
      /**
       * The glob-style pattern to match against.
       *
       * Patterns with no special glob characters should be treated as having
       * asterisks prepended and appended when testing the condition.
       */ pattern: string;
    }): EventMatch_ {
      return new EventMatch_(inner);
    }

    static instanceOf(obj: any): obj is EventMatch_ {
      return obj.tag === PushCondition_Tags.EventMatch;
    }
  }

  type ContainsDisplayName__interface = {
    tag: PushCondition_Tags.ContainsDisplayName;
  };

  /**
   * Matches unencrypted messages where `content.body` contains the owner's
   * display name in that room.
   */
  class ContainsDisplayName_
    extends UniffiEnum
    implements ContainsDisplayName__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PushCondition';
    readonly tag = PushCondition_Tags.ContainsDisplayName;
    constructor() {
      super('PushCondition', 'ContainsDisplayName');
    }

    static new(): ContainsDisplayName_ {
      return new ContainsDisplayName_();
    }

    static instanceOf(obj: any): obj is ContainsDisplayName_ {
      return obj.tag === PushCondition_Tags.ContainsDisplayName;
    }
  }

  type RoomMemberCount__interface = {
    tag: PushCondition_Tags.RoomMemberCount;
    inner: Readonly<{ prefix: ComparisonOperator; count: /*u64*/ bigint }>;
  };

  /**
   * Matches the current number of members in the room.
   */
  class RoomMemberCount_
    extends UniffiEnum
    implements RoomMemberCount__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PushCondition';
    readonly tag = PushCondition_Tags.RoomMemberCount;
    readonly inner: Readonly<{
      prefix: ComparisonOperator;
      count: /*u64*/ bigint;
    }>;
    constructor(inner: { prefix: ComparisonOperator; count: /*u64*/ bigint }) {
      super('PushCondition', 'RoomMemberCount');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      prefix: ComparisonOperator;
      count: /*u64*/ bigint;
    }): RoomMemberCount_ {
      return new RoomMemberCount_(inner);
    }

    static instanceOf(obj: any): obj is RoomMemberCount_ {
      return obj.tag === PushCondition_Tags.RoomMemberCount;
    }
  }

  type SenderNotificationPermission__interface = {
    tag: PushCondition_Tags.SenderNotificationPermission;
    inner: Readonly<{ key: string }>;
  };

  /**
   * Takes into account the current power levels in the room, ensuring the
   * sender of the event has high enough power to trigger the
   * notification.
   */
  class SenderNotificationPermission_
    extends UniffiEnum
    implements SenderNotificationPermission__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PushCondition';
    readonly tag = PushCondition_Tags.SenderNotificationPermission;
    readonly inner: Readonly<{ key: string }>;
    constructor(inner: {
      /**
       * The field in the power level event the user needs a minimum power
       * level for.
       *
       * Fields must be specified under the `notifications` property in the
       * power level event's `content`.
       */ key: string;
    }) {
      super('PushCondition', 'SenderNotificationPermission');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The field in the power level event the user needs a minimum power
       * level for.
       *
       * Fields must be specified under the `notifications` property in the
       * power level event's `content`.
       */ key: string;
    }): SenderNotificationPermission_ {
      return new SenderNotificationPermission_(inner);
    }

    static instanceOf(obj: any): obj is SenderNotificationPermission_ {
      return obj.tag === PushCondition_Tags.SenderNotificationPermission;
    }
  }

  type EventPropertyIs__interface = {
    tag: PushCondition_Tags.EventPropertyIs;
    inner: Readonly<{ key: string; value: JsonValue }>;
  };

  /**
   * Exact value match on a property of the event.
   */
  class EventPropertyIs_
    extends UniffiEnum
    implements EventPropertyIs__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PushCondition';
    readonly tag = PushCondition_Tags.EventPropertyIs;
    readonly inner: Readonly<{ key: string; value: JsonValue }>;
    constructor(inner: {
      /**
       * The [dot-separated path] of the property of the event to match.
       *
       * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
       */ key: string;
      /**
       * The value to match against.
       */ value: JsonValue;
    }) {
      super('PushCondition', 'EventPropertyIs');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The [dot-separated path] of the property of the event to match.
       *
       * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
       */ key: string;
      /**
       * The value to match against.
       */ value: JsonValue;
    }): EventPropertyIs_ {
      return new EventPropertyIs_(inner);
    }

    static instanceOf(obj: any): obj is EventPropertyIs_ {
      return obj.tag === PushCondition_Tags.EventPropertyIs;
    }
  }

  type EventPropertyContains__interface = {
    tag: PushCondition_Tags.EventPropertyContains;
    inner: Readonly<{ key: string; value: JsonValue }>;
  };

  /**
   * Exact value match on a value in an array property of the event.
   */
  class EventPropertyContains_
    extends UniffiEnum
    implements EventPropertyContains__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PushCondition';
    readonly tag = PushCondition_Tags.EventPropertyContains;
    readonly inner: Readonly<{ key: string; value: JsonValue }>;
    constructor(inner: {
      /**
       * The [dot-separated path] of the property of the event to match.
       *
       * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
       */ key: string;
      /**
       * The value to match against.
       */ value: JsonValue;
    }) {
      super('PushCondition', 'EventPropertyContains');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The [dot-separated path] of the property of the event to match.
       *
       * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
       */ key: string;
      /**
       * The value to match against.
       */ value: JsonValue;
    }): EventPropertyContains_ {
      return new EventPropertyContains_(inner);
    }

    static instanceOf(obj: any): obj is EventPropertyContains_ {
      return obj.tag === PushCondition_Tags.EventPropertyContains;
    }
  }

  function instanceOf(obj: any): obj is PushCondition {
    return obj[uniffiTypeNameSymbol] === 'PushCondition';
  }

  return Object.freeze({
    instanceOf,
    EventMatch: EventMatch_,
    ContainsDisplayName: ContainsDisplayName_,
    RoomMemberCount: RoomMemberCount_,
    SenderNotificationPermission: SenderNotificationPermission_,
    EventPropertyIs: EventPropertyIs_,
    EventPropertyContains: EventPropertyContains_,
  });
})();

export type PushCondition = InstanceType<
  (typeof PushCondition)[keyof Omit<typeof PushCondition, 'instanceOf'>]
>;

// FfiConverter for enum PushCondition
const FfiConverterTypePushCondition = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PushCondition;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PushCondition.EventMatch({
            key: FfiConverterString.read(from),
            pattern: FfiConverterString.read(from),
          });
        case 2:
          return new PushCondition.ContainsDisplayName();
        case 3:
          return new PushCondition.RoomMemberCount({
            prefix: FfiConverterTypeComparisonOperator.read(from),
            count: FfiConverterUInt64.read(from),
          });
        case 4:
          return new PushCondition.SenderNotificationPermission({
            key: FfiConverterString.read(from),
          });
        case 5:
          return new PushCondition.EventPropertyIs({
            key: FfiConverterString.read(from),
            value: FfiConverterTypeJsonValue.read(from),
          });
        case 6:
          return new PushCondition.EventPropertyContains({
            key: FfiConverterString.read(from),
            value: FfiConverterTypeJsonValue.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PushCondition_Tags.EventMatch: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.key, into);
          FfiConverterString.write(inner.pattern, into);
          return;
        }
        case PushCondition_Tags.ContainsDisplayName: {
          ordinalConverter.write(2, into);
          return;
        }
        case PushCondition_Tags.RoomMemberCount: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeComparisonOperator.write(inner.prefix, into);
          FfiConverterUInt64.write(inner.count, into);
          return;
        }
        case PushCondition_Tags.SenderNotificationPermission: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.key, into);
          return;
        }
        case PushCondition_Tags.EventPropertyIs: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.key, into);
          FfiConverterTypeJsonValue.write(inner.value, into);
          return;
        }
        case PushCondition_Tags.EventPropertyContains: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.key, into);
          FfiConverterTypeJsonValue.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that PushCondition_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PushCondition_Tags.EventMatch: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.key);
          size += FfiConverterString.allocationSize(inner.pattern);
          return size;
        }
        case PushCondition_Tags.ContainsDisplayName: {
          return ordinalConverter.allocationSize(2);
        }
        case PushCondition_Tags.RoomMemberCount: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeComparisonOperator.allocationSize(
            inner.prefix
          );
          size += FfiConverterUInt64.allocationSize(inner.count);
          return size;
        }
        case PushCondition_Tags.SenderNotificationPermission: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.key);
          return size;
        }
        case PushCondition_Tags.EventPropertyIs: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.key);
          size += FfiConverterTypeJsonValue.allocationSize(inner.value);
          return size;
        }
        case PushCondition_Tags.EventPropertyContains: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.key);
          size += FfiConverterTypeJsonValue.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum PushFormat {
  EventIdOnly,
}

const FfiConverterTypePushFormat = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PushFormat;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PushFormat.EventIdOnly;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PushFormat.EventIdOnly:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: PusherKind
export enum PusherKind_Tags {
  Http = 'Http',
  Email = 'Email',
}
export const PusherKind = (() => {
  type Http__interface = {
    tag: PusherKind_Tags.Http;
    inner: Readonly<{ data: HttpPusherData }>;
  };

  class Http_ extends UniffiEnum implements Http__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PusherKind';
    readonly tag = PusherKind_Tags.Http;
    readonly inner: Readonly<{ data: HttpPusherData }>;
    constructor(inner: { data: HttpPusherData }) {
      super('PusherKind', 'Http');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: HttpPusherData }): Http_ {
      return new Http_(inner);
    }

    static instanceOf(obj: any): obj is Http_ {
      return obj.tag === PusherKind_Tags.Http;
    }
  }

  type Email__interface = {
    tag: PusherKind_Tags.Email;
  };

  class Email_ extends UniffiEnum implements Email__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PusherKind';
    readonly tag = PusherKind_Tags.Email;
    constructor() {
      super('PusherKind', 'Email');
    }

    static new(): Email_ {
      return new Email_();
    }

    static instanceOf(obj: any): obj is Email_ {
      return obj.tag === PusherKind_Tags.Email;
    }
  }

  function instanceOf(obj: any): obj is PusherKind {
    return obj[uniffiTypeNameSymbol] === 'PusherKind';
  }

  return Object.freeze({
    instanceOf,
    Http: Http_,
    Email: Email_,
  });
})();

export type PusherKind = InstanceType<
  (typeof PusherKind)[keyof Omit<typeof PusherKind, 'instanceOf'>]
>;

// FfiConverter for enum PusherKind
const FfiConverterTypePusherKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PusherKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PusherKind.Http({
            data: FfiConverterTypeHttpPusherData.read(from),
          });
        case 2:
          return new PusherKind.Email();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PusherKind_Tags.Http: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeHttpPusherData.write(inner.data, into);
          return;
        }
        case PusherKind_Tags.Email: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that PusherKind_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PusherKind_Tags.Http: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeHttpPusherData.allocationSize(inner.data);
          return size;
        }
        case PusherKind_Tags.Email: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: QrCodeDecodeError
export enum QrCodeDecodeError_Tags {
  Crypto = 'Crypto',
}
/**
 * Error type for the decoding of the [`QrCodeData`].
 */
export const QrCodeDecodeError = (() => {
  class Crypto extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'QrCodeDecodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = QrCodeDecodeError_Tags.Crypto;

    constructor(message: string) {
      super('QrCodeDecodeError', 'Crypto', message);
    }

    static instanceOf(e: any): e is Crypto {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is QrCodeDecodeError {
    return (e as any)[uniffiTypeNameSymbol] === 'QrCodeDecodeError';
  }
  return {
    Crypto,
    instanceOf,
  };
})();

// Union type for QrCodeDecodeError error type.

/**
 * Error type for the decoding of the [`QrCodeData`].
 */

export type QrCodeDecodeError = InstanceType<
  (typeof QrCodeDecodeError)[keyof Omit<typeof QrCodeDecodeError, 'instanceOf'>]
>;

const FfiConverterTypeQrCodeDecodeError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = QrCodeDecodeError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new QrCodeDecodeError.Crypto(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: QrLoginProgress
export enum QrLoginProgress_Tags {
  Starting = 'Starting',
  EstablishingSecureChannel = 'EstablishingSecureChannel',
  WaitingForToken = 'WaitingForToken',
  Done = 'Done',
}
/**
 * Enum describing the progress of the QR-code login.
 */
export const QrLoginProgress = (() => {
  type Starting__interface = {
    tag: QrLoginProgress_Tags.Starting;
  };

  /**
   * The login process is starting.
   */
  class Starting_ extends UniffiEnum implements Starting__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QrLoginProgress';
    readonly tag = QrLoginProgress_Tags.Starting;
    constructor() {
      super('QrLoginProgress', 'Starting');
    }

    static new(): Starting_ {
      return new Starting_();
    }

    static instanceOf(obj: any): obj is Starting_ {
      return obj.tag === QrLoginProgress_Tags.Starting;
    }
  }

  type EstablishingSecureChannel__interface = {
    tag: QrLoginProgress_Tags.EstablishingSecureChannel;
    inner: Readonly<{ checkCode: /*u8*/ number; checkCodeString: string }>;
  };

  /**
   * We established a secure channel with the other device.
   */
  class EstablishingSecureChannel_
    extends UniffiEnum
    implements EstablishingSecureChannel__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QrLoginProgress';
    readonly tag = QrLoginProgress_Tags.EstablishingSecureChannel;
    readonly inner: Readonly<{
      checkCode: /*u8*/ number;
      checkCodeString: string;
    }>;
    constructor(inner: {
      /**
       * The check code that the device should display so the other device
       * can confirm that the channel is secure as well.
       */ checkCode: /*u8*/ number;
      /**
       * The string representation of the check code, will be guaranteed to
       * be 2 characters long, preserving the leading zero if the
       * first digit is a zero.
       */ checkCodeString: string;
    }) {
      super('QrLoginProgress', 'EstablishingSecureChannel');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The check code that the device should display so the other device
       * can confirm that the channel is secure as well.
       */ checkCode: /*u8*/ number;
      /**
       * The string representation of the check code, will be guaranteed to
       * be 2 characters long, preserving the leading zero if the
       * first digit is a zero.
       */ checkCodeString: string;
    }): EstablishingSecureChannel_ {
      return new EstablishingSecureChannel_(inner);
    }

    static instanceOf(obj: any): obj is EstablishingSecureChannel_ {
      return obj.tag === QrLoginProgress_Tags.EstablishingSecureChannel;
    }
  }

  type WaitingForToken__interface = {
    tag: QrLoginProgress_Tags.WaitingForToken;
    inner: Readonly<{ userCode: string }>;
  };

  /**
   * We are waiting for the login and for the OAuth 2.0 authorization server
   * to give us an access token.
   */
  class WaitingForToken_
    extends UniffiEnum
    implements WaitingForToken__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QrLoginProgress';
    readonly tag = QrLoginProgress_Tags.WaitingForToken;
    readonly inner: Readonly<{ userCode: string }>;
    constructor(inner: { userCode: string }) {
      super('QrLoginProgress', 'WaitingForToken');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { userCode: string }): WaitingForToken_ {
      return new WaitingForToken_(inner);
    }

    static instanceOf(obj: any): obj is WaitingForToken_ {
      return obj.tag === QrLoginProgress_Tags.WaitingForToken;
    }
  }

  type Done__interface = {
    tag: QrLoginProgress_Tags.Done;
  };

  /**
   * The login has successfully finished.
   */
  class Done_ extends UniffiEnum implements Done__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QrLoginProgress';
    readonly tag = QrLoginProgress_Tags.Done;
    constructor() {
      super('QrLoginProgress', 'Done');
    }

    static new(): Done_ {
      return new Done_();
    }

    static instanceOf(obj: any): obj is Done_ {
      return obj.tag === QrLoginProgress_Tags.Done;
    }
  }

  function instanceOf(obj: any): obj is QrLoginProgress {
    return obj[uniffiTypeNameSymbol] === 'QrLoginProgress';
  }

  return Object.freeze({
    instanceOf,
    Starting: Starting_,
    EstablishingSecureChannel: EstablishingSecureChannel_,
    WaitingForToken: WaitingForToken_,
    Done: Done_,
  });
})();

/**
 * Enum describing the progress of the QR-code login.
 */

export type QrLoginProgress = InstanceType<
  (typeof QrLoginProgress)[keyof Omit<typeof QrLoginProgress, 'instanceOf'>]
>;

// FfiConverter for enum QrLoginProgress
const FfiConverterTypeQrLoginProgress = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = QrLoginProgress;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new QrLoginProgress.Starting();
        case 2:
          return new QrLoginProgress.EstablishingSecureChannel({
            checkCode: FfiConverterUInt8.read(from),
            checkCodeString: FfiConverterString.read(from),
          });
        case 3:
          return new QrLoginProgress.WaitingForToken({
            userCode: FfiConverterString.read(from),
          });
        case 4:
          return new QrLoginProgress.Done();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case QrLoginProgress_Tags.Starting: {
          ordinalConverter.write(1, into);
          return;
        }
        case QrLoginProgress_Tags.EstablishingSecureChannel: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt8.write(inner.checkCode, into);
          FfiConverterString.write(inner.checkCodeString, into);
          return;
        }
        case QrLoginProgress_Tags.WaitingForToken: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.userCode, into);
          return;
        }
        case QrLoginProgress_Tags.Done: {
          ordinalConverter.write(4, into);
          return;
        }
        default:
          // Throwing from here means that QrLoginProgress_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case QrLoginProgress_Tags.Starting: {
          return ordinalConverter.allocationSize(1);
        }
        case QrLoginProgress_Tags.EstablishingSecureChannel: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt8.allocationSize(inner.checkCode);
          size += FfiConverterString.allocationSize(inner.checkCodeString);
          return size;
        }
        case QrLoginProgress_Tags.WaitingForToken: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.userCode);
          return size;
        }
        case QrLoginProgress_Tags.Done: {
          return ordinalConverter.allocationSize(4);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: QueueWedgeError
export enum QueueWedgeError_Tags {
  InsecureDevices = 'InsecureDevices',
  IdentityViolations = 'IdentityViolations',
  CrossVerificationRequired = 'CrossVerificationRequired',
  MissingMediaContent = 'MissingMediaContent',
  InvalidMimeType = 'InvalidMimeType',
  GenericApiError = 'GenericApiError',
}
/**
 * Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
 * String.
 *
 * Represent a failed to send unrecoverable error of an event sent via the
 * send_queue. It is a serializable representation of a client error, see
 * `From` implementation for more details. These errors can not be
 * automatically retried, but yet some manual action can be taken before retry
 * sending. If not the only solution is to delete the local event.
 */
export const QueueWedgeError = (() => {
  type InsecureDevices__interface = {
    tag: QueueWedgeError_Tags.InsecureDevices;
    inner: Readonly<{ userDeviceMap: Map<string, Array<string>> }>;
  };

  /**
   * This error occurs when there are some insecure devices in the room, and
   * the current encryption setting prohibit sharing with them.
   */
  class InsecureDevices_
    extends UniffiEnum
    implements InsecureDevices__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.InsecureDevices;
    readonly inner: Readonly<{ userDeviceMap: Map<string, Array<string>> }>;
    constructor(inner: {
      /**
       * The insecure devices as a Map of userID to deviceID.
       */ userDeviceMap: Map<string, Array<string>>;
    }) {
      super('QueueWedgeError', 'InsecureDevices');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The insecure devices as a Map of userID to deviceID.
       */ userDeviceMap: Map<string, Array<string>>;
    }): InsecureDevices_ {
      return new InsecureDevices_(inner);
    }

    static instanceOf(obj: any): obj is InsecureDevices_ {
      return obj.tag === QueueWedgeError_Tags.InsecureDevices;
    }
  }

  type IdentityViolations__interface = {
    tag: QueueWedgeError_Tags.IdentityViolations;
    inner: Readonly<{ users: Array<string> }>;
  };

  /**
   * This error occurs when a previously verified user is not anymore, and
   * the current encryption setting prohibit sharing when it happens.
   */
  class IdentityViolations_
    extends UniffiEnum
    implements IdentityViolations__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.IdentityViolations;
    readonly inner: Readonly<{ users: Array<string> }>;
    constructor(inner: {
      /**
       * The users that are expected to be verified but are not.
       */ users: Array<string>;
    }) {
      super('QueueWedgeError', 'IdentityViolations');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The users that are expected to be verified but are not.
       */ users: Array<string>;
    }): IdentityViolations_ {
      return new IdentityViolations_(inner);
    }

    static instanceOf(obj: any): obj is IdentityViolations_ {
      return obj.tag === QueueWedgeError_Tags.IdentityViolations;
    }
  }

  type CrossVerificationRequired__interface = {
    tag: QueueWedgeError_Tags.CrossVerificationRequired;
  };

  /**
   * It is required to set up cross-signing and properly erify the current
   * session before sending.
   */
  class CrossVerificationRequired_
    extends UniffiEnum
    implements CrossVerificationRequired__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.CrossVerificationRequired;
    constructor() {
      super('QueueWedgeError', 'CrossVerificationRequired');
    }

    static new(): CrossVerificationRequired_ {
      return new CrossVerificationRequired_();
    }

    static instanceOf(obj: any): obj is CrossVerificationRequired_ {
      return obj.tag === QueueWedgeError_Tags.CrossVerificationRequired;
    }
  }

  type MissingMediaContent__interface = {
    tag: QueueWedgeError_Tags.MissingMediaContent;
  };

  /**
   * Some media content to be sent has disappeared from the cache.
   */
  class MissingMediaContent_
    extends UniffiEnum
    implements MissingMediaContent__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.MissingMediaContent;
    constructor() {
      super('QueueWedgeError', 'MissingMediaContent');
    }

    static new(): MissingMediaContent_ {
      return new MissingMediaContent_();
    }

    static instanceOf(obj: any): obj is MissingMediaContent_ {
      return obj.tag === QueueWedgeError_Tags.MissingMediaContent;
    }
  }

  type InvalidMimeType__interface = {
    tag: QueueWedgeError_Tags.InvalidMimeType;
    inner: Readonly<{ mimeType: string }>;
  };

  /**
   * Some mime type couldn't be parsed.
   */
  class InvalidMimeType_
    extends UniffiEnum
    implements InvalidMimeType__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.InvalidMimeType;
    readonly inner: Readonly<{ mimeType: string }>;
    constructor(inner: { mimeType: string }) {
      super('QueueWedgeError', 'InvalidMimeType');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { mimeType: string }): InvalidMimeType_ {
      return new InvalidMimeType_(inner);
    }

    static instanceOf(obj: any): obj is InvalidMimeType_ {
      return obj.tag === QueueWedgeError_Tags.InvalidMimeType;
    }
  }

  type GenericApiError__interface = {
    tag: QueueWedgeError_Tags.GenericApiError;
    inner: Readonly<{ msg: string }>;
  };

  /**
   * Other errors.
   */
  class GenericApiError_
    extends UniffiEnum
    implements GenericApiError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'QueueWedgeError';
    readonly tag = QueueWedgeError_Tags.GenericApiError;
    readonly inner: Readonly<{ msg: string }>;
    constructor(inner: { msg: string }) {
      super('QueueWedgeError', 'GenericApiError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string }): GenericApiError_ {
      return new GenericApiError_(inner);
    }

    static instanceOf(obj: any): obj is GenericApiError_ {
      return obj.tag === QueueWedgeError_Tags.GenericApiError;
    }
  }

  function instanceOf(obj: any): obj is QueueWedgeError {
    return obj[uniffiTypeNameSymbol] === 'QueueWedgeError';
  }

  return Object.freeze({
    instanceOf,
    InsecureDevices: InsecureDevices_,
    IdentityViolations: IdentityViolations_,
    CrossVerificationRequired: CrossVerificationRequired_,
    MissingMediaContent: MissingMediaContent_,
    InvalidMimeType: InvalidMimeType_,
    GenericApiError: GenericApiError_,
  });
})();

/**
 * Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
 * String.
 *
 * Represent a failed to send unrecoverable error of an event sent via the
 * send_queue. It is a serializable representation of a client error, see
 * `From` implementation for more details. These errors can not be
 * automatically retried, but yet some manual action can be taken before retry
 * sending. If not the only solution is to delete the local event.
 */

export type QueueWedgeError = InstanceType<
  (typeof QueueWedgeError)[keyof Omit<typeof QueueWedgeError, 'instanceOf'>]
>;

// FfiConverter for enum QueueWedgeError
const FfiConverterTypeQueueWedgeError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = QueueWedgeError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new QueueWedgeError.InsecureDevices({
            userDeviceMap: FfiConverterMapStringArrayString.read(from),
          });
        case 2:
          return new QueueWedgeError.IdentityViolations({
            users: FfiConverterArrayString.read(from),
          });
        case 3:
          return new QueueWedgeError.CrossVerificationRequired();
        case 4:
          return new QueueWedgeError.MissingMediaContent();
        case 5:
          return new QueueWedgeError.InvalidMimeType({
            mimeType: FfiConverterString.read(from),
          });
        case 6:
          return new QueueWedgeError.GenericApiError({
            msg: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case QueueWedgeError_Tags.InsecureDevices: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterMapStringArrayString.write(inner.userDeviceMap, into);
          return;
        }
        case QueueWedgeError_Tags.IdentityViolations: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayString.write(inner.users, into);
          return;
        }
        case QueueWedgeError_Tags.CrossVerificationRequired: {
          ordinalConverter.write(3, into);
          return;
        }
        case QueueWedgeError_Tags.MissingMediaContent: {
          ordinalConverter.write(4, into);
          return;
        }
        case QueueWedgeError_Tags.InvalidMimeType: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.mimeType, into);
          return;
        }
        case QueueWedgeError_Tags.GenericApiError: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msg, into);
          return;
        }
        default:
          // Throwing from here means that QueueWedgeError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case QueueWedgeError_Tags.InsecureDevices: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterMapStringArrayString.allocationSize(
            inner.userDeviceMap
          );
          return size;
        }
        case QueueWedgeError_Tags.IdentityViolations: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayString.allocationSize(inner.users);
          return size;
        }
        case QueueWedgeError_Tags.CrossVerificationRequired: {
          return ordinalConverter.allocationSize(3);
        }
        case QueueWedgeError_Tags.MissingMediaContent: {
          return ordinalConverter.allocationSize(4);
        }
        case QueueWedgeError_Tags.InvalidMimeType: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.mimeType);
          return size;
        }
        case QueueWedgeError_Tags.GenericApiError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.msg);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */
export enum ReceiptType {
  Read,
  ReadPrivate,
  FullyRead,
}

const FfiConverterTypeReceiptType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ReceiptType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ReceiptType.Read;
        case 2:
          return ReceiptType.ReadPrivate;
        case 3:
          return ReceiptType.FullyRead;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ReceiptType.Read:
          return ordinalConverter.write(1, into);
        case ReceiptType.ReadPrivate:
          return ordinalConverter.write(2, into);
        case ReceiptType.FullyRead:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: RecoveryError

// Enum: RecoveryError
export enum RecoveryError_Tags {
  BackupExistsOnServer = 'BackupExistsOnServer',
  Client = 'Client',
  SecretStorage = 'SecretStorage',
}
export const RecoveryError = (() => {
  type BackupExistsOnServer__interface = {
    tag: RecoveryError_Tags.BackupExistsOnServer;
  };

  /**
   * A backup already exists on the homeserver, the recovery subsystem does
   * not allow backups to be overwritten, disable recovery first.
   */
  class BackupExistsOnServer_
    extends UniffiError
    implements BackupExistsOnServer__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RecoveryError';
    readonly tag = RecoveryError_Tags.BackupExistsOnServer;
    constructor() {
      super('RecoveryError', 'BackupExistsOnServer');
    }

    static new(): BackupExistsOnServer_ {
      return new BackupExistsOnServer_();
    }

    static instanceOf(obj: any): obj is BackupExistsOnServer_ {
      return obj.tag === RecoveryError_Tags.BackupExistsOnServer;
    }

    static hasInner(obj: any): obj is BackupExistsOnServer_ {
      return false;
    }
  }

  type Client__interface = {
    tag: RecoveryError_Tags.Client;
    inner: Readonly<{ source: ClientError }>;
  };

  /**
   * A typical SDK error.
   */
  class Client_ extends UniffiError implements Client__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RecoveryError';
    readonly tag = RecoveryError_Tags.Client;
    readonly inner: Readonly<{ source: ClientError }>;
    constructor(inner: { source: ClientError }) {
      super('RecoveryError', 'Client');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { source: ClientError }): Client_ {
      return new Client_(inner);
    }

    static instanceOf(obj: any): obj is Client_ {
      return obj.tag === RecoveryError_Tags.Client;
    }

    static hasInner(obj: any): obj is Client_ {
      return Client_.instanceOf(obj);
    }

    static getInner(obj: Client_): Readonly<{ source: ClientError }> {
      return obj.inner;
    }
  }

  type SecretStorage__interface = {
    tag: RecoveryError_Tags.SecretStorage;
    inner: Readonly<{ errorMessage: string }>;
  };

  /**
   * Error in the secret storage subsystem.
   */
  class SecretStorage_ extends UniffiError implements SecretStorage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RecoveryError';
    readonly tag = RecoveryError_Tags.SecretStorage;
    readonly inner: Readonly<{ errorMessage: string }>;
    constructor(inner: { errorMessage: string }) {
      super('RecoveryError', 'SecretStorage');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { errorMessage: string }): SecretStorage_ {
      return new SecretStorage_(inner);
    }

    static instanceOf(obj: any): obj is SecretStorage_ {
      return obj.tag === RecoveryError_Tags.SecretStorage;
    }

    static hasInner(obj: any): obj is SecretStorage_ {
      return SecretStorage_.instanceOf(obj);
    }

    static getInner(obj: SecretStorage_): Readonly<{ errorMessage: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is RecoveryError {
    return obj[uniffiTypeNameSymbol] === 'RecoveryError';
  }

  return Object.freeze({
    instanceOf,
    BackupExistsOnServer: BackupExistsOnServer_,
    Client: Client_,
    SecretStorage: SecretStorage_,
  });
})();

export type RecoveryError = InstanceType<
  (typeof RecoveryError)[keyof Omit<typeof RecoveryError, 'instanceOf'>]
>;

// FfiConverter for enum RecoveryError
const FfiConverterTypeRecoveryError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RecoveryError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RecoveryError.BackupExistsOnServer();
        case 2:
          return new RecoveryError.Client({
            source: FfiConverterTypeClientError.read(from),
          });
        case 3:
          return new RecoveryError.SecretStorage({
            errorMessage: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RecoveryError_Tags.BackupExistsOnServer: {
          ordinalConverter.write(1, into);
          return;
        }
        case RecoveryError_Tags.Client: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeClientError.write(inner.source, into);
          return;
        }
        case RecoveryError_Tags.SecretStorage: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.errorMessage, into);
          return;
        }
        default:
          // Throwing from here means that RecoveryError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RecoveryError_Tags.BackupExistsOnServer: {
          return ordinalConverter.allocationSize(1);
        }
        case RecoveryError_Tags.Client: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeClientError.allocationSize(inner.source);
          return size;
        }
        case RecoveryError_Tags.SecretStorage: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.errorMessage);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RecoveryState {
  Unknown,
  Enabled,
  Disabled,
  Incomplete,
}

const FfiConverterTypeRecoveryState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RecoveryState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RecoveryState.Unknown;
        case 2:
          return RecoveryState.Enabled;
        case 3:
          return RecoveryState.Disabled;
        case 4:
          return RecoveryState.Incomplete;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RecoveryState.Unknown:
          return ordinalConverter.write(1, into);
        case RecoveryState.Enabled:
          return ordinalConverter.write(2, into);
        case RecoveryState.Disabled:
          return ordinalConverter.write(3, into);
        case RecoveryState.Incomplete:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomAccountDataEvent
export enum RoomAccountDataEvent_Tags {
  FullyReadEvent = 'FullyReadEvent',
  MarkedUnread = 'MarkedUnread',
  Tag = 'Tag',
  UnstableMarkedUnread = 'UnstableMarkedUnread',
}
/**
 * Room account data events.
 */
export const RoomAccountDataEvent = (() => {
  type FullyReadEvent__interface = {
    tag: RoomAccountDataEvent_Tags.FullyReadEvent;
    inner: Readonly<{ eventId: string }>;
  };

  /**
   * m.fully_read
   */
  class FullyReadEvent_
    extends UniffiEnum
    implements FullyReadEvent__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomAccountDataEvent';
    readonly tag = RoomAccountDataEvent_Tags.FullyReadEvent;
    readonly inner: Readonly<{ eventId: string }>;
    constructor(inner: {
      /**
       * The event the user's read marker is located at in the room.
       */ eventId: string;
    }) {
      super('RoomAccountDataEvent', 'FullyReadEvent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The event the user's read marker is located at in the room.
       */ eventId: string;
    }): FullyReadEvent_ {
      return new FullyReadEvent_(inner);
    }

    static instanceOf(obj: any): obj is FullyReadEvent_ {
      return obj.tag === RoomAccountDataEvent_Tags.FullyReadEvent;
    }
  }

  type MarkedUnread__interface = {
    tag: RoomAccountDataEvent_Tags.MarkedUnread;
    inner: Readonly<{ unread: boolean }>;
  };

  /**
   * m.marked_unread
   */
  class MarkedUnread_ extends UniffiEnum implements MarkedUnread__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomAccountDataEvent';
    readonly tag = RoomAccountDataEvent_Tags.MarkedUnread;
    readonly inner: Readonly<{ unread: boolean }>;
    constructor(inner: {
      /**
       * The current unread state.
       */ unread: boolean;
    }) {
      super('RoomAccountDataEvent', 'MarkedUnread');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The current unread state.
       */ unread: boolean;
    }): MarkedUnread_ {
      return new MarkedUnread_(inner);
    }

    static instanceOf(obj: any): obj is MarkedUnread_ {
      return obj.tag === RoomAccountDataEvent_Tags.MarkedUnread;
    }
  }

  type Tag__interface = {
    tag: RoomAccountDataEvent_Tags.Tag;
    inner: Readonly<{ tags: Map<TagName, TagInfo> }>;
  };

  /**
   * m.tag
   */
  class Tag_ extends UniffiEnum implements Tag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomAccountDataEvent';
    readonly tag = RoomAccountDataEvent_Tags.Tag;
    readonly inner: Readonly<{ tags: Map<TagName, TagInfo> }>;
    constructor(inner: { tags: Map<TagName, TagInfo> }) {
      super('RoomAccountDataEvent', 'Tag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { tags: Map<TagName, TagInfo> }): Tag_ {
      return new Tag_(inner);
    }

    static instanceOf(obj: any): obj is Tag_ {
      return obj.tag === RoomAccountDataEvent_Tags.Tag;
    }
  }

  type UnstableMarkedUnread__interface = {
    tag: RoomAccountDataEvent_Tags.UnstableMarkedUnread;
    inner: Readonly<{ unread: boolean }>;
  };

  /**
   * com.famedly.marked_unread
   */
  class UnstableMarkedUnread_
    extends UniffiEnum
    implements UnstableMarkedUnread__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomAccountDataEvent';
    readonly tag = RoomAccountDataEvent_Tags.UnstableMarkedUnread;
    readonly inner: Readonly<{ unread: boolean }>;
    constructor(inner: {
      /**
       * The current unread state.
       */ unread: boolean;
    }) {
      super('RoomAccountDataEvent', 'UnstableMarkedUnread');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The current unread state.
       */ unread: boolean;
    }): UnstableMarkedUnread_ {
      return new UnstableMarkedUnread_(inner);
    }

    static instanceOf(obj: any): obj is UnstableMarkedUnread_ {
      return obj.tag === RoomAccountDataEvent_Tags.UnstableMarkedUnread;
    }
  }

  function instanceOf(obj: any): obj is RoomAccountDataEvent {
    return obj[uniffiTypeNameSymbol] === 'RoomAccountDataEvent';
  }

  return Object.freeze({
    instanceOf,
    FullyReadEvent: FullyReadEvent_,
    MarkedUnread: MarkedUnread_,
    Tag: Tag_,
    UnstableMarkedUnread: UnstableMarkedUnread_,
  });
})();

/**
 * Room account data events.
 */

export type RoomAccountDataEvent = InstanceType<
  (typeof RoomAccountDataEvent)[keyof Omit<
    typeof RoomAccountDataEvent,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomAccountDataEvent
const FfiConverterTypeRoomAccountDataEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomAccountDataEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomAccountDataEvent.FullyReadEvent({
            eventId: FfiConverterString.read(from),
          });
        case 2:
          return new RoomAccountDataEvent.MarkedUnread({
            unread: FfiConverterBool.read(from),
          });
        case 3:
          return new RoomAccountDataEvent.Tag({
            tags: FfiConverterMapTypeTagNameTypeTagInfo.read(from),
          });
        case 4:
          return new RoomAccountDataEvent.UnstableMarkedUnread({
            unread: FfiConverterBool.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomAccountDataEvent_Tags.FullyReadEvent: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          return;
        }
        case RoomAccountDataEvent_Tags.MarkedUnread: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.unread, into);
          return;
        }
        case RoomAccountDataEvent_Tags.Tag: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterMapTypeTagNameTypeTagInfo.write(inner.tags, into);
          return;
        }
        case RoomAccountDataEvent_Tags.UnstableMarkedUnread: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.unread, into);
          return;
        }
        default:
          // Throwing from here means that RoomAccountDataEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomAccountDataEvent_Tags.FullyReadEvent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.eventId);
          return size;
        }
        case RoomAccountDataEvent_Tags.MarkedUnread: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterBool.allocationSize(inner.unread);
          return size;
        }
        case RoomAccountDataEvent_Tags.Tag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterMapTypeTagNameTypeTagInfo.allocationSize(
            inner.tags
          );
          return size;
        }
        case RoomAccountDataEvent_Tags.UnstableMarkedUnread: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterBool.allocationSize(inner.unread);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Types of room account data events.
 */
export enum RoomAccountDataEventType {
  /**
   * m.fully_read
   */
  FullyRead,
  /**
   * m.marked_unread
   */
  MarkedUnread,
  /**
   * m.tag
   */
  Tag,
  /**
   * com.famedly.marked_unread
   */
  UnstableMarkedUnread,
}

const FfiConverterTypeRoomAccountDataEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomAccountDataEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomAccountDataEventType.FullyRead;
        case 2:
          return RoomAccountDataEventType.MarkedUnread;
        case 3:
          return RoomAccountDataEventType.Tag;
        case 4:
          return RoomAccountDataEventType.UnstableMarkedUnread;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomAccountDataEventType.FullyRead:
          return ordinalConverter.write(1, into);
        case RoomAccountDataEventType.MarkedUnread:
          return ordinalConverter.write(2, into);
        case RoomAccountDataEventType.Tag:
          return ordinalConverter.write(3, into);
        case RoomAccountDataEventType.UnstableMarkedUnread:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomDirectorySearchEntryUpdate
export enum RoomDirectorySearchEntryUpdate_Tags {
  Append = 'Append',
  Clear = 'Clear',
  PushFront = 'PushFront',
  PushBack = 'PushBack',
  PopFront = 'PopFront',
  PopBack = 'PopBack',
  Insert = 'Insert',
  Set = 'Set',
  Remove = 'Remove',
  Truncate = 'Truncate',
  Reset = 'Reset',
}
export const RoomDirectorySearchEntryUpdate = (() => {
  type Append__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Append;
    inner: Readonly<{ values: Array<RoomDescription> }>;
  };

  class Append_ extends UniffiEnum implements Append__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Append;
    readonly inner: Readonly<{ values: Array<RoomDescription> }>;
    constructor(inner: { values: Array<RoomDescription> }) {
      super('RoomDirectorySearchEntryUpdate', 'Append');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array<RoomDescription> }): Append_ {
      return new Append_(inner);
    }

    static instanceOf(obj: any): obj is Append_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Append;
    }
  }

  type Clear__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Clear;
  };

  class Clear_ extends UniffiEnum implements Clear__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Clear;
    constructor() {
      super('RoomDirectorySearchEntryUpdate', 'Clear');
    }

    static new(): Clear_ {
      return new Clear_();
    }

    static instanceOf(obj: any): obj is Clear_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Clear;
    }
  }

  type PushFront__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.PushFront;
    inner: Readonly<{ value: RoomDescription }>;
  };

  class PushFront_ extends UniffiEnum implements PushFront__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.PushFront;
    readonly inner: Readonly<{ value: RoomDescription }>;
    constructor(inner: { value: RoomDescription }) {
      super('RoomDirectorySearchEntryUpdate', 'PushFront');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: RoomDescription }): PushFront_ {
      return new PushFront_(inner);
    }

    static instanceOf(obj: any): obj is PushFront_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PushFront;
    }
  }

  type PushBack__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.PushBack;
    inner: Readonly<{ value: RoomDescription }>;
  };

  class PushBack_ extends UniffiEnum implements PushBack__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.PushBack;
    readonly inner: Readonly<{ value: RoomDescription }>;
    constructor(inner: { value: RoomDescription }) {
      super('RoomDirectorySearchEntryUpdate', 'PushBack');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: RoomDescription }): PushBack_ {
      return new PushBack_(inner);
    }

    static instanceOf(obj: any): obj is PushBack_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PushBack;
    }
  }

  type PopFront__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.PopFront;
  };

  class PopFront_ extends UniffiEnum implements PopFront__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.PopFront;
    constructor() {
      super('RoomDirectorySearchEntryUpdate', 'PopFront');
    }

    static new(): PopFront_ {
      return new PopFront_();
    }

    static instanceOf(obj: any): obj is PopFront_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PopFront;
    }
  }

  type PopBack__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.PopBack;
  };

  class PopBack_ extends UniffiEnum implements PopBack__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.PopBack;
    constructor() {
      super('RoomDirectorySearchEntryUpdate', 'PopBack');
    }

    static new(): PopBack_ {
      return new PopBack_();
    }

    static instanceOf(obj: any): obj is PopBack_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PopBack;
    }
  }

  type Insert__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Insert;
    inner: Readonly<{ index: /*u32*/ number; value: RoomDescription }>;
  };

  class Insert_ extends UniffiEnum implements Insert__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Insert;
    readonly inner: Readonly<{ index: /*u32*/ number; value: RoomDescription }>;
    constructor(inner: { index: /*u32*/ number; value: RoomDescription }) {
      super('RoomDirectorySearchEntryUpdate', 'Insert');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      index: /*u32*/ number;
      value: RoomDescription;
    }): Insert_ {
      return new Insert_(inner);
    }

    static instanceOf(obj: any): obj is Insert_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Insert;
    }
  }

  type Set__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Set;
    inner: Readonly<{ index: /*u32*/ number; value: RoomDescription }>;
  };

  class Set_ extends UniffiEnum implements Set__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Set;
    readonly inner: Readonly<{ index: /*u32*/ number; value: RoomDescription }>;
    constructor(inner: { index: /*u32*/ number; value: RoomDescription }) {
      super('RoomDirectorySearchEntryUpdate', 'Set');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { index: /*u32*/ number; value: RoomDescription }): Set_ {
      return new Set_(inner);
    }

    static instanceOf(obj: any): obj is Set_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Set;
    }
  }

  type Remove__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Remove;
    inner: Readonly<{ index: /*u32*/ number }>;
  };

  class Remove_ extends UniffiEnum implements Remove__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Remove;
    readonly inner: Readonly<{ index: /*u32*/ number }>;
    constructor(inner: { index: /*u32*/ number }) {
      super('RoomDirectorySearchEntryUpdate', 'Remove');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { index: /*u32*/ number }): Remove_ {
      return new Remove_(inner);
    }

    static instanceOf(obj: any): obj is Remove_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Remove;
    }
  }

  type Truncate__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Truncate;
    inner: Readonly<{ length: /*u32*/ number }>;
  };

  class Truncate_ extends UniffiEnum implements Truncate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Truncate;
    readonly inner: Readonly<{ length: /*u32*/ number }>;
    constructor(inner: { length: /*u32*/ number }) {
      super('RoomDirectorySearchEntryUpdate', 'Truncate');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { length: /*u32*/ number }): Truncate_ {
      return new Truncate_(inner);
    }

    static instanceOf(obj: any): obj is Truncate_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Truncate;
    }
  }

  type Reset__interface = {
    tag: RoomDirectorySearchEntryUpdate_Tags.Reset;
    inner: Readonly<{ values: Array<RoomDescription> }>;
  };

  class Reset_ extends UniffiEnum implements Reset__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearchEntryUpdate';
    readonly tag = RoomDirectorySearchEntryUpdate_Tags.Reset;
    readonly inner: Readonly<{ values: Array<RoomDescription> }>;
    constructor(inner: { values: Array<RoomDescription> }) {
      super('RoomDirectorySearchEntryUpdate', 'Reset');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array<RoomDescription> }): Reset_ {
      return new Reset_(inner);
    }

    static instanceOf(obj: any): obj is Reset_ {
      return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Reset;
    }
  }

  function instanceOf(obj: any): obj is RoomDirectorySearchEntryUpdate {
    return obj[uniffiTypeNameSymbol] === 'RoomDirectorySearchEntryUpdate';
  }

  return Object.freeze({
    instanceOf,
    Append: Append_,
    Clear: Clear_,
    PushFront: PushFront_,
    PushBack: PushBack_,
    PopFront: PopFront_,
    PopBack: PopBack_,
    Insert: Insert_,
    Set: Set_,
    Remove: Remove_,
    Truncate: Truncate_,
    Reset: Reset_,
  });
})();

export type RoomDirectorySearchEntryUpdate = InstanceType<
  (typeof RoomDirectorySearchEntryUpdate)[keyof Omit<
    typeof RoomDirectorySearchEntryUpdate,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomDirectorySearchEntryUpdate
const FfiConverterTypeRoomDirectorySearchEntryUpdate = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomDirectorySearchEntryUpdate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomDirectorySearchEntryUpdate.Append({
            values: FfiConverterArrayTypeRoomDescription.read(from),
          });
        case 2:
          return new RoomDirectorySearchEntryUpdate.Clear();
        case 3:
          return new RoomDirectorySearchEntryUpdate.PushFront({
            value: FfiConverterTypeRoomDescription.read(from),
          });
        case 4:
          return new RoomDirectorySearchEntryUpdate.PushBack({
            value: FfiConverterTypeRoomDescription.read(from),
          });
        case 5:
          return new RoomDirectorySearchEntryUpdate.PopFront();
        case 6:
          return new RoomDirectorySearchEntryUpdate.PopBack();
        case 7:
          return new RoomDirectorySearchEntryUpdate.Insert({
            index: FfiConverterUInt32.read(from),
            value: FfiConverterTypeRoomDescription.read(from),
          });
        case 8:
          return new RoomDirectorySearchEntryUpdate.Set({
            index: FfiConverterUInt32.read(from),
            value: FfiConverterTypeRoomDescription.read(from),
          });
        case 9:
          return new RoomDirectorySearchEntryUpdate.Remove({
            index: FfiConverterUInt32.read(from),
          });
        case 10:
          return new RoomDirectorySearchEntryUpdate.Truncate({
            length: FfiConverterUInt32.read(from),
          });
        case 11:
          return new RoomDirectorySearchEntryUpdate.Reset({
            values: FfiConverterArrayTypeRoomDescription.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomDirectorySearchEntryUpdate_Tags.Append: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomDescription.write(inner.values, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Clear: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PushFront: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PushBack: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PopFront: {
          ordinalConverter.write(5, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PopBack: {
          ordinalConverter.write(6, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Insert: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Set: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoomDescription.write(inner.value, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Remove: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Truncate: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.length, into);
          return;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Reset: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomDescription.write(inner.values, into);
          return;
        }
        default:
          // Throwing from here means that RoomDirectorySearchEntryUpdate_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomDirectorySearchEntryUpdate_Tags.Append: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeRoomDescription.allocationSize(
            inner.values
          );
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Clear: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomDirectorySearchEntryUpdate_Tags.PushFront: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PushBack: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.PopFront: {
          return ordinalConverter.allocationSize(5);
        }
        case RoomDirectorySearchEntryUpdate_Tags.PopBack: {
          return ordinalConverter.allocationSize(6);
        }
        case RoomDirectorySearchEntryUpdate_Tags.Insert: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Set: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Remove: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterUInt32.allocationSize(inner.index);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Truncate: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterUInt32.allocationSize(inner.length);
          return size;
        }
        case RoomDirectorySearchEntryUpdate_Tags.Reset: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterArrayTypeRoomDescription.allocationSize(
            inner.values
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: RoomError
export enum RoomError_Tags {
  InvalidAttachmentData = 'InvalidAttachmentData',
  InvalidAttachmentMimeType = 'InvalidAttachmentMimeType',
  InvalidMediaInfo = 'InvalidMediaInfo',
  TimelineUnavailable = 'TimelineUnavailable',
  InvalidThumbnailData = 'InvalidThumbnailData',
  InvalidRepliedToEventId = 'InvalidRepliedToEventId',
  FailedSendingAttachment = 'FailedSendingAttachment',
}
export const RoomError = (() => {
  class InvalidAttachmentData extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = RoomError_Tags.InvalidAttachmentData;

    constructor(message: string) {
      super('RoomError', 'InvalidAttachmentData', message);
    }

    static instanceOf(e: any): e is InvalidAttachmentData {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class InvalidAttachmentMimeType extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = RoomError_Tags.InvalidAttachmentMimeType;

    constructor(message: string) {
      super('RoomError', 'InvalidAttachmentMimeType', message);
    }

    static instanceOf(e: any): e is InvalidAttachmentMimeType {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class InvalidMediaInfo extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = RoomError_Tags.InvalidMediaInfo;

    constructor(message: string) {
      super('RoomError', 'InvalidMediaInfo', message);
    }

    static instanceOf(e: any): e is InvalidMediaInfo {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class TimelineUnavailable extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = RoomError_Tags.TimelineUnavailable;

    constructor(message: string) {
      super('RoomError', 'TimelineUnavailable', message);
    }

    static instanceOf(e: any): e is TimelineUnavailable {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class InvalidThumbnailData extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = RoomError_Tags.InvalidThumbnailData;

    constructor(message: string) {
      super('RoomError', 'InvalidThumbnailData', message);
    }

    static instanceOf(e: any): e is InvalidThumbnailData {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class InvalidRepliedToEventId extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = RoomError_Tags.InvalidRepliedToEventId;

    constructor(message: string) {
      super('RoomError', 'InvalidRepliedToEventId', message);
    }

    static instanceOf(e: any): e is InvalidRepliedToEventId {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  class FailedSendingAttachment extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'RoomError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = RoomError_Tags.FailedSendingAttachment;

    constructor(message: string) {
      super('RoomError', 'FailedSendingAttachment', message);
    }

    static instanceOf(e: any): e is FailedSendingAttachment {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is RoomError {
    return (e as any)[uniffiTypeNameSymbol] === 'RoomError';
  }
  return {
    InvalidAttachmentData,
    InvalidAttachmentMimeType,
    InvalidMediaInfo,
    TimelineUnavailable,
    InvalidThumbnailData,
    InvalidRepliedToEventId,
    FailedSendingAttachment,
    instanceOf,
  };
})();

// Union type for RoomError error type.

export type RoomError = InstanceType<
  (typeof RoomError)[keyof Omit<typeof RoomError, 'instanceOf'>]
>;

const FfiConverterTypeRoomError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = RoomError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new RoomError.InvalidAttachmentData(
            FfiConverterString.read(from)
          );

        case 2:
          return new RoomError.InvalidAttachmentMimeType(
            FfiConverterString.read(from)
          );

        case 3:
          return new RoomError.InvalidMediaInfo(FfiConverterString.read(from));

        case 4:
          return new RoomError.TimelineUnavailable(
            FfiConverterString.read(from)
          );

        case 5:
          return new RoomError.InvalidThumbnailData(
            FfiConverterString.read(from)
          );

        case 6:
          return new RoomError.InvalidRepliedToEventId(
            FfiConverterString.read(from)
          );

        case 7:
          return new RoomError.FailedSendingAttachment(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: RoomHistoryVisibility
export enum RoomHistoryVisibility_Tags {
  Invited = 'Invited',
  Joined = 'Joined',
  Shared = 'Shared',
  WorldReadable = 'WorldReadable',
  Custom = 'Custom',
}
export const RoomHistoryVisibility = (() => {
  type Invited__interface = {
    tag: RoomHistoryVisibility_Tags.Invited;
  };

  /**
   * Previous events are accessible to newly joined members from the point
   * they were invited onwards.
   *
   * Events stop being accessible when the member's state changes to
   * something other than *invite* or *join*.
   */
  class Invited_ extends UniffiEnum implements Invited__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomHistoryVisibility';
    readonly tag = RoomHistoryVisibility_Tags.Invited;
    constructor() {
      super('RoomHistoryVisibility', 'Invited');
    }

    static new(): Invited_ {
      return new Invited_();
    }

    static instanceOf(obj: any): obj is Invited_ {
      return obj.tag === RoomHistoryVisibility_Tags.Invited;
    }
  }

  type Joined__interface = {
    tag: RoomHistoryVisibility_Tags.Joined;
  };

  /**
   * Previous events are accessible to newly joined members from the point
   * they joined the room onwards.
   * Events stop being accessible when the member's state changes to
   * something other than *join*.
   */
  class Joined_ extends UniffiEnum implements Joined__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomHistoryVisibility';
    readonly tag = RoomHistoryVisibility_Tags.Joined;
    constructor() {
      super('RoomHistoryVisibility', 'Joined');
    }

    static new(): Joined_ {
      return new Joined_();
    }

    static instanceOf(obj: any): obj is Joined_ {
      return obj.tag === RoomHistoryVisibility_Tags.Joined;
    }
  }

  type Shared__interface = {
    tag: RoomHistoryVisibility_Tags.Shared;
  };

  /**
   * Previous events are always accessible to newly joined members.
   *
   * All events in the room are accessible, even those sent when the member
   * was not a part of the room.
   */
  class Shared_ extends UniffiEnum implements Shared__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomHistoryVisibility';
    readonly tag = RoomHistoryVisibility_Tags.Shared;
    constructor() {
      super('RoomHistoryVisibility', 'Shared');
    }

    static new(): Shared_ {
      return new Shared_();
    }

    static instanceOf(obj: any): obj is Shared_ {
      return obj.tag === RoomHistoryVisibility_Tags.Shared;
    }
  }

  type WorldReadable__interface = {
    tag: RoomHistoryVisibility_Tags.WorldReadable;
  };

  /**
   * All events while this is the `HistoryVisibility` value may be shared by
   * any participating homeserver with anyone, regardless of whether they
   * have ever joined the room.
   */
  class WorldReadable_ extends UniffiEnum implements WorldReadable__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomHistoryVisibility';
    readonly tag = RoomHistoryVisibility_Tags.WorldReadable;
    constructor() {
      super('RoomHistoryVisibility', 'WorldReadable');
    }

    static new(): WorldReadable_ {
      return new WorldReadable_();
    }

    static instanceOf(obj: any): obj is WorldReadable_ {
      return obj.tag === RoomHistoryVisibility_Tags.WorldReadable;
    }
  }

  type Custom__interface = {
    tag: RoomHistoryVisibility_Tags.Custom;
    inner: Readonly<{ value: string }>;
  };

  /**
   * A custom visibility value.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomHistoryVisibility';
    readonly tag = RoomHistoryVisibility_Tags.Custom;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('RoomHistoryVisibility', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === RoomHistoryVisibility_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is RoomHistoryVisibility {
    return obj[uniffiTypeNameSymbol] === 'RoomHistoryVisibility';
  }

  return Object.freeze({
    instanceOf,
    Invited: Invited_,
    Joined: Joined_,
    Shared: Shared_,
    WorldReadable: WorldReadable_,
    Custom: Custom_,
  });
})();

export type RoomHistoryVisibility = InstanceType<
  (typeof RoomHistoryVisibility)[keyof Omit<
    typeof RoomHistoryVisibility,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomHistoryVisibility
const FfiConverterTypeRoomHistoryVisibility = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomHistoryVisibility;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomHistoryVisibility.Invited();
        case 2:
          return new RoomHistoryVisibility.Joined();
        case 3:
          return new RoomHistoryVisibility.Shared();
        case 4:
          return new RoomHistoryVisibility.WorldReadable();
        case 5:
          return new RoomHistoryVisibility.Custom({
            value: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomHistoryVisibility_Tags.Invited: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoomHistoryVisibility_Tags.Joined: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomHistoryVisibility_Tags.Shared: {
          ordinalConverter.write(3, into);
          return;
        }
        case RoomHistoryVisibility_Tags.WorldReadable: {
          ordinalConverter.write(4, into);
          return;
        }
        case RoomHistoryVisibility_Tags.Custom: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that RoomHistoryVisibility_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomHistoryVisibility_Tags.Invited: {
          return ordinalConverter.allocationSize(1);
        }
        case RoomHistoryVisibility_Tags.Joined: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomHistoryVisibility_Tags.Shared: {
          return ordinalConverter.allocationSize(3);
        }
        case RoomHistoryVisibility_Tags.WorldReadable: {
          return ordinalConverter.allocationSize(4);
        }
        case RoomHistoryVisibility_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RoomListEntriesDynamicFilterKind
export enum RoomListEntriesDynamicFilterKind_Tags {
  All = 'All',
  Any = 'Any',
  NonLeft = 'NonLeft',
  Joined = 'Joined',
  Unread = 'Unread',
  Favourite = 'Favourite',
  Invite = 'Invite',
  Category = 'Category',
  None = 'None',
  NormalizedMatchRoomName = 'NormalizedMatchRoomName',
  FuzzyMatchRoomName = 'FuzzyMatchRoomName',
  DeduplicateVersions = 'DeduplicateVersions',
}
export const RoomListEntriesDynamicFilterKind = (() => {
  type All__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.All;
    inner: Readonly<{ filters: Array<RoomListEntriesDynamicFilterKind> }>;
  };

  class All_ extends UniffiEnum implements All__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.All;
    readonly inner: Readonly<{
      filters: Array<RoomListEntriesDynamicFilterKind>;
    }>;
    constructor(inner: { filters: Array<RoomListEntriesDynamicFilterKind> }) {
      super('RoomListEntriesDynamicFilterKind', 'All');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      filters: Array<RoomListEntriesDynamicFilterKind>;
    }): All_ {
      return new All_(inner);
    }

    static instanceOf(obj: any): obj is All_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.All;
    }
  }

  type Any__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Any;
    inner: Readonly<{ filters: Array<RoomListEntriesDynamicFilterKind> }>;
  };

  class Any_ extends UniffiEnum implements Any__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Any;
    readonly inner: Readonly<{
      filters: Array<RoomListEntriesDynamicFilterKind>;
    }>;
    constructor(inner: { filters: Array<RoomListEntriesDynamicFilterKind> }) {
      super('RoomListEntriesDynamicFilterKind', 'Any');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      filters: Array<RoomListEntriesDynamicFilterKind>;
    }): Any_ {
      return new Any_(inner);
    }

    static instanceOf(obj: any): obj is Any_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Any;
    }
  }

  type NonLeft__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.NonLeft;
  };

  class NonLeft_ extends UniffiEnum implements NonLeft__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.NonLeft;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'NonLeft');
    }

    static new(): NonLeft_ {
      return new NonLeft_();
    }

    static instanceOf(obj: any): obj is NonLeft_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.NonLeft;
    }
  }

  type Joined__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Joined;
  };

  class Joined_ extends UniffiEnum implements Joined__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Joined;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'Joined');
    }

    static new(): Joined_ {
      return new Joined_();
    }

    static instanceOf(obj: any): obj is Joined_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Joined;
    }
  }

  type Unread__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Unread;
  };

  class Unread_ extends UniffiEnum implements Unread__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Unread;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'Unread');
    }

    static new(): Unread_ {
      return new Unread_();
    }

    static instanceOf(obj: any): obj is Unread_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Unread;
    }
  }

  type Favourite__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Favourite;
  };

  class Favourite_ extends UniffiEnum implements Favourite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Favourite;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'Favourite');
    }

    static new(): Favourite_ {
      return new Favourite_();
    }

    static instanceOf(obj: any): obj is Favourite_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Favourite;
    }
  }

  type Invite__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Invite;
  };

  class Invite_ extends UniffiEnum implements Invite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Invite;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'Invite');
    }

    static new(): Invite_ {
      return new Invite_();
    }

    static instanceOf(obj: any): obj is Invite_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Invite;
    }
  }

  type Category__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.Category;
    inner: Readonly<{ expect: RoomListFilterCategory }>;
  };

  class Category_ extends UniffiEnum implements Category__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.Category;
    readonly inner: Readonly<{ expect: RoomListFilterCategory }>;
    constructor(inner: { expect: RoomListFilterCategory }) {
      super('RoomListEntriesDynamicFilterKind', 'Category');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { expect: RoomListFilterCategory }): Category_ {
      return new Category_(inner);
    }

    static instanceOf(obj: any): obj is Category_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Category;
    }
  }

  type None__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.None;
  };

  class None_ extends UniffiEnum implements None__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.None;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'None');
    }

    static new(): None_ {
      return new None_();
    }

    static instanceOf(obj: any): obj is None_ {
      return obj.tag === RoomListEntriesDynamicFilterKind_Tags.None;
    }
  }

  type NormalizedMatchRoomName__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName;
    inner: Readonly<{ pattern: string }>;
  };

  class NormalizedMatchRoomName_
    extends UniffiEnum
    implements NormalizedMatchRoomName__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag =
      RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName;
    readonly inner: Readonly<{ pattern: string }>;
    constructor(inner: { pattern: string }) {
      super('RoomListEntriesDynamicFilterKind', 'NormalizedMatchRoomName');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { pattern: string }): NormalizedMatchRoomName_ {
      return new NormalizedMatchRoomName_(inner);
    }

    static instanceOf(obj: any): obj is NormalizedMatchRoomName_ {
      return (
        obj.tag ===
        RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName
      );
    }
  }

  type FuzzyMatchRoomName__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName;
    inner: Readonly<{ pattern: string }>;
  };

  class FuzzyMatchRoomName_
    extends UniffiEnum
    implements FuzzyMatchRoomName__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName;
    readonly inner: Readonly<{ pattern: string }>;
    constructor(inner: { pattern: string }) {
      super('RoomListEntriesDynamicFilterKind', 'FuzzyMatchRoomName');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { pattern: string }): FuzzyMatchRoomName_ {
      return new FuzzyMatchRoomName_(inner);
    }

    static instanceOf(obj: any): obj is FuzzyMatchRoomName_ {
      return (
        obj.tag === RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName
      );
    }
  }

  type DeduplicateVersions__interface = {
    tag: RoomListEntriesDynamicFilterKind_Tags.DeduplicateVersions;
  };

  class DeduplicateVersions_
    extends UniffiEnum
    implements DeduplicateVersions__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesDynamicFilterKind';
    readonly tag = RoomListEntriesDynamicFilterKind_Tags.DeduplicateVersions;
    constructor() {
      super('RoomListEntriesDynamicFilterKind', 'DeduplicateVersions');
    }

    static new(): DeduplicateVersions_ {
      return new DeduplicateVersions_();
    }

    static instanceOf(obj: any): obj is DeduplicateVersions_ {
      return (
        obj.tag === RoomListEntriesDynamicFilterKind_Tags.DeduplicateVersions
      );
    }
  }

  function instanceOf(obj: any): obj is RoomListEntriesDynamicFilterKind {
    return obj[uniffiTypeNameSymbol] === 'RoomListEntriesDynamicFilterKind';
  }

  return Object.freeze({
    instanceOf,
    All: All_,
    Any: Any_,
    NonLeft: NonLeft_,
    Joined: Joined_,
    Unread: Unread_,
    Favourite: Favourite_,
    Invite: Invite_,
    Category: Category_,
    None: None_,
    NormalizedMatchRoomName: NormalizedMatchRoomName_,
    FuzzyMatchRoomName: FuzzyMatchRoomName_,
    DeduplicateVersions: DeduplicateVersions_,
  });
})();

export type RoomListEntriesDynamicFilterKind = InstanceType<
  (typeof RoomListEntriesDynamicFilterKind)[keyof Omit<
    typeof RoomListEntriesDynamicFilterKind,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomListEntriesDynamicFilterKind
const FfiConverterTypeRoomListEntriesDynamicFilterKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListEntriesDynamicFilterKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomListEntriesDynamicFilterKind.All({
            filters:
              FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.read(from),
          });
        case 2:
          return new RoomListEntriesDynamicFilterKind.Any({
            filters:
              FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.read(from),
          });
        case 3:
          return new RoomListEntriesDynamicFilterKind.NonLeft();
        case 4:
          return new RoomListEntriesDynamicFilterKind.Joined();
        case 5:
          return new RoomListEntriesDynamicFilterKind.Unread();
        case 6:
          return new RoomListEntriesDynamicFilterKind.Favourite();
        case 7:
          return new RoomListEntriesDynamicFilterKind.Invite();
        case 8:
          return new RoomListEntriesDynamicFilterKind.Category({
            expect: FfiConverterTypeRoomListFilterCategory.read(from),
          });
        case 9:
          return new RoomListEntriesDynamicFilterKind.None();
        case 10:
          return new RoomListEntriesDynamicFilterKind.NormalizedMatchRoomName({
            pattern: FfiConverterString.read(from),
          });
        case 11:
          return new RoomListEntriesDynamicFilterKind.FuzzyMatchRoomName({
            pattern: FfiConverterString.read(from),
          });
        case 12:
          return new RoomListEntriesDynamicFilterKind.DeduplicateVersions();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomListEntriesDynamicFilterKind_Tags.All: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.write(
            inner.filters,
            into
          );
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Any: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.write(
            inner.filters,
            into
          );
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.NonLeft: {
          ordinalConverter.write(3, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Joined: {
          ordinalConverter.write(4, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Unread: {
          ordinalConverter.write(5, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Favourite: {
          ordinalConverter.write(6, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Invite: {
          ordinalConverter.write(7, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Category: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeRoomListFilterCategory.write(inner.expect, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.None: {
          ordinalConverter.write(9, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner.pattern, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterString.write(inner.pattern, into);
          return;
        }
        case RoomListEntriesDynamicFilterKind_Tags.DeduplicateVersions: {
          ordinalConverter.write(12, into);
          return;
        }
        default:
          // Throwing from here means that RoomListEntriesDynamicFilterKind_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomListEntriesDynamicFilterKind_Tags.All: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size +=
            FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.allocationSize(
              inner.filters
            );
          return size;
        }
        case RoomListEntriesDynamicFilterKind_Tags.Any: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size +=
            FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.allocationSize(
              inner.filters
            );
          return size;
        }
        case RoomListEntriesDynamicFilterKind_Tags.NonLeft: {
          return ordinalConverter.allocationSize(3);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Joined: {
          return ordinalConverter.allocationSize(4);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Unread: {
          return ordinalConverter.allocationSize(5);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Favourite: {
          return ordinalConverter.allocationSize(6);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Invite: {
          return ordinalConverter.allocationSize(7);
        }
        case RoomListEntriesDynamicFilterKind_Tags.Category: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeRoomListFilterCategory.allocationSize(
            inner.expect
          );
          return size;
        }
        case RoomListEntriesDynamicFilterKind_Tags.None: {
          return ordinalConverter.allocationSize(9);
        }
        case RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner.pattern);
          return size;
        }
        case RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterString.allocationSize(inner.pattern);
          return size;
        }
        case RoomListEntriesDynamicFilterKind_Tags.DeduplicateVersions: {
          return ordinalConverter.allocationSize(12);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RoomListEntriesUpdate
export enum RoomListEntriesUpdate_Tags {
  Append = 'Append',
  Clear = 'Clear',
  PushFront = 'PushFront',
  PushBack = 'PushBack',
  PopFront = 'PopFront',
  PopBack = 'PopBack',
  Insert = 'Insert',
  Set = 'Set',
  Remove = 'Remove',
  Truncate = 'Truncate',
  Reset = 'Reset',
}
export const RoomListEntriesUpdate = (() => {
  type Append__interface = {
    tag: RoomListEntriesUpdate_Tags.Append;
    inner: Readonly<{ values: Array<RoomInterface> }>;
  };

  class Append_ extends UniffiEnum implements Append__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Append;
    readonly inner: Readonly<{ values: Array<RoomInterface> }>;
    constructor(inner: { values: Array<RoomInterface> }) {
      super('RoomListEntriesUpdate', 'Append');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array<RoomInterface> }): Append_ {
      return new Append_(inner);
    }

    static instanceOf(obj: any): obj is Append_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Append;
    }
  }

  type Clear__interface = {
    tag: RoomListEntriesUpdate_Tags.Clear;
  };

  class Clear_ extends UniffiEnum implements Clear__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Clear;
    constructor() {
      super('RoomListEntriesUpdate', 'Clear');
    }

    static new(): Clear_ {
      return new Clear_();
    }

    static instanceOf(obj: any): obj is Clear_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Clear;
    }
  }

  type PushFront__interface = {
    tag: RoomListEntriesUpdate_Tags.PushFront;
    inner: Readonly<{ value: RoomInterface }>;
  };

  class PushFront_ extends UniffiEnum implements PushFront__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.PushFront;
    readonly inner: Readonly<{ value: RoomInterface }>;
    constructor(inner: { value: RoomInterface }) {
      super('RoomListEntriesUpdate', 'PushFront');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: RoomInterface }): PushFront_ {
      return new PushFront_(inner);
    }

    static instanceOf(obj: any): obj is PushFront_ {
      return obj.tag === RoomListEntriesUpdate_Tags.PushFront;
    }
  }

  type PushBack__interface = {
    tag: RoomListEntriesUpdate_Tags.PushBack;
    inner: Readonly<{ value: RoomInterface }>;
  };

  class PushBack_ extends UniffiEnum implements PushBack__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.PushBack;
    readonly inner: Readonly<{ value: RoomInterface }>;
    constructor(inner: { value: RoomInterface }) {
      super('RoomListEntriesUpdate', 'PushBack');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: RoomInterface }): PushBack_ {
      return new PushBack_(inner);
    }

    static instanceOf(obj: any): obj is PushBack_ {
      return obj.tag === RoomListEntriesUpdate_Tags.PushBack;
    }
  }

  type PopFront__interface = {
    tag: RoomListEntriesUpdate_Tags.PopFront;
  };

  class PopFront_ extends UniffiEnum implements PopFront__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.PopFront;
    constructor() {
      super('RoomListEntriesUpdate', 'PopFront');
    }

    static new(): PopFront_ {
      return new PopFront_();
    }

    static instanceOf(obj: any): obj is PopFront_ {
      return obj.tag === RoomListEntriesUpdate_Tags.PopFront;
    }
  }

  type PopBack__interface = {
    tag: RoomListEntriesUpdate_Tags.PopBack;
  };

  class PopBack_ extends UniffiEnum implements PopBack__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.PopBack;
    constructor() {
      super('RoomListEntriesUpdate', 'PopBack');
    }

    static new(): PopBack_ {
      return new PopBack_();
    }

    static instanceOf(obj: any): obj is PopBack_ {
      return obj.tag === RoomListEntriesUpdate_Tags.PopBack;
    }
  }

  type Insert__interface = {
    tag: RoomListEntriesUpdate_Tags.Insert;
    inner: Readonly<{ index: /*u32*/ number; value: RoomInterface }>;
  };

  class Insert_ extends UniffiEnum implements Insert__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Insert;
    readonly inner: Readonly<{ index: /*u32*/ number; value: RoomInterface }>;
    constructor(inner: { index: /*u32*/ number; value: RoomInterface }) {
      super('RoomListEntriesUpdate', 'Insert');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      index: /*u32*/ number;
      value: RoomInterface;
    }): Insert_ {
      return new Insert_(inner);
    }

    static instanceOf(obj: any): obj is Insert_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Insert;
    }
  }

  type Set__interface = {
    tag: RoomListEntriesUpdate_Tags.Set;
    inner: Readonly<{ index: /*u32*/ number; value: RoomInterface }>;
  };

  class Set_ extends UniffiEnum implements Set__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Set;
    readonly inner: Readonly<{ index: /*u32*/ number; value: RoomInterface }>;
    constructor(inner: { index: /*u32*/ number; value: RoomInterface }) {
      super('RoomListEntriesUpdate', 'Set');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { index: /*u32*/ number; value: RoomInterface }): Set_ {
      return new Set_(inner);
    }

    static instanceOf(obj: any): obj is Set_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Set;
    }
  }

  type Remove__interface = {
    tag: RoomListEntriesUpdate_Tags.Remove;
    inner: Readonly<{ index: /*u32*/ number }>;
  };

  class Remove_ extends UniffiEnum implements Remove__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Remove;
    readonly inner: Readonly<{ index: /*u32*/ number }>;
    constructor(inner: { index: /*u32*/ number }) {
      super('RoomListEntriesUpdate', 'Remove');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { index: /*u32*/ number }): Remove_ {
      return new Remove_(inner);
    }

    static instanceOf(obj: any): obj is Remove_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Remove;
    }
  }

  type Truncate__interface = {
    tag: RoomListEntriesUpdate_Tags.Truncate;
    inner: Readonly<{ length: /*u32*/ number }>;
  };

  class Truncate_ extends UniffiEnum implements Truncate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Truncate;
    readonly inner: Readonly<{ length: /*u32*/ number }>;
    constructor(inner: { length: /*u32*/ number }) {
      super('RoomListEntriesUpdate', 'Truncate');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { length: /*u32*/ number }): Truncate_ {
      return new Truncate_(inner);
    }

    static instanceOf(obj: any): obj is Truncate_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Truncate;
    }
  }

  type Reset__interface = {
    tag: RoomListEntriesUpdate_Tags.Reset;
    inner: Readonly<{ values: Array<RoomInterface> }>;
  };

  class Reset_ extends UniffiEnum implements Reset__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListEntriesUpdate';
    readonly tag = RoomListEntriesUpdate_Tags.Reset;
    readonly inner: Readonly<{ values: Array<RoomInterface> }>;
    constructor(inner: { values: Array<RoomInterface> }) {
      super('RoomListEntriesUpdate', 'Reset');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array<RoomInterface> }): Reset_ {
      return new Reset_(inner);
    }

    static instanceOf(obj: any): obj is Reset_ {
      return obj.tag === RoomListEntriesUpdate_Tags.Reset;
    }
  }

  function instanceOf(obj: any): obj is RoomListEntriesUpdate {
    return obj[uniffiTypeNameSymbol] === 'RoomListEntriesUpdate';
  }

  return Object.freeze({
    instanceOf,
    Append: Append_,
    Clear: Clear_,
    PushFront: PushFront_,
    PushBack: PushBack_,
    PopFront: PopFront_,
    PopBack: PopBack_,
    Insert: Insert_,
    Set: Set_,
    Remove: Remove_,
    Truncate: Truncate_,
    Reset: Reset_,
  });
})();

export type RoomListEntriesUpdate = InstanceType<
  (typeof RoomListEntriesUpdate)[keyof Omit<
    typeof RoomListEntriesUpdate,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomListEntriesUpdate
const FfiConverterTypeRoomListEntriesUpdate = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListEntriesUpdate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomListEntriesUpdate.Append({
            values: FfiConverterArrayTypeRoom.read(from),
          });
        case 2:
          return new RoomListEntriesUpdate.Clear();
        case 3:
          return new RoomListEntriesUpdate.PushFront({
            value: FfiConverterTypeRoom.read(from),
          });
        case 4:
          return new RoomListEntriesUpdate.PushBack({
            value: FfiConverterTypeRoom.read(from),
          });
        case 5:
          return new RoomListEntriesUpdate.PopFront();
        case 6:
          return new RoomListEntriesUpdate.PopBack();
        case 7:
          return new RoomListEntriesUpdate.Insert({
            index: FfiConverterUInt32.read(from),
            value: FfiConverterTypeRoom.read(from),
          });
        case 8:
          return new RoomListEntriesUpdate.Set({
            index: FfiConverterUInt32.read(from),
            value: FfiConverterTypeRoom.read(from),
          });
        case 9:
          return new RoomListEntriesUpdate.Remove({
            index: FfiConverterUInt32.read(from),
          });
        case 10:
          return new RoomListEntriesUpdate.Truncate({
            length: FfiConverterUInt32.read(from),
          });
        case 11:
          return new RoomListEntriesUpdate.Reset({
            values: FfiConverterArrayTypeRoom.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomListEntriesUpdate_Tags.Append: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoom.write(inner.values, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Clear: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.PushFront: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeRoom.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.PushBack: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeRoom.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.PopFront: {
          ordinalConverter.write(5, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.PopBack: {
          ordinalConverter.write(6, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Insert: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoom.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Set: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterTypeRoom.write(inner.value, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Remove: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Truncate: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.length, into);
          return;
        }
        case RoomListEntriesUpdate_Tags.Reset: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoom.write(inner.values, into);
          return;
        }
        default:
          // Throwing from here means that RoomListEntriesUpdate_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomListEntriesUpdate_Tags.Append: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeRoom.allocationSize(inner.values);
          return size;
        }
        case RoomListEntriesUpdate_Tags.Clear: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomListEntriesUpdate_Tags.PushFront: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeRoom.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdate_Tags.PushBack: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeRoom.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdate_Tags.PopFront: {
          return ordinalConverter.allocationSize(5);
        }
        case RoomListEntriesUpdate_Tags.PopBack: {
          return ordinalConverter.allocationSize(6);
        }
        case RoomListEntriesUpdate_Tags.Insert: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoom.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdate_Tags.Set: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterTypeRoom.allocationSize(inner.value);
          return size;
        }
        case RoomListEntriesUpdate_Tags.Remove: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterUInt32.allocationSize(inner.index);
          return size;
        }
        case RoomListEntriesUpdate_Tags.Truncate: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterUInt32.allocationSize(inner.length);
          return size;
        }
        case RoomListEntriesUpdate_Tags.Reset: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterArrayTypeRoom.allocationSize(inner.values);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: RoomListError

// Enum: RoomListError
export enum RoomListError_Tags {
  SlidingSync = 'SlidingSync',
  UnknownList = 'UnknownList',
  InputCannotBeApplied = 'InputCannotBeApplied',
  RoomNotFound = 'RoomNotFound',
  InvalidRoomId = 'InvalidRoomId',
  EventCache = 'EventCache',
  IncorrectRoomMembership = 'IncorrectRoomMembership',
}
export const RoomListError = (() => {
  type SlidingSync__interface = {
    tag: RoomListError_Tags.SlidingSync;
    inner: Readonly<{ error: string }>;
  };

  class SlidingSync_ extends UniffiError implements SlidingSync__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.SlidingSync;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('RoomListError', 'SlidingSync');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): SlidingSync_ {
      return new SlidingSync_(inner);
    }

    static instanceOf(obj: any): obj is SlidingSync_ {
      return obj.tag === RoomListError_Tags.SlidingSync;
    }

    static hasInner(obj: any): obj is SlidingSync_ {
      return SlidingSync_.instanceOf(obj);
    }

    static getInner(obj: SlidingSync_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type UnknownList__interface = {
    tag: RoomListError_Tags.UnknownList;
    inner: Readonly<{ listName: string }>;
  };

  class UnknownList_ extends UniffiError implements UnknownList__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.UnknownList;
    readonly inner: Readonly<{ listName: string }>;
    constructor(inner: { listName: string }) {
      super('RoomListError', 'UnknownList');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { listName: string }): UnknownList_ {
      return new UnknownList_(inner);
    }

    static instanceOf(obj: any): obj is UnknownList_ {
      return obj.tag === RoomListError_Tags.UnknownList;
    }

    static hasInner(obj: any): obj is UnknownList_ {
      return UnknownList_.instanceOf(obj);
    }

    static getInner(obj: UnknownList_): Readonly<{ listName: string }> {
      return obj.inner;
    }
  }

  type InputCannotBeApplied__interface = {
    tag: RoomListError_Tags.InputCannotBeApplied;
  };

  class InputCannotBeApplied_
    extends UniffiError
    implements InputCannotBeApplied__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.InputCannotBeApplied;
    constructor() {
      super('RoomListError', 'InputCannotBeApplied');
    }

    static new(): InputCannotBeApplied_ {
      return new InputCannotBeApplied_();
    }

    static instanceOf(obj: any): obj is InputCannotBeApplied_ {
      return obj.tag === RoomListError_Tags.InputCannotBeApplied;
    }

    static hasInner(obj: any): obj is InputCannotBeApplied_ {
      return false;
    }
  }

  type RoomNotFound__interface = {
    tag: RoomListError_Tags.RoomNotFound;
    inner: Readonly<{ roomName: string }>;
  };

  class RoomNotFound_ extends UniffiError implements RoomNotFound__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.RoomNotFound;
    readonly inner: Readonly<{ roomName: string }>;
    constructor(inner: { roomName: string }) {
      super('RoomListError', 'RoomNotFound');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomName: string }): RoomNotFound_ {
      return new RoomNotFound_(inner);
    }

    static instanceOf(obj: any): obj is RoomNotFound_ {
      return obj.tag === RoomListError_Tags.RoomNotFound;
    }

    static hasInner(obj: any): obj is RoomNotFound_ {
      return RoomNotFound_.instanceOf(obj);
    }

    static getInner(obj: RoomNotFound_): Readonly<{ roomName: string }> {
      return obj.inner;
    }
  }

  type InvalidRoomId__interface = {
    tag: RoomListError_Tags.InvalidRoomId;
    inner: Readonly<{ error: string }>;
  };

  class InvalidRoomId_ extends UniffiError implements InvalidRoomId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.InvalidRoomId;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('RoomListError', 'InvalidRoomId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): InvalidRoomId_ {
      return new InvalidRoomId_(inner);
    }

    static instanceOf(obj: any): obj is InvalidRoomId_ {
      return obj.tag === RoomListError_Tags.InvalidRoomId;
    }

    static hasInner(obj: any): obj is InvalidRoomId_ {
      return InvalidRoomId_.instanceOf(obj);
    }

    static getInner(obj: InvalidRoomId_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type EventCache__interface = {
    tag: RoomListError_Tags.EventCache;
    inner: Readonly<{ error: string }>;
  };

  class EventCache_ extends UniffiError implements EventCache__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.EventCache;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('RoomListError', 'EventCache');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): EventCache_ {
      return new EventCache_(inner);
    }

    static instanceOf(obj: any): obj is EventCache_ {
      return obj.tag === RoomListError_Tags.EventCache;
    }

    static hasInner(obj: any): obj is EventCache_ {
      return EventCache_.instanceOf(obj);
    }

    static getInner(obj: EventCache_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type IncorrectRoomMembership__interface = {
    tag: RoomListError_Tags.IncorrectRoomMembership;
    inner: Readonly<{ expected: Array<Membership>; actual: Membership }>;
  };

  class IncorrectRoomMembership_
    extends UniffiError
    implements IncorrectRoomMembership__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListError';
    readonly tag = RoomListError_Tags.IncorrectRoomMembership;
    readonly inner: Readonly<{
      expected: Array<Membership>;
      actual: Membership;
    }>;
    constructor(inner: { expected: Array<Membership>; actual: Membership }) {
      super('RoomListError', 'IncorrectRoomMembership');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      expected: Array<Membership>;
      actual: Membership;
    }): IncorrectRoomMembership_ {
      return new IncorrectRoomMembership_(inner);
    }

    static instanceOf(obj: any): obj is IncorrectRoomMembership_ {
      return obj.tag === RoomListError_Tags.IncorrectRoomMembership;
    }

    static hasInner(obj: any): obj is IncorrectRoomMembership_ {
      return IncorrectRoomMembership_.instanceOf(obj);
    }

    static getInner(
      obj: IncorrectRoomMembership_
    ): Readonly<{ expected: Array<Membership>; actual: Membership }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is RoomListError {
    return obj[uniffiTypeNameSymbol] === 'RoomListError';
  }

  return Object.freeze({
    instanceOf,
    SlidingSync: SlidingSync_,
    UnknownList: UnknownList_,
    InputCannotBeApplied: InputCannotBeApplied_,
    RoomNotFound: RoomNotFound_,
    InvalidRoomId: InvalidRoomId_,
    EventCache: EventCache_,
    IncorrectRoomMembership: IncorrectRoomMembership_,
  });
})();

export type RoomListError = InstanceType<
  (typeof RoomListError)[keyof Omit<typeof RoomListError, 'instanceOf'>]
>;

// FfiConverter for enum RoomListError
const FfiConverterTypeRoomListError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomListError.SlidingSync({
            error: FfiConverterString.read(from),
          });
        case 2:
          return new RoomListError.UnknownList({
            listName: FfiConverterString.read(from),
          });
        case 3:
          return new RoomListError.InputCannotBeApplied();
        case 4:
          return new RoomListError.RoomNotFound({
            roomName: FfiConverterString.read(from),
          });
        case 5:
          return new RoomListError.InvalidRoomId({
            error: FfiConverterString.read(from),
          });
        case 6:
          return new RoomListError.EventCache({
            error: FfiConverterString.read(from),
          });
        case 7:
          return new RoomListError.IncorrectRoomMembership({
            expected: FfiConverterArrayTypeMembership.read(from),
            actual: FfiConverterTypeMembership.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomListError_Tags.SlidingSync: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case RoomListError_Tags.UnknownList: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.listName, into);
          return;
        }
        case RoomListError_Tags.InputCannotBeApplied: {
          ordinalConverter.write(3, into);
          return;
        }
        case RoomListError_Tags.RoomNotFound: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomName, into);
          return;
        }
        case RoomListError_Tags.InvalidRoomId: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case RoomListError_Tags.EventCache: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case RoomListError_Tags.IncorrectRoomMembership: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterArrayTypeMembership.write(inner.expected, into);
          FfiConverterTypeMembership.write(inner.actual, into);
          return;
        }
        default:
          // Throwing from here means that RoomListError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomListError_Tags.SlidingSync: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case RoomListError_Tags.UnknownList: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.listName);
          return size;
        }
        case RoomListError_Tags.InputCannotBeApplied: {
          return ordinalConverter.allocationSize(3);
        }
        case RoomListError_Tags.RoomNotFound: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.roomName);
          return size;
        }
        case RoomListError_Tags.InvalidRoomId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case RoomListError_Tags.EventCache: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case RoomListError_Tags.IncorrectRoomMembership: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterArrayTypeMembership.allocationSize(
            inner.expected
          );
          size += FfiConverterTypeMembership.allocationSize(inner.actual);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RoomListFilterCategory {
  Group,
  People,
}

const FfiConverterTypeRoomListFilterCategory = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListFilterCategory;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomListFilterCategory.Group;
        case 2:
          return RoomListFilterCategory.People;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomListFilterCategory.Group:
          return ordinalConverter.write(1, into);
        case RoomListFilterCategory.People:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomListLoadingState
export enum RoomListLoadingState_Tags {
  NotLoaded = 'NotLoaded',
  Loaded = 'Loaded',
}
export const RoomListLoadingState = (() => {
  type NotLoaded__interface = {
    tag: RoomListLoadingState_Tags.NotLoaded;
  };

  class NotLoaded_ extends UniffiEnum implements NotLoaded__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListLoadingState';
    readonly tag = RoomListLoadingState_Tags.NotLoaded;
    constructor() {
      super('RoomListLoadingState', 'NotLoaded');
    }

    static new(): NotLoaded_ {
      return new NotLoaded_();
    }

    static instanceOf(obj: any): obj is NotLoaded_ {
      return obj.tag === RoomListLoadingState_Tags.NotLoaded;
    }
  }

  type Loaded__interface = {
    tag: RoomListLoadingState_Tags.Loaded;
    inner: Readonly<{ maximumNumberOfRooms: /*u32*/ number | undefined }>;
  };

  class Loaded_ extends UniffiEnum implements Loaded__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomListLoadingState';
    readonly tag = RoomListLoadingState_Tags.Loaded;
    readonly inner: Readonly<{
      maximumNumberOfRooms: /*u32*/ number | undefined;
    }>;
    constructor(inner: { maximumNumberOfRooms: /*u32*/ number | undefined }) {
      super('RoomListLoadingState', 'Loaded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      maximumNumberOfRooms: /*u32*/ number | undefined;
    }): Loaded_ {
      return new Loaded_(inner);
    }

    static instanceOf(obj: any): obj is Loaded_ {
      return obj.tag === RoomListLoadingState_Tags.Loaded;
    }
  }

  function instanceOf(obj: any): obj is RoomListLoadingState {
    return obj[uniffiTypeNameSymbol] === 'RoomListLoadingState';
  }

  return Object.freeze({
    instanceOf,
    NotLoaded: NotLoaded_,
    Loaded: Loaded_,
  });
})();

export type RoomListLoadingState = InstanceType<
  (typeof RoomListLoadingState)[keyof Omit<
    typeof RoomListLoadingState,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoomListLoadingState
const FfiConverterTypeRoomListLoadingState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListLoadingState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomListLoadingState.NotLoaded();
        case 2:
          return new RoomListLoadingState.Loaded({
            maximumNumberOfRooms: FfiConverterOptionalUInt32.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomListLoadingState_Tags.NotLoaded: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoomListLoadingState_Tags.Loaded: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalUInt32.write(inner.maximumNumberOfRooms, into);
          return;
        }
        default:
          // Throwing from here means that RoomListLoadingState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomListLoadingState_Tags.NotLoaded: {
          return ordinalConverter.allocationSize(1);
        }
        case RoomListLoadingState_Tags.Loaded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalUInt32.allocationSize(
            inner.maximumNumberOfRooms
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RoomListServiceState {
  Initial,
  SettingUp,
  Recovering,
  Running,
  Error,
  Terminated,
}

const FfiConverterTypeRoomListServiceState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListServiceState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomListServiceState.Initial;
        case 2:
          return RoomListServiceState.SettingUp;
        case 3:
          return RoomListServiceState.Recovering;
        case 4:
          return RoomListServiceState.Running;
        case 5:
          return RoomListServiceState.Error;
        case 6:
          return RoomListServiceState.Terminated;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomListServiceState.Initial:
          return ordinalConverter.write(1, into);
        case RoomListServiceState.SettingUp:
          return ordinalConverter.write(2, into);
        case RoomListServiceState.Recovering:
          return ordinalConverter.write(3, into);
        case RoomListServiceState.Running:
          return ordinalConverter.write(4, into);
        case RoomListServiceState.Error:
          return ordinalConverter.write(5, into);
        case RoomListServiceState.Terminated:
          return ordinalConverter.write(6, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum RoomListServiceSyncIndicator {
  Show,
  Hide,
}

const FfiConverterTypeRoomListServiceSyncIndicator = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomListServiceSyncIndicator;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomListServiceSyncIndicator.Show;
        case 2:
          return RoomListServiceSyncIndicator.Hide;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomListServiceSyncIndicator.Show:
          return ordinalConverter.write(1, into);
        case RoomListServiceSyncIndicator.Hide:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomLoadSettings
export enum RoomLoadSettings_Tags {
  All = 'All',
  One = 'One',
}
/**
 * Configure how many rooms will be restored when restoring the session with
 * [`Client::restore_session_with`].
 *
 * Please, see the documentation of [`matrix_sdk::store::RoomLoadSettings`] to
 * learn more.
 */
export const RoomLoadSettings = (() => {
  type All__interface = {
    tag: RoomLoadSettings_Tags.All;
  };

  /**
   * Load all rooms from the `StateStore` into the in-memory state store
   * `BaseStateStore`.
   */
  class All_ extends UniffiEnum implements All__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomLoadSettings';
    readonly tag = RoomLoadSettings_Tags.All;
    constructor() {
      super('RoomLoadSettings', 'All');
    }

    static new(): All_ {
      return new All_();
    }

    static instanceOf(obj: any): obj is All_ {
      return obj.tag === RoomLoadSettings_Tags.All;
    }
  }

  type One__interface = {
    tag: RoomLoadSettings_Tags.One;
    inner: Readonly<{ roomId: string }>;
  };

  /**
   * Load a single room from the `StateStore` into the in-memory state
   * store `BaseStateStore`.
   *
   * Please, be careful with this option. Read the documentation of
   * [`RoomLoadSettings`].
   */
  class One_ extends UniffiEnum implements One__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomLoadSettings';
    readonly tag = RoomLoadSettings_Tags.One;
    readonly inner: Readonly<{ roomId: string }>;
    constructor(inner: { roomId: string }) {
      super('RoomLoadSettings', 'One');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { roomId: string }): One_ {
      return new One_(inner);
    }

    static instanceOf(obj: any): obj is One_ {
      return obj.tag === RoomLoadSettings_Tags.One;
    }
  }

  function instanceOf(obj: any): obj is RoomLoadSettings {
    return obj[uniffiTypeNameSymbol] === 'RoomLoadSettings';
  }

  return Object.freeze({
    instanceOf,
    All: All_,
    One: One_,
  });
})();

/**
 * Configure how many rooms will be restored when restoring the session with
 * [`Client::restore_session_with`].
 *
 * Please, see the documentation of [`matrix_sdk::store::RoomLoadSettings`] to
 * learn more.
 */

export type RoomLoadSettings = InstanceType<
  (typeof RoomLoadSettings)[keyof Omit<typeof RoomLoadSettings, 'instanceOf'>]
>;

// FfiConverter for enum RoomLoadSettings
const FfiConverterTypeRoomLoadSettings = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomLoadSettings;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomLoadSettings.All();
        case 2:
          return new RoomLoadSettings.One({
            roomId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomLoadSettings_Tags.All: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoomLoadSettings_Tags.One: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.roomId, into);
          return;
        }
        default:
          // Throwing from here means that RoomLoadSettings_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomLoadSettings_Tags.All: {
          return ordinalConverter.allocationSize(1);
        }
        case RoomLoadSettings_Tags.One: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.roomId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RoomMessageEventMessageType {
  Audio,
  Emote,
  File,
  Gallery,
  Image,
  Location,
  Notice,
  ServerNotice,
  Text,
  Video,
  VerificationRequest,
  Other,
}

const FfiConverterTypeRoomMessageEventMessageType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomMessageEventMessageType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomMessageEventMessageType.Audio;
        case 2:
          return RoomMessageEventMessageType.Emote;
        case 3:
          return RoomMessageEventMessageType.File;
        case 4:
          return RoomMessageEventMessageType.Gallery;
        case 5:
          return RoomMessageEventMessageType.Image;
        case 6:
          return RoomMessageEventMessageType.Location;
        case 7:
          return RoomMessageEventMessageType.Notice;
        case 8:
          return RoomMessageEventMessageType.ServerNotice;
        case 9:
          return RoomMessageEventMessageType.Text;
        case 10:
          return RoomMessageEventMessageType.Video;
        case 11:
          return RoomMessageEventMessageType.VerificationRequest;
        case 12:
          return RoomMessageEventMessageType.Other;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomMessageEventMessageType.Audio:
          return ordinalConverter.write(1, into);
        case RoomMessageEventMessageType.Emote:
          return ordinalConverter.write(2, into);
        case RoomMessageEventMessageType.File:
          return ordinalConverter.write(3, into);
        case RoomMessageEventMessageType.Gallery:
          return ordinalConverter.write(4, into);
        case RoomMessageEventMessageType.Image:
          return ordinalConverter.write(5, into);
        case RoomMessageEventMessageType.Location:
          return ordinalConverter.write(6, into);
        case RoomMessageEventMessageType.Notice:
          return ordinalConverter.write(7, into);
        case RoomMessageEventMessageType.ServerNotice:
          return ordinalConverter.write(8, into);
        case RoomMessageEventMessageType.Text:
          return ordinalConverter.write(9, into);
        case RoomMessageEventMessageType.Video:
          return ordinalConverter.write(10, into);
        case RoomMessageEventMessageType.VerificationRequest:
          return ordinalConverter.write(11, into);
        case RoomMessageEventMessageType.Other:
          return ordinalConverter.write(12, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Enum representing the push notification modes for a room.
 */
export enum RoomNotificationMode {
  /**
   * Receive notifications for all messages.
   */
  AllMessages,
  /**
   * Receive notifications for mentions and keywords only.
   */
  MentionsAndKeywordsOnly,
  /**
   * Do not receive any notifications.
   */
  Mute,
}

const FfiConverterTypeRoomNotificationMode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomNotificationMode;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomNotificationMode.AllMessages;
        case 2:
          return RoomNotificationMode.MentionsAndKeywordsOnly;
        case 3:
          return RoomNotificationMode.Mute;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomNotificationMode.AllMessages:
          return ordinalConverter.write(1, into);
        case RoomNotificationMode.MentionsAndKeywordsOnly:
          return ordinalConverter.write(2, into);
        case RoomNotificationMode.Mute:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum RoomPreset {
  /**
   * `join_rules` is set to `invite` and `history_visibility` is set to
   * `shared`.
   */
  PrivateChat,
  /**
   * `join_rules` is set to `public` and `history_visibility` is set to
   * `shared`.
   */
  PublicChat,
  /**
   * Same as `PrivateChat`, but all initial invitees get the same power level
   * as the creator.
   */
  TrustedPrivateChat,
}

const FfiConverterTypeRoomPreset = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomPreset;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomPreset.PrivateChat;
        case 2:
          return RoomPreset.PublicChat;
        case 3:
          return RoomPreset.TrustedPrivateChat;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomPreset.PrivateChat:
          return ordinalConverter.write(1, into);
        case RoomPreset.PublicChat:
          return ordinalConverter.write(2, into);
        case RoomPreset.TrustedPrivateChat:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RoomType
export enum RoomType_Tags {
  Room = 'Room',
  Space = 'Space',
  Custom = 'Custom',
}
/**
 * The type of room for a [`RoomPreviewInfo`].
 */
export const RoomType = (() => {
  type Room__interface = {
    tag: RoomType_Tags.Room;
  };

  /**
   * It's a plain chat room.
   */
  class Room_ extends UniffiEnum implements Room__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomType';
    readonly tag = RoomType_Tags.Room;
    constructor() {
      super('RoomType', 'Room');
    }

    static new(): Room_ {
      return new Room_();
    }

    static instanceOf(obj: any): obj is Room_ {
      return obj.tag === RoomType_Tags.Room;
    }
  }

  type Space__interface = {
    tag: RoomType_Tags.Space;
  };

  /**
   * It's a space that can group several rooms.
   */
  class Space_ extends UniffiEnum implements Space__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomType';
    readonly tag = RoomType_Tags.Space;
    constructor() {
      super('RoomType', 'Space');
    }

    static new(): Space_ {
      return new Space_();
    }

    static instanceOf(obj: any): obj is Space_ {
      return obj.tag === RoomType_Tags.Space;
    }
  }

  type Custom__interface = {
    tag: RoomType_Tags.Custom;
    inner: Readonly<{ value: string }>;
  };

  /**
   * It's a custom implementation.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomType';
    readonly tag = RoomType_Tags.Custom;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('RoomType', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === RoomType_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is RoomType {
    return obj[uniffiTypeNameSymbol] === 'RoomType';
  }

  return Object.freeze({
    instanceOf,
    Room: Room_,
    Space: Space_,
    Custom: Custom_,
  });
})();

/**
 * The type of room for a [`RoomPreviewInfo`].
 */

export type RoomType = InstanceType<
  (typeof RoomType)[keyof Omit<typeof RoomType, 'instanceOf'>]
>;

// FfiConverter for enum RoomType
const FfiConverterTypeRoomType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomType.Room();
        case 2:
          return new RoomType.Space();
        case 3:
          return new RoomType.Custom({ value: FfiConverterString.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomType_Tags.Room: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoomType_Tags.Space: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomType_Tags.Custom: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that RoomType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomType_Tags.Room: {
          return ordinalConverter.allocationSize(1);
        }
        case RoomType_Tags.Space: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomType_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RoomVisibility
export enum RoomVisibility_Tags {
  Public = 'Public',
  Private = 'Private',
  Custom = 'Custom',
}
export const RoomVisibility = (() => {
  type Public__interface = {
    tag: RoomVisibility_Tags.Public;
  };

  /**
   * Indicates that the room will be shown in the published room list.
   */
  class Public_ extends UniffiEnum implements Public__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomVisibility';
    readonly tag = RoomVisibility_Tags.Public;
    constructor() {
      super('RoomVisibility', 'Public');
    }

    static new(): Public_ {
      return new Public_();
    }

    static instanceOf(obj: any): obj is Public_ {
      return obj.tag === RoomVisibility_Tags.Public;
    }
  }

  type Private__interface = {
    tag: RoomVisibility_Tags.Private;
  };

  /**
   * Indicates that the room will not be shown in the published room list.
   */
  class Private_ extends UniffiEnum implements Private__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomVisibility';
    readonly tag = RoomVisibility_Tags.Private;
    constructor() {
      super('RoomVisibility', 'Private');
    }

    static new(): Private_ {
      return new Private_();
    }

    static instanceOf(obj: any): obj is Private_ {
      return obj.tag === RoomVisibility_Tags.Private;
    }
  }

  type Custom__interface = {
    tag: RoomVisibility_Tags.Custom;
    inner: Readonly<{ value: string }>;
  };

  /**
   * A custom value that's not present in the spec.
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoomVisibility';
    readonly tag = RoomVisibility_Tags.Custom;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('RoomVisibility', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === RoomVisibility_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is RoomVisibility {
    return obj[uniffiTypeNameSymbol] === 'RoomVisibility';
  }

  return Object.freeze({
    instanceOf,
    Public: Public_,
    Private: Private_,
    Custom: Custom_,
  });
})();

export type RoomVisibility = InstanceType<
  (typeof RoomVisibility)[keyof Omit<typeof RoomVisibility, 'instanceOf'>]
>;

// FfiConverter for enum RoomVisibility
const FfiConverterTypeRoomVisibility = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomVisibility;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoomVisibility.Public();
        case 2:
          return new RoomVisibility.Private();
        case 3:
          return new RoomVisibility.Custom({
            value: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoomVisibility_Tags.Public: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoomVisibility_Tags.Private: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoomVisibility_Tags.Custom: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that RoomVisibility_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoomVisibility_Tags.Public: {
          return ordinalConverter.allocationSize(1);
        }
        case RoomVisibility_Tags.Private: {
          return ordinalConverter.allocationSize(2);
        }
        case RoomVisibility_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RtcApplicationType {
  Call,
}

const FfiConverterTypeRtcApplicationType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RtcApplicationType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RtcApplicationType.Call;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RtcApplicationType.Call:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RuleKind
export enum RuleKind_Tags {
  Override = 'Override',
  Underride = 'Underride',
  Sender = 'Sender',
  Room = 'Room',
  Content = 'Content',
  Custom = 'Custom',
}
export const RuleKind = (() => {
  type Override__interface = {
    tag: RuleKind_Tags.Override;
  };

  /**
   * User-configured rules that override all other kinds.
   */
  class Override_ extends UniffiEnum implements Override__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RuleKind';
    readonly tag = RuleKind_Tags.Override;
    constructor() {
      super('RuleKind', 'Override');
    }

    static new(): Override_ {
      return new Override_();
    }

    static instanceOf(obj: any): obj is Override_ {
      return obj.tag === RuleKind_Tags.Override;
    }
  }

  type Underride__interface = {
    tag: RuleKind_Tags.Underride;
  };

  /**
   * Lowest priority user-defined rules.
   */
  class Underride_ extends UniffiEnum implements Underride__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RuleKind';
    readonly tag = RuleKind_Tags.Underride;
    constructor() {
      super('RuleKind', 'Underride');
    }

    static new(): Underride_ {
      return new Underride_();
    }

    static instanceOf(obj: any): obj is Underride_ {
      return obj.tag === RuleKind_Tags.Underride;
    }
  }

  type Sender__interface = {
    tag: RuleKind_Tags.Sender;
  };

  /**
   * Sender-specific rules.
   */
  class Sender_ extends UniffiEnum implements Sender__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RuleKind';
    readonly tag = RuleKind_Tags.Sender;
    constructor() {
      super('RuleKind', 'Sender');
    }

    static new(): Sender_ {
      return new Sender_();
    }

    static instanceOf(obj: any): obj is Sender_ {
      return obj.tag === RuleKind_Tags.Sender;
    }
  }

  type Room__interface = {
    tag: RuleKind_Tags.Room;
  };

  /**
   * Room-specific rules.
   */
  class Room_ extends UniffiEnum implements Room__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RuleKind';
    readonly tag = RuleKind_Tags.Room;
    constructor() {
      super('RuleKind', 'Room');
    }

    static new(): Room_ {
      return new Room_();
    }

    static instanceOf(obj: any): obj is Room_ {
      return obj.tag === RuleKind_Tags.Room;
    }
  }

  type Content__interface = {
    tag: RuleKind_Tags.Content;
  };

  /**
   * Content-specific rules.
   */
  class Content_ extends UniffiEnum implements Content__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RuleKind';
    readonly tag = RuleKind_Tags.Content;
    constructor() {
      super('RuleKind', 'Content');
    }

    static new(): Content_ {
      return new Content_();
    }

    static instanceOf(obj: any): obj is Content_ {
      return obj.tag === RuleKind_Tags.Content;
    }
  }

  type Custom__interface = {
    tag: RuleKind_Tags.Custom;
    inner: Readonly<{ value: string }>;
  };

  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RuleKind';
    readonly tag = RuleKind_Tags.Custom;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('RuleKind', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === RuleKind_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is RuleKind {
    return obj[uniffiTypeNameSymbol] === 'RuleKind';
  }

  return Object.freeze({
    instanceOf,
    Override: Override_,
    Underride: Underride_,
    Sender: Sender_,
    Room: Room_,
    Content: Content_,
    Custom: Custom_,
  });
})();

export type RuleKind = InstanceType<
  (typeof RuleKind)[keyof Omit<typeof RuleKind, 'instanceOf'>]
>;

// FfiConverter for enum RuleKind
const FfiConverterTypeRuleKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RuleKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RuleKind.Override();
        case 2:
          return new RuleKind.Underride();
        case 3:
          return new RuleKind.Sender();
        case 4:
          return new RuleKind.Room();
        case 5:
          return new RuleKind.Content();
        case 6:
          return new RuleKind.Custom({ value: FfiConverterString.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RuleKind_Tags.Override: {
          ordinalConverter.write(1, into);
          return;
        }
        case RuleKind_Tags.Underride: {
          ordinalConverter.write(2, into);
          return;
        }
        case RuleKind_Tags.Sender: {
          ordinalConverter.write(3, into);
          return;
        }
        case RuleKind_Tags.Room: {
          ordinalConverter.write(4, into);
          return;
        }
        case RuleKind_Tags.Content: {
          ordinalConverter.write(5, into);
          return;
        }
        case RuleKind_Tags.Custom: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that RuleKind_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RuleKind_Tags.Override: {
          return ordinalConverter.allocationSize(1);
        }
        case RuleKind_Tags.Underride: {
          return ordinalConverter.allocationSize(2);
        }
        case RuleKind_Tags.Sender: {
          return ordinalConverter.allocationSize(3);
        }
        case RuleKind_Tags.Room: {
          return ordinalConverter.allocationSize(4);
        }
        case RuleKind_Tags.Content: {
          return ordinalConverter.allocationSize(5);
        }
        case RuleKind_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SecretStorageEncryptionAlgorithm
export enum SecretStorageEncryptionAlgorithm_Tags {
  V1AesHmacSha2 = 'V1AesHmacSha2',
}
/**
 * An algorithm and its properties, used to encrypt a secret.
 */
export const SecretStorageEncryptionAlgorithm = (() => {
  type V1AesHmacSha2__interface = {
    tag: SecretStorageEncryptionAlgorithm_Tags.V1AesHmacSha2;
    inner: Readonly<{ properties: SecretStorageV1AesHmacSha2Properties }>;
  };

  /**
   * Encrypted using the `m.secret_storage.v1.aes-hmac-sha2` algorithm.
   *
   * Secrets using this method are encrypted using AES-CTR-256 and
   * authenticated using HMAC-SHA-256.
   */
  class V1AesHmacSha2_ extends UniffiEnum implements V1AesHmacSha2__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SecretStorageEncryptionAlgorithm';
    readonly tag = SecretStorageEncryptionAlgorithm_Tags.V1AesHmacSha2;
    readonly inner: Readonly<{
      properties: SecretStorageV1AesHmacSha2Properties;
    }>;
    constructor(inner: { properties: SecretStorageV1AesHmacSha2Properties }) {
      super('SecretStorageEncryptionAlgorithm', 'V1AesHmacSha2');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      properties: SecretStorageV1AesHmacSha2Properties;
    }): V1AesHmacSha2_ {
      return new V1AesHmacSha2_(inner);
    }

    static instanceOf(obj: any): obj is V1AesHmacSha2_ {
      return obj.tag === SecretStorageEncryptionAlgorithm_Tags.V1AesHmacSha2;
    }
  }

  function instanceOf(obj: any): obj is SecretStorageEncryptionAlgorithm {
    return obj[uniffiTypeNameSymbol] === 'SecretStorageEncryptionAlgorithm';
  }

  return Object.freeze({
    instanceOf,
    V1AesHmacSha2: V1AesHmacSha2_,
  });
})();

/**
 * An algorithm and its properties, used to encrypt a secret.
 */

export type SecretStorageEncryptionAlgorithm = InstanceType<
  (typeof SecretStorageEncryptionAlgorithm)[keyof Omit<
    typeof SecretStorageEncryptionAlgorithm,
    'instanceOf'
  >]
>;

// FfiConverter for enum SecretStorageEncryptionAlgorithm
const FfiConverterTypeSecretStorageEncryptionAlgorithm = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SecretStorageEncryptionAlgorithm;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SecretStorageEncryptionAlgorithm.V1AesHmacSha2({
            properties:
              FfiConverterTypeSecretStorageV1AesHmacSha2Properties.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SecretStorageEncryptionAlgorithm_Tags.V1AesHmacSha2: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeSecretStorageV1AesHmacSha2Properties.write(
            inner.properties,
            into
          );
          return;
        }
        default:
          // Throwing from here means that SecretStorageEncryptionAlgorithm_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SecretStorageEncryptionAlgorithm_Tags.V1AesHmacSha2: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size +=
            FfiConverterTypeSecretStorageV1AesHmacSha2Properties.allocationSize(
              inner.properties
            );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SessionVerificationData
export enum SessionVerificationData_Tags {
  Emojis = 'Emojis',
  Decimals = 'Decimals',
}
export const SessionVerificationData = (() => {
  type Emojis__interface = {
    tag: SessionVerificationData_Tags.Emojis;
    inner: Readonly<{
      emojis: Array<SessionVerificationEmojiInterface>;
      indices: ArrayBuffer;
    }>;
  };

  class Emojis_ extends UniffiEnum implements Emojis__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionVerificationData';
    readonly tag = SessionVerificationData_Tags.Emojis;
    readonly inner: Readonly<{
      emojis: Array<SessionVerificationEmojiInterface>;
      indices: ArrayBuffer;
    }>;
    constructor(inner: {
      emojis: Array<SessionVerificationEmojiInterface>;
      indices: ArrayBuffer;
    }) {
      super('SessionVerificationData', 'Emojis');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      emojis: Array<SessionVerificationEmojiInterface>;
      indices: ArrayBuffer;
    }): Emojis_ {
      return new Emojis_(inner);
    }

    static instanceOf(obj: any): obj is Emojis_ {
      return obj.tag === SessionVerificationData_Tags.Emojis;
    }
  }

  type Decimals__interface = {
    tag: SessionVerificationData_Tags.Decimals;
    inner: Readonly<{ values: Array</*u16*/ number> }>;
  };

  class Decimals_ extends UniffiEnum implements Decimals__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionVerificationData';
    readonly tag = SessionVerificationData_Tags.Decimals;
    readonly inner: Readonly<{ values: Array</*u16*/ number> }>;
    constructor(inner: { values: Array</*u16*/ number> }) {
      super('SessionVerificationData', 'Decimals');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { values: Array</*u16*/ number> }): Decimals_ {
      return new Decimals_(inner);
    }

    static instanceOf(obj: any): obj is Decimals_ {
      return obj.tag === SessionVerificationData_Tags.Decimals;
    }
  }

  function instanceOf(obj: any): obj is SessionVerificationData {
    return obj[uniffiTypeNameSymbol] === 'SessionVerificationData';
  }

  return Object.freeze({
    instanceOf,
    Emojis: Emojis_,
    Decimals: Decimals_,
  });
})();

export type SessionVerificationData = InstanceType<
  (typeof SessionVerificationData)[keyof Omit<
    typeof SessionVerificationData,
    'instanceOf'
  >]
>;

// FfiConverter for enum SessionVerificationData
const FfiConverterTypeSessionVerificationData = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SessionVerificationData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SessionVerificationData.Emojis({
            emojis: FfiConverterArrayTypeSessionVerificationEmoji.read(from),
            indices: FfiConverterArrayBuffer.read(from),
          });
        case 2:
          return new SessionVerificationData.Decimals({
            values: FfiConverterArrayUInt16.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SessionVerificationData_Tags.Emojis: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeSessionVerificationEmoji.write(
            inner.emojis,
            into
          );
          FfiConverterArrayBuffer.write(inner.indices, into);
          return;
        }
        case SessionVerificationData_Tags.Decimals: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayUInt16.write(inner.values, into);
          return;
        }
        default:
          // Throwing from here means that SessionVerificationData_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SessionVerificationData_Tags.Emojis: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeSessionVerificationEmoji.allocationSize(
            inner.emojis
          );
          size += FfiConverterArrayBuffer.allocationSize(inner.indices);
          return size;
        }
        case SessionVerificationData_Tags.Decimals: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayUInt16.allocationSize(inner.values);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ShieldState
export enum ShieldState_Tags {
  Red = 'Red',
  Grey = 'Grey',
  None = 'None',
}
/**
 * Recommended decorations for decrypted messages, representing the message's
 * authenticity properties.
 */
export const ShieldState = (() => {
  type Red__interface = {
    tag: ShieldState_Tags.Red;
    inner: Readonly<{ code: ShieldStateCode; message: string }>;
  };

  /**
   * A red shield with a tooltip containing the associated message should be
   * presented.
   */
  class Red_ extends UniffiEnum implements Red__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ShieldState';
    readonly tag = ShieldState_Tags.Red;
    readonly inner: Readonly<{ code: ShieldStateCode; message: string }>;
    constructor(inner: { code: ShieldStateCode; message: string }) {
      super('ShieldState', 'Red');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { code: ShieldStateCode; message: string }): Red_ {
      return new Red_(inner);
    }

    static instanceOf(obj: any): obj is Red_ {
      return obj.tag === ShieldState_Tags.Red;
    }
  }

  type Grey__interface = {
    tag: ShieldState_Tags.Grey;
    inner: Readonly<{ code: ShieldStateCode; message: string }>;
  };

  /**
   * A grey shield with a tooltip containing the associated message should be
   * presented.
   */
  class Grey_ extends UniffiEnum implements Grey__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ShieldState';
    readonly tag = ShieldState_Tags.Grey;
    readonly inner: Readonly<{ code: ShieldStateCode; message: string }>;
    constructor(inner: { code: ShieldStateCode; message: string }) {
      super('ShieldState', 'Grey');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { code: ShieldStateCode; message: string }): Grey_ {
      return new Grey_(inner);
    }

    static instanceOf(obj: any): obj is Grey_ {
      return obj.tag === ShieldState_Tags.Grey;
    }
  }

  type None__interface = {
    tag: ShieldState_Tags.None;
  };

  /**
   * No shield should be presented.
   */
  class None_ extends UniffiEnum implements None__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ShieldState';
    readonly tag = ShieldState_Tags.None;
    constructor() {
      super('ShieldState', 'None');
    }

    static new(): None_ {
      return new None_();
    }

    static instanceOf(obj: any): obj is None_ {
      return obj.tag === ShieldState_Tags.None;
    }
  }

  function instanceOf(obj: any): obj is ShieldState {
    return obj[uniffiTypeNameSymbol] === 'ShieldState';
  }

  return Object.freeze({
    instanceOf,
    Red: Red_,
    Grey: Grey_,
    None: None_,
  });
})();

/**
 * Recommended decorations for decrypted messages, representing the message's
 * authenticity properties.
 */

export type ShieldState = InstanceType<
  (typeof ShieldState)[keyof Omit<typeof ShieldState, 'instanceOf'>]
>;

// FfiConverter for enum ShieldState
const FfiConverterTypeShieldState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ShieldState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ShieldState.Red({
            code: FfiConverterTypeShieldStateCode.read(from),
            message: FfiConverterString.read(from),
          });
        case 2:
          return new ShieldState.Grey({
            code: FfiConverterTypeShieldStateCode.read(from),
            message: FfiConverterString.read(from),
          });
        case 3:
          return new ShieldState.None();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ShieldState_Tags.Red: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeShieldStateCode.write(inner.code, into);
          FfiConverterString.write(inner.message, into);
          return;
        }
        case ShieldState_Tags.Grey: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeShieldStateCode.write(inner.code, into);
          FfiConverterString.write(inner.message, into);
          return;
        }
        case ShieldState_Tags.None: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that ShieldState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ShieldState_Tags.Red: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeShieldStateCode.allocationSize(inner.code);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case ShieldState_Tags.Grey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeShieldStateCode.allocationSize(inner.code);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case ShieldState_Tags.None: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum SlidingSyncVersion {
  None,
  Native,
}

const FfiConverterTypeSlidingSyncVersion = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SlidingSyncVersion;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SlidingSyncVersion.None;
        case 2:
          return SlidingSyncVersion.Native;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case SlidingSyncVersion.None:
          return ordinalConverter.write(1, into);
        case SlidingSyncVersion.Native:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum SlidingSyncVersionBuilder {
  None,
  Native,
  DiscoverNative,
}

const FfiConverterTypeSlidingSyncVersionBuilder = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SlidingSyncVersionBuilder;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SlidingSyncVersionBuilder.None;
        case 2:
          return SlidingSyncVersionBuilder.Native;
        case 3:
          return SlidingSyncVersionBuilder.DiscoverNative;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case SlidingSyncVersionBuilder.None:
          return ordinalConverter.write(1, into);
        case SlidingSyncVersionBuilder.Native:
          return ordinalConverter.write(2, into);
        case SlidingSyncVersionBuilder.DiscoverNative:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: SsoError
export enum SsoError_Tags {
  CallbackUrlInvalid = 'CallbackUrlInvalid',
  LoginWithTokenFailed = 'LoginWithTokenFailed',
  Generic = 'Generic',
}
export const SsoError = (() => {
  class CallbackUrlInvalid extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SsoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = SsoError_Tags.CallbackUrlInvalid;

    constructor(message: string) {
      super('SsoError', 'CallbackUrlInvalid', message);
    }

    static instanceOf(e: any): e is CallbackUrlInvalid {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class LoginWithTokenFailed extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SsoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = SsoError_Tags.LoginWithTokenFailed;

    constructor(message: string) {
      super('SsoError', 'LoginWithTokenFailed', message);
    }

    static instanceOf(e: any): e is LoginWithTokenFailed {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SsoError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = SsoError_Tags.Generic;

    constructor(message: string) {
      super('SsoError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is SsoError {
    return (e as any)[uniffiTypeNameSymbol] === 'SsoError';
  }
  return {
    CallbackUrlInvalid,
    LoginWithTokenFailed,
    Generic,
    instanceOf,
  };
})();

// Union type for SsoError error type.

export type SsoError = InstanceType<
  (typeof SsoError)[keyof Omit<typeof SsoError, 'instanceOf'>]
>;

const FfiConverterTypeSsoError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = SsoError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new SsoError.CallbackUrlInvalid(FfiConverterString.read(from));

        case 2:
          return new SsoError.LoginWithTokenFailed(
            FfiConverterString.read(from)
          );

        case 3:
          return new SsoError.Generic(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: StateEventContent
export enum StateEventContent_Tags {
  PolicyRuleRoom = 'PolicyRuleRoom',
  PolicyRuleServer = 'PolicyRuleServer',
  PolicyRuleUser = 'PolicyRuleUser',
  RoomAliases = 'RoomAliases',
  RoomAvatar = 'RoomAvatar',
  RoomCanonicalAlias = 'RoomCanonicalAlias',
  RoomCreate = 'RoomCreate',
  RoomEncryption = 'RoomEncryption',
  RoomGuestAccess = 'RoomGuestAccess',
  RoomHistoryVisibility = 'RoomHistoryVisibility',
  RoomJoinRules = 'RoomJoinRules',
  RoomMemberContent = 'RoomMemberContent',
  RoomName = 'RoomName',
  RoomPinnedEvents = 'RoomPinnedEvents',
  RoomPowerLevels = 'RoomPowerLevels',
  RoomServerAcl = 'RoomServerAcl',
  RoomThirdPartyInvite = 'RoomThirdPartyInvite',
  RoomTombstone = 'RoomTombstone',
  RoomTopic = 'RoomTopic',
  SpaceChild = 'SpaceChild',
  SpaceParent = 'SpaceParent',
}
export const StateEventContent = (() => {
  type PolicyRuleRoom__interface = {
    tag: StateEventContent_Tags.PolicyRuleRoom;
  };

  class PolicyRuleRoom_
    extends UniffiEnum
    implements PolicyRuleRoom__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.PolicyRuleRoom;
    constructor() {
      super('StateEventContent', 'PolicyRuleRoom');
    }

    static new(): PolicyRuleRoom_ {
      return new PolicyRuleRoom_();
    }

    static instanceOf(obj: any): obj is PolicyRuleRoom_ {
      return obj.tag === StateEventContent_Tags.PolicyRuleRoom;
    }
  }

  type PolicyRuleServer__interface = {
    tag: StateEventContent_Tags.PolicyRuleServer;
  };

  class PolicyRuleServer_
    extends UniffiEnum
    implements PolicyRuleServer__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.PolicyRuleServer;
    constructor() {
      super('StateEventContent', 'PolicyRuleServer');
    }

    static new(): PolicyRuleServer_ {
      return new PolicyRuleServer_();
    }

    static instanceOf(obj: any): obj is PolicyRuleServer_ {
      return obj.tag === StateEventContent_Tags.PolicyRuleServer;
    }
  }

  type PolicyRuleUser__interface = {
    tag: StateEventContent_Tags.PolicyRuleUser;
  };

  class PolicyRuleUser_
    extends UniffiEnum
    implements PolicyRuleUser__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.PolicyRuleUser;
    constructor() {
      super('StateEventContent', 'PolicyRuleUser');
    }

    static new(): PolicyRuleUser_ {
      return new PolicyRuleUser_();
    }

    static instanceOf(obj: any): obj is PolicyRuleUser_ {
      return obj.tag === StateEventContent_Tags.PolicyRuleUser;
    }
  }

  type RoomAliases__interface = {
    tag: StateEventContent_Tags.RoomAliases;
  };

  class RoomAliases_ extends UniffiEnum implements RoomAliases__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomAliases;
    constructor() {
      super('StateEventContent', 'RoomAliases');
    }

    static new(): RoomAliases_ {
      return new RoomAliases_();
    }

    static instanceOf(obj: any): obj is RoomAliases_ {
      return obj.tag === StateEventContent_Tags.RoomAliases;
    }
  }

  type RoomAvatar__interface = {
    tag: StateEventContent_Tags.RoomAvatar;
  };

  class RoomAvatar_ extends UniffiEnum implements RoomAvatar__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomAvatar;
    constructor() {
      super('StateEventContent', 'RoomAvatar');
    }

    static new(): RoomAvatar_ {
      return new RoomAvatar_();
    }

    static instanceOf(obj: any): obj is RoomAvatar_ {
      return obj.tag === StateEventContent_Tags.RoomAvatar;
    }
  }

  type RoomCanonicalAlias__interface = {
    tag: StateEventContent_Tags.RoomCanonicalAlias;
  };

  class RoomCanonicalAlias_
    extends UniffiEnum
    implements RoomCanonicalAlias__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomCanonicalAlias;
    constructor() {
      super('StateEventContent', 'RoomCanonicalAlias');
    }

    static new(): RoomCanonicalAlias_ {
      return new RoomCanonicalAlias_();
    }

    static instanceOf(obj: any): obj is RoomCanonicalAlias_ {
      return obj.tag === StateEventContent_Tags.RoomCanonicalAlias;
    }
  }

  type RoomCreate__interface = {
    tag: StateEventContent_Tags.RoomCreate;
  };

  class RoomCreate_ extends UniffiEnum implements RoomCreate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomCreate;
    constructor() {
      super('StateEventContent', 'RoomCreate');
    }

    static new(): RoomCreate_ {
      return new RoomCreate_();
    }

    static instanceOf(obj: any): obj is RoomCreate_ {
      return obj.tag === StateEventContent_Tags.RoomCreate;
    }
  }

  type RoomEncryption__interface = {
    tag: StateEventContent_Tags.RoomEncryption;
  };

  class RoomEncryption_
    extends UniffiEnum
    implements RoomEncryption__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomEncryption;
    constructor() {
      super('StateEventContent', 'RoomEncryption');
    }

    static new(): RoomEncryption_ {
      return new RoomEncryption_();
    }

    static instanceOf(obj: any): obj is RoomEncryption_ {
      return obj.tag === StateEventContent_Tags.RoomEncryption;
    }
  }

  type RoomGuestAccess__interface = {
    tag: StateEventContent_Tags.RoomGuestAccess;
  };

  class RoomGuestAccess_
    extends UniffiEnum
    implements RoomGuestAccess__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomGuestAccess;
    constructor() {
      super('StateEventContent', 'RoomGuestAccess');
    }

    static new(): RoomGuestAccess_ {
      return new RoomGuestAccess_();
    }

    static instanceOf(obj: any): obj is RoomGuestAccess_ {
      return obj.tag === StateEventContent_Tags.RoomGuestAccess;
    }
  }

  type RoomHistoryVisibility__interface = {
    tag: StateEventContent_Tags.RoomHistoryVisibility;
  };

  class RoomHistoryVisibility_
    extends UniffiEnum
    implements RoomHistoryVisibility__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomHistoryVisibility;
    constructor() {
      super('StateEventContent', 'RoomHistoryVisibility');
    }

    static new(): RoomHistoryVisibility_ {
      return new RoomHistoryVisibility_();
    }

    static instanceOf(obj: any): obj is RoomHistoryVisibility_ {
      return obj.tag === StateEventContent_Tags.RoomHistoryVisibility;
    }
  }

  type RoomJoinRules__interface = {
    tag: StateEventContent_Tags.RoomJoinRules;
  };

  class RoomJoinRules_ extends UniffiEnum implements RoomJoinRules__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomJoinRules;
    constructor() {
      super('StateEventContent', 'RoomJoinRules');
    }

    static new(): RoomJoinRules_ {
      return new RoomJoinRules_();
    }

    static instanceOf(obj: any): obj is RoomJoinRules_ {
      return obj.tag === StateEventContent_Tags.RoomJoinRules;
    }
  }

  type RoomMemberContent__interface = {
    tag: StateEventContent_Tags.RoomMemberContent;
    inner: Readonly<{ userId: string; membershipState: MembershipState }>;
  };

  class RoomMemberContent_
    extends UniffiEnum
    implements RoomMemberContent__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomMemberContent;
    readonly inner: Readonly<{
      userId: string;
      membershipState: MembershipState;
    }>;
    constructor(inner: { userId: string; membershipState: MembershipState }) {
      super('StateEventContent', 'RoomMemberContent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      userId: string;
      membershipState: MembershipState;
    }): RoomMemberContent_ {
      return new RoomMemberContent_(inner);
    }

    static instanceOf(obj: any): obj is RoomMemberContent_ {
      return obj.tag === StateEventContent_Tags.RoomMemberContent;
    }
  }

  type RoomName__interface = {
    tag: StateEventContent_Tags.RoomName;
  };

  class RoomName_ extends UniffiEnum implements RoomName__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomName;
    constructor() {
      super('StateEventContent', 'RoomName');
    }

    static new(): RoomName_ {
      return new RoomName_();
    }

    static instanceOf(obj: any): obj is RoomName_ {
      return obj.tag === StateEventContent_Tags.RoomName;
    }
  }

  type RoomPinnedEvents__interface = {
    tag: StateEventContent_Tags.RoomPinnedEvents;
  };

  class RoomPinnedEvents_
    extends UniffiEnum
    implements RoomPinnedEvents__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomPinnedEvents;
    constructor() {
      super('StateEventContent', 'RoomPinnedEvents');
    }

    static new(): RoomPinnedEvents_ {
      return new RoomPinnedEvents_();
    }

    static instanceOf(obj: any): obj is RoomPinnedEvents_ {
      return obj.tag === StateEventContent_Tags.RoomPinnedEvents;
    }
  }

  type RoomPowerLevels__interface = {
    tag: StateEventContent_Tags.RoomPowerLevels;
  };

  class RoomPowerLevels_
    extends UniffiEnum
    implements RoomPowerLevels__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomPowerLevels;
    constructor() {
      super('StateEventContent', 'RoomPowerLevels');
    }

    static new(): RoomPowerLevels_ {
      return new RoomPowerLevels_();
    }

    static instanceOf(obj: any): obj is RoomPowerLevels_ {
      return obj.tag === StateEventContent_Tags.RoomPowerLevels;
    }
  }

  type RoomServerAcl__interface = {
    tag: StateEventContent_Tags.RoomServerAcl;
  };

  class RoomServerAcl_ extends UniffiEnum implements RoomServerAcl__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomServerAcl;
    constructor() {
      super('StateEventContent', 'RoomServerAcl');
    }

    static new(): RoomServerAcl_ {
      return new RoomServerAcl_();
    }

    static instanceOf(obj: any): obj is RoomServerAcl_ {
      return obj.tag === StateEventContent_Tags.RoomServerAcl;
    }
  }

  type RoomThirdPartyInvite__interface = {
    tag: StateEventContent_Tags.RoomThirdPartyInvite;
  };

  class RoomThirdPartyInvite_
    extends UniffiEnum
    implements RoomThirdPartyInvite__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomThirdPartyInvite;
    constructor() {
      super('StateEventContent', 'RoomThirdPartyInvite');
    }

    static new(): RoomThirdPartyInvite_ {
      return new RoomThirdPartyInvite_();
    }

    static instanceOf(obj: any): obj is RoomThirdPartyInvite_ {
      return obj.tag === StateEventContent_Tags.RoomThirdPartyInvite;
    }
  }

  type RoomTombstone__interface = {
    tag: StateEventContent_Tags.RoomTombstone;
  };

  class RoomTombstone_ extends UniffiEnum implements RoomTombstone__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomTombstone;
    constructor() {
      super('StateEventContent', 'RoomTombstone');
    }

    static new(): RoomTombstone_ {
      return new RoomTombstone_();
    }

    static instanceOf(obj: any): obj is RoomTombstone_ {
      return obj.tag === StateEventContent_Tags.RoomTombstone;
    }
  }

  type RoomTopic__interface = {
    tag: StateEventContent_Tags.RoomTopic;
    inner: Readonly<{ topic: string }>;
  };

  class RoomTopic_ extends UniffiEnum implements RoomTopic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.RoomTopic;
    readonly inner: Readonly<{ topic: string }>;
    constructor(inner: { topic: string }) {
      super('StateEventContent', 'RoomTopic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { topic: string }): RoomTopic_ {
      return new RoomTopic_(inner);
    }

    static instanceOf(obj: any): obj is RoomTopic_ {
      return obj.tag === StateEventContent_Tags.RoomTopic;
    }
  }

  type SpaceChild__interface = {
    tag: StateEventContent_Tags.SpaceChild;
  };

  class SpaceChild_ extends UniffiEnum implements SpaceChild__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.SpaceChild;
    constructor() {
      super('StateEventContent', 'SpaceChild');
    }

    static new(): SpaceChild_ {
      return new SpaceChild_();
    }

    static instanceOf(obj: any): obj is SpaceChild_ {
      return obj.tag === StateEventContent_Tags.SpaceChild;
    }
  }

  type SpaceParent__interface = {
    tag: StateEventContent_Tags.SpaceParent;
  };

  class SpaceParent_ extends UniffiEnum implements SpaceParent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StateEventContent';
    readonly tag = StateEventContent_Tags.SpaceParent;
    constructor() {
      super('StateEventContent', 'SpaceParent');
    }

    static new(): SpaceParent_ {
      return new SpaceParent_();
    }

    static instanceOf(obj: any): obj is SpaceParent_ {
      return obj.tag === StateEventContent_Tags.SpaceParent;
    }
  }

  function instanceOf(obj: any): obj is StateEventContent {
    return obj[uniffiTypeNameSymbol] === 'StateEventContent';
  }

  return Object.freeze({
    instanceOf,
    PolicyRuleRoom: PolicyRuleRoom_,
    PolicyRuleServer: PolicyRuleServer_,
    PolicyRuleUser: PolicyRuleUser_,
    RoomAliases: RoomAliases_,
    RoomAvatar: RoomAvatar_,
    RoomCanonicalAlias: RoomCanonicalAlias_,
    RoomCreate: RoomCreate_,
    RoomEncryption: RoomEncryption_,
    RoomGuestAccess: RoomGuestAccess_,
    RoomHistoryVisibility: RoomHistoryVisibility_,
    RoomJoinRules: RoomJoinRules_,
    RoomMemberContent: RoomMemberContent_,
    RoomName: RoomName_,
    RoomPinnedEvents: RoomPinnedEvents_,
    RoomPowerLevels: RoomPowerLevels_,
    RoomServerAcl: RoomServerAcl_,
    RoomThirdPartyInvite: RoomThirdPartyInvite_,
    RoomTombstone: RoomTombstone_,
    RoomTopic: RoomTopic_,
    SpaceChild: SpaceChild_,
    SpaceParent: SpaceParent_,
  });
})();

export type StateEventContent = InstanceType<
  (typeof StateEventContent)[keyof Omit<typeof StateEventContent, 'instanceOf'>]
>;

// FfiConverter for enum StateEventContent
const FfiConverterTypeStateEventContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StateEventContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new StateEventContent.PolicyRuleRoom();
        case 2:
          return new StateEventContent.PolicyRuleServer();
        case 3:
          return new StateEventContent.PolicyRuleUser();
        case 4:
          return new StateEventContent.RoomAliases();
        case 5:
          return new StateEventContent.RoomAvatar();
        case 6:
          return new StateEventContent.RoomCanonicalAlias();
        case 7:
          return new StateEventContent.RoomCreate();
        case 8:
          return new StateEventContent.RoomEncryption();
        case 9:
          return new StateEventContent.RoomGuestAccess();
        case 10:
          return new StateEventContent.RoomHistoryVisibility();
        case 11:
          return new StateEventContent.RoomJoinRules();
        case 12:
          return new StateEventContent.RoomMemberContent({
            userId: FfiConverterString.read(from),
            membershipState: FfiConverterTypeMembershipState.read(from),
          });
        case 13:
          return new StateEventContent.RoomName();
        case 14:
          return new StateEventContent.RoomPinnedEvents();
        case 15:
          return new StateEventContent.RoomPowerLevels();
        case 16:
          return new StateEventContent.RoomServerAcl();
        case 17:
          return new StateEventContent.RoomThirdPartyInvite();
        case 18:
          return new StateEventContent.RoomTombstone();
        case 19:
          return new StateEventContent.RoomTopic({
            topic: FfiConverterString.read(from),
          });
        case 20:
          return new StateEventContent.SpaceChild();
        case 21:
          return new StateEventContent.SpaceParent();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case StateEventContent_Tags.PolicyRuleRoom: {
          ordinalConverter.write(1, into);
          return;
        }
        case StateEventContent_Tags.PolicyRuleServer: {
          ordinalConverter.write(2, into);
          return;
        }
        case StateEventContent_Tags.PolicyRuleUser: {
          ordinalConverter.write(3, into);
          return;
        }
        case StateEventContent_Tags.RoomAliases: {
          ordinalConverter.write(4, into);
          return;
        }
        case StateEventContent_Tags.RoomAvatar: {
          ordinalConverter.write(5, into);
          return;
        }
        case StateEventContent_Tags.RoomCanonicalAlias: {
          ordinalConverter.write(6, into);
          return;
        }
        case StateEventContent_Tags.RoomCreate: {
          ordinalConverter.write(7, into);
          return;
        }
        case StateEventContent_Tags.RoomEncryption: {
          ordinalConverter.write(8, into);
          return;
        }
        case StateEventContent_Tags.RoomGuestAccess: {
          ordinalConverter.write(9, into);
          return;
        }
        case StateEventContent_Tags.RoomHistoryVisibility: {
          ordinalConverter.write(10, into);
          return;
        }
        case StateEventContent_Tags.RoomJoinRules: {
          ordinalConverter.write(11, into);
          return;
        }
        case StateEventContent_Tags.RoomMemberContent: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterString.write(inner.userId, into);
          FfiConverterTypeMembershipState.write(inner.membershipState, into);
          return;
        }
        case StateEventContent_Tags.RoomName: {
          ordinalConverter.write(13, into);
          return;
        }
        case StateEventContent_Tags.RoomPinnedEvents: {
          ordinalConverter.write(14, into);
          return;
        }
        case StateEventContent_Tags.RoomPowerLevels: {
          ordinalConverter.write(15, into);
          return;
        }
        case StateEventContent_Tags.RoomServerAcl: {
          ordinalConverter.write(16, into);
          return;
        }
        case StateEventContent_Tags.RoomThirdPartyInvite: {
          ordinalConverter.write(17, into);
          return;
        }
        case StateEventContent_Tags.RoomTombstone: {
          ordinalConverter.write(18, into);
          return;
        }
        case StateEventContent_Tags.RoomTopic: {
          ordinalConverter.write(19, into);
          const inner = value.inner;
          FfiConverterString.write(inner.topic, into);
          return;
        }
        case StateEventContent_Tags.SpaceChild: {
          ordinalConverter.write(20, into);
          return;
        }
        case StateEventContent_Tags.SpaceParent: {
          ordinalConverter.write(21, into);
          return;
        }
        default:
          // Throwing from here means that StateEventContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case StateEventContent_Tags.PolicyRuleRoom: {
          return ordinalConverter.allocationSize(1);
        }
        case StateEventContent_Tags.PolicyRuleServer: {
          return ordinalConverter.allocationSize(2);
        }
        case StateEventContent_Tags.PolicyRuleUser: {
          return ordinalConverter.allocationSize(3);
        }
        case StateEventContent_Tags.RoomAliases: {
          return ordinalConverter.allocationSize(4);
        }
        case StateEventContent_Tags.RoomAvatar: {
          return ordinalConverter.allocationSize(5);
        }
        case StateEventContent_Tags.RoomCanonicalAlias: {
          return ordinalConverter.allocationSize(6);
        }
        case StateEventContent_Tags.RoomCreate: {
          return ordinalConverter.allocationSize(7);
        }
        case StateEventContent_Tags.RoomEncryption: {
          return ordinalConverter.allocationSize(8);
        }
        case StateEventContent_Tags.RoomGuestAccess: {
          return ordinalConverter.allocationSize(9);
        }
        case StateEventContent_Tags.RoomHistoryVisibility: {
          return ordinalConverter.allocationSize(10);
        }
        case StateEventContent_Tags.RoomJoinRules: {
          return ordinalConverter.allocationSize(11);
        }
        case StateEventContent_Tags.RoomMemberContent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterString.allocationSize(inner.userId);
          size += FfiConverterTypeMembershipState.allocationSize(
            inner.membershipState
          );
          return size;
        }
        case StateEventContent_Tags.RoomName: {
          return ordinalConverter.allocationSize(13);
        }
        case StateEventContent_Tags.RoomPinnedEvents: {
          return ordinalConverter.allocationSize(14);
        }
        case StateEventContent_Tags.RoomPowerLevels: {
          return ordinalConverter.allocationSize(15);
        }
        case StateEventContent_Tags.RoomServerAcl: {
          return ordinalConverter.allocationSize(16);
        }
        case StateEventContent_Tags.RoomThirdPartyInvite: {
          return ordinalConverter.allocationSize(17);
        }
        case StateEventContent_Tags.RoomTombstone: {
          return ordinalConverter.allocationSize(18);
        }
        case StateEventContent_Tags.RoomTopic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(19);
          size += FfiConverterString.allocationSize(inner.topic);
          return size;
        }
        case StateEventContent_Tags.SpaceChild: {
          return ordinalConverter.allocationSize(20);
        }
        case StateEventContent_Tags.SpaceParent: {
          return ordinalConverter.allocationSize(21);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum StateEventType {
  CallMember,
  PolicyRuleRoom,
  PolicyRuleServer,
  PolicyRuleUser,
  RoomAliases,
  RoomAvatar,
  RoomCanonicalAlias,
  RoomCreate,
  RoomEncryption,
  RoomGuestAccess,
  RoomHistoryVisibility,
  RoomJoinRules,
  RoomMemberEvent,
  RoomName,
  RoomPinnedEvents,
  RoomPowerLevels,
  RoomServerAcl,
  RoomThirdPartyInvite,
  RoomTombstone,
  RoomTopic,
  SpaceChild,
  SpaceParent,
}

const FfiConverterTypeStateEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StateEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return StateEventType.CallMember;
        case 2:
          return StateEventType.PolicyRuleRoom;
        case 3:
          return StateEventType.PolicyRuleServer;
        case 4:
          return StateEventType.PolicyRuleUser;
        case 5:
          return StateEventType.RoomAliases;
        case 6:
          return StateEventType.RoomAvatar;
        case 7:
          return StateEventType.RoomCanonicalAlias;
        case 8:
          return StateEventType.RoomCreate;
        case 9:
          return StateEventType.RoomEncryption;
        case 10:
          return StateEventType.RoomGuestAccess;
        case 11:
          return StateEventType.RoomHistoryVisibility;
        case 12:
          return StateEventType.RoomJoinRules;
        case 13:
          return StateEventType.RoomMemberEvent;
        case 14:
          return StateEventType.RoomName;
        case 15:
          return StateEventType.RoomPinnedEvents;
        case 16:
          return StateEventType.RoomPowerLevels;
        case 17:
          return StateEventType.RoomServerAcl;
        case 18:
          return StateEventType.RoomThirdPartyInvite;
        case 19:
          return StateEventType.RoomTombstone;
        case 20:
          return StateEventType.RoomTopic;
        case 21:
          return StateEventType.SpaceChild;
        case 22:
          return StateEventType.SpaceParent;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case StateEventType.CallMember:
          return ordinalConverter.write(1, into);
        case StateEventType.PolicyRuleRoom:
          return ordinalConverter.write(2, into);
        case StateEventType.PolicyRuleServer:
          return ordinalConverter.write(3, into);
        case StateEventType.PolicyRuleUser:
          return ordinalConverter.write(4, into);
        case StateEventType.RoomAliases:
          return ordinalConverter.write(5, into);
        case StateEventType.RoomAvatar:
          return ordinalConverter.write(6, into);
        case StateEventType.RoomCanonicalAlias:
          return ordinalConverter.write(7, into);
        case StateEventType.RoomCreate:
          return ordinalConverter.write(8, into);
        case StateEventType.RoomEncryption:
          return ordinalConverter.write(9, into);
        case StateEventType.RoomGuestAccess:
          return ordinalConverter.write(10, into);
        case StateEventType.RoomHistoryVisibility:
          return ordinalConverter.write(11, into);
        case StateEventType.RoomJoinRules:
          return ordinalConverter.write(12, into);
        case StateEventType.RoomMemberEvent:
          return ordinalConverter.write(13, into);
        case StateEventType.RoomName:
          return ordinalConverter.write(14, into);
        case StateEventType.RoomPinnedEvents:
          return ordinalConverter.write(15, into);
        case StateEventType.RoomPowerLevels:
          return ordinalConverter.write(16, into);
        case StateEventType.RoomServerAcl:
          return ordinalConverter.write(17, into);
        case StateEventType.RoomThirdPartyInvite:
          return ordinalConverter.write(18, into);
        case StateEventType.RoomTombstone:
          return ordinalConverter.write(19, into);
        case StateEventType.RoomTopic:
          return ordinalConverter.write(20, into);
        case StateEventType.SpaceChild:
          return ordinalConverter.write(21, into);
        case StateEventType.SpaceParent:
          return ordinalConverter.write(22, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: SteadyStateError
export enum SteadyStateError_Tags {
  BackupDisabled = 'BackupDisabled',
  Connection = 'Connection',
  Lagged = 'Lagged',
}
export const SteadyStateError = (() => {
  class BackupDisabled extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SteadyStateError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = SteadyStateError_Tags.BackupDisabled;

    constructor(message: string) {
      super('SteadyStateError', 'BackupDisabled', message);
    }

    static instanceOf(e: any): e is BackupDisabled {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class Connection extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SteadyStateError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = SteadyStateError_Tags.Connection;

    constructor(message: string) {
      super('SteadyStateError', 'Connection', message);
    }

    static instanceOf(e: any): e is Connection {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class Lagged extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'SteadyStateError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = SteadyStateError_Tags.Lagged;

    constructor(message: string) {
      super('SteadyStateError', 'Lagged', message);
    }

    static instanceOf(e: any): e is Lagged {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is SteadyStateError {
    return (e as any)[uniffiTypeNameSymbol] === 'SteadyStateError';
  }
  return {
    BackupDisabled,
    Connection,
    Lagged,
    instanceOf,
  };
})();

// Union type for SteadyStateError error type.

export type SteadyStateError = InstanceType<
  (typeof SteadyStateError)[keyof Omit<typeof SteadyStateError, 'instanceOf'>]
>;

const FfiConverterTypeSteadyStateError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = SteadyStateError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new SteadyStateError.BackupDisabled(
            FfiConverterString.read(from)
          );

        case 2:
          return new SteadyStateError.Connection(FfiConverterString.read(from));

        case 3:
          return new SteadyStateError.Lagged(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum SyncServiceState {
  Idle,
  Running,
  Terminated,
  Error,
  Offline,
}

const FfiConverterTypeSyncServiceState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SyncServiceState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SyncServiceState.Idle;
        case 2:
          return SyncServiceState.Running;
        case 3:
          return SyncServiceState.Terminated;
        case 4:
          return SyncServiceState.Error;
        case 5:
          return SyncServiceState.Offline;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case SyncServiceState.Idle:
          return ordinalConverter.write(1, into);
        case SyncServiceState.Running:
          return ordinalConverter.write(2, into);
        case SyncServiceState.Terminated:
          return ordinalConverter.write(3, into);
        case SyncServiceState.Error:
          return ordinalConverter.write(4, into);
        case SyncServiceState.Offline:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: TagName
export enum TagName_Tags {
  Favorite = 'Favorite',
  LowPriority = 'LowPriority',
  ServerNotice = 'ServerNotice',
  User = 'User',
}
/**
 * The name of a tag.
 */
export const TagName = (() => {
  type Favorite__interface = {
    tag: TagName_Tags.Favorite;
  };

  /**
   * `m.favourite`: The user's favorite rooms.
   */
  class Favorite_ extends UniffiEnum implements Favorite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagName';
    readonly tag = TagName_Tags.Favorite;
    constructor() {
      super('TagName', 'Favorite');
    }

    static new(): Favorite_ {
      return new Favorite_();
    }

    static instanceOf(obj: any): obj is Favorite_ {
      return obj.tag === TagName_Tags.Favorite;
    }
  }

  type LowPriority__interface = {
    tag: TagName_Tags.LowPriority;
  };

  /**
   * `m.lowpriority`: These should be shown with lower precedence than
   * others.
   */
  class LowPriority_ extends UniffiEnum implements LowPriority__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagName';
    readonly tag = TagName_Tags.LowPriority;
    constructor() {
      super('TagName', 'LowPriority');
    }

    static new(): LowPriority_ {
      return new LowPriority_();
    }

    static instanceOf(obj: any): obj is LowPriority_ {
      return obj.tag === TagName_Tags.LowPriority;
    }
  }

  type ServerNotice__interface = {
    tag: TagName_Tags.ServerNotice;
  };

  /**
   * `m.server_notice`: Used to identify
   */
  class ServerNotice_ extends UniffiEnum implements ServerNotice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagName';
    readonly tag = TagName_Tags.ServerNotice;
    constructor() {
      super('TagName', 'ServerNotice');
    }

    static new(): ServerNotice_ {
      return new ServerNotice_();
    }

    static instanceOf(obj: any): obj is ServerNotice_ {
      return obj.tag === TagName_Tags.ServerNotice;
    }
  }

  type User__interface = {
    tag: TagName_Tags.User;
    inner: Readonly<{ name: UserTagName }>;
  };

  /**
   * `u.*`: User-defined tag
   */
  class User_ extends UniffiEnum implements User__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagName';
    readonly tag = TagName_Tags.User;
    readonly inner: Readonly<{ name: UserTagName }>;
    constructor(inner: { name: UserTagName }) {
      super('TagName', 'User');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { name: UserTagName }): User_ {
      return new User_(inner);
    }

    static instanceOf(obj: any): obj is User_ {
      return obj.tag === TagName_Tags.User;
    }
  }

  function instanceOf(obj: any): obj is TagName {
    return obj[uniffiTypeNameSymbol] === 'TagName';
  }

  return Object.freeze({
    instanceOf,
    Favorite: Favorite_,
    LowPriority: LowPriority_,
    ServerNotice: ServerNotice_,
    User: User_,
  });
})();

/**
 * The name of a tag.
 */

export type TagName = InstanceType<
  (typeof TagName)[keyof Omit<typeof TagName, 'instanceOf'>]
>;

// FfiConverter for enum TagName
const FfiConverterTypeTagName = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TagName;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TagName.Favorite();
        case 2:
          return new TagName.LowPriority();
        case 3:
          return new TagName.ServerNotice();
        case 4:
          return new TagName.User({
            name: FfiConverterTypeUserTagName.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TagName_Tags.Favorite: {
          ordinalConverter.write(1, into);
          return;
        }
        case TagName_Tags.LowPriority: {
          ordinalConverter.write(2, into);
          return;
        }
        case TagName_Tags.ServerNotice: {
          ordinalConverter.write(3, into);
          return;
        }
        case TagName_Tags.User: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeUserTagName.write(inner.name, into);
          return;
        }
        default:
          // Throwing from here means that TagName_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TagName_Tags.Favorite: {
          return ordinalConverter.allocationSize(1);
        }
        case TagName_Tags.LowPriority: {
          return ordinalConverter.allocationSize(2);
        }
        case TagName_Tags.ServerNotice: {
          return ordinalConverter.allocationSize(3);
        }
        case TagName_Tags.User: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeUserTagName.allocationSize(inner.name);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum TimelineChange {
  Append,
  Clear,
  Insert,
  Set,
  Remove,
  PushBack,
  PushFront,
  PopBack,
  PopFront,
  Truncate,
  Reset,
}

const FfiConverterTypeTimelineChange = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TimelineChange.Append;
        case 2:
          return TimelineChange.Clear;
        case 3:
          return TimelineChange.Insert;
        case 4:
          return TimelineChange.Set;
        case 5:
          return TimelineChange.Remove;
        case 6:
          return TimelineChange.PushBack;
        case 7:
          return TimelineChange.PushFront;
        case 8:
          return TimelineChange.PopBack;
        case 9:
          return TimelineChange.PopFront;
        case 10:
          return TimelineChange.Truncate;
        case 11:
          return TimelineChange.Reset;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case TimelineChange.Append:
          return ordinalConverter.write(1, into);
        case TimelineChange.Clear:
          return ordinalConverter.write(2, into);
        case TimelineChange.Insert:
          return ordinalConverter.write(3, into);
        case TimelineChange.Set:
          return ordinalConverter.write(4, into);
        case TimelineChange.Remove:
          return ordinalConverter.write(5, into);
        case TimelineChange.PushBack:
          return ordinalConverter.write(6, into);
        case TimelineChange.PushFront:
          return ordinalConverter.write(7, into);
        case TimelineChange.PopBack:
          return ordinalConverter.write(8, into);
        case TimelineChange.PopFront:
          return ordinalConverter.write(9, into);
        case TimelineChange.Truncate:
          return ordinalConverter.write(10, into);
        case TimelineChange.Reset:
          return ordinalConverter.write(11, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: TimelineEventType
export enum TimelineEventType_Tags {
  MessageLike = 'MessageLike',
  State = 'State',
}
export const TimelineEventType = (() => {
  type MessageLike__interface = {
    tag: TimelineEventType_Tags.MessageLike;
    inner: Readonly<{ content: MessageLikeEventContent }>;
  };

  class MessageLike_ extends UniffiEnum implements MessageLike__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineEventType';
    readonly tag = TimelineEventType_Tags.MessageLike;
    readonly inner: Readonly<{ content: MessageLikeEventContent }>;
    constructor(inner: { content: MessageLikeEventContent }) {
      super('TimelineEventType', 'MessageLike');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: MessageLikeEventContent }): MessageLike_ {
      return new MessageLike_(inner);
    }

    static instanceOf(obj: any): obj is MessageLike_ {
      return obj.tag === TimelineEventType_Tags.MessageLike;
    }
  }

  type State__interface = {
    tag: TimelineEventType_Tags.State;
    inner: Readonly<{ content: StateEventContent }>;
  };

  class State_ extends UniffiEnum implements State__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineEventType';
    readonly tag = TimelineEventType_Tags.State;
    readonly inner: Readonly<{ content: StateEventContent }>;
    constructor(inner: { content: StateEventContent }) {
      super('TimelineEventType', 'State');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: StateEventContent }): State_ {
      return new State_(inner);
    }

    static instanceOf(obj: any): obj is State_ {
      return obj.tag === TimelineEventType_Tags.State;
    }
  }

  function instanceOf(obj: any): obj is TimelineEventType {
    return obj[uniffiTypeNameSymbol] === 'TimelineEventType';
  }

  return Object.freeze({
    instanceOf,
    MessageLike: MessageLike_,
    State: State_,
  });
})();

export type TimelineEventType = InstanceType<
  (typeof TimelineEventType)[keyof Omit<typeof TimelineEventType, 'instanceOf'>]
>;

// FfiConverter for enum TimelineEventType
const FfiConverterTypeTimelineEventType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineEventType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TimelineEventType.MessageLike({
            content: FfiConverterTypeMessageLikeEventContent.read(from),
          });
        case 2:
          return new TimelineEventType.State({
            content: FfiConverterTypeStateEventContent.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TimelineEventType_Tags.MessageLike: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeMessageLikeEventContent.write(inner.content, into);
          return;
        }
        case TimelineEventType_Tags.State: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeStateEventContent.write(inner.content, into);
          return;
        }
        default:
          // Throwing from here means that TimelineEventType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TimelineEventType_Tags.MessageLike: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeMessageLikeEventContent.allocationSize(
            inner.content
          );
          return size;
        }
        case TimelineEventType_Tags.State: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeStateEventContent.allocationSize(
            inner.content
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: TimelineFilter
export enum TimelineFilter_Tags {
  All = 'All',
  OnlyMessage = 'OnlyMessage',
  EventTypeFilter = 'EventTypeFilter',
}
export const TimelineFilter = (() => {
  type All__interface = {
    tag: TimelineFilter_Tags.All;
  };

  /**
   * Show all the events in the timeline, independent of their type.
   */
  class All_ extends UniffiEnum implements All__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineFilter';
    readonly tag = TimelineFilter_Tags.All;
    constructor() {
      super('TimelineFilter', 'All');
    }

    static new(): All_ {
      return new All_();
    }

    static instanceOf(obj: any): obj is All_ {
      return obj.tag === TimelineFilter_Tags.All;
    }
  }

  type OnlyMessage__interface = {
    tag: TimelineFilter_Tags.OnlyMessage;
    inner: Readonly<{ types: Array<RoomMessageEventMessageType> }>;
  };

  /**
   * Show only `m.room.messages` of the given room message types.
   */
  class OnlyMessage_ extends UniffiEnum implements OnlyMessage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineFilter';
    readonly tag = TimelineFilter_Tags.OnlyMessage;
    readonly inner: Readonly<{ types: Array<RoomMessageEventMessageType> }>;
    constructor(inner: {
      /**
       * A list of [`RoomMessageEventMessageType`] that will be allowed to
       * appear in the timeline.
       */ types: Array<RoomMessageEventMessageType>;
    }) {
      super('TimelineFilter', 'OnlyMessage');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * A list of [`RoomMessageEventMessageType`] that will be allowed to
       * appear in the timeline.
       */ types: Array<RoomMessageEventMessageType>;
    }): OnlyMessage_ {
      return new OnlyMessage_(inner);
    }

    static instanceOf(obj: any): obj is OnlyMessage_ {
      return obj.tag === TimelineFilter_Tags.OnlyMessage;
    }
  }

  type EventTypeFilter__interface = {
    tag: TimelineFilter_Tags.EventTypeFilter;
    inner: Readonly<{ filter: TimelineEventTypeFilterInterface }>;
  };

  /**
   * Show only events which match this filter.
   */
  class EventTypeFilter_
    extends UniffiEnum
    implements EventTypeFilter__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineFilter';
    readonly tag = TimelineFilter_Tags.EventTypeFilter;
    readonly inner: Readonly<{ filter: TimelineEventTypeFilterInterface }>;
    constructor(inner: { filter: TimelineEventTypeFilterInterface }) {
      super('TimelineFilter', 'EventTypeFilter');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      filter: TimelineEventTypeFilterInterface;
    }): EventTypeFilter_ {
      return new EventTypeFilter_(inner);
    }

    static instanceOf(obj: any): obj is EventTypeFilter_ {
      return obj.tag === TimelineFilter_Tags.EventTypeFilter;
    }
  }

  function instanceOf(obj: any): obj is TimelineFilter {
    return obj[uniffiTypeNameSymbol] === 'TimelineFilter';
  }

  return Object.freeze({
    instanceOf,
    All: All_,
    OnlyMessage: OnlyMessage_,
    EventTypeFilter: EventTypeFilter_,
  });
})();

export type TimelineFilter = InstanceType<
  (typeof TimelineFilter)[keyof Omit<typeof TimelineFilter, 'instanceOf'>]
>;

// FfiConverter for enum TimelineFilter
const FfiConverterTypeTimelineFilter = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineFilter;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TimelineFilter.All();
        case 2:
          return new TimelineFilter.OnlyMessage({
            types: FfiConverterArrayTypeRoomMessageEventMessageType.read(from),
          });
        case 3:
          return new TimelineFilter.EventTypeFilter({
            filter: FfiConverterTypeTimelineEventTypeFilter.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TimelineFilter_Tags.All: {
          ordinalConverter.write(1, into);
          return;
        }
        case TimelineFilter_Tags.OnlyMessage: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayTypeRoomMessageEventMessageType.write(
            inner.types,
            into
          );
          return;
        }
        case TimelineFilter_Tags.EventTypeFilter: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeTimelineEventTypeFilter.write(inner.filter, into);
          return;
        }
        default:
          // Throwing from here means that TimelineFilter_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TimelineFilter_Tags.All: {
          return ordinalConverter.allocationSize(1);
        }
        case TimelineFilter_Tags.OnlyMessage: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size +=
            FfiConverterArrayTypeRoomMessageEventMessageType.allocationSize(
              inner.types
            );
          return size;
        }
        case TimelineFilter_Tags.EventTypeFilter: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeTimelineEventTypeFilter.allocationSize(
            inner.filter
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: TimelineFocus
export enum TimelineFocus_Tags {
  Live = 'Live',
  Event = 'Event',
  Thread = 'Thread',
  PinnedEvents = 'PinnedEvents',
}
export const TimelineFocus = (() => {
  type Live__interface = {
    tag: TimelineFocus_Tags.Live;
    inner: Readonly<{ hideThreadedEvents: boolean }>;
  };

  class Live_ extends UniffiEnum implements Live__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineFocus';
    readonly tag = TimelineFocus_Tags.Live;
    readonly inner: Readonly<{ hideThreadedEvents: boolean }>;
    constructor(inner: {
      /**
       * Whether to hide in-thread replies from the live timeline.
       */ hideThreadedEvents: boolean;
    }) {
      super('TimelineFocus', 'Live');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Whether to hide in-thread replies from the live timeline.
       */ hideThreadedEvents: boolean;
    }): Live_ {
      return new Live_(inner);
    }

    static instanceOf(obj: any): obj is Live_ {
      return obj.tag === TimelineFocus_Tags.Live;
    }
  }

  type Event__interface = {
    tag: TimelineFocus_Tags.Event;
    inner: Readonly<{
      eventId: string;
      numContextEvents: /*u16*/ number;
      hideThreadedEvents: boolean;
    }>;
  };

  class Event_ extends UniffiEnum implements Event__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineFocus';
    readonly tag = TimelineFocus_Tags.Event;
    readonly inner: Readonly<{
      eventId: string;
      numContextEvents: /*u16*/ number;
      hideThreadedEvents: boolean;
    }>;
    constructor(inner: {
      /**
       * The initial event to focus on. This is usually the target of a
       * permalink.
       */ eventId: string;
      /**
       * The number of context events to load around the focused event.
       */ numContextEvents: /*u16*/ number;
      /**
       * Whether to hide in-thread replies from the live timeline.
       */ hideThreadedEvents: boolean;
    }) {
      super('TimelineFocus', 'Event');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The initial event to focus on. This is usually the target of a
       * permalink.
       */ eventId: string;
      /**
       * The number of context events to load around the focused event.
       */ numContextEvents: /*u16*/ number;
      /**
       * Whether to hide in-thread replies from the live timeline.
       */ hideThreadedEvents: boolean;
    }): Event_ {
      return new Event_(inner);
    }

    static instanceOf(obj: any): obj is Event_ {
      return obj.tag === TimelineFocus_Tags.Event;
    }
  }

  type Thread__interface = {
    tag: TimelineFocus_Tags.Thread;
    inner: Readonly<{ rootEventId: string; numEvents: /*u16*/ number }>;
  };

  class Thread_ extends UniffiEnum implements Thread__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineFocus';
    readonly tag = TimelineFocus_Tags.Thread;
    readonly inner: Readonly<{
      rootEventId: string;
      numEvents: /*u16*/ number;
    }>;
    constructor(inner: {
      /**
       * The thread root event ID to focus on.
       */ rootEventId: string;
      numEvents: /*u16*/ number;
    }) {
      super('TimelineFocus', 'Thread');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The thread root event ID to focus on.
       */ rootEventId: string;
      numEvents: /*u16*/ number;
    }): Thread_ {
      return new Thread_(inner);
    }

    static instanceOf(obj: any): obj is Thread_ {
      return obj.tag === TimelineFocus_Tags.Thread;
    }
  }

  type PinnedEvents__interface = {
    tag: TimelineFocus_Tags.PinnedEvents;
    inner: Readonly<{
      maxEventsToLoad: /*u16*/ number;
      maxConcurrentRequests: /*u16*/ number;
    }>;
  };

  class PinnedEvents_ extends UniffiEnum implements PinnedEvents__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineFocus';
    readonly tag = TimelineFocus_Tags.PinnedEvents;
    readonly inner: Readonly<{
      maxEventsToLoad: /*u16*/ number;
      maxConcurrentRequests: /*u16*/ number;
    }>;
    constructor(inner: {
      maxEventsToLoad: /*u16*/ number;
      maxConcurrentRequests: /*u16*/ number;
    }) {
      super('TimelineFocus', 'PinnedEvents');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      maxEventsToLoad: /*u16*/ number;
      maxConcurrentRequests: /*u16*/ number;
    }): PinnedEvents_ {
      return new PinnedEvents_(inner);
    }

    static instanceOf(obj: any): obj is PinnedEvents_ {
      return obj.tag === TimelineFocus_Tags.PinnedEvents;
    }
  }

  function instanceOf(obj: any): obj is TimelineFocus {
    return obj[uniffiTypeNameSymbol] === 'TimelineFocus';
  }

  return Object.freeze({
    instanceOf,
    Live: Live_,
    Event: Event_,
    Thread: Thread_,
    PinnedEvents: PinnedEvents_,
  });
})();

export type TimelineFocus = InstanceType<
  (typeof TimelineFocus)[keyof Omit<typeof TimelineFocus, 'instanceOf'>]
>;

// FfiConverter for enum TimelineFocus
const FfiConverterTypeTimelineFocus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineFocus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TimelineFocus.Live({
            hideThreadedEvents: FfiConverterBool.read(from),
          });
        case 2:
          return new TimelineFocus.Event({
            eventId: FfiConverterString.read(from),
            numContextEvents: FfiConverterUInt16.read(from),
            hideThreadedEvents: FfiConverterBool.read(from),
          });
        case 3:
          return new TimelineFocus.Thread({
            rootEventId: FfiConverterString.read(from),
            numEvents: FfiConverterUInt16.read(from),
          });
        case 4:
          return new TimelineFocus.PinnedEvents({
            maxEventsToLoad: FfiConverterUInt16.read(from),
            maxConcurrentRequests: FfiConverterUInt16.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TimelineFocus_Tags.Live: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.hideThreadedEvents, into);
          return;
        }
        case TimelineFocus_Tags.Event: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventId, into);
          FfiConverterUInt16.write(inner.numContextEvents, into);
          FfiConverterBool.write(inner.hideThreadedEvents, into);
          return;
        }
        case TimelineFocus_Tags.Thread: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.rootEventId, into);
          FfiConverterUInt16.write(inner.numEvents, into);
          return;
        }
        case TimelineFocus_Tags.PinnedEvents: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterUInt16.write(inner.maxEventsToLoad, into);
          FfiConverterUInt16.write(inner.maxConcurrentRequests, into);
          return;
        }
        default:
          // Throwing from here means that TimelineFocus_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TimelineFocus_Tags.Live: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterBool.allocationSize(inner.hideThreadedEvents);
          return size;
        }
        case TimelineFocus_Tags.Event: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.eventId);
          size += FfiConverterUInt16.allocationSize(inner.numContextEvents);
          size += FfiConverterBool.allocationSize(inner.hideThreadedEvents);
          return size;
        }
        case TimelineFocus_Tags.Thread: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.rootEventId);
          size += FfiConverterUInt16.allocationSize(inner.numEvents);
          return size;
        }
        case TimelineFocus_Tags.PinnedEvents: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterUInt16.allocationSize(inner.maxEventsToLoad);
          size += FfiConverterUInt16.allocationSize(
            inner.maxConcurrentRequests
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: TimelineItemContent
export enum TimelineItemContent_Tags {
  MsgLike = 'MsgLike',
  CallInvite = 'CallInvite',
  CallNotify = 'CallNotify',
  RoomMembership = 'RoomMembership',
  ProfileChange = 'ProfileChange',
  State = 'State',
  FailedToParseMessageLike = 'FailedToParseMessageLike',
  FailedToParseState = 'FailedToParseState',
}
export const TimelineItemContent = (() => {
  type MsgLike__interface = {
    tag: TimelineItemContent_Tags.MsgLike;
    inner: Readonly<{ content: MsgLikeContent }>;
  };

  class MsgLike_ extends UniffiEnum implements MsgLike__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.MsgLike;
    readonly inner: Readonly<{ content: MsgLikeContent }>;
    constructor(inner: { content: MsgLikeContent }) {
      super('TimelineItemContent', 'MsgLike');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { content: MsgLikeContent }): MsgLike_ {
      return new MsgLike_(inner);
    }

    static instanceOf(obj: any): obj is MsgLike_ {
      return obj.tag === TimelineItemContent_Tags.MsgLike;
    }
  }

  type CallInvite__interface = {
    tag: TimelineItemContent_Tags.CallInvite;
  };

  class CallInvite_ extends UniffiEnum implements CallInvite__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.CallInvite;
    constructor() {
      super('TimelineItemContent', 'CallInvite');
    }

    static new(): CallInvite_ {
      return new CallInvite_();
    }

    static instanceOf(obj: any): obj is CallInvite_ {
      return obj.tag === TimelineItemContent_Tags.CallInvite;
    }
  }

  type CallNotify__interface = {
    tag: TimelineItemContent_Tags.CallNotify;
  };

  class CallNotify_ extends UniffiEnum implements CallNotify__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.CallNotify;
    constructor() {
      super('TimelineItemContent', 'CallNotify');
    }

    static new(): CallNotify_ {
      return new CallNotify_();
    }

    static instanceOf(obj: any): obj is CallNotify_ {
      return obj.tag === TimelineItemContent_Tags.CallNotify;
    }
  }

  type RoomMembership__interface = {
    tag: TimelineItemContent_Tags.RoomMembership;
    inner: Readonly<{
      userId: string;
      userDisplayName: string | undefined;
      change: MembershipChange | undefined;
      reason: string | undefined;
    }>;
  };

  class RoomMembership_
    extends UniffiEnum
    implements RoomMembership__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.RoomMembership;
    readonly inner: Readonly<{
      userId: string;
      userDisplayName: string | undefined;
      change: MembershipChange | undefined;
      reason: string | undefined;
    }>;
    constructor(inner: {
      userId: string;
      userDisplayName: string | undefined;
      change: MembershipChange | undefined;
      reason: string | undefined;
    }) {
      super('TimelineItemContent', 'RoomMembership');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      userId: string;
      userDisplayName: string | undefined;
      change: MembershipChange | undefined;
      reason: string | undefined;
    }): RoomMembership_ {
      return new RoomMembership_(inner);
    }

    static instanceOf(obj: any): obj is RoomMembership_ {
      return obj.tag === TimelineItemContent_Tags.RoomMembership;
    }
  }

  type ProfileChange__interface = {
    tag: TimelineItemContent_Tags.ProfileChange;
    inner: Readonly<{
      displayName: string | undefined;
      prevDisplayName: string | undefined;
      avatarUrl: string | undefined;
      prevAvatarUrl: string | undefined;
    }>;
  };

  class ProfileChange_ extends UniffiEnum implements ProfileChange__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.ProfileChange;
    readonly inner: Readonly<{
      displayName: string | undefined;
      prevDisplayName: string | undefined;
      avatarUrl: string | undefined;
      prevAvatarUrl: string | undefined;
    }>;
    constructor(inner: {
      displayName: string | undefined;
      prevDisplayName: string | undefined;
      avatarUrl: string | undefined;
      prevAvatarUrl: string | undefined;
    }) {
      super('TimelineItemContent', 'ProfileChange');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      displayName: string | undefined;
      prevDisplayName: string | undefined;
      avatarUrl: string | undefined;
      prevAvatarUrl: string | undefined;
    }): ProfileChange_ {
      return new ProfileChange_(inner);
    }

    static instanceOf(obj: any): obj is ProfileChange_ {
      return obj.tag === TimelineItemContent_Tags.ProfileChange;
    }
  }

  type State__interface = {
    tag: TimelineItemContent_Tags.State;
    inner: Readonly<{ stateKey: string; content: OtherState }>;
  };

  class State_ extends UniffiEnum implements State__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.State;
    readonly inner: Readonly<{ stateKey: string; content: OtherState }>;
    constructor(inner: { stateKey: string; content: OtherState }) {
      super('TimelineItemContent', 'State');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { stateKey: string; content: OtherState }): State_ {
      return new State_(inner);
    }

    static instanceOf(obj: any): obj is State_ {
      return obj.tag === TimelineItemContent_Tags.State;
    }
  }

  type FailedToParseMessageLike__interface = {
    tag: TimelineItemContent_Tags.FailedToParseMessageLike;
    inner: Readonly<{ eventType: string; error: string }>;
  };

  class FailedToParseMessageLike_
    extends UniffiEnum
    implements FailedToParseMessageLike__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.FailedToParseMessageLike;
    readonly inner: Readonly<{ eventType: string; error: string }>;
    constructor(inner: { eventType: string; error: string }) {
      super('TimelineItemContent', 'FailedToParseMessageLike');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventType: string;
      error: string;
    }): FailedToParseMessageLike_ {
      return new FailedToParseMessageLike_(inner);
    }

    static instanceOf(obj: any): obj is FailedToParseMessageLike_ {
      return obj.tag === TimelineItemContent_Tags.FailedToParseMessageLike;
    }
  }

  type FailedToParseState__interface = {
    tag: TimelineItemContent_Tags.FailedToParseState;
    inner: Readonly<{ eventType: string; stateKey: string; error: string }>;
  };

  class FailedToParseState_
    extends UniffiEnum
    implements FailedToParseState__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TimelineItemContent';
    readonly tag = TimelineItemContent_Tags.FailedToParseState;
    readonly inner: Readonly<{
      eventType: string;
      stateKey: string;
      error: string;
    }>;
    constructor(inner: { eventType: string; stateKey: string; error: string }) {
      super('TimelineItemContent', 'FailedToParseState');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventType: string;
      stateKey: string;
      error: string;
    }): FailedToParseState_ {
      return new FailedToParseState_(inner);
    }

    static instanceOf(obj: any): obj is FailedToParseState_ {
      return obj.tag === TimelineItemContent_Tags.FailedToParseState;
    }
  }

  function instanceOf(obj: any): obj is TimelineItemContent {
    return obj[uniffiTypeNameSymbol] === 'TimelineItemContent';
  }

  return Object.freeze({
    instanceOf,
    MsgLike: MsgLike_,
    CallInvite: CallInvite_,
    CallNotify: CallNotify_,
    RoomMembership: RoomMembership_,
    ProfileChange: ProfileChange_,
    State: State_,
    FailedToParseMessageLike: FailedToParseMessageLike_,
    FailedToParseState: FailedToParseState_,
  });
})();

export type TimelineItemContent = InstanceType<
  (typeof TimelineItemContent)[keyof Omit<
    typeof TimelineItemContent,
    'instanceOf'
  >]
>;

// FfiConverter for enum TimelineItemContent
const FfiConverterTypeTimelineItemContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TimelineItemContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TimelineItemContent.MsgLike({
            content: FfiConverterTypeMsgLikeContent.read(from),
          });
        case 2:
          return new TimelineItemContent.CallInvite();
        case 3:
          return new TimelineItemContent.CallNotify();
        case 4:
          return new TimelineItemContent.RoomMembership({
            userId: FfiConverterString.read(from),
            userDisplayName: FfiConverterOptionalString.read(from),
            change: FfiConverterOptionalTypeMembershipChange.read(from),
            reason: FfiConverterOptionalString.read(from),
          });
        case 5:
          return new TimelineItemContent.ProfileChange({
            displayName: FfiConverterOptionalString.read(from),
            prevDisplayName: FfiConverterOptionalString.read(from),
            avatarUrl: FfiConverterOptionalString.read(from),
            prevAvatarUrl: FfiConverterOptionalString.read(from),
          });
        case 6:
          return new TimelineItemContent.State({
            stateKey: FfiConverterString.read(from),
            content: FfiConverterTypeOtherState.read(from),
          });
        case 7:
          return new TimelineItemContent.FailedToParseMessageLike({
            eventType: FfiConverterString.read(from),
            error: FfiConverterString.read(from),
          });
        case 8:
          return new TimelineItemContent.FailedToParseState({
            eventType: FfiConverterString.read(from),
            stateKey: FfiConverterString.read(from),
            error: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TimelineItemContent_Tags.MsgLike: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeMsgLikeContent.write(inner.content, into);
          return;
        }
        case TimelineItemContent_Tags.CallInvite: {
          ordinalConverter.write(2, into);
          return;
        }
        case TimelineItemContent_Tags.CallNotify: {
          ordinalConverter.write(3, into);
          return;
        }
        case TimelineItemContent_Tags.RoomMembership: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.userId, into);
          FfiConverterOptionalString.write(inner.userDisplayName, into);
          FfiConverterOptionalTypeMembershipChange.write(inner.change, into);
          FfiConverterOptionalString.write(inner.reason, into);
          return;
        }
        case TimelineItemContent_Tags.ProfileChange: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.displayName, into);
          FfiConverterOptionalString.write(inner.prevDisplayName, into);
          FfiConverterOptionalString.write(inner.avatarUrl, into);
          FfiConverterOptionalString.write(inner.prevAvatarUrl, into);
          return;
        }
        case TimelineItemContent_Tags.State: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.stateKey, into);
          FfiConverterTypeOtherState.write(inner.content, into);
          return;
        }
        case TimelineItemContent_Tags.FailedToParseMessageLike: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          FfiConverterString.write(inner.error, into);
          return;
        }
        case TimelineItemContent_Tags.FailedToParseState: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          FfiConverterString.write(inner.stateKey, into);
          FfiConverterString.write(inner.error, into);
          return;
        }
        default:
          // Throwing from here means that TimelineItemContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TimelineItemContent_Tags.MsgLike: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeMsgLikeContent.allocationSize(inner.content);
          return size;
        }
        case TimelineItemContent_Tags.CallInvite: {
          return ordinalConverter.allocationSize(2);
        }
        case TimelineItemContent_Tags.CallNotify: {
          return ordinalConverter.allocationSize(3);
        }
        case TimelineItemContent_Tags.RoomMembership: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.userId);
          size += FfiConverterOptionalString.allocationSize(
            inner.userDisplayName
          );
          size += FfiConverterOptionalTypeMembershipChange.allocationSize(
            inner.change
          );
          size += FfiConverterOptionalString.allocationSize(inner.reason);
          return size;
        }
        case TimelineItemContent_Tags.ProfileChange: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterOptionalString.allocationSize(inner.displayName);
          size += FfiConverterOptionalString.allocationSize(
            inner.prevDisplayName
          );
          size += FfiConverterOptionalString.allocationSize(inner.avatarUrl);
          size += FfiConverterOptionalString.allocationSize(
            inner.prevAvatarUrl
          );
          return size;
        }
        case TimelineItemContent_Tags.State: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.stateKey);
          size += FfiConverterTypeOtherState.allocationSize(inner.content);
          return size;
        }
        case TimelineItemContent_Tags.FailedToParseMessageLike: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.eventType);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case TimelineItemContent_Tags.FailedToParseState: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner.eventType);
          size += FfiConverterString.allocationSize(inner.stateKey);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * A log pack can be used to set the trace log level for a group of multiple
 * log targets at once, for debugging purposes.
 */
export enum TraceLogPacks {
  /**
   * Enables all the logs relevant to the event cache.
   */
  EventCache,
  /**
   * Enables all the logs relevant to the send queue.
   */
  SendQueue,
  /**
   * Enables all the logs relevant to the timeline.
   */
  Timeline,
}

const FfiConverterTypeTraceLogPacks = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TraceLogPacks;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TraceLogPacks.EventCache;
        case 2:
          return TraceLogPacks.SendQueue;
        case 3:
          return TraceLogPacks.Timeline;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case TraceLogPacks.EventCache:
          return ordinalConverter.write(1, into);
        case TraceLogPacks.SendQueue:
          return ordinalConverter.write(2, into);
        case TraceLogPacks.Timeline:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: Tweak
export enum Tweak_Tags {
  Sound = 'Sound',
  Highlight = 'Highlight',
  Custom = 'Custom',
}
/**
 * Enum representing the push notification tweaks for a rule.
 */
export const Tweak = (() => {
  type Sound__interface = {
    tag: Tweak_Tags.Sound;
    inner: Readonly<{ value: string }>;
  };

  /**
   * A string representing the sound to be played when this notification
   * arrives.
   *
   * A value of "default" means to play a default sound. A device may choose
   * to alert the user by some other means if appropriate, eg. vibration.
   */
  class Sound_ extends UniffiEnum implements Sound__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Tweak';
    readonly tag = Tweak_Tags.Sound;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('Tweak', 'Sound');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Sound_ {
      return new Sound_(inner);
    }

    static instanceOf(obj: any): obj is Sound_ {
      return obj.tag === Tweak_Tags.Sound;
    }
  }

  type Highlight__interface = {
    tag: Tweak_Tags.Highlight;
    inner: Readonly<{ value: boolean }>;
  };

  /**
   * A boolean representing whether or not this message should be highlighted
   * in the UI.
   */
  class Highlight_ extends UniffiEnum implements Highlight__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Tweak';
    readonly tag = Tweak_Tags.Highlight;
    readonly inner: Readonly<{ value: boolean }>;
    constructor(inner: { value: boolean }) {
      super('Tweak', 'Highlight');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: boolean }): Highlight_ {
      return new Highlight_(inner);
    }

    static instanceOf(obj: any): obj is Highlight_ {
      return obj.tag === Tweak_Tags.Highlight;
    }
  }

  type Custom__interface = {
    tag: Tweak_Tags.Custom;
    inner: Readonly<{ name: string; value: string }>;
  };

  /**
   * A custom tweak
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Tweak';
    readonly tag = Tweak_Tags.Custom;
    readonly inner: Readonly<{ name: string; value: string }>;
    constructor(inner: {
      /**
       * The name of the custom tweak (`set_tweak` field)
       */ name: string;
      /**
       * The value of the custom tweak as an encoded JSON string
       */ value: string;
    }) {
      super('Tweak', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The name of the custom tweak (`set_tweak` field)
       */ name: string;
      /**
       * The value of the custom tweak as an encoded JSON string
       */ value: string;
    }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === Tweak_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is Tweak {
    return obj[uniffiTypeNameSymbol] === 'Tweak';
  }

  return Object.freeze({
    instanceOf,
    Sound: Sound_,
    Highlight: Highlight_,
    Custom: Custom_,
  });
})();

/**
 * Enum representing the push notification tweaks for a rule.
 */

export type Tweak = InstanceType<
  (typeof Tweak)[keyof Omit<typeof Tweak, 'instanceOf'>]
>;

// FfiConverter for enum Tweak
const FfiConverterTypeTweak = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Tweak;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Tweak.Sound({ value: FfiConverterString.read(from) });
        case 2:
          return new Tweak.Highlight({ value: FfiConverterBool.read(from) });
        case 3:
          return new Tweak.Custom({
            name: FfiConverterString.read(from),
            value: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Tweak_Tags.Sound: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        case Tweak_Tags.Highlight: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.value, into);
          return;
        }
        case Tweak_Tags.Custom: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.name, into);
          FfiConverterString.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that Tweak_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Tweak_Tags.Sound: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        case Tweak_Tags.Highlight: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterBool.allocationSize(inner.value);
          return size;
        }
        case Tweak_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.name);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: UploadSource
export enum UploadSource_Tags {
  File = 'File',
  Data = 'Data',
}
/**
 * A source for uploading a file
 */
export const UploadSource = (() => {
  type File__interface = {
    tag: UploadSource_Tags.File;
    inner: Readonly<{ filename: string }>;
  };

  /**
   * Upload source is a file on disk
   */
  class File_ extends UniffiEnum implements File__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'UploadSource';
    readonly tag = UploadSource_Tags.File;
    readonly inner: Readonly<{ filename: string }>;
    constructor(inner: {
      /**
       * Path to file
       */ filename: string;
    }) {
      super('UploadSource', 'File');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Path to file
       */ filename: string;
    }): File_ {
      return new File_(inner);
    }

    static instanceOf(obj: any): obj is File_ {
      return obj.tag === UploadSource_Tags.File;
    }
  }

  type Data__interface = {
    tag: UploadSource_Tags.Data;
    inner: Readonly<{ bytes: ArrayBuffer; filename: string }>;
  };

  /**
   * Upload source is data in memory
   */
  class Data_ extends UniffiEnum implements Data__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'UploadSource';
    readonly tag = UploadSource_Tags.Data;
    readonly inner: Readonly<{ bytes: ArrayBuffer; filename: string }>;
    constructor(inner: {
      /**
       * Bytes being uploaded
       */ bytes: ArrayBuffer;
      /**
       * Filename to associate with bytes
       */ filename: string;
    }) {
      super('UploadSource', 'Data');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Bytes being uploaded
       */ bytes: ArrayBuffer;
      /**
       * Filename to associate with bytes
       */ filename: string;
    }): Data_ {
      return new Data_(inner);
    }

    static instanceOf(obj: any): obj is Data_ {
      return obj.tag === UploadSource_Tags.Data;
    }
  }

  function instanceOf(obj: any): obj is UploadSource {
    return obj[uniffiTypeNameSymbol] === 'UploadSource';
  }

  return Object.freeze({
    instanceOf,
    File: File_,
    Data: Data_,
  });
})();

/**
 * A source for uploading a file
 */

export type UploadSource = InstanceType<
  (typeof UploadSource)[keyof Omit<typeof UploadSource, 'instanceOf'>]
>;

// FfiConverter for enum UploadSource
const FfiConverterTypeUploadSource = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = UploadSource;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new UploadSource.File({
            filename: FfiConverterString.read(from),
          });
        case 2:
          return new UploadSource.Data({
            bytes: FfiConverterArrayBuffer.read(from),
            filename: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case UploadSource_Tags.File: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.filename, into);
          return;
        }
        case UploadSource_Tags.Data: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayBuffer.write(inner.bytes, into);
          FfiConverterString.write(inner.filename, into);
          return;
        }
        default:
          // Throwing from here means that UploadSource_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case UploadSource_Tags.File: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.filename);
          return size;
        }
        case UploadSource_Tags.Data: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayBuffer.allocationSize(inner.bytes);
          size += FfiConverterString.allocationSize(inner.filename);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum VerificationState {
  Unknown,
  Verified,
  Unverified,
}

const FfiConverterTypeVerificationState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = VerificationState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return VerificationState.Unknown;
        case 2:
          return VerificationState.Verified;
        case 3:
          return VerificationState.Unverified;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case VerificationState.Unknown:
          return ordinalConverter.write(1, into);
        case VerificationState.Verified:
          return ordinalConverter.write(2, into);
        case VerificationState.Unverified:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: VirtualTimelineItem
export enum VirtualTimelineItem_Tags {
  DateDivider = 'DateDivider',
  ReadMarker = 'ReadMarker',
  TimelineStart = 'TimelineStart',
}
/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */
export const VirtualTimelineItem = (() => {
  type DateDivider__interface = {
    tag: VirtualTimelineItem_Tags.DateDivider;
    inner: Readonly<{ ts: Timestamp }>;
  };

  /**
   * A divider between messages of different day or month depending on
   * timeline settings.
   */
  class DateDivider_ extends UniffiEnum implements DateDivider__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'VirtualTimelineItem';
    readonly tag = VirtualTimelineItem_Tags.DateDivider;
    readonly inner: Readonly<{ ts: Timestamp }>;
    constructor(inner: {
      /**
       * A timestamp in milliseconds since Unix Epoch on that day in local
       * time.
       */ ts: Timestamp;
    }) {
      super('VirtualTimelineItem', 'DateDivider');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * A timestamp in milliseconds since Unix Epoch on that day in local
       * time.
       */ ts: Timestamp;
    }): DateDivider_ {
      return new DateDivider_(inner);
    }

    static instanceOf(obj: any): obj is DateDivider_ {
      return obj.tag === VirtualTimelineItem_Tags.DateDivider;
    }
  }

  type ReadMarker__interface = {
    tag: VirtualTimelineItem_Tags.ReadMarker;
  };

  /**
   * The user's own read marker.
   */
  class ReadMarker_ extends UniffiEnum implements ReadMarker__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'VirtualTimelineItem';
    readonly tag = VirtualTimelineItem_Tags.ReadMarker;
    constructor() {
      super('VirtualTimelineItem', 'ReadMarker');
    }

    static new(): ReadMarker_ {
      return new ReadMarker_();
    }

    static instanceOf(obj: any): obj is ReadMarker_ {
      return obj.tag === VirtualTimelineItem_Tags.ReadMarker;
    }
  }

  type TimelineStart__interface = {
    tag: VirtualTimelineItem_Tags.TimelineStart;
  };

  /**
   * The timeline start, that is, the *oldest* event in time for that room.
   */
  class TimelineStart_ extends UniffiEnum implements TimelineStart__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'VirtualTimelineItem';
    readonly tag = VirtualTimelineItem_Tags.TimelineStart;
    constructor() {
      super('VirtualTimelineItem', 'TimelineStart');
    }

    static new(): TimelineStart_ {
      return new TimelineStart_();
    }

    static instanceOf(obj: any): obj is TimelineStart_ {
      return obj.tag === VirtualTimelineItem_Tags.TimelineStart;
    }
  }

  function instanceOf(obj: any): obj is VirtualTimelineItem {
    return obj[uniffiTypeNameSymbol] === 'VirtualTimelineItem';
  }

  return Object.freeze({
    instanceOf,
    DateDivider: DateDivider_,
    ReadMarker: ReadMarker_,
    TimelineStart: TimelineStart_,
  });
})();

/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */

export type VirtualTimelineItem = InstanceType<
  (typeof VirtualTimelineItem)[keyof Omit<
    typeof VirtualTimelineItem,
    'instanceOf'
  >]
>;

// FfiConverter for enum VirtualTimelineItem
const FfiConverterTypeVirtualTimelineItem = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = VirtualTimelineItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new VirtualTimelineItem.DateDivider({
            ts: FfiConverterTypeTimestamp.read(from),
          });
        case 2:
          return new VirtualTimelineItem.ReadMarker();
        case 3:
          return new VirtualTimelineItem.TimelineStart();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case VirtualTimelineItem_Tags.DateDivider: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeTimestamp.write(inner.ts, into);
          return;
        }
        case VirtualTimelineItem_Tags.ReadMarker: {
          ordinalConverter.write(2, into);
          return;
        }
        case VirtualTimelineItem_Tags.TimelineStart: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that VirtualTimelineItem_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case VirtualTimelineItem_Tags.DateDivider: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeTimestamp.allocationSize(inner.ts);
          return size;
        }
        case VirtualTimelineItem_Tags.ReadMarker: {
          return ordinalConverter.allocationSize(2);
        }
        case VirtualTimelineItem_Tags.TimelineStart: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: WidgetEventFilter
export enum WidgetEventFilter_Tags {
  MessageLikeWithType = 'MessageLikeWithType',
  RoomMessageWithMsgtype = 'RoomMessageWithMsgtype',
  StateWithType = 'StateWithType',
  StateWithTypeAndStateKey = 'StateWithTypeAndStateKey',
  ToDevice = 'ToDevice',
}
/**
 * Different kinds of filters that could be applied to the timeline events.
 */
export const WidgetEventFilter = (() => {
  type MessageLikeWithType__interface = {
    tag: WidgetEventFilter_Tags.MessageLikeWithType;
    inner: Readonly<{ eventType: string }>;
  };

  /**
   * Matches message-like events with the given `type`.
   */
  class MessageLikeWithType_
    extends UniffiEnum
    implements MessageLikeWithType__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WidgetEventFilter';
    readonly tag = WidgetEventFilter_Tags.MessageLikeWithType;
    readonly inner: Readonly<{ eventType: string }>;
    constructor(inner: { eventType: string }) {
      super('WidgetEventFilter', 'MessageLikeWithType');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: string }): MessageLikeWithType_ {
      return new MessageLikeWithType_(inner);
    }

    static instanceOf(obj: any): obj is MessageLikeWithType_ {
      return obj.tag === WidgetEventFilter_Tags.MessageLikeWithType;
    }
  }

  type RoomMessageWithMsgtype__interface = {
    tag: WidgetEventFilter_Tags.RoomMessageWithMsgtype;
    inner: Readonly<{ msgtype: string }>;
  };

  /**
   * Matches `m.room.message` events with the given `msgtype`.
   */
  class RoomMessageWithMsgtype_
    extends UniffiEnum
    implements RoomMessageWithMsgtype__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WidgetEventFilter';
    readonly tag = WidgetEventFilter_Tags.RoomMessageWithMsgtype;
    readonly inner: Readonly<{ msgtype: string }>;
    constructor(inner: { msgtype: string }) {
      super('WidgetEventFilter', 'RoomMessageWithMsgtype');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msgtype: string }): RoomMessageWithMsgtype_ {
      return new RoomMessageWithMsgtype_(inner);
    }

    static instanceOf(obj: any): obj is RoomMessageWithMsgtype_ {
      return obj.tag === WidgetEventFilter_Tags.RoomMessageWithMsgtype;
    }
  }

  type StateWithType__interface = {
    tag: WidgetEventFilter_Tags.StateWithType;
    inner: Readonly<{ eventType: string }>;
  };

  /**
   * Matches state events with the given `type`, regardless of `state_key`.
   */
  class StateWithType_ extends UniffiEnum implements StateWithType__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WidgetEventFilter';
    readonly tag = WidgetEventFilter_Tags.StateWithType;
    readonly inner: Readonly<{ eventType: string }>;
    constructor(inner: { eventType: string }) {
      super('WidgetEventFilter', 'StateWithType');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: string }): StateWithType_ {
      return new StateWithType_(inner);
    }

    static instanceOf(obj: any): obj is StateWithType_ {
      return obj.tag === WidgetEventFilter_Tags.StateWithType;
    }
  }

  type StateWithTypeAndStateKey__interface = {
    tag: WidgetEventFilter_Tags.StateWithTypeAndStateKey;
    inner: Readonly<{ eventType: string; stateKey: string }>;
  };

  /**
   * Matches state events with the given `type` and `state_key`.
   */
  class StateWithTypeAndStateKey_
    extends UniffiEnum
    implements StateWithTypeAndStateKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WidgetEventFilter';
    readonly tag = WidgetEventFilter_Tags.StateWithTypeAndStateKey;
    readonly inner: Readonly<{ eventType: string; stateKey: string }>;
    constructor(inner: { eventType: string; stateKey: string }) {
      super('WidgetEventFilter', 'StateWithTypeAndStateKey');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventType: string;
      stateKey: string;
    }): StateWithTypeAndStateKey_ {
      return new StateWithTypeAndStateKey_(inner);
    }

    static instanceOf(obj: any): obj is StateWithTypeAndStateKey_ {
      return obj.tag === WidgetEventFilter_Tags.StateWithTypeAndStateKey;
    }
  }

  type ToDevice__interface = {
    tag: WidgetEventFilter_Tags.ToDevice;
    inner: Readonly<{ eventType: string }>;
  };

  /**
   * Matches to-device events with the given `event_type`.
   */
  class ToDevice_ extends UniffiEnum implements ToDevice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WidgetEventFilter';
    readonly tag = WidgetEventFilter_Tags.ToDevice;
    readonly inner: Readonly<{ eventType: string }>;
    constructor(inner: { eventType: string }) {
      super('WidgetEventFilter', 'ToDevice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventType: string }): ToDevice_ {
      return new ToDevice_(inner);
    }

    static instanceOf(obj: any): obj is ToDevice_ {
      return obj.tag === WidgetEventFilter_Tags.ToDevice;
    }
  }

  function instanceOf(obj: any): obj is WidgetEventFilter {
    return obj[uniffiTypeNameSymbol] === 'WidgetEventFilter';
  }

  return Object.freeze({
    instanceOf,
    MessageLikeWithType: MessageLikeWithType_,
    RoomMessageWithMsgtype: RoomMessageWithMsgtype_,
    StateWithType: StateWithType_,
    StateWithTypeAndStateKey: StateWithTypeAndStateKey_,
    ToDevice: ToDevice_,
  });
})();

/**
 * Different kinds of filters that could be applied to the timeline events.
 */

export type WidgetEventFilter = InstanceType<
  (typeof WidgetEventFilter)[keyof Omit<typeof WidgetEventFilter, 'instanceOf'>]
>;

// FfiConverter for enum WidgetEventFilter
const FfiConverterTypeWidgetEventFilter = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = WidgetEventFilter;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new WidgetEventFilter.MessageLikeWithType({
            eventType: FfiConverterString.read(from),
          });
        case 2:
          return new WidgetEventFilter.RoomMessageWithMsgtype({
            msgtype: FfiConverterString.read(from),
          });
        case 3:
          return new WidgetEventFilter.StateWithType({
            eventType: FfiConverterString.read(from),
          });
        case 4:
          return new WidgetEventFilter.StateWithTypeAndStateKey({
            eventType: FfiConverterString.read(from),
            stateKey: FfiConverterString.read(from),
          });
        case 5:
          return new WidgetEventFilter.ToDevice({
            eventType: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case WidgetEventFilter_Tags.MessageLikeWithType: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        case WidgetEventFilter_Tags.RoomMessageWithMsgtype: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.msgtype, into);
          return;
        }
        case WidgetEventFilter_Tags.StateWithType: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        case WidgetEventFilter_Tags.StateWithTypeAndStateKey: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          FfiConverterString.write(inner.stateKey, into);
          return;
        }
        case WidgetEventFilter_Tags.ToDevice: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.eventType, into);
          return;
        }
        default:
          // Throwing from here means that WidgetEventFilter_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case WidgetEventFilter_Tags.MessageLikeWithType: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        case WidgetEventFilter_Tags.RoomMessageWithMsgtype: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.msgtype);
          return size;
        }
        case WidgetEventFilter_Tags.StateWithType: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        case WidgetEventFilter_Tags.StateWithTypeAndStateKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.eventType);
          size += FfiConverterString.allocationSize(inner.stateKey);
          return size;
        }
        case WidgetEventFilter_Tags.ToDevice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.eventType);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, /*i32*/number>
const FfiConverterMapStringInt32 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterInt32
);

// FfiConverter for Map<string, /*i64*/bigint>
const FfiConverterMapStringInt64 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterInt64
);

// FfiConverter for Map<string, IgnoredUser>
const FfiConverterMapStringTypeIgnoredUser = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeIgnoredUser
);

// FfiConverter for Map<string, NotificationItem>
const FfiConverterMapStringTypeNotificationItem = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeNotificationItem
);

// FfiConverter for Map<string, Receipt>
const FfiConverterMapStringTypeReceipt = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeReceipt
);

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

export interface ClientInterface {
  /**
   * Aborts an existing OIDC login operation that might have been cancelled,
   * failed etc.
   */
  abortOidcAuth(
    authorizationData: OAuthAuthorizationDataInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Get the content of the event of the given type out of the account data
   * store.
   *
   * It will be returned as a JSON string.
   */
  accountData(
    eventType: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  accountUrl(
    action: AccountManagementAction | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  /**
   * Find all sliding sync versions that are available.
   *
   * Be careful: This method may hit the store and will send new requests for
   * each call. It can be costly to call it repeatedly.
   *
   * If `.well-known` or `/versions` is unreachable, it will simply move
   * potential sliding sync versions aside. No error will be reported.
   */
  availableSlidingSyncVersions(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<SlidingSyncVersion>>;
  /**
   * Sends a request to retrieve the avatar URL. Will fill the cache used by
   * [`Self::cached_avatar_url`] on success.
   */
  avatarUrl(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string | undefined>;
  /**
   * Waits until an at least partially synced room is received, and returns
   * it.
   *
   * **Note: this function will loop endlessly until either it finds the room
   * or an externally set timeout happens.**
   */
  awaitRoomRemoteEcho(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomInterface>;
  /**
   * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
   */
  cachedAvatarUrl(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string | undefined>;
  /**
   * Lets the user know whether this is an `m.login.password` based
   * auth and if the account can actually be deactivated
   */
  canDeactivateAccount(): boolean;
  /**
   * Clear all the non-critical caches for this Client instance.
   *
   * WARNING: This will clear all the caches, including the base store (state
   * store), so callers must make sure that any sync is inactive before
   * calling this method. In particular, the `SyncService` must not be
   * running. After the method returns, the Client will be in an unstable
   * state, and it is required that the caller reinstantiates a new
   * Client instance, be it via dropping the previous and re-creating it,
   * restarting their application, or any other similar means.
   *
   * - This will get rid of the backing state store file, if provided.
   * - This will empty all the room's persisted event caches, so all rooms
   * will start as if they were empty.
   * - This will empty the media cache according to the current media
   * retention policy.
   */
  clearCaches(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  createRoom(
    request: CreateRoomParameters,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * Login using JWT
   * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
   * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
   */
  customLoginWithJwt(
    jwt: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Deactivate this account definitively.
   * Similarly to `encryption::reset_identity` this
   * will only work with password-based authentication (`m.login.password`)
   *
   * # Arguments
   *
   * * `auth_data` - This request uses the [User-Interactive Authentication
   * API][uiaa]. The first request needs to set this to `None` and will
   * always fail and the same request needs to be made but this time with
   * some `auth_data` provided.
   */
  deactivateAccount(
    authData: AuthData | undefined,
    eraseData: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Deletes a pusher of given pusher ids
   */
  deletePusher(
    identifiers: PusherIdentifiers,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  deviceId() /*throws*/ : string;
  displayName(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string>;
  /**
   * Enables or disables all the room send queues at once.
   *
   * When connectivity is lost on a device, it is recommended to disable the
   * room sending queues.
   *
   * This can be controlled for individual rooms, using
   * [`Room::enable_send_queue`].
   */
  enableAllSendQueues(
    enable: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  encryption(): EncryptionInterface;
  /**
   * Fetch the media preview configuration from the server.
   */
  fetchMediaPreviewConfig(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<MediaPreviewConfig | undefined>;
  getDmRoom(userId: string) /*throws*/ : RoomInterface | undefined;
  /**
   * Get the invite request avatars display policy
   * currently stored in the cache.
   */
  getInviteAvatarsDisplayPolicy(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<InviteAvatars | undefined>;
  /**
   * Gets the `max_upload_size` value from the homeserver, which controls the
   * max size a media upload request can have.
   */
  getMaxMediaUploadSize(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise</*u64*/ bigint>;
  getMediaContent(
    mediaSource: MediaSourceInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ArrayBuffer>;
  getMediaFile(
    mediaSource: MediaSourceInterface,
    filename: string | undefined,
    mimeType: string,
    useCache: boolean,
    tempDir: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<MediaFileHandleInterface>;
  /**
   * Get the media previews timeline display policy
   * currently stored in the cache.
   */
  getMediaPreviewDisplayPolicy(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<MediaPreviews | undefined>;
  getMediaThumbnail(
    mediaSource: MediaSourceInterface,
    width: /*u64*/ bigint,
    height: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ArrayBuffer>;
  getNotificationSettings(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<NotificationSettingsInterface>;
  getProfile(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<UserProfile>;
  getRecentlyVisitedRooms(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<string>>;
  /**
   * Get a room by its ID.
   *
   * # Arguments
   *
   * * `room_id` - The ID of the room to get.
   *
   * # Returns
   *
   * A `Result` containing an optional room, or a `ClientError`.
   * This method will not initialize the room's timeline or populate it with
   * events.
   */
  getRoom(roomId: string) /*throws*/ : RoomInterface | undefined;
  /**
   * Given a room alias, get the preview of a room, to interact with it.
   */
  getRoomPreviewFromRoomAlias(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomPreviewInterface>;
  /**
   * Given a room id, get the preview of a room, to interact with it.
   *
   * The list of `via_servers` must be a list of servers that know
   * about the room and can resolve it, and that may appear as a `via`
   * parameter in e.g. a permalink URL. This list can be empty.
   */
  getRoomPreviewFromRoomId(
    roomId: string,
    viaServers: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomPreviewInterface>;
  getSessionVerificationController(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<SessionVerificationControllerInterface>;
  /**
   * Allows generic GET requests to be made through the SDKs internal HTTP
   * client
   */
  getUrl(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * The homeserver this client is configured to use.
   */
  homeserver(): string;
  /**
   * Information about login options for the client's homeserver.
   */
  homeserverLoginDetails(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<HomeserverLoginDetailsInterface>;
  ignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  ignoredUsers(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<string>>;
  /**
   * Checks if the server supports the report room API.
   */
  isReportRoomApiSupported(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Checks if a room alias is not in use yet.
   *
   * Returns:
   * - `Ok(true)` if the room alias is available.
   * - `Ok(false)` if it's not (the resolve alias request returned a `404`
   * status code).
   * - An `Err` otherwise.
   */
  isRoomAliasAvailable(
    alias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Join a room by its ID.
   *
   * Use this method when the homeserver already knows of the given room ID.
   * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
   * server names for the homeserver to find the room.
   */
  joinRoomById(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomInterface>;
  /**
   * Join a room by its ID or alias.
   *
   * When supplying the room's ID, you can also supply a list of server names
   * for the homeserver to find the room. Typically these server names
   * come from a permalink's `via` parameters, or from resolving a room's
   * alias into an ID.
   */
  joinRoomByIdOrAlias(
    roomIdOrAlias: string,
    serverNames: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomInterface>;
  /**
   * Knock on a room to join it using its ID or alias.
   */
  knock(
    roomIdOrAlias: string,
    reason: string | undefined,
    serverNames: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomInterface>;
  /**
   * Login using a username and password.
   */
  login(
    username: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Login using an email and password.
   */
  loginWithEmail(
    email: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Completes the OIDC login process.
   */
  loginWithOidcCallback(
    callbackUrl: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Log the current user out.
   */
  logout(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  notificationClient(
    processSetup: NotificationProcessSetup,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<NotificationClientInterface>;
  /**
   * Subscribe to updates of global account data events.
   *
   * Be careful that only the most recent value can be observed. Subscribers
   * are notified when a new value is sent, but there is no guarantee that
   * they will see all values.
   */
  observeAccountDataEvent(
    eventType: AccountDataEventType,
    listener: AccountDataListener
  ): TaskHandleInterface;
  /**
   * Subscribe to updates of room account data events.
   *
   * Be careful that only the most recent value can be observed. Subscribers
   * are notified when a new value is sent, but there is no guarantee that
   * they will see all values.
   */
  observeRoomAccountDataEvent(
    roomId: string,
    eventType: RoomAccountDataEventType,
    listener: RoomAccountDataListener
  ) /*throws*/ : TaskHandleInterface;
  removeAvatar(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Empty the server version and unstable features cache.
   *
   * Since the SDK caches server capabilities (versions and unstable
   * features), it's possible to have a stale entry in the cache. This
   * functions makes it possible to force reset it.
   */
  resetServerCapabilities(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Resolves the given room alias to a room ID (and a list of servers), if
   * possible.
   */
  resolveRoomAlias(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ResolvedRoomAlias | undefined>;
  /**
   * Restores the client from a `Session`.
   *
   * It reloads the entire set of rooms from the previous session.
   *
   * If you want to control the amount of rooms to reloads, check
   * [`Client::restore_session_with`].
   */
  restoreSession(
    session: Session,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Restores the client from a `Session`.
   *
   * It reloads a set of rooms controlled by [`RoomLoadSettings`].
   */
  restoreSessionWith(
    session: Session,
    roomLoadSettings: RoomLoadSettings,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Checks if a room alias exists in the current homeserver.
   */
  roomAliasExists(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  roomDirectorySearch(): RoomDirectorySearchInterface;
  rooms(): Array<RoomInterface>;
  searchUsers(
    searchTerm: string,
    limit: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SearchUsersResults>;
  /**
   * The URL of the server.
   *
   * Not to be confused with the `Self::homeserver`. `server` is usually
   * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
   * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
   * homeserver (at the time of writing  2024-08-28).
   *
   * This value is optional depending on how the `Client` has been built.
   * If it's been built from a homeserver URL directly, we don't know the
   * server. However, if the `Client` has been built from a server URL or
   * name, then the homeserver has been discovered, and we know both.
   */
  server(): string | undefined;
  session() /*throws*/ : Session;
  /**
   * Set the given account data content for the given event type.
   *
   * It should be supplied as a JSON string.
   */
  setAccountData(
    eventType: string,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Sets the [ClientDelegate] which will inform about authentication errors.
   * Returns an error if the delegate was already set.
   */
  setDelegate(
    delegate: ClientDelegate | undefined
  ) /*throws*/ : TaskHandleInterface | undefined;
  setDisplayName(
    name: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set the invite request avatars display policy
   */
  setInviteAvatarsDisplayPolicy(
    policy: InviteAvatars,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set the media previews timeline display policy
   */
  setMediaPreviewDisplayPolicy(
    policy: MediaPreviews,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set the media retention policy.
   */
  setMediaRetentionPolicy(
    policy: MediaRetentionPolicy,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Registers a pusher with given parameters
   */
  setPusher(
    identifiers: PusherIdentifiers,
    kind: PusherKind,
    appDisplayName: string,
    deviceDisplayName: string,
    profileTag: string | undefined,
    lang: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Sets the [UnableToDecryptDelegate] which will inform about UTDs.
   * Returns an error if the delegate was already set.
   */
  setUtdDelegate(
    utdDelegate: UnableToDecryptDelegate,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * The sliding sync version.
   */
  slidingSyncVersion(): SlidingSyncVersion;
  /**
   * Returns a handler to start the SSO login process.
   */
  startSsoLogin(
    redirectUrl: string,
    idpId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SsoHandlerInterface>;
  subscribeToIgnoredUsers(listener: IgnoredUsersListener): TaskHandleInterface;
  /**
   * Subscribe to changes in the media preview configuration.
   */
  subscribeToMediaPreviewConfig(
    listener: MediaPreviewConfigListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TaskHandleInterface>;
  /**
   * Subscribe to [`RoomInfo`] updates given a provided [`RoomId`].
   *
   * This works even for rooms we haven't received yet, so we can subscribe
   * to this and wait until we receive updates from them when sync responses
   * are processed.
   *
   * Note this method should be used sparingly since using callback
   * interfaces is expensive, as well as keeping them alive for a long
   * time. Usages of this method should be short-lived and dropped as
   * soon as possible.
   */
  subscribeToRoomInfo(
    roomId: string,
    listener: RoomInfoListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TaskHandleInterface>;
  /**
   * Subscribe to the global enablement status of the send queue, at the
   * client-wide level.
   *
   * The given listener will be immediately called with the initial value of
   * the enablement status.
   */
  subscribeToSendQueueStatus(
    listener: SendQueueRoomErrorListener
  ): TaskHandleInterface;
  syncService(): SyncServiceBuilderInterface;
  trackRecentlyVisitedRoom(
    room: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  unignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  uploadMedia(
    mimeType: string,
    data: ArrayBuffer,
    progressWatcher: ProgressWatcher | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * Requests the URL needed for opening a web view using OIDC. Once the web
   * view has succeeded, call `login_with_oidc_callback` with the callback it
   * returns. If a failure occurs and a callback isn't available, make sure
   * to call `abort_oidc_auth` to inform the client of this.
   *
   * # Arguments
   *
   * * `oidc_configuration` - The configuration used to load the credentials
   * of the client if it is already registered with the authorization
   * server, or register the client and store its credentials if it isn't.
   *
   * * `prompt` - The desired user experience in the web UI. No value means
   * that the user wishes to login into an existing account, and a value of
   * `Create` means that the user wishes to register a new account.
   *
   * * `login_hint` - A generic login hint that an identity provider can use
   * to pre-fill the login form. The format of this hint is not restricted
   * by the spec as external providers all have their own way to handle the hint.
   * However, it should be noted that when providing a user ID as a hint
   * for MAS (with no upstream provider), then the format to use is defined
   * by [MSC4198]: https://github.com/matrix-org/matrix-spec-proposals/pull/4198
   */
  urlForOidc(
    oidcConfiguration: OidcConfiguration,
    prompt: OidcPrompt | undefined,
    loginHint: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<OAuthAuthorizationDataInterface>;
  userId() /*throws*/ : string;
  /**
   * The server name part of the current user ID
   */
  userIdServerName() /*throws*/ : string;
}

export class Client extends UniffiAbstractObject implements ClientInterface {
  readonly [uniffiTypeNameSymbol] = 'Client';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeClientObjectFactory.bless(pointer);
  }

  /**
   * Aborts an existing OIDC login operation that might have been cancelled,
   * failed etc.
   */
  public async abortOidcAuth(
    authorizationData: OAuthAuthorizationDataInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeOAuthAuthorizationData.lower(authorizationData)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the content of the event of the given type out of the account data
   * store.
   *
   * It will be returned as a JSON string.
   */
  public async accountData(
    eventType: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_account_data(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventType)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async accountUrl(
    action: AccountManagementAction | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_account_url(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeAccountManagementAction.lower(action)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Find all sliding sync versions that are available.
   *
   * Be careful: This method may hit the store and will send new requests for
   * each call. It can be costly to call it repeatedly.
   *
   * If `.well-known` or `/versions` is unreachable, it will simply move
   * potential sliding sync versions aside. No error will be reported.
   */
  public async availableSlidingSyncVersions(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<SlidingSyncVersion>> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeSlidingSyncVersion.lift.bind(
          FfiConverterArrayTypeSlidingSyncVersion
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sends a request to retrieve the avatar URL. Will fill the cache used by
   * [`Self::cached_avatar_url`] on success.
   */
  public async avatarUrl(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Waits until an at least partially synced room is received, and returns
   * it.
   *
   * **Note: this function will loop endlessly until either it finds the room
   * or an externally set timeout happens.**
   */
  public async awaitRoomRemoteEcho(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
   */
  public async cachedAvatarUrl(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Lets the user know whether this is an `m.login.password` based
   * auth and if the account can actually be deactivated
   */
  public canDeactivateAccount(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Clear all the non-critical caches for this Client instance.
   *
   * WARNING: This will clear all the caches, including the base store (state
   * store), so callers must make sure that any sync is inactive before
   * calling this method. In particular, the `SyncService` must not be
   * running. After the method returns, the Client will be in an unstable
   * state, and it is required that the caller reinstantiates a new
   * Client instance, be it via dropping the previous and re-creating it,
   * restarting their application, or any other similar means.
   *
   * - This will get rid of the backing state store file, if provided.
   * - This will empty all the room's persisted event caches, so all rooms
   * will start as if they were empty.
   * - This will empty the media cache according to the current media
   * retention policy.
   */
  public async clearCaches(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_clear_caches(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async createRoom(
    request: CreateRoomParameters,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_create_room(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeCreateRoomParameters.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Login using JWT
   * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
   * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
   */
  public async customLoginWithJwt(
    jwt: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(jwt),
            FfiConverterOptionalString.lower(initialDeviceName),
            FfiConverterOptionalString.lower(deviceId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Deactivate this account definitively.
   * Similarly to `encryption::reset_identity` this
   * will only work with password-based authentication (`m.login.password`)
   *
   * # Arguments
   *
   * * `auth_data` - This request uses the [User-Interactive Authentication
   * API][uiaa]. The first request needs to set this to `None` and will
   * always fail and the same request needs to be made but this time with
   * some `auth_data` provided.
   */
  public async deactivateAccount(
    authData: AuthData | undefined,
    eraseData: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeAuthData.lower(authData),
            FfiConverterBool.lower(eraseData)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Deletes a pusher of given pusher ids
   */
  public async deletePusher(
    identifiers: PusherIdentifiers,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypePusherIdentifiers.lower(identifiers)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public deviceId(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_device_id(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async displayName(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_display_name(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Enables or disables all the room send queues at once.
   *
   * When connectivity is lost on a device, it is recommended to disable the
   * room sending queues.
   *
   * This can be controlled for individual rooms, using
   * [`Room::enable_send_queue`].
   */
  public async enableAllSendQueues(
    enable: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enable)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public encryption(): EncryptionInterface {
    return FfiConverterTypeEncryption.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_encryption(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Fetch the media preview configuration from the server.
   */
  public async fetchMediaPreviewConfig(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<MediaPreviewConfig | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_fetch_media_preview_config(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeMediaPreviewConfig.lift.bind(
          FfiConverterOptionalTypeMediaPreviewConfig
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public getDmRoom(userId: string): RoomInterface | undefined /*throws*/ {
    return FfiConverterOptionalTypeRoom.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the invite request avatars display policy
   * currently stored in the cache.
   */
  public async getInviteAvatarsDisplayPolicy(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<InviteAvatars | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_invite_avatars_display_policy(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeInviteAvatars.lift.bind(
          FfiConverterOptionalTypeInviteAvatars
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Gets the `max_upload_size` value from the homeserver, which controls the
   * max size a media upload request can have.
   */
  public async getMaxMediaUploadSize(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise</*u64*/ bigint> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_max_media_upload_size(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_u64,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_u64,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_u64,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_u64,
        /*liftFunc:*/ FfiConverterUInt64.lift.bind(FfiConverterUInt64),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getMediaContent(
    mediaSource: MediaSourceInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ArrayBuffer> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMediaSource.lower(mediaSource)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(
          FfiConverterArrayBuffer
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getMediaFile(
    mediaSource: MediaSourceInterface,
    filename: string | undefined,
    mimeType: string,
    useCache: boolean,
    tempDir: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<MediaFileHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMediaSource.lower(mediaSource),
            FfiConverterOptionalString.lower(filename),
            FfiConverterString.lower(mimeType),
            FfiConverterBool.lower(useCache),
            FfiConverterOptionalString.lower(tempDir)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeMediaFileHandle.lift.bind(
          FfiConverterTypeMediaFileHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the media previews timeline display policy
   * currently stored in the cache.
   */
  public async getMediaPreviewDisplayPolicy(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<MediaPreviews | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_preview_display_policy(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeMediaPreviews.lift.bind(
          FfiConverterOptionalTypeMediaPreviews
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getMediaThumbnail(
    mediaSource: MediaSourceInterface,
    width: /*u64*/ bigint,
    height: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ArrayBuffer> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMediaSource.lower(mediaSource),
            FfiConverterUInt64.lower(width),
            FfiConverterUInt64.lower(height)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(
          FfiConverterArrayBuffer
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getNotificationSettings(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<NotificationSettingsInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeNotificationSettings.lift.bind(
          FfiConverterTypeNotificationSettings
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getProfile(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<UserProfile> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_profile(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeUserProfile.lift.bind(
          FfiConverterTypeUserProfile
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getRecentlyVisitedRooms(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<string>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayString.lift.bind(
          FfiConverterArrayString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get a room by its ID.
   *
   * # Arguments
   *
   * * `room_id` - The ID of the room to get.
   *
   * # Returns
   *
   * A `Result` containing an optional room, or a `ClientError`.
   * This method will not initialize the room's timeline or populate it with
   * events.
   */
  public getRoom(roomId: string): RoomInterface | undefined /*throws*/ {
    return FfiConverterOptionalTypeRoom.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_room(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Given a room alias, get the preview of a room, to interact with it.
   */
  public async getRoomPreviewFromRoomAlias(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomPreviewInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomAlias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomPreview.lift.bind(
          FfiConverterTypeRoomPreview
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Given a room id, get the preview of a room, to interact with it.
   *
   * The list of `via_servers` must be a list of servers that know
   * about the room and can resolve it, and that may appear as a `via`
   * parameter in e.g. a permalink URL. This list can be empty.
   */
  public async getRoomPreviewFromRoomId(
    roomId: string,
    viaServers: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomPreviewInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterArrayString.lower(viaServers)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomPreview.lift.bind(
          FfiConverterTypeRoomPreview
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getSessionVerificationController(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<SessionVerificationControllerInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeSessionVerificationController.lift.bind(
          FfiConverterTypeSessionVerificationController
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Allows generic GET requests to be made through the SDKs internal HTTP
   * client
   */
  public async getUrl(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_url(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The homeserver this client is configured to use.
   */
  public homeserver(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_homeserver(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Information about login options for the client's homeserver.
   */
  public async homeserverLoginDetails(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<HomeserverLoginDetailsInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeHomeserverLoginDetails.lift.bind(
          FfiConverterTypeHomeserverLoginDetails
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async ignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async ignoredUsers(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<string>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayString.lift.bind(
          FfiConverterArrayString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Checks if the server supports the report room API.
   */
  public async isReportRoomApiSupported(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_is_report_room_api_supported(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Checks if a room alias is not in use yet.
   *
   * Returns:
   * - `Ok(true)` if the room alias is available.
   * - `Ok(false)` if it's not (the resolve alias request returned a `404`
   * status code).
   * - An `Err` otherwise.
   */
  public async isRoomAliasAvailable(
    alias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(alias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Join a room by its ID.
   *
   * Use this method when the homeserver already knows of the given room ID.
   * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
   * server names for the homeserver to find the room.
   */
  public async joinRoomById(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Join a room by its ID or alias.
   *
   * When supplying the room's ID, you can also supply a list of server names
   * for the homeserver to find the room. Typically these server names
   * come from a permalink's `via` parameters, or from resolving a room's
   * alias into an ID.
   */
  public async joinRoomByIdOrAlias(
    roomIdOrAlias: string,
    serverNames: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomIdOrAlias),
            FfiConverterArrayString.lower(serverNames)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Knock on a room to join it using its ID or alias.
   */
  public async knock(
    roomIdOrAlias: string,
    reason: string | undefined,
    serverNames: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_knock(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomIdOrAlias),
            FfiConverterOptionalString.lower(reason),
            FfiConverterArrayString.lower(serverNames)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Login using a username and password.
   */
  public async login(
    username: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_login(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(username),
            FfiConverterString.lower(password),
            FfiConverterOptionalString.lower(initialDeviceName),
            FfiConverterOptionalString.lower(deviceId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Login using an email and password.
   */
  public async loginWithEmail(
    email: string,
    password: string,
    initialDeviceName: string | undefined,
    deviceId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(email),
            FfiConverterString.lower(password),
            FfiConverterOptionalString.lower(initialDeviceName),
            FfiConverterOptionalString.lower(deviceId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Completes the OIDC login process.
   */
  public async loginWithOidcCallback(
    callbackUrl: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(callbackUrl)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeOidcError.lift.bind(
          FfiConverterTypeOidcError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Log the current user out.
   */
  public async logout(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_logout(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async notificationClient(
    processSetup: NotificationProcessSetup,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<NotificationClientInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_notification_client(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeNotificationProcessSetup.lower(processSetup)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeNotificationClient.lift.bind(
          FfiConverterTypeNotificationClient
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribe to updates of global account data events.
   *
   * Be careful that only the most recent value can be observed. Subscribers
   * are notified when a new value is sent, but there is no guarantee that
   * they will see all values.
   */
  public observeAccountDataEvent(
    eventType: AccountDataEventType,
    listener: AccountDataListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_observe_account_data_event(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeAccountDataEventType.lower(eventType),
            FfiConverterTypeAccountDataListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe to updates of room account data events.
   *
   * Be careful that only the most recent value can be observed. Subscribers
   * are notified when a new value is sent, but there is no guarantee that
   * they will see all values.
   */
  public observeRoomAccountDataEvent(
    roomId: string,
    eventType: RoomAccountDataEventType,
    listener: RoomAccountDataListener
  ): TaskHandleInterface /*throws*/ {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_observe_room_account_data_event(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterTypeRoomAccountDataEventType.lower(eventType),
            FfiConverterTypeRoomAccountDataListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async removeAvatar(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Empty the server version and unstable features cache.
   *
   * Since the SDK caches server capabilities (versions and unstable
   * features), it's possible to have a stale entry in the cache. This
   * functions makes it possible to force reset it.
   */
  public async resetServerCapabilities(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_reset_server_capabilities(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Resolves the given room alias to a room ID (and a list of servers), if
   * possible.
   */
  public async resolveRoomAlias(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ResolvedRoomAlias | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomAlias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeResolvedRoomAlias.lift.bind(
          FfiConverterOptionalTypeResolvedRoomAlias
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Restores the client from a `Session`.
   *
   * It reloads the entire set of rooms from the previous session.
   *
   * If you want to control the amount of rooms to reloads, check
   * [`Client::restore_session_with`].
   */
  public async restoreSession(
    session: Session,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_restore_session(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeSession.lower(session)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Restores the client from a `Session`.
   *
   * It reloads a set of rooms controlled by [`RoomLoadSettings`].
   */
  public async restoreSessionWith(
    session: Session,
    roomLoadSettings: RoomLoadSettings,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_restore_session_with(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeSession.lower(session),
            FfiConverterTypeRoomLoadSettings.lower(roomLoadSettings)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Checks if a room alias exists in the current homeserver.
   */
  public async roomAliasExists(
    roomAlias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomAlias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public roomDirectorySearch(): RoomDirectorySearchInterface {
    return FfiConverterTypeRoomDirectorySearch.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public rooms(): Array<RoomInterface> {
    return FfiConverterArrayTypeRoom.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_rooms(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async searchUsers(
    searchTerm: string,
    limit: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SearchUsersResults> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_search_users(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(searchTerm),
            FfiConverterUInt64.lower(limit)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSearchUsersResults.lift.bind(
          FfiConverterTypeSearchUsersResults
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The URL of the server.
   *
   * Not to be confused with the `Self::homeserver`. `server` is usually
   * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
   * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
   * homeserver (at the time of writing  2024-08-28).
   *
   * This value is optional depending on how the `Client` has been built.
   * If it's been built from a homeserver URL directly, we don't know the
   * server. However, if the `Client` has been built from a server URL or
   * name, then the homeserver has been discovered, and we know both.
   */
  public server(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_server(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public session(): Session /*throws*/ {
    return FfiConverterTypeSession.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_session(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the given account data content for the given event type.
   *
   * It should be supplied as a JSON string.
   */
  public async setAccountData(
    eventType: string,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventType),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the [ClientDelegate] which will inform about authentication errors.
   * Returns an error if the delegate was already set.
   */
  public setDelegate(
    delegate: ClientDelegate | undefined
  ): TaskHandleInterface | undefined /*throws*/ {
    return FfiConverterOptionalTypeTaskHandle.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeClientDelegate.lower(delegate),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async setDisplayName(
    name: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(name)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set the invite request avatars display policy
   */
  public async setInviteAvatarsDisplayPolicy(
    policy: InviteAvatars,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_invite_avatars_display_policy(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeInviteAvatars.lower(policy)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set the media previews timeline display policy
   */
  public async setMediaPreviewDisplayPolicy(
    policy: MediaPreviews,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_media_preview_display_policy(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMediaPreviews.lower(policy)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set the media retention policy.
   */
  public async setMediaRetentionPolicy(
    policy: MediaRetentionPolicy,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_media_retention_policy(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMediaRetentionPolicy.lower(policy)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Registers a pusher with given parameters
   */
  public async setPusher(
    identifiers: PusherIdentifiers,
    kind: PusherKind,
    appDisplayName: string,
    deviceDisplayName: string,
    profileTag: string | undefined,
    lang: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypePusherIdentifiers.lower(identifiers),
            FfiConverterTypePusherKind.lower(kind),
            FfiConverterString.lower(appDisplayName),
            FfiConverterString.lower(deviceDisplayName),
            FfiConverterOptionalString.lower(profileTag),
            FfiConverterString.lower(lang)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the [UnableToDecryptDelegate] which will inform about UTDs.
   * Returns an error if the delegate was already set.
   */
  public async setUtdDelegate(
    utdDelegate: UnableToDecryptDelegate,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_utd_delegate(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeUnableToDecryptDelegate.lower(utdDelegate)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The sliding sync version.
   */
  public slidingSyncVersion(): SlidingSyncVersion {
    return FfiConverterTypeSlidingSyncVersion.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns a handler to start the SSO login process.
   */
  public async startSsoLogin(
    redirectUrl: string,
    idpId: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SsoHandlerInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(redirectUrl),
            FfiConverterOptionalString.lower(idpId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeSsoHandler.lift.bind(
          FfiConverterTypeSsoHandler
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSsoError.lift.bind(
          FfiConverterTypeSsoError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public subscribeToIgnoredUsers(
    listener: IgnoredUsersListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeIgnoredUsersListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe to changes in the media preview configuration.
   */
  public async subscribeToMediaPreviewConfig(
    listener: MediaPreviewConfigListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_media_preview_config(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMediaPreviewConfigListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribe to [`RoomInfo`] updates given a provided [`RoomId`].
   *
   * This works even for rooms we haven't received yet, so we can subscribe
   * to this and wait until we receive updates from them when sync responses
   * are processed.
   *
   * Note this method should be used sparingly since using callback
   * interfaces is expensive, as well as keeping them alive for a long
   * time. Usages of this method should be short-lived and dropped as
   * soon as possible.
   */
  public async subscribeToRoomInfo(
    roomId: string,
    listener: RoomInfoListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_room_info(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterTypeRoomInfoListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribe to the global enablement status of the send queue, at the
   * client-wide level.
   *
   * The given listener will be immediately called with the initial value of
   * the enablement status.
   */
  public subscribeToSendQueueStatus(
    listener: SendQueueRoomErrorListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeSendQueueRoomErrorListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public syncService(): SyncServiceBuilderInterface {
    return FfiConverterTypeSyncServiceBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_sync_service(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async trackRecentlyVisitedRoom(
    room: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(room)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async unignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(mimeType),
            FfiConverterArrayBuffer.lower(data)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async uploadMedia(
    mimeType: string,
    data: ArrayBuffer,
    progressWatcher: ProgressWatcher | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_upload_media(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(mimeType),
            FfiConverterArrayBuffer.lower(data),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Requests the URL needed for opening a web view using OIDC. Once the web
   * view has succeeded, call `login_with_oidc_callback` with the callback it
   * returns. If a failure occurs and a callback isn't available, make sure
   * to call `abort_oidc_auth` to inform the client of this.
   *
   * # Arguments
   *
   * * `oidc_configuration` - The configuration used to load the credentials
   * of the client if it is already registered with the authorization
   * server, or register the client and store its credentials if it isn't.
   *
   * * `prompt` - The desired user experience in the web UI. No value means
   * that the user wishes to login into an existing account, and a value of
   * `Create` means that the user wishes to register a new account.
   *
   * * `login_hint` - A generic login hint that an identity provider can use
   * to pre-fill the login form. The format of this hint is not restricted
   * by the spec as external providers all have their own way to handle the hint.
   * However, it should be noted that when providing a user ID as a hint
   * for MAS (with no upstream provider), then the format to use is defined
   * by [MSC4198]: https://github.com/matrix-org/matrix-spec-proposals/pull/4198
   */
  public async urlForOidc(
    oidcConfiguration: OidcConfiguration,
    prompt: OidcPrompt | undefined,
    loginHint: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<OAuthAuthorizationDataInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeOidcConfiguration.lower(oidcConfiguration),
            FfiConverterOptionalTypeOidcPrompt.lower(prompt),
            FfiConverterOptionalString.lower(loginHint)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeOAuthAuthorizationData.lift.bind(
          FfiConverterTypeOAuthAuthorizationData
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeOidcError.lift.bind(
          FfiConverterTypeOidcError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public userId(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_user_id(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * The server name part of the current user ID
   */
  public userIdServerName(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeClientObjectFactory.pointer(this);
      uniffiTypeClientObjectFactory.freePointer(pointer);
      uniffiTypeClientObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Client {
    return uniffiTypeClientObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeClientObjectFactory: UniffiObjectFactory<ClientInterface> = {
  create(pointer: UnsafeMutableRawPointer): ClientInterface {
    const instance = Object.create(Client.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Client';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_client_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: ClientInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: ClientInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_client(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_client(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is ClientInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Client';
  },
};
// FfiConverter for ClientInterface
const FfiConverterTypeClient = new FfiConverterObject(
  uniffiTypeClientObjectFactory
);

export interface ClientBuilderInterface {
  addRootCertificates(certificates: Array<ArrayBuffer>): ClientBuilderInterface;
  /**
   * Automatically create a backup version if no backup exists.
   */
  autoEnableBackups(autoEnableBackups: boolean): ClientBuilderInterface;
  autoEnableCrossSigning(
    autoEnableCrossSigning: boolean
  ): ClientBuilderInterface;
  /**
   * Select a strategy to download room keys from the backup. By default
   * we download after a decryption failure.
   *
   * Take a look at the [`BackupDownloadStrategy`] enum for more options.
   */
  backupDownloadStrategy(
    backupDownloadStrategy: BackupDownloadStrategy
  ): ClientBuilderInterface;
  build(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<ClientInterface>;
  /**
   * Finish the building of the client and attempt to log in using the
   * provided [`QrCodeData`].
   *
   * This method will build the client and immediately attempt to log the
   * client in using the provided [`QrCodeData`] using the login
   * mechanism described in [MSC4108]. As such this methods requires OAuth
   * 2.0 support as well as sliding sync support.
   *
   * The usage of the progress_listener is required to transfer the
   * [`CheckCode`] to the existing client.
   *
   * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
   */
  buildWithQrCode(
    qrCodeData: QrCodeDataInterface,
    oidcConfiguration: OidcConfiguration,
    progressListener: QrLoginProgressListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ClientInterface>;
  crossProcessStoreLocksHolderName(holderName: string): ClientBuilderInterface;
  disableAutomaticTokenRefresh(): ClientBuilderInterface;
  /**
   * Don't trust any system root certificates, only trust the certificates
   * provided through
   * [`add_root_certificates`][ClientBuilder::add_root_certificates].
   */
  disableBuiltInRootCertificates(): ClientBuilderInterface;
  disableSslVerification(): ClientBuilderInterface;
  enableOidcRefreshLock(): ClientBuilderInterface;
  /**
   * Set whether to enable the experimental support for sending and receiving
   * encrypted room history on invite, per [MSC4268].
   *
   * [MSC4268]: https://github.com/matrix-org/matrix-spec-proposals/pull/4268
   */
  enableShareHistoryOnInvite(
    enableShareHistoryOnInvite: boolean
  ): ClientBuilderInterface;
  homeserverUrl(url: string): ClientBuilderInterface;
  proxy(url: string): ClientBuilderInterface;
  /**
   * Add a default request config to this client.
   */
  requestConfig(config: RequestConfig): ClientBuilderInterface;
  /**
   * Set the trust requirement to be used when decrypting events.
   */
  roomDecryptionTrustRequirement(
    trustRequirement: TrustRequirement
  ): ClientBuilderInterface;
  /**
   * Set the strategy to be used for picking recipient devices when sending
   * an encrypted message.
   */
  roomKeyRecipientStrategy(strategy: CollectStrategy): ClientBuilderInterface;
  serverName(serverName: string): ClientBuilderInterface;
  serverNameOrHomeserverUrl(serverNameOrUrl: string): ClientBuilderInterface;
  /**
   * Set the cache size for the SQLite stores given to
   * [`ClientBuilder::session_paths`].
   *
   * Each store exposes a SQLite connection. This method controls the cache
   * size, in **bytes (!)**.
   *
   * The cache represents data SQLite holds in memory at once per open
   * database file. The default cache implementation does not allocate the
   * full amount of cache memory all at once. Cache memory is allocated
   * in smaller chunks on an as-needed basis.
   *
   * See [`SqliteStoreConfig::cache_size`] to learn more.
   */
  sessionCacheSize(
    cacheSize: /*u32*/ number | undefined
  ): ClientBuilderInterface;
  /**
   * Set the size limit for the SQLite WAL files of stores given to
   * [`ClientBuilder::session_paths`].
   *
   * Each store uses the WAL journal mode. This method controls the size
   * limit of the WAL files, in **bytes (!)**.
   *
   * See [`SqliteStoreConfig::journal_size_limit`] to learn more.
   */
  sessionJournalSizeLimit(
    limit: /*u32*/ number | undefined
  ): ClientBuilderInterface;
  /**
   * Set the passphrase for the stores given to
   * [`ClientBuilder::session_paths`].
   */
  sessionPassphrase(passphrase: string | undefined): ClientBuilderInterface;
  /**
   * Sets the paths that the client will use to store its data and caches.
   * Both paths **must** be unique per session as the SDK stores aren't
   * capable of handling multiple users, however it is valid to use the
   * same path for both stores on a single session.
   *
   * Leaving this unset tells the client to use an in-memory data store.
   */
  sessionPaths(dataPath: string, cachePath: string): ClientBuilderInterface;
  /**
   * Set the pool max size for the SQLite stores given to
   * [`ClientBuilder::session_paths`].
   *
   * Each store exposes an async pool of connections. This method controls
   * the size of the pool. The larger the pool is, the more memory is
   * consumed, but also the more the app is reactive because it doesn't need
   * to wait on a pool to be available to run queries.
   *
   * See [`SqliteStoreConfig::pool_max_size`] to learn more.
   */
  sessionPoolMaxSize(
    poolMaxSize: /*u32*/ number | undefined
  ): ClientBuilderInterface;
  setSessionDelegate(
    sessionDelegate: ClientSessionDelegate
  ): ClientBuilderInterface;
  slidingSyncVersionBuilder(
    versionBuilder: SlidingSyncVersionBuilder
  ): ClientBuilderInterface;
  /**
   * Tell the client that the system is memory constrained, like in a push
   * notification process for example.
   *
   * So far, at the time of writing (2025-04-07), it changes the defaults of
   * [`SqliteStoreConfig`], so one might not need to call
   * [`ClientBuilder::session_cache_size`] and siblings for example. Please
   * check [`SqliteStoreConfig::with_low_memory_config`].
   */
  systemIsMemoryConstrained(): ClientBuilderInterface;
  userAgent(userAgent: string): ClientBuilderInterface;
  username(username: string): ClientBuilderInterface;
}

export class ClientBuilder
  extends UniffiAbstractObject
  implements ClientBuilderInterface
{
  readonly [uniffiTypeNameSymbol] = 'ClientBuilder';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeClientBuilderObjectFactory.bless(pointer);
  }

  public addRootCertificates(
    certificates: Array<ArrayBuffer>
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterArrayArrayBuffer.lower(certificates),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Automatically create a backup version if no backup exists.
   */
  public autoEnableBackups(autoEnableBackups: boolean): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterBool.lower(autoEnableBackups),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public autoEnableCrossSigning(
    autoEnableCrossSigning: boolean
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterBool.lower(autoEnableCrossSigning),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Select a strategy to download room keys from the backup. By default
   * we download after a decryption failure.
   *
   * Take a look at the [`BackupDownloadStrategy`] enum for more options.
   */
  public backupDownloadStrategy(
    backupDownloadStrategy: BackupDownloadStrategy
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeBackupDownloadStrategy.lower(
              backupDownloadStrategy
            ),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async build(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<ClientInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeClient.lift.bind(FfiConverterTypeClient),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientBuildError.lift.bind(
          FfiConverterTypeClientBuildError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Finish the building of the client and attempt to log in using the
   * provided [`QrCodeData`].
   *
   * This method will build the client and immediately attempt to log the
   * client in using the provided [`QrCodeData`] using the login
   * mechanism described in [MSC4108]. As such this methods requires OAuth
   * 2.0 support as well as sliding sync support.
   *
   * The usage of the progress_listener is required to transfer the
   * [`CheckCode`] to the existing client.
   *
   * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
   */
  public async buildWithQrCode(
    qrCodeData: QrCodeDataInterface,
    oidcConfiguration: OidcConfiguration,
    progressListener: QrLoginProgressListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ClientInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build_with_qr_code(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeQrCodeData.lower(qrCodeData),
            FfiConverterTypeOidcConfiguration.lower(oidcConfiguration),
            FfiConverterTypeQrLoginProgressListener.lower(progressListener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeClient.lift.bind(FfiConverterTypeClient),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeHumanQrLoginError.lift.bind(
          FfiConverterTypeHumanQrLoginError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public crossProcessStoreLocksHolderName(
    holderName: string
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(holderName),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public disableAutomaticTokenRefresh(): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Don't trust any system root certificates, only trust the certificates
   * provided through
   * [`add_root_certificates`][ClientBuilder::add_root_certificates].
   */
  public disableBuiltInRootCertificates(): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public disableSslVerification(): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public enableOidcRefreshLock(): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set whether to enable the experimental support for sending and receiving
   * encrypted room history on invite, per [MSC4268].
   *
   * [MSC4268]: https://github.com/matrix-org/matrix-spec-proposals/pull/4268
   */
  public enableShareHistoryOnInvite(
    enableShareHistoryOnInvite: boolean
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_share_history_on_invite(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enableShareHistoryOnInvite),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public homeserverUrl(url: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public proxy(url: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add a default request config to this client.
   */
  public requestConfig(config: RequestConfig): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeRequestConfig.lower(config),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the trust requirement to be used when decrypting events.
   */
  public roomDecryptionTrustRequirement(
    trustRequirement: TrustRequirement
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_decryption_trust_requirement(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeTrustRequirement.lower(trustRequirement),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the strategy to be used for picking recipient devices when sending
   * an encrypted message.
   */
  public roomKeyRecipientStrategy(
    strategy: CollectStrategy
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeCollectStrategy.lower(strategy),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public serverName(serverName: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(serverName),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public serverNameOrHomeserverUrl(
    serverNameOrUrl: string
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(serverNameOrUrl),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the cache size for the SQLite stores given to
   * [`ClientBuilder::session_paths`].
   *
   * Each store exposes a SQLite connection. This method controls the cache
   * size, in **bytes (!)**.
   *
   * The cache represents data SQLite holds in memory at once per open
   * database file. The default cache implementation does not allocate the
   * full amount of cache memory all at once. Cache memory is allocated
   * in smaller chunks on an as-needed basis.
   *
   * See [`SqliteStoreConfig::cache_size`] to learn more.
   */
  public sessionCacheSize(
    cacheSize: /*u32*/ number | undefined
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_cache_size(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterOptionalUInt32.lower(cacheSize),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the size limit for the SQLite WAL files of stores given to
   * [`ClientBuilder::session_paths`].
   *
   * Each store uses the WAL journal mode. This method controls the size
   * limit of the WAL files, in **bytes (!)**.
   *
   * See [`SqliteStoreConfig::journal_size_limit`] to learn more.
   */
  public sessionJournalSizeLimit(
    limit: /*u32*/ number | undefined
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_journal_size_limit(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterOptionalUInt32.lower(limit),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the passphrase for the stores given to
   * [`ClientBuilder::session_paths`].
   */
  public sessionPassphrase(
    passphrase: string | undefined
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_passphrase(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(passphrase),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Sets the paths that the client will use to store its data and caches.
   * Both paths **must** be unique per session as the SDK stores aren't
   * capable of handling multiple users, however it is valid to use the
   * same path for both stores on a single session.
   *
   * Leaving this unset tells the client to use an in-memory data store.
   */
  public sessionPaths(
    dataPath: string,
    cachePath: string
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_paths(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(dataPath),
            FfiConverterString.lower(cachePath),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the pool max size for the SQLite stores given to
   * [`ClientBuilder::session_paths`].
   *
   * Each store exposes an async pool of connections. This method controls
   * the size of the pool. The larger the pool is, the more memory is
   * consumed, but also the more the app is reactive because it doesn't need
   * to wait on a pool to be available to run queries.
   *
   * See [`SqliteStoreConfig::pool_max_size`] to learn more.
   */
  public sessionPoolMaxSize(
    poolMaxSize: /*u32*/ number | undefined
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_pool_max_size(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterOptionalUInt32.lower(poolMaxSize),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setSessionDelegate(
    sessionDelegate: ClientSessionDelegate
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeClientSessionDelegate.lower(sessionDelegate),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public slidingSyncVersionBuilder(
    versionBuilder: SlidingSyncVersionBuilder
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeSlidingSyncVersionBuilder.lower(versionBuilder),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Tell the client that the system is memory constrained, like in a push
   * notification process for example.
   *
   * So far, at the time of writing (2025-04-07), it changes the defaults of
   * [`SqliteStoreConfig`], so one might not need to call
   * [`ClientBuilder::session_cache_size`] and siblings for example. Please
   * check [`SqliteStoreConfig::with_low_memory_config`].
   */
  public systemIsMemoryConstrained(): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_system_is_memory_constrained(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public userAgent(userAgent: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(userAgent),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public username(username: string): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(username),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeClientBuilderObjectFactory.pointer(this);
      uniffiTypeClientBuilderObjectFactory.freePointer(pointer);
      uniffiTypeClientBuilderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ClientBuilder {
    return uniffiTypeClientBuilderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeClientBuilderObjectFactory: UniffiObjectFactory<ClientBuilderInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ClientBuilderInterface {
      const instance = Object.create(ClientBuilder.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ClientBuilder';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_clientbuilder_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ClientBuilderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ClientBuilderInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_clientbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ClientBuilderInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ClientBuilder'
      );
    },
  };
// FfiConverter for ClientBuilderInterface
const FfiConverterTypeClientBuilder = new FfiConverterObject(
  uniffiTypeClientBuilderObjectFactory
);

export interface EncryptionInterface {
  /**
   * Does a backup exist on the server?
   *
   * Because the homeserver doesn't notify us about changes to the backup
   * version, the [`BackupState`] and its listener are a bit crippled.
   * The `BackupState::Unknown` state might mean there is no backup at all or
   * a backup exists but we don't have access to it.
   *
   * Therefore it is necessary to poll the server for an answer every time
   * you want to differentiate between those two states.
   */
  backupExistsOnServer(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  backupState(): BackupState;
  backupStateListener(listener: BackupStateListener): TaskHandleInterface;
  /**
   * Get the public curve25519 key of our own device in base64. This is
   * usually what is called the identity key of the device.
   */
  curve25519Key(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined>;
  disableRecovery(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Get the public ed25519 key of our own device. This is usually what is
   * called the fingerprint of the device.
   */
  ed25519Key(asyncOpts_?: { signal: AbortSignal }): Promise<string | undefined>;
  enableBackups(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  enableRecovery(
    waitForBackupsToUpload: boolean,
    passphrase: string | undefined,
    progressListener: EnableRecoveryProgressListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  isLastDevice(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  recover(
    recoveryKey: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  recoverAndReset(
    oldRecoveryKey: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  recoveryState(): RecoveryState;
  recoveryStateListener(listener: RecoveryStateListener): TaskHandleInterface;
  /**
   * Completely reset the current user's crypto identity: reset the cross
   * signing keys, delete the existing backup and recovery key.
   */
  resetIdentity(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<IdentityResetHandleInterface | undefined>;
  resetRecoveryKey(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string>;
  /**
   * Get the E2EE identity of a user.
   *
   * This method always tries to fetch the identity from the store, which we
   * only have if the user is tracked, meaning that we are both members
   * of the same encrypted room. If no user is found locally, a request will
   * be made to the homeserver.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user that the identity belongs to.
   *
   * Returns a `UserIdentity` if one is found. Returns an error if there
   * was an issue with the crypto store or with the request to the
   * homeserver.
   *
   * This will always return `None` if the client hasn't been logged in.
   */
  userIdentity(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<UserIdentityInterface | undefined>;
  verificationState(): VerificationState;
  verificationStateListener(
    listener: VerificationStateListener
  ): TaskHandleInterface;
  waitForBackupUploadSteadyState(
    progressListener: BackupSteadyStateListener | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Waits for end-to-end encryption initialization tasks to finish, if any
   * was running in the background.
   */
  waitForE2eeInitializationTasks(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void>;
}

export class Encryption
  extends UniffiAbstractObject
  implements EncryptionInterface
{
  readonly [uniffiTypeNameSymbol] = 'Encryption';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeEncryptionObjectFactory.bless(pointer);
  }

  /**
   * Does a backup exist on the server?
   *
   * Because the homeserver doesn't notify us about changes to the backup
   * version, the [`BackupState`] and its listener are a bit crippled.
   * The `BackupState::Unknown` state might mean there is no backup at all or
   * a backup exists but we don't have access to it.
   *
   * Therefore it is necessary to poll the server for an answer every time
   * you want to differentiate between those two states.
   */
  public async backupExistsOnServer(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public backupState(): BackupState {
    return FfiConverterTypeBackupState.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public backupStateListener(
    listener: BackupStateListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterTypeBackupStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the public curve25519 key of our own device in base64. This is
   * usually what is called the identity key of the device.
   */
  public async curve25519Key(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async disableRecovery(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the public ed25519 key of our own device. This is usually what is
   * called the fingerprint of the device.
   */
  public async ed25519Key(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async enableBackups(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async enableRecovery(
    waitForBackupsToUpload: boolean,
    passphrase: string | undefined,
    progressListener: EnableRecoveryProgressListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterBool.lower(waitForBackupsToUpload),
            FfiConverterOptionalString.lower(passphrase),
            FfiConverterTypeEnableRecoveryProgressListener.lower(
              progressListener
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async isLastDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async recover(
    recoveryKey: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recover(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterString.lower(recoveryKey)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async recoverAndReset(
    oldRecoveryKey: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterString.lower(oldRecoveryKey)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public recoveryState(): RecoveryState {
    return FfiConverterTypeRecoveryState.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public recoveryStateListener(
    listener: RecoveryStateListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterTypeRecoveryStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Completely reset the current user's crypto identity: reset the cross
   * signing keys, delete the existing backup and recovery key.
   */
  public async resetIdentity(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<IdentityResetHandleInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeIdentityResetHandle.lift.bind(
          FfiConverterOptionalTypeIdentityResetHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async resetRecoveryKey(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(
          FfiConverterTypeRecoveryError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the E2EE identity of a user.
   *
   * This method always tries to fetch the identity from the store, which we
   * only have if the user is tracked, meaning that we are both members
   * of the same encrypted room. If no user is found locally, a request will
   * be made to the homeserver.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user that the identity belongs to.
   *
   * Returns a `UserIdentity` if one is found. Returns an error if there
   * was an issue with the crypto store or with the request to the
   * homeserver.
   *
   * This will always return `None` if the client hasn't been logged in.
   */
  public async userIdentity(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<UserIdentityInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeUserIdentity.lift.bind(
          FfiConverterOptionalTypeUserIdentity
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public verificationState(): VerificationState {
    return FfiConverterTypeVerificationState.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public verificationStateListener(
    listener: VerificationStateListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterTypeVerificationStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async waitForBackupUploadSteadyState(
    progressListener: BackupSteadyStateListener | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(
            uniffiTypeEncryptionObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeBackupSteadyStateListener.lower(
              progressListener
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSteadyStateError.lift.bind(
          FfiConverterTypeSteadyStateError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Waits for end-to-end encryption initialization tasks to finish, if any
   * was running in the background.
   */
  public async waitForE2eeInitializationTasks(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(
            uniffiTypeEncryptionObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeEncryptionObjectFactory.pointer(this);
      uniffiTypeEncryptionObjectFactory.freePointer(pointer);
      uniffiTypeEncryptionObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Encryption {
    return uniffiTypeEncryptionObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeEncryptionObjectFactory: UniffiObjectFactory<EncryptionInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): EncryptionInterface {
      const instance = Object.create(Encryption.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Encryption';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_encryption_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: EncryptionInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: EncryptionInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_encryption(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_encryption(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is EncryptionInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Encryption'
      );
    },
  };
// FfiConverter for EncryptionInterface
const FfiConverterTypeEncryption = new FfiConverterObject(
  uniffiTypeEncryptionObjectFactory
);

export interface HomeserverLoginDetailsInterface {
  /**
   * The sliding sync version.
   */
  slidingSyncVersion(): SlidingSyncVersion;
  /**
   * The prompts advertised by the authentication issuer for use in the login
   * URL.
   */
  supportedOidcPrompts(): Array<OidcPrompt>;
  /**
   * Whether the current homeserver supports login using OIDC.
   */
  supportsOidcLogin(): boolean;
  /**
   * Whether the current homeserver supports the password login flow.
   */
  supportsPasswordLogin(): boolean;
  /**
   * The URL of the currently configured homeserver.
   */
  url(): string;
}

export class HomeserverLoginDetails
  extends UniffiAbstractObject
  implements HomeserverLoginDetailsInterface
{
  readonly [uniffiTypeNameSymbol] = 'HomeserverLoginDetails';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeHomeserverLoginDetailsObjectFactory.bless(pointer);
  }

  /**
   * The sliding sync version.
   */
  public slidingSyncVersion(): SlidingSyncVersion {
    return FfiConverterTypeSlidingSyncVersion.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * The prompts advertised by the authentication issuer for use in the login
   * URL.
   */
  public supportedOidcPrompts(): Array<OidcPrompt> {
    return FfiConverterArrayTypeOidcPrompt.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the current homeserver supports login using OIDC.
   */
  public supportsOidcLogin(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the current homeserver supports the password login flow.
   */
  public supportsPasswordLogin(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * The URL of the currently configured homeserver.
   */
  public url(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(
            uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeHomeserverLoginDetailsObjectFactory.pointer(this);
      uniffiTypeHomeserverLoginDetailsObjectFactory.freePointer(pointer);
      uniffiTypeHomeserverLoginDetailsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is HomeserverLoginDetails {
    return uniffiTypeHomeserverLoginDetailsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeHomeserverLoginDetailsObjectFactory: UniffiObjectFactory<HomeserverLoginDetailsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): HomeserverLoginDetailsInterface {
      const instance = Object.create(HomeserverLoginDetails.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'HomeserverLoginDetails';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_homeserverlogindetails_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: HomeserverLoginDetailsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: HomeserverLoginDetailsInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is HomeserverLoginDetailsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'HomeserverLoginDetails'
      );
    },
  };
// FfiConverter for HomeserverLoginDetailsInterface
const FfiConverterTypeHomeserverLoginDetails = new FfiConverterObject(
  uniffiTypeHomeserverLoginDetailsObjectFactory
);

export interface IdentityResetHandleInterface {
  /**
   * Get the underlying [`CrossSigningResetAuthType`] this identity reset
   * process is using.
   */
  authType(): CrossSigningResetAuthType;
  cancel(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * This method starts the identity reset process and
   * will go through the following steps:
   *
   * 1. Disable backing up room keys and delete the active backup
   * 2. Disable recovery and delete secret storage
   * 3. Go through the cross-signing key reset flow
   * 4. Finally, re-enable key backups only if they were enabled before
   */
  reset(
    auth: AuthData | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class IdentityResetHandle
  extends UniffiAbstractObject
  implements IdentityResetHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'IdentityResetHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeIdentityResetHandleObjectFactory.bless(pointer);
  }

  /**
   * Get the underlying [`CrossSigningResetAuthType`] this identity reset
   * process is using.
   */
  public authType(): CrossSigningResetAuthType {
    return FfiConverterTypeCrossSigningResetAuthType.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(
            uniffiTypeIdentityResetHandleObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async cancel(asyncOpts_?: { signal: AbortSignal }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(
            uniffiTypeIdentityResetHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * This method starts the identity reset process and
   * will go through the following steps:
   *
   * 1. Disable backing up room keys and delete the active backup
   * 2. Disable recovery and delete secret storage
   * 3. Go through the cross-signing key reset flow
   * 4. Finally, re-enable key backups only if they were enabled before
   */
  public async reset(
    auth: AuthData | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(
            uniffiTypeIdentityResetHandleObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeAuthData.lower(auth)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeIdentityResetHandleObjectFactory.pointer(this);
      uniffiTypeIdentityResetHandleObjectFactory.freePointer(pointer);
      uniffiTypeIdentityResetHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is IdentityResetHandle {
    return uniffiTypeIdentityResetHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeIdentityResetHandleObjectFactory: UniffiObjectFactory<IdentityResetHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): IdentityResetHandleInterface {
      const instance = Object.create(IdentityResetHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'IdentityResetHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_identityresethandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: IdentityResetHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: IdentityResetHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_identityresethandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is IdentityResetHandleInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'IdentityResetHandle'
      );
    },
  };
// FfiConverter for IdentityResetHandleInterface
const FfiConverterTypeIdentityResetHandle = new FfiConverterObject(
  uniffiTypeIdentityResetHandleObjectFactory
);

export interface InReplyToDetailsInterface {
  event(): EmbeddedEventDetails;
  eventId(): string;
}

export class InReplyToDetails
  extends UniffiAbstractObject
  implements InReplyToDetailsInterface
{
  readonly [uniffiTypeNameSymbol] = 'InReplyToDetails';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeInReplyToDetailsObjectFactory.bless(pointer);
  }

  public event(): EmbeddedEventDetails {
    return FfiConverterTypeEmbeddedEventDetails.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(
            uniffiTypeInReplyToDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public eventId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(
            uniffiTypeInReplyToDetailsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeInReplyToDetailsObjectFactory.pointer(this);
      uniffiTypeInReplyToDetailsObjectFactory.freePointer(pointer);
      uniffiTypeInReplyToDetailsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is InReplyToDetails {
    return uniffiTypeInReplyToDetailsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeInReplyToDetailsObjectFactory: UniffiObjectFactory<InReplyToDetailsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): InReplyToDetailsInterface {
      const instance = Object.create(InReplyToDetails.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'InReplyToDetails';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_inreplytodetails_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: InReplyToDetailsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: InReplyToDetailsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is InReplyToDetailsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'InReplyToDetails'
      );
    },
  };
// FfiConverter for InReplyToDetailsInterface
const FfiConverterTypeInReplyToDetails = new FfiConverterObject(
  uniffiTypeInReplyToDetailsObjectFactory
);

/**
 * A set of actions to perform for a knock request.
 */
export interface KnockRequestActionsInterface {
  /**
   * Accepts the knock request by inviting the user to the room.
   */
  accept(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Declines the knock request by kicking the user from the room with an
   * optional reason.
   */
  decline(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Declines the knock request by banning the user from the room with an
   * optional reason.
   */
  declineAndBan(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Marks the knock request as 'seen'.
   *
   * **IMPORTANT**: this won't update the current reference to this request,
   * a new one with the updated value should be emitted instead.
   */
  markAsSeen(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

/**
 * A set of actions to perform for a knock request.
 */
export class KnockRequestActions
  extends UniffiAbstractObject
  implements KnockRequestActionsInterface
{
  readonly [uniffiTypeNameSymbol] = 'KnockRequestActions';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeKnockRequestActionsObjectFactory.bless(pointer);
  }

  /**
   * Accepts the knock request by inviting the user to the room.
   */
  public async accept(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(
            uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Declines the knock request by kicking the user from the room with an
   * optional reason.
   */
  public async decline(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(
            uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Declines the knock request by banning the user from the room with an
   * optional reason.
   */
  public async declineAndBan(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(
            uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Marks the knock request as 'seen'.
   *
   * **IMPORTANT**: this won't update the current reference to this request,
   * a new one with the updated value should be emitted instead.
   */
  public async markAsSeen(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(
            uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeKnockRequestActionsObjectFactory.pointer(this);
      uniffiTypeKnockRequestActionsObjectFactory.freePointer(pointer);
      uniffiTypeKnockRequestActionsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is KnockRequestActions {
    return uniffiTypeKnockRequestActionsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeKnockRequestActionsObjectFactory: UniffiObjectFactory<KnockRequestActionsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): KnockRequestActionsInterface {
      const instance = Object.create(KnockRequestActions.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'KnockRequestActions';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_knockrequestactions_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: KnockRequestActionsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: KnockRequestActionsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is KnockRequestActionsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'KnockRequestActions'
      );
    },
  };
// FfiConverter for KnockRequestActionsInterface
const FfiConverterTypeKnockRequestActions = new FfiConverterObject(
  uniffiTypeKnockRequestActionsObjectFactory
);

/**
 * Wrapper to retrieve some timeline item info lazily.
 */
export interface LazyTimelineItemProviderInterface {
  containsOnlyEmojis(): boolean;
  /**
   * Returns some debug information for this event timeline item.
   */
  debugInfo(): EventTimelineItemDebugInfo;
  /**
   * For local echoes, return the associated send handle; returns `None` for
   * remote echoes.
   */
  getSendHandle(): SendHandleInterface | undefined;
  /**
   * Returns the shields for this event timeline item.
   */
  getShields(strict: boolean): ShieldState | undefined;
}

/**
 * Wrapper to retrieve some timeline item info lazily.
 */
export class LazyTimelineItemProvider
  extends UniffiAbstractObject
  implements LazyTimelineItemProviderInterface
{
  readonly [uniffiTypeNameSymbol] = 'LazyTimelineItemProvider';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLazyTimelineItemProviderObjectFactory.bless(pointer);
  }

  public containsOnlyEmojis(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_contains_only_emojis(
            uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns some debug information for this event timeline item.
   */
  public debugInfo(): EventTimelineItemDebugInfo {
    return FfiConverterTypeEventTimelineItemDebugInfo.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(
            uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * For local echoes, return the associated send handle; returns `None` for
   * remote echoes.
   */
  public getSendHandle(): SendHandleInterface | undefined {
    return FfiConverterOptionalTypeSendHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(
            uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns the shields for this event timeline item.
   */
  public getShields(strict: boolean): ShieldState | undefined {
    return FfiConverterOptionalTypeShieldState.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(
            uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this),
            FfiConverterBool.lower(strict),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeLazyTimelineItemProviderObjectFactory.pointer(this);
      uniffiTypeLazyTimelineItemProviderObjectFactory.freePointer(pointer);
      uniffiTypeLazyTimelineItemProviderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LazyTimelineItemProvider {
    return uniffiTypeLazyTimelineItemProviderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLazyTimelineItemProviderObjectFactory: UniffiObjectFactory<LazyTimelineItemProviderInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): LazyTimelineItemProviderInterface {
      const instance = Object.create(LazyTimelineItemProvider.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LazyTimelineItemProvider';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_lazytimelineitemprovider_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LazyTimelineItemProviderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: LazyTimelineItemProviderInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LazyTimelineItemProviderInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'LazyTimelineItemProvider'
      );
    },
  };
// FfiConverter for LazyTimelineItemProviderInterface
const FfiConverterTypeLazyTimelineItemProvider = new FfiConverterObject(
  uniffiTypeLazyTimelineItemProviderObjectFactory
);

/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
export interface MediaFileHandleInterface {
  /**
   * Get the media file's path.
   */
  path() /*throws*/ : string;
  persist(path: string) /*throws*/ : boolean;
}

/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
export class MediaFileHandle
  extends UniffiAbstractObject
  implements MediaFileHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'MediaFileHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeMediaFileHandleObjectFactory.bless(pointer);
  }

  /**
   * Get the media file's path.
   */
  public path(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(
            uniffiTypeMediaFileHandleObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public persist(path: string): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(
            uniffiTypeMediaFileHandleObjectFactory.clonePointer(this),
            FfiConverterString.lower(path),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeMediaFileHandleObjectFactory.pointer(this);
      uniffiTypeMediaFileHandleObjectFactory.freePointer(pointer);
      uniffiTypeMediaFileHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is MediaFileHandle {
    return uniffiTypeMediaFileHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeMediaFileHandleObjectFactory: UniffiObjectFactory<MediaFileHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): MediaFileHandleInterface {
      const instance = Object.create(MediaFileHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'MediaFileHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_mediafilehandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: MediaFileHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: MediaFileHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is MediaFileHandleInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'MediaFileHandle'
      );
    },
  };
// FfiConverter for MediaFileHandleInterface
const FfiConverterTypeMediaFileHandle = new FfiConverterObject(
  uniffiTypeMediaFileHandleObjectFactory
);

export interface MediaSourceInterface {
  toJson(): string;
  url(): string;
}

export class MediaSource
  extends UniffiAbstractObject
  implements MediaSourceInterface
{
  readonly [uniffiTypeNameSymbol] = 'MediaSource';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeMediaSourceObjectFactory.bless(pointer);
  }

  public static fromJson(json: string): MediaSourceInterface /*throws*/ {
    return FfiConverterTypeMediaSource.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromUrl(url: string): MediaSourceInterface /*throws*/ {
    return FfiConverterTypeMediaSource.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(
            FfiConverterString.lower(url),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toJson(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(
            uniffiTypeMediaSourceObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public url(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediasource_url(
            uniffiTypeMediaSourceObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeMediaSourceObjectFactory.pointer(this);
      uniffiTypeMediaSourceObjectFactory.freePointer(pointer);
      uniffiTypeMediaSourceObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is MediaSource {
    return uniffiTypeMediaSourceObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeMediaSourceObjectFactory: UniffiObjectFactory<MediaSourceInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): MediaSourceInterface {
      const instance = Object.create(MediaSource.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'MediaSource';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_mediasource_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: MediaSourceInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: MediaSourceInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_mediasource(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_mediasource(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is MediaSourceInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'MediaSource'
      );
    },
  };
// FfiConverter for MediaSourceInterface
const FfiConverterTypeMediaSource = new FfiConverterObject(
  uniffiTypeMediaSourceObjectFactory
);

export interface NotificationClientInterface {
  /**
   * See also documentation of
   * `MatrixNotificationClient::get_notification`.
   */
  getNotification(
    roomId: string,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<NotificationItem | undefined>;
  /**
   * Get several notification items in a single batch.
   *
   * Returns an error if the flow failed when preparing to fetch the
   * notifications, and a [`HashMap`] containing either a
   * [`NotificationItem`] or no entry for it if it failed to fetch a
   * notification for the provided [`EventId`].
   */
  getNotifications(
    requests: Array<NotificationItemsRequest>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Map<string, NotificationItem>>;
  /**
   * Fetches a room by its ID using the in-memory state store backed client.
   *
   * Useful to retrieve room information after running the limited
   * notification client sliding sync loop.
   */
  getRoom(roomId: string) /*throws*/ : RoomInterface | undefined;
}

export class NotificationClient
  extends UniffiAbstractObject
  implements NotificationClientInterface
{
  readonly [uniffiTypeNameSymbol] = 'NotificationClient';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNotificationClientObjectFactory.bless(pointer);
  }

  /**
   * See also documentation of
   * `MatrixNotificationClient::get_notification`.
   */
  public async getNotification(
    roomId: string,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<NotificationItem | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(
            uniffiTypeNotificationClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeNotificationItem.lift.bind(
          FfiConverterOptionalTypeNotificationItem
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get several notification items in a single batch.
   *
   * Returns an error if the flow failed when preparing to fetch the
   * notifications, and a [`HashMap`] containing either a
   * [`NotificationItem`] or no entry for it if it failed to fetch a
   * notification for the provided [`EventId`].
   */
  public async getNotifications(
    requests: Array<NotificationItemsRequest>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Map<string, NotificationItem>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notifications(
            uniffiTypeNotificationClientObjectFactory.clonePointer(this),
            FfiConverterArrayTypeNotificationItemsRequest.lower(requests)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterMapStringTypeNotificationItem.lift.bind(
          FfiConverterMapStringTypeNotificationItem
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Fetches a room by its ID using the in-memory state store backed client.
   *
   * Useful to retrieve room information after running the limited
   * notification client sliding sync loop.
   */
  public getRoom(roomId: string): RoomInterface | undefined /*throws*/ {
    return FfiConverterOptionalTypeRoom.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_room(
            uniffiTypeNotificationClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNotificationClientObjectFactory.pointer(this);
      uniffiTypeNotificationClientObjectFactory.freePointer(pointer);
      uniffiTypeNotificationClientObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NotificationClient {
    return uniffiTypeNotificationClientObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNotificationClientObjectFactory: UniffiObjectFactory<NotificationClientInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NotificationClientInterface {
      const instance = Object.create(NotificationClient.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NotificationClient';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_notificationclient_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NotificationClientInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NotificationClientInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_notificationclient(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_notificationclient(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NotificationClientInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NotificationClient'
      );
    },
  };
// FfiConverter for NotificationClientInterface
const FfiConverterTypeNotificationClient = new FfiConverterObject(
  uniffiTypeNotificationClientObjectFactory
);

export interface NotificationSettingsInterface {
  /**
   * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  canHomeserverPushEncryptedEventToDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean>;
  /**
   * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  canPushEncryptedEventToDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean>;
  /**
   * Get whether some enabled keyword rules exist.
   */
  containsKeywordsRules(asyncOpts_?: { signal: AbortSignal }): Promise<boolean>;
  /**
   * Get the default room notification mode
   *
   * The mode will depend on the associated `PushRule` based on whether the
   * room is encrypted or not, and on the number of members.
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chats involving two
   * people
   */
  getDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomNotificationMode>;
  /**
   * Get the notification settings for a room.
   *
   * # Arguments
   *
   * * `room_id` - the room ID
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  getRoomNotificationSettings(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomNotificationSettings>;
  /**
   * Get all room IDs for which a user-defined rule exists.
   */
  getRoomsWithUserDefinedRules(
    enabled: boolean | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<string>>;
  /**
   * Get the user defined room notification mode
   */
  getUserDefinedRoomNotificationMode(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomNotificationMode | undefined>;
  /**
   * Get whether the `.m.rule.call` push rule is enabled
   */
  isCallEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Get whether the `.m.rule.invite_for_me` push rule is enabled
   */
  isInviteForMeEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Get whether room mentions are enabled.
   */
  isRoomMentionEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Get whether user mentions are enabled.
   */
  isUserMentionEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Restore the default notification mode for a room
   */
  restoreDefaultRoomNotificationMode(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set whether the `.m.rule.call` push rule is enabled
   */
  setCallEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Sets a custom push rule with the given actions and conditions.
   */
  setCustomPushRule(
    ruleId: string,
    ruleKind: RuleKind,
    actions: Array<Action>,
    conditions: Array<PushCondition>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set the default room notification mode
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the mode is for encrypted rooms
   * * `is_one_to_one` - whether the mode is for direct chats involving two
   * people
   * * `mode` - the new default mode
   */
  setDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    mode: RoomNotificationMode,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  setDelegate(delegate: NotificationSettingsDelegate | undefined): void;
  /**
   * Set whether the `.m.rule.invite_for_me` push rule is enabled
   */
  setInviteForMeEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set whether room mentions are enabled.
   */
  setRoomMentionEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set the notification mode for a room.
   */
  setRoomNotificationMode(
    roomId: string,
    mode: RoomNotificationMode,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set whether user mentions are enabled.
   */
  setUserMentionEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Unmute a room.
   *
   * # Arguments
   *
   * * `room_id` - the room to unmute
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  unmuteRoom(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class NotificationSettings
  extends UniffiAbstractObject
  implements NotificationSettingsInterface
{
  readonly [uniffiTypeNameSymbol] = 'NotificationSettings';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNotificationSettingsObjectFactory.bless(pointer);
  }

  /**
   * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  public async canHomeserverPushEncryptedEventToDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
   *
   * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
   */
  public async canPushEncryptedEventToDevice(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether some enabled keyword rules exist.
   */
  public async containsKeywordsRules(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the default room notification mode
   *
   * The mode will depend on the associated `PushRule` based on whether the
   * room is encrypted or not, and on the number of members.
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chats involving two
   * people
   */
  public async getDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomNotificationMode> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isEncrypted),
            FfiConverterBool.lower(isOneToOne)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomNotificationMode.lift.bind(
          FfiConverterTypeRoomNotificationMode
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the notification settings for a room.
   *
   * # Arguments
   *
   * * `room_id` - the room ID
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  public async getRoomNotificationSettings(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomNotificationSettings> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterBool.lower(isEncrypted),
            FfiConverterBool.lower(isOneToOne)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomNotificationSettings.lift.bind(
          FfiConverterTypeRoomNotificationSettings
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get all room IDs for which a user-defined rule exists.
   */
  public async getRoomsWithUserDefinedRules(
    enabled: boolean | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<string>> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterOptionalBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayString.lift.bind(
          FfiConverterArrayString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the user defined room notification mode
   */
  public async getUserDefinedRoomNotificationMode(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomNotificationMode | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeRoomNotificationMode.lift.bind(
          FfiConverterOptionalTypeRoomNotificationMode
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether the `.m.rule.call` push rule is enabled
   */
  public async isCallEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether the `.m.rule.invite_for_me` push rule is enabled
   */
  public async isInviteForMeEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether room mentions are enabled.
   */
  public async isRoomMentionEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get whether user mentions are enabled.
   */
  public async isUserMentionEnabled(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Restore the default notification mode for a room
   */
  public async restoreDefaultRoomNotificationMode(
    roomId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set whether the `.m.rule.call` push rule is enabled
   */
  public async setCallEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets a custom push rule with the given actions and conditions.
   */
  public async setCustomPushRule(
    ruleId: string,
    ruleKind: RuleKind,
    actions: Array<Action>,
    conditions: Array<PushCondition>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_custom_push_rule(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(ruleId),
            FfiConverterTypeRuleKind.lower(ruleKind),
            FfiConverterArrayTypeAction.lower(actions),
            FfiConverterArrayTypePushCondition.lower(conditions)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set the default room notification mode
   *
   * # Arguments
   *
   * * `is_encrypted` - whether the mode is for encrypted rooms
   * * `is_one_to_one` - whether the mode is for direct chats involving two
   * people
   * * `mode` - the new default mode
   */
  public async setDefaultRoomNotificationMode(
    isEncrypted: boolean,
    isOneToOne: boolean,
    mode: RoomNotificationMode,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isEncrypted),
            FfiConverterBool.lower(isOneToOne),
            FfiConverterTypeRoomNotificationMode.lower(mode)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public setDelegate(delegate: NotificationSettingsDelegate | undefined): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(
          uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
          FfiConverterOptionalTypeNotificationSettingsDelegate.lower(delegate),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set whether the `.m.rule.invite_for_me` push rule is enabled
   */
  public async setInviteForMeEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set whether room mentions are enabled.
   */
  public async setRoomMentionEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set the notification mode for a room.
   */
  public async setRoomNotificationMode(
    roomId: string,
    mode: RoomNotificationMode,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterTypeRoomNotificationMode.lower(mode)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set whether user mentions are enabled.
   */
  public async setUserMentionEnabled(
    enabled: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Unmute a room.
   *
   * # Arguments
   *
   * * `room_id` - the room to unmute
   * * `is_encrypted` - whether the room is encrypted
   * * `is_one_to_one` - whether the room is a direct chat involving two
   * people
   */
  public async unmuteRoom(
    roomId: string,
    isEncrypted: boolean,
    isOneToOne: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
            uniffiTypeNotificationSettingsObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            FfiConverterBool.lower(isEncrypted),
            FfiConverterBool.lower(isOneToOne)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(
          FfiConverterTypeNotificationSettingsError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNotificationSettingsObjectFactory.pointer(this);
      uniffiTypeNotificationSettingsObjectFactory.freePointer(pointer);
      uniffiTypeNotificationSettingsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NotificationSettings {
    return uniffiTypeNotificationSettingsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNotificationSettingsObjectFactory: UniffiObjectFactory<NotificationSettingsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NotificationSettingsInterface {
      const instance = Object.create(NotificationSettings.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NotificationSettings';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_notificationsettings_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NotificationSettingsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NotificationSettingsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_notificationsettings(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NotificationSettingsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NotificationSettings'
      );
    },
  };
// FfiConverter for NotificationSettingsInterface
const FfiConverterTypeNotificationSettings = new FfiConverterObject(
  uniffiTypeNotificationSettingsObjectFactory
);

/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
export interface QrCodeDataInterface {
  /**
   * The server name contained within the scanned QR code data.
   *
   * Note: This value is only present when scanning a QR code the belongs to
   * a logged in client. The mode where the new client shows the QR code
   * will return `None`.
   */
  serverName(): string | undefined;
}

/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
export class QrCodeData
  extends UniffiAbstractObject
  implements QrCodeDataInterface
{
  readonly [uniffiTypeNameSymbol] = 'QrCodeData';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeQrCodeDataObjectFactory.bless(pointer);
  }

  /**
   * Attempt to decode a slice of bytes into a [`QrCodeData`] object.
   *
   * The slice of bytes would generally be returned by a QR code decoder.
   */
  public static fromBytes(bytes: ArrayBuffer): QrCodeDataInterface /*throws*/ {
    return FfiConverterTypeQrCodeData.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeQrCodeDecodeError.lift.bind(
          FfiConverterTypeQrCodeDecodeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(
            FfiConverterArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * The server name contained within the scanned QR code data.
   *
   * Note: This value is only present when scanning a QR code the belongs to
   * a logged in client. The mode where the new client shows the QR code
   * will return `None`.
   */
  public serverName(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_qrcodedata_server_name(
            uniffiTypeQrCodeDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeQrCodeDataObjectFactory.pointer(this);
      uniffiTypeQrCodeDataObjectFactory.freePointer(pointer);
      uniffiTypeQrCodeDataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is QrCodeData {
    return uniffiTypeQrCodeDataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeQrCodeDataObjectFactory: UniffiObjectFactory<QrCodeDataInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): QrCodeDataInterface {
      const instance = Object.create(QrCodeData.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'QrCodeData';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_qrcodedata_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: QrCodeDataInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: QrCodeDataInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_qrcodedata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is QrCodeDataInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'QrCodeData'
      );
    },
  };
// FfiConverter for QrCodeDataInterface
const FfiConverterTypeQrCodeData = new FfiConverterObject(
  uniffiTypeQrCodeDataObjectFactory
);

export interface RoomInterface {
  activeMembersCount(): /*u64*/ bigint;
  /**
   * Returns a Vec of userId's that participate in the room call.
   *
   * MatrixRTC memberships with application "m.call" and scope "m.room" are
   * considered. A user can occur twice if they join with two devices.
   * convert to a set depending if the different users are required or the
   * amount of sessions.
   *
   * The vector is ordered by oldest membership user to newest.
   */
  activeRoomCallParticipants(): Array<string>;
  alternativeAliases(): Array<string>;
  applyPowerLevelChanges(
    changes: RoomPowerLevelChanges,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  avatarUrl(): string | undefined;
  banUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  canUserBan(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserInvite(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserKick(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserPinUnpin(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserRedactOther(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserRedactOwn(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserSendMessage(
    userId: string,
    message: MessageLikeEventType,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserSendState(
    userId: string,
    stateEvent: StateEventType,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canUserTriggerRoomNotification(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  canonicalAlias(): string | undefined;
  /**
   * Remove the `ComposerDraft` stored in the state store for this room.
   */
  clearComposerDraft(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Clear the event cache storage for the current room.
   *
   * This will remove all the information related to the event cache, in
   * memory and in the persisted storage, if enabled.
   */
  clearEventCacheStorage(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Forces the currently active room key, which is used to encrypt messages,
   * to be rotated.
   *
   * A new room key will be crated and shared with all the room members the
   * next time a message will be sent. You don't have to call this method,
   * room keys will be rotated automatically when necessary. This method is
   * still useful for debugging purposes.
   */
  discardRoomKey(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  displayName(): string | undefined;
  /**
   * Edit an event given its event id.
   *
   * Useful outside the context of a timeline, or when a timeline doesn't
   * have the full content of an event.
   */
  edit(
    eventId: string,
    newContent: RoomMessageEventContentWithoutRelationInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Enable End-to-end encryption in this room.
   */
  enableEncryption(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Enable or disable the send queue for that particular room.
   */
  enableSendQueue(enable: boolean): void;
  encryptionState(): EncryptionState;
  /**
   * Forget this room.
   *
   * This communicates to the homeserver that it should forget the room.
   *
   * Only left or banned-from rooms can be forgotten.
   */
  forget(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  getPowerLevels(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomPowerLevels>;
  /**
   * Returns the visibility for this room in the room directory.
   *
   * [Public](`RoomVisibility::Public`) rooms are listed in the room
   * directory and can be found using it.
   */
  getRoomVisibility(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomVisibility>;
  /**
   * Is there a non expired membership with application "m.call" and scope
   * "m.room" in this room.
   */
  hasActiveRoomCall(): boolean;
  /**
   * Returns the room heroes for this room.
   */
  heroes(): Array<RoomHero>;
  id(): string;
  /**
   * Set the local trust for the given devices to `LocalTrust::Ignored`
   * and resend messages that failed to send because said devices are
   * unverified (in response to
   * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
   * # Arguments
   *
   * * `devices` - The map of users identifiers to device identifiers
   * received in the error
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo the send error applies to
   */
  ignoreDeviceTrustAndResend(
    devices: Map<string, Array<string>>,
    sendHandle: SendHandleInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Ignores a user.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user to ignore.
   */
  ignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  inviteUserById(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  invitedMembersCount(): /*u64*/ bigint;
  /**
   * Get the user who created the invite, if any.
   */
  inviter(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomMember | undefined>;
  isDirect(asyncOpts_?: { signal: AbortSignal }): Promise<boolean>;
  /**
   * Checks whether the room is encrypted or not.
   *
   * **Note**: this info may not be reliable if you don't set up
   * `m.room.encryption` as required state.
   */
  isEncrypted(asyncOpts_?: { signal: AbortSignal }): Promise<boolean>;
  isPublic(): boolean;
  /**
   * Returns whether the send queue for that particular room is enabled or
   * not.
   */
  isSendQueueEnabled(): boolean;
  isSpace(): boolean;
  /**
   * Join this room.
   *
   * Only invited and left rooms can be joined via this method.
   */
  join(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  joinedMembersCount(): /*u64*/ bigint;
  kickUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  latestEncryptionState(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<EncryptionState>;
  latestEvent(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<EventTimelineItem | undefined>;
  /**
   * Leave this room.
   *
   * Only invited and joined rooms can be left.
   */
  leave(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Retrieve the `ComposerDraft` stored in the state store for this room.
   */
  loadComposerDraft(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<ComposerDraft | undefined>;
  /**
   * Mark a room as read, by attaching a read receipt on the latest event.
   *
   * Note: this does NOT unset the unread flag; it's the caller's
   * responsibility to do so, if need be.
   */
  markAsRead(
    receiptType: ReceiptType,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  matrixToEventPermalink(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  matrixToPermalink(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<string>;
  member(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomMember>;
  memberAvatarUrl(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  memberDisplayName(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  /**
   * Get the membership details for the current user.
   *
   * Returns:
   * - If the user was present in the room, a
   * [`matrix_sdk::room::RoomMemberWithSenderInfo`] containing both the
   * user info and the member info of the sender of the `m.room.member`
   * event.
   * - If the current user is not present, an error.
   */
  memberWithSenderInfo(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomMemberWithSenderInfo>;
  members(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomMembersIteratorInterface>;
  membersNoSync(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomMembersIteratorInterface>;
  /**
   * The room's current membership state.
   */
  membership(): Membership;
  ownUserId(): string;
  /**
   * If this room is the successor of a tombstoned room, return the
   * reference to the predecessor room.
   *
   * A room is tombstoned if it has received a [`m.room.tombstone`] state
   * event.
   *
   * To determine if a room is the successor of a tombstoned room, the
   * [`m.room.create`] must have been received, **with** a `predecessor`
   * field.
   *
   * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
   * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
   */
  predecessorRoom(): PredecessorRoom | undefined;
  /**
   * Builds a `RoomPreview` from a room list item. This is intended for
   * invited, knocked or banned rooms.
   */
  previewRoom(
    via: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomPreviewInterface>;
  /**
   * Publish a new room alias for this room in the room directory.
   *
   * Returns:
   * - `true` if the room alias didn't exist and it's now published.
   * - `false` if the room alias was already present so it couldn't be
   * published.
   */
  publishRoomAliasInRoomDirectory(
    alias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * The raw name as present in the room state event.
   */
  rawName(): string | undefined;
  /**
   * Redacts an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to redact
   *
   * * `reason` - The reason for the event being redacted (optional). its
   * transaction ID (optional). If not given one is created.
   */
  redact(
    eventId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Removes the current room avatar
   */
  removeAvatar(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Remove an existing room alias for this room in the room directory.
   *
   * Returns:
   * - `true` if the room alias was present and it's now removed from the
   * room directory.
   * - `false` if the room alias didn't exist so it couldn't be removed.
   */
  removeRoomAliasFromRoomDirectory(
    alias: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Reports an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to report
   *
   * * `reason` - The reason for the event being reported (optional).
   *
   * * `score` - The score to rate this content as where -100 is most
   * offensive and 0 is inoffensive (optional).
   */
  reportContent(
    eventId: string,
    score: /*i32*/ number | undefined,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Reports a room as inappropriate to the server.
   * The caller is not required to be joined to the room to report it.
   *
   * # Arguments
   *
   * * `reason` - The reason the room is being reported.
   *
   * # Errors
   *
   * Returns an error if the room is not found or on rate limit
   */
  reportRoom(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  resetPowerLevels(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomPowerLevels>;
  /**
   * Return a debug representation for the internal room events data
   * structure, one line per entry in the resulting vector.
   */
  roomEventsDebugString(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<string>>;
  roomInfo(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<RoomInfo>;
  /**
   * Store the given `ComposerDraft` in the state store using the current
   * room id, as identifier.
   */
  saveComposerDraft(
    draft: ComposerDraft,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Send a call notification event in the current room.
   *
   * This is only supposed to be used in **custom** situations where the user
   * explicitly chooses to send a `m.call.notify` event to invite/notify
   * someone explicitly in unusual conditions. The default should be to
   * use `send_call_notification_if_necessary` just before a new room call is
   * created/joined.
   *
   * One example could be that the UI allows to start a call with a subset of
   * users of the room members first. And then later on the user can
   * invite more users to the call.
   */
  sendCallNotification(
    callId: string,
    application: RtcApplicationType,
    notifyType: NotifyType,
    mentions: Mentions,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * This will only send a call notification event if appropriate.
   *
   * This function is supposed to be called whenever the user creates a room
   * call. It will send a `m.call.notify` event if:
   * - there is not yet a running call.
   *
   * It will configure the notify type: ring or notify based on:
   * - is this a DM room -> ring
   * - is this a group with more than one other member -> notify
   *
   * Returns:
   * - `Ok(true)` if the event was successfully sent.
   * - `Ok(false)` if we didn't send it because it was unnecessary.
   * - `Err(_)` if sending the event failed.
   */
  sendCallNotificationIfNeeded(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Send the current users live location beacon in the room.
   */
  sendLiveLocation(
    geoUri: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Send a raw event to the room.
   *
   * # Arguments
   *
   * * `event_type` - The type of the event to send.
   *
   * * `content` - The content of the event to send encoded as JSON string.
   */
  sendRaw(
    eventType: string,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  setIsFavourite(
    isFavourite: boolean,
    tagOrder: /*f64*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  setIsLowPriority(
    isLowPriority: boolean,
    tagOrder: /*f64*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Sets a new name to the room.
   */
  setName(
    name: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Sets a new topic in the room.
   */
  setTopic(
    topic: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Set (or unset) a flag on the room to indicate that the user has
   * explicitly marked it as unread.
   */
  setUnreadFlag(
    newValue: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Start the current users live location share in the room.
   */
  startLiveLocationShare(
    durationMillis: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Stop the current users live location share in the room.
   */
  stopLiveLocationShare(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  subscribeToIdentityStatusChanges(
    listener: IdentityStatusChangeListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TaskHandleInterface>;
  /**
   * Subscribes to requests to join this room (knock member events), using a
   * `listener` to be notified of the changes.
   *
   * The current requests to join the room will be emitted immediately
   * when subscribing, along with a [`TaskHandle`] to cancel the
   * subscription.
   */
  subscribeToKnockRequests(
    listener: KnockRequestsListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TaskHandleInterface>;
  /**
   * Subscribes to live location shares in this room, using a `listener` to
   * be notified of the changes.
   *
   * The current live location shares will be emitted immediately when
   * subscribing, along with a [`TaskHandle`] to cancel the subscription.
   */
  subscribeToLiveLocationShares(
    listener: LiveLocationShareListener
  ): TaskHandleInterface;
  subscribeToRoomInfoUpdates(listener: RoomInfoListener): TaskHandleInterface;
  subscribeToTypingNotifications(
    listener: TypingNotificationsListener
  ): TaskHandleInterface;
  /**
   * If this room is tombstoned, return the reference to the successor room
   * i.e. the room replacing this one.
   *
   * A room is tombstoned if it has received a [`m.room.tombstone`] state
   * event.
   *
   * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
   */
  successorRoom(): SuccessorRoom | undefined;
  suggestedRoleForUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RoomMemberRole>;
  /**
   * Create a timeline with a default configuration, i.e. a live timeline
   * with read receipts and read marker tracking.
   */
  timeline(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<TimelineInterface>;
  /**
   * Build a new timeline instance with the given configuration.
   */
  timelineWithConfiguration(
    configuration: TimelineConfiguration,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TimelineInterface>;
  topic(): string | undefined;
  typingNotice(
    isTyping: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  unbanUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Update the canonical alias of the room.
   *
   * Note that publishing the alias in the room directory is done separately.
   */
  updateCanonicalAlias(
    alias: string | undefined,
    altAliases: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Update room history visibility for this room.
   */
  updateHistoryVisibility(
    visibility: RoomHistoryVisibility,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Update the join rule for this room.
   */
  updateJoinRules(
    newRule: JoinRule,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  updatePowerLevelsForUsers(
    updates: Array<UserPowerLevelUpdate>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Update the room's visibility in the room directory.
   */
  updateRoomVisibility(
    visibility: RoomVisibility,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Upload and set the room's avatar.
   *
   * This will upload the data produced by the reader to the homeserver's
   * content repository, and set the room's avatar to the MXC URI for the
   * uploaded file.
   *
   * # Arguments
   *
   * * `mime_type` - The mime description of the avatar, for example
   * image/jpeg
   * * `data` - The raw data that will be uploaded to the homeserver's
   * content repository
   * * `media_info` - The media info used as avatar image info.
   */
  uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    mediaInfo: ImageInfo | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Remove verification requirements for the given users and
   * resend messages that failed to send because their identities were no
   * longer verified (in response to
   * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
   *
   * # Arguments
   *
   * * `user_ids` - The list of users identifiers received in the error
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo the send error applies to
   */
  withdrawVerificationAndResend(
    userIds: Array<string>,
    sendHandle: SendHandleInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class Room extends UniffiAbstractObject implements RoomInterface {
  readonly [uniffiTypeNameSymbol] = 'Room';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeRoomObjectFactory.bless(pointer);
  }

  public activeMembersCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns a Vec of userId's that participate in the room call.
   *
   * MatrixRTC memberships with application "m.call" and scope "m.room" are
   * considered. A user can occur twice if they join with two devices.
   * convert to a set depending if the different users are required or the
   * amount of sessions.
   *
   * The vector is ordered by oldest membership user to newest.
   */
  public activeRoomCallParticipants(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public alternativeAliases(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async applyPowerLevelChanges(
    changes: RoomPowerLevelChanges,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeRoomPowerLevelChanges.lower(changes)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public avatarUrl(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async banUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_ban_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserBan(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_ban(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserInvite(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_invite(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserKick(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_kick(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserPinUnpin(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_pin_unpin(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserRedactOther(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_other(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserRedactOwn(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_own(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserSendMessage(
    userId: string,
    message: MessageLikeEventType,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_message(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterTypeMessageLikeEventType.lower(message)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserSendState(
    userId: string,
    stateEvent: StateEventType,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_state(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterTypeStateEventType.lower(stateEvent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async canUserTriggerRoomNotification(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_can_user_trigger_room_notification(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public canonicalAlias(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Remove the `ComposerDraft` stored in the state store for this room.
   */
  public async clearComposerDraft(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Clear the event cache storage for the current room.
   *
   * This will remove all the information related to the event cache, in
   * memory and in the persisted storage, if enabled.
   */
  public async clearEventCacheStorage(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Forces the currently active room key, which is used to encrypt messages,
   * to be rotated.
   *
   * A new room key will be crated and shared with all the room members the
   * next time a message will be sent. You don't have to call this method,
   * room keys will be rotated automatically when necessary. This method is
   * still useful for debugging purposes.
   */
  public async discardRoomKey(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the room's name from the state event if available, otherwise
   * compute a room name based on the room's nature (DM or not) and number of
   * members.
   */
  public displayName(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_display_name(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Edit an event given its event id.
   *
   * Useful outside the context of a timeline, or when a timeline doesn't
   * have the full content of an event.
   */
  public async edit(
    eventId: string,
    newContent: RoomMessageEventContentWithoutRelationInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_edit(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId),
            FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(
              newContent
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Enable End-to-end encryption in this room.
   */
  public async enableEncryption(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_enable_encryption(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Enable or disable the send queue for that particular room.
   */
  public enableSendQueue(enable: boolean): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(
          uniffiTypeRoomObjectFactory.clonePointer(this),
          FfiConverterBool.lower(enable),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public encryptionState(): EncryptionState {
    return FfiConverterTypeEncryptionState.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_encryption_state(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Forget this room.
   *
   * This communicates to the homeserver that it should forget the room.
   *
   * Only left or banned-from rooms can be forgotten.
   */
  public async forget(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_forget(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getPowerLevels(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomPowerLevels> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomPowerLevels.lift.bind(
          FfiConverterTypeRoomPowerLevels
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the visibility for this room in the room directory.
   *
   * [Public](`RoomVisibility::Public`) rooms are listed in the room
   * directory and can be found using it.
   */
  public async getRoomVisibility(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomVisibility> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_get_room_visibility(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomVisibility.lift.bind(
          FfiConverterTypeRoomVisibility
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Is there a non expired membership with application "m.call" and scope
   * "m.room" in this room.
   */
  public hasActiveRoomCall(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns the room heroes for this room.
   */
  public heroes(): Array<RoomHero> {
    return FfiConverterArrayTypeRoomHero.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_heroes(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public id(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_id(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the local trust for the given devices to `LocalTrust::Ignored`
   * and resend messages that failed to send because said devices are
   * unverified (in response to
   * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
   * # Arguments
   *
   * * `devices` - The map of users identifiers to device identifiers
   * received in the error
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo the send error applies to
   */
  public async ignoreDeviceTrustAndResend(
    devices: Map<string, Array<string>>,
    sendHandle: SendHandleInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterMapStringArrayString.lower(devices),
            FfiConverterTypeSendHandle.lower(sendHandle)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Ignores a user.
   *
   * # Arguments
   *
   * * `user_id` - The ID of the user to ignore.
   */
  public async ignoreUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async inviteUserById(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public invitedMembersCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the user who created the invite, if any.
   */
  public async inviter(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMember | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_inviter(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeRoomMember.lift.bind(
          FfiConverterOptionalTypeRoomMember
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async isDirect(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_direct(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Checks whether the room is encrypted or not.
   *
   * **Note**: this info may not be reliable if you don't set up
   * `m.room.encryption` as required state.
   */
  public async isEncrypted(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public isPublic(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_public(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns whether the send queue for that particular room is enabled or
   * not.
   */
  public isSendQueueEnabled(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isSpace(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_space(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Join this room.
   *
   * Only invited and left rooms can be joined via this method.
   */
  public async join(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_join(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public joinedMembersCount(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async kickUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_kick_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async latestEncryptionState(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<EncryptionState> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_latest_encryption_state(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeEncryptionState.lift.bind(
          FfiConverterTypeEncryptionState
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async latestEvent(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<EventTimelineItem | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_latest_event(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeEventTimelineItem.lift.bind(
          FfiConverterOptionalTypeEventTimelineItem
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Leave this room.
   *
   * Only invited and joined rooms can be left.
   */
  public async leave(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_leave(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Retrieve the `ComposerDraft` stored in the state store for this room.
   */
  public async loadComposerDraft(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<ComposerDraft | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeComposerDraft.lift.bind(
          FfiConverterOptionalTypeComposerDraft
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Mark a room as read, by attaching a read receipt on the latest event.
   *
   * Note: this does NOT unset the unread flag; it's the caller's
   * responsibility to do so, if need be.
   */
  public async markAsRead(
    receiptType: ReceiptType,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeReceiptType.lower(receiptType)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async matrixToEventPermalink(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async matrixToPermalink(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async member(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomMember> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomMember.lift.bind(
          FfiConverterTypeRoomMember
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async memberAvatarUrl(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async memberDisplayName(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the membership details for the current user.
   *
   * Returns:
   * - If the user was present in the room, a
   * [`matrix_sdk::room::RoomMemberWithSenderInfo`] containing both the
   * user info and the member info of the sender of the `m.room.member`
   * event.
   * - If the current user is not present, an error.
   */
  public async memberWithSenderInfo(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomMemberWithSenderInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member_with_sender_info(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomMemberWithSenderInfo.lift.bind(
          FfiConverterTypeRoomMemberWithSenderInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async members(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMembersIteratorInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_members(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomMembersIterator.lift.bind(
          FfiConverterTypeRoomMembersIterator
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async membersNoSync(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMembersIteratorInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomMembersIterator.lift.bind(
          FfiConverterTypeRoomMembersIterator
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The room's current membership state.
   */
  public membership(): Membership {
    return FfiConverterTypeMembership.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_membership(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public ownUserId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * If this room is the successor of a tombstoned room, return the
   * reference to the predecessor room.
   *
   * A room is tombstoned if it has received a [`m.room.tombstone`] state
   * event.
   *
   * To determine if a room is the successor of a tombstoned room, the
   * [`m.room.create`] must have been received, **with** a `predecessor`
   * field.
   *
   * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
   * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
   */
  public predecessorRoom(): PredecessorRoom | undefined {
    return FfiConverterOptionalTypePredecessorRoom.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_predecessor_room(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Builds a `RoomPreview` from a room list item. This is intended for
   * invited, knocked or banned rooms.
   */
  public async previewRoom(
    via: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomPreviewInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_preview_room(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(via)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomPreview.lift.bind(
          FfiConverterTypeRoomPreview
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Publish a new room alias for this room in the room directory.
   *
   * Returns:
   * - `true` if the room alias didn't exist and it's now published.
   * - `false` if the room alias was already present so it couldn't be
   * published.
   */
  public async publishRoomAliasInRoomDirectory(
    alias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_publish_room_alias_in_room_directory(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(alias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * The raw name as present in the room state event.
   */
  public rawName(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_raw_name(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Redacts an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to redact
   *
   * * `reason` - The reason for the event being redacted (optional). its
   * transaction ID (optional). If not given one is created.
   */
  public async redact(
    eventId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_redact(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Removes the current room avatar
   */
  public async removeAvatar(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Remove an existing room alias for this room in the room directory.
   *
   * Returns:
   * - `true` if the room alias was present and it's now removed from the
   * room directory.
   * - `false` if the room alias didn't exist so it couldn't be removed.
   */
  public async removeRoomAliasFromRoomDirectory(
    alias: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_remove_room_alias_from_room_directory(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(alias)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Reports an event from the room.
   *
   * # Arguments
   *
   * * `event_id` - The ID of the event to report
   *
   * * `reason` - The reason for the event being reported (optional).
   *
   * * `score` - The score to rate this content as where -100 is most
   * offensive and 0 is inoffensive (optional).
   */
  public async reportContent(
    eventId: string,
    score: /*i32*/ number | undefined,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_report_content(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId),
            FfiConverterOptionalInt32.lower(score),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Reports a room as inappropriate to the server.
   * The caller is not required to be joined to the room to report it.
   *
   * # Arguments
   *
   * * `reason` - The reason the room is being reported.
   *
   * # Errors
   *
   * Returns an error if the room is not found or on rate limit
   */
  public async reportRoom(
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_report_room(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async resetPowerLevels(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomPowerLevels> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomPowerLevels.lift.bind(
          FfiConverterTypeRoomPowerLevels
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Return a debug representation for the internal room events data
   * structure, one line per entry in the resulting vector.
   */
  public async roomEventsDebugString(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<string>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayString.lift.bind(
          FfiConverterArrayString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async roomInfo(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_room_info(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomInfo.lift.bind(
          FfiConverterTypeRoomInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Store the given `ComposerDraft` in the state store using the current
   * room id, as identifier.
   */
  public async saveComposerDraft(
    draft: ComposerDraft,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeComposerDraft.lower(draft)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send a call notification event in the current room.
   *
   * This is only supposed to be used in **custom** situations where the user
   * explicitly chooses to send a `m.call.notify` event to invite/notify
   * someone explicitly in unusual conditions. The default should be to
   * use `send_call_notification_if_necessary` just before a new room call is
   * created/joined.
   *
   * One example could be that the UI allows to start a call with a subset of
   * users of the room members first. And then later on the user can
   * invite more users to the call.
   */
  public async sendCallNotification(
    callId: string,
    application: RtcApplicationType,
    notifyType: NotifyType,
    mentions: Mentions,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(callId),
            FfiConverterTypeRtcApplicationType.lower(application),
            FfiConverterTypeNotifyType.lower(notifyType),
            FfiConverterTypeMentions.lower(mentions)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * This will only send a call notification event if appropriate.
   *
   * This function is supposed to be called whenever the user creates a room
   * call. It will send a `m.call.notify` event if:
   * - there is not yet a running call.
   *
   * It will configure the notify type: ring or notify based on:
   * - is this a DM room -> ring
   * - is this a group with more than one other member -> notify
   *
   * Returns:
   * - `Ok(true)` if the event was successfully sent.
   * - `Ok(false)` if we didn't send it because it was unnecessary.
   * - `Err(_)` if sending the event failed.
   */
  public async sendCallNotificationIfNeeded(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification_if_needed(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send the current users live location beacon in the room.
   */
  public async sendLiveLocation(
    geoUri: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_send_live_location(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(geoUri)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send a raw event to the room.
   *
   * # Arguments
   *
   * * `event_type` - The type of the event to send.
   *
   * * `content` - The content of the event to send encoded as JSON string.
   */
  public async sendRaw(
    eventType: string,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_send_raw(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventType),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async setIsFavourite(
    isFavourite: boolean,
    tagOrder: /*f64*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isFavourite),
            FfiConverterOptionalFloat64.lower(tagOrder)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async setIsLowPriority(
    isLowPriority: boolean,
    tagOrder: /*f64*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isLowPriority),
            FfiConverterOptionalFloat64.lower(tagOrder)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets a new name to the room.
   */
  public async setName(
    name: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_name(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(name)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets a new topic in the room.
   */
  public async setTopic(
    topic: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_topic(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(topic)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set (or unset) a flag on the room to indicate that the user has
   * explicitly marked it as unread.
   */
  public async setUnreadFlag(
    newValue: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterBool.lower(newValue)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Start the current users live location share in the room.
   */
  public async startLiveLocationShare(
    durationMillis: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_start_live_location_share(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterUInt64.lower(durationMillis)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Stop the current users live location share in the room.
   */
  public async stopLiveLocationShare(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_stop_live_location_share(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async subscribeToIdentityStatusChanges(
    listener: IdentityStatusChangeListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeIdentityStatusChangeListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribes to requests to join this room (knock member events), using a
   * `listener` to be notified of the changes.
   *
   * The current requests to join the room will be emitted immediately
   * when subscribing, along with a [`TaskHandle`] to cancel the
   * subscription.
   */
  public async subscribeToKnockRequests(
    listener: KnockRequestsListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeKnockRequestsListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribes to live location shares in this room, using a `listener` to
   * be notified of the changes.
   *
   * The current live location shares will be emitted immediately when
   * subscribing, along with a [`TaskHandle`] to cancel the subscription.
   */
  public subscribeToLiveLocationShares(
    listener: LiveLocationShareListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_live_location_shares(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeLiveLocationShareListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public subscribeToRoomInfoUpdates(
    listener: RoomInfoListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeRoomInfoListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public subscribeToTypingNotifications(
    listener: TypingNotificationsListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeTypingNotificationsListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * If this room is tombstoned, return the reference to the successor room
   * i.e. the room replacing this one.
   *
   * A room is tombstoned if it has received a [`m.room.tombstone`] state
   * event.
   *
   * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
   */
  public successorRoom(): SuccessorRoom | undefined {
    return FfiConverterOptionalTypeSuccessorRoom.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_successor_room(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async suggestedRoleForUser(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RoomMemberRole> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRoomMemberRole.lift.bind(
          FfiConverterTypeRoomMemberRole
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Create a timeline with a default configuration, i.e. a live timeline
   * with read receipts and read marker tracking.
   */
  public async timeline(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<TimelineInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_timeline(
            uniffiTypeRoomObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTimeline.lift.bind(
          FfiConverterTypeTimeline
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Build a new timeline instance with the given configuration.
   */
  public async timelineWithConfiguration(
    configuration: TimelineConfiguration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TimelineInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_timeline_with_configuration(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeTimelineConfiguration.lower(configuration)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTimeline.lift.bind(
          FfiConverterTypeTimeline
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public topic(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_topic(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async typingNotice(
    isTyping: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterBool.lower(isTyping)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async unbanUser(
    userId: string,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_unban_user(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(userId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Update the canonical alias of the room.
   *
   * Note that publishing the alias in the room directory is done separately.
   */
  public async updateCanonicalAlias(
    alias: string | undefined,
    altAliases: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_canonical_alias(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(alias),
            FfiConverterArrayString.lower(altAliases)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Update room history visibility for this room.
   */
  public async updateHistoryVisibility(
    visibility: RoomHistoryVisibility,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_history_visibility(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeRoomHistoryVisibility.lower(visibility)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Update the join rule for this room.
   */
  public async updateJoinRules(
    newRule: JoinRule,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_join_rules(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeJoinRule.lower(newRule)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async updatePowerLevelsForUsers(
    updates: Array<UserPowerLevelUpdate>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterArrayTypeUserPowerLevelUpdate.lower(updates)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Update the room's visibility in the room directory.
   */
  public async updateRoomVisibility(
    visibility: RoomVisibility,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_room_visibility(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterTypeRoomVisibility.lower(visibility)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Upload and set the room's avatar.
   *
   * This will upload the data produced by the reader to the homeserver's
   * content repository, and set the room's avatar to the MXC URI for the
   * uploaded file.
   *
   * # Arguments
   *
   * * `mime_type` - The mime description of the avatar, for example
   * image/jpeg
   * * `data` - The raw data that will be uploaded to the homeserver's
   * content repository
   * * `media_info` - The media info used as avatar image info.
   */
  public async uploadAvatar(
    mimeType: string,
    data: ArrayBuffer,
    mediaInfo: ImageInfo | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterString.lower(mimeType),
            FfiConverterArrayBuffer.lower(data),
            FfiConverterOptionalTypeImageInfo.lower(mediaInfo)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Remove verification requirements for the given users and
   * resend messages that failed to send because their identities were no
   * longer verified (in response to
   * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
   *
   * # Arguments
   *
   * * `user_ids` - The list of users identifiers received in the error
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo the send error applies to
   */
  public async withdrawVerificationAndResend(
    userIds: Array<string>,
    sendHandle: SendHandleInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(
            uniffiTypeRoomObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(userIds),
            FfiConverterTypeSendHandle.lower(sendHandle)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomObjectFactory.pointer(this);
      uniffiTypeRoomObjectFactory.freePointer(pointer);
      uniffiTypeRoomObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Room {
    return uniffiTypeRoomObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomObjectFactory: UniffiObjectFactory<RoomInterface> = {
  create(pointer: UnsafeMutableRawPointer): RoomInterface {
    const instance = Object.create(Room.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Room';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_room_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: RoomInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: RoomInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_room(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_room(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is RoomInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Room';
  },
};
// FfiConverter for RoomInterface
const FfiConverterTypeRoom = new FfiConverterObject(
  uniffiTypeRoomObjectFactory
);

/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
export interface RoomDirectorySearchInterface {
  /**
   * Get whether the search is at the last page.
   */
  isAtLastPage(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<boolean>;
  /**
   * Get the number of pages that have been loaded so far.
   */
  loadedPages(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise</*u32*/ number>;
  /**
   * Asks the server for the next page of the current search.
   */
  nextPage(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Registers a callback to receive new search results when starting a
   * search or getting new paginated results.
   */
  results(
    listener: RoomDirectorySearchEntriesListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface>;
  /**
   * Starts a filtered search for the server.
   *
   * If the `filter` is not provided it will search for all the rooms.
   * You can specify a `batch_size` to control the number of rooms to fetch
   * per request.
   *
   * If the `via_server` is not provided it will search in the current
   * homeserver by default.
   *
   * This method will clear the current search results and start a new one.
   */
  search(
    filter: string | undefined,
    batchSize: /*u32*/ number,
    viaServerName: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
export class RoomDirectorySearch
  extends UniffiAbstractObject
  implements RoomDirectorySearchInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomDirectorySearch';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomDirectorySearchObjectFactory.bless(pointer);
  }

  /**
   * Get whether the search is at the last page.
   */
  public async isAtLastPage(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the number of pages that have been loaded so far.
   */
  public async loadedPages(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise</*u32*/ number> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_u32,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_u32,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_u32,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_u32,
        /*liftFunc:*/ FfiConverterUInt32.lift.bind(FfiConverterUInt32),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Asks the server for the next page of the current search.
   */
  public async nextPage(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Registers a callback to receive new search results when starting a
   * search or getting new paginated results.
   */
  public async results(
    listener: RoomDirectorySearchEntriesListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this),
            FfiConverterTypeRoomDirectorySearchEntriesListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Starts a filtered search for the server.
   *
   * If the `filter` is not provided it will search for all the rooms.
   * You can specify a `batch_size` to control the number of rooms to fetch
   * per request.
   *
   * If the `via_server` is not provided it will search in the current
   * homeserver by default.
   *
   * This method will clear the current search results and start a new one.
   */
  public async search(
    filter: string | undefined,
    batchSize: /*u32*/ number,
    viaServerName: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(
            uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this),
            FfiConverterOptionalString.lower(filter),
            FfiConverterUInt32.lower(batchSize),
            FfiConverterOptionalString.lower(viaServerName)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomDirectorySearchObjectFactory.pointer(this);
      uniffiTypeRoomDirectorySearchObjectFactory.freePointer(pointer);
      uniffiTypeRoomDirectorySearchObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomDirectorySearch {
    return uniffiTypeRoomDirectorySearchObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomDirectorySearchObjectFactory: UniffiObjectFactory<RoomDirectorySearchInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomDirectorySearchInterface {
      const instance = Object.create(RoomDirectorySearch.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomDirectorySearch';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomdirectorysearch_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomDirectorySearchInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomDirectorySearchInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomDirectorySearchInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomDirectorySearch'
      );
    },
  };
// FfiConverter for RoomDirectorySearchInterface
const FfiConverterTypeRoomDirectorySearch = new FfiConverterObject(
  uniffiTypeRoomDirectorySearchObjectFactory
);

export interface RoomListInterface {
  entriesWithDynamicAdapters(
    pageSize: /*u32*/ number,
    listener: RoomListEntriesListener
  ): RoomListEntriesWithDynamicAdaptersResultInterface;
  loadingState(
    listener: RoomListLoadingStateListener
  ) /*throws*/ : RoomListLoadingStateResult;
  room(roomId: string) /*throws*/ : RoomInterface;
}

export class RoomList
  extends UniffiAbstractObject
  implements RoomListInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomList';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomListObjectFactory.bless(pointer);
  }

  public entriesWithDynamicAdapters(
    pageSize: /*u32*/ number,
    listener: RoomListEntriesListener
  ): RoomListEntriesWithDynamicAdaptersResultInterface {
    return FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(
            uniffiTypeRoomListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pageSize),
            FfiConverterTypeRoomListEntriesListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public loadingState(
    listener: RoomListLoadingStateListener
  ): RoomListLoadingStateResult /*throws*/ {
    return FfiConverterTypeRoomListLoadingStateResult.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(
            uniffiTypeRoomListObjectFactory.clonePointer(this),
            FfiConverterTypeRoomListLoadingStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public room(roomId: string): RoomInterface /*throws*/ {
    return FfiConverterTypeRoom.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_room(
            uniffiTypeRoomListObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomListObjectFactory.pointer(this);
      uniffiTypeRoomListObjectFactory.freePointer(pointer);
      uniffiTypeRoomListObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomList {
    return uniffiTypeRoomListObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomListObjectFactory: UniffiObjectFactory<RoomListInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomListInterface {
      const instance = Object.create(RoomList.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomList';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomlist_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomListInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomListInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlist(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlist(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomListInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'RoomList'
      );
    },
  };
// FfiConverter for RoomListInterface
const FfiConverterTypeRoomList = new FfiConverterObject(
  uniffiTypeRoomListObjectFactory
);

export interface RoomListDynamicEntriesControllerInterface {
  addOnePage(): void;
  resetToOnePage(): void;
  setFilter(kind: RoomListEntriesDynamicFilterKind): boolean;
}

export class RoomListDynamicEntriesController
  extends UniffiAbstractObject
  implements RoomListDynamicEntriesControllerInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomListDynamicEntriesController';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomListDynamicEntriesControllerObjectFactory.bless(pointer);
  }

  public addOnePage(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(
          uniffiTypeRoomListDynamicEntriesControllerObjectFactory.clonePointer(
            this
          ),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public resetToOnePage(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(
          uniffiTypeRoomListDynamicEntriesControllerObjectFactory.clonePointer(
            this
          ),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public setFilter(kind: RoomListEntriesDynamicFilterKind): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(
            uniffiTypeRoomListDynamicEntriesControllerObjectFactory.clonePointer(
              this
            ),
            FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(kind),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeRoomListDynamicEntriesControllerObjectFactory.pointer(this);
      uniffiTypeRoomListDynamicEntriesControllerObjectFactory.freePointer(
        pointer
      );
      uniffiTypeRoomListDynamicEntriesControllerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomListDynamicEntriesController {
    return uniffiTypeRoomListDynamicEntriesControllerObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeRoomListDynamicEntriesControllerObjectFactory: UniffiObjectFactory<RoomListDynamicEntriesControllerInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): RoomListDynamicEntriesControllerInterface {
      const instance = Object.create(
        RoomListDynamicEntriesController.prototype
      );
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomListDynamicEntriesController';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomlistdynamicentriescontroller_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(
      obj: RoomListDynamicEntriesControllerInterface
    ): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: RoomListDynamicEntriesControllerInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomListDynamicEntriesControllerInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomListDynamicEntriesController'
      );
    },
  };
// FfiConverter for RoomListDynamicEntriesControllerInterface
const FfiConverterTypeRoomListDynamicEntriesController = new FfiConverterObject(
  uniffiTypeRoomListDynamicEntriesControllerObjectFactory
);

export interface RoomListEntriesWithDynamicAdaptersResultInterface {
  controller(): RoomListDynamicEntriesControllerInterface;
  entriesStream(): TaskHandleInterface;
}

export class RoomListEntriesWithDynamicAdaptersResult
  extends UniffiAbstractObject
  implements RoomListEntriesWithDynamicAdaptersResultInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomListEntriesWithDynamicAdaptersResult';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.bless(
        pointer
      );
  }

  public controller(): RoomListDynamicEntriesControllerInterface {
    return FfiConverterTypeRoomListDynamicEntriesController.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(
            uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.clonePointer(
              this
            ),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public entriesStream(): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(
            uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.clonePointer(
              this
            ),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.pointer(
          this
        );
      uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.freePointer(
        pointer
      );
      uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.unbless(
        ptr
      );
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomListEntriesWithDynamicAdaptersResult {
    return uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory: UniffiObjectFactory<RoomListEntriesWithDynamicAdaptersResultInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): RoomListEntriesWithDynamicAdaptersResultInterface {
      const instance = Object.create(
        RoomListEntriesWithDynamicAdaptersResult.prototype
      );
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] =
        'RoomListEntriesWithDynamicAdaptersResult';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomlistentrieswithdynamicadaptersresult_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(
      obj: RoomListEntriesWithDynamicAdaptersResultInterface
    ): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: RoomListEntriesWithDynamicAdaptersResultInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(
      obj: any
    ): obj is RoomListEntriesWithDynamicAdaptersResultInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomListEntriesWithDynamicAdaptersResult'
      );
    },
  };
// FfiConverter for RoomListEntriesWithDynamicAdaptersResultInterface
const FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult =
  new FfiConverterObject(
    uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory
  );

export interface RoomListServiceInterface {
  allRooms(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<RoomListInterface>;
  room(roomId: string) /*throws*/ : RoomInterface;
  state(listener: RoomListServiceStateListener): TaskHandleInterface;
  subscribeToRooms(roomIds: Array<string>) /*throws*/ : void;
  syncIndicator(
    delayBeforeShowingInMs: /*u32*/ number,
    delayBeforeHidingInMs: /*u32*/ number,
    listener: RoomListServiceSyncIndicatorListener
  ): TaskHandleInterface;
}

export class RoomListService
  extends UniffiAbstractObject
  implements RoomListServiceInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomListService';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomListServiceObjectFactory.bless(pointer);
  }

  public async allRooms(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomListInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(
            uniffiTypeRoomListServiceObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRoomList.lift.bind(
          FfiConverterTypeRoomList
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public room(roomId: string): RoomInterface /*throws*/ {
    return FfiConverterTypeRoom.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
          FfiConverterTypeRoomListError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(
            uniffiTypeRoomListServiceObjectFactory.clonePointer(this),
            FfiConverterString.lower(roomId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public state(listener: RoomListServiceStateListener): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(
            uniffiTypeRoomListServiceObjectFactory.clonePointer(this),
            FfiConverterTypeRoomListServiceStateListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public subscribeToRooms(roomIds: Array<string>): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(
        FfiConverterTypeRoomListError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(
          uniffiTypeRoomListServiceObjectFactory.clonePointer(this),
          FfiConverterArrayString.lower(roomIds),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public syncIndicator(
    delayBeforeShowingInMs: /*u32*/ number,
    delayBeforeHidingInMs: /*u32*/ number,
    listener: RoomListServiceSyncIndicatorListener
  ): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(
            uniffiTypeRoomListServiceObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(delayBeforeShowingInMs),
            FfiConverterUInt32.lower(delayBeforeHidingInMs),
            FfiConverterTypeRoomListServiceSyncIndicatorListener.lower(
              listener
            ),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomListServiceObjectFactory.pointer(this);
      uniffiTypeRoomListServiceObjectFactory.freePointer(pointer);
      uniffiTypeRoomListServiceObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomListService {
    return uniffiTypeRoomListServiceObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomListServiceObjectFactory: UniffiObjectFactory<RoomListServiceInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomListServiceInterface {
      const instance = Object.create(RoomListService.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomListService';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roomlistservice_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomListServiceInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomListServiceInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomListServiceInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomListService'
      );
    },
  };
// FfiConverter for RoomListServiceInterface
const FfiConverterTypeRoomListService = new FfiConverterObject(
  uniffiTypeRoomListServiceObjectFactory
);

export interface RoomMembersIteratorInterface {
  len(): /*u32*/ number;
  nextChunk(chunkSize: /*u32*/ number): Array<RoomMember> | undefined;
}

export class RoomMembersIterator
  extends UniffiAbstractObject
  implements RoomMembersIteratorInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomMembersIterator';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomMembersIteratorObjectFactory.bless(pointer);
  }

  public len(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(
            uniffiTypeRoomMembersIteratorObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public nextChunk(chunkSize: /*u32*/ number): Array<RoomMember> | undefined {
    return FfiConverterOptionalArrayTypeRoomMember.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(
            uniffiTypeRoomMembersIteratorObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(chunkSize),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomMembersIteratorObjectFactory.pointer(this);
      uniffiTypeRoomMembersIteratorObjectFactory.freePointer(pointer);
      uniffiTypeRoomMembersIteratorObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomMembersIterator {
    return uniffiTypeRoomMembersIteratorObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomMembersIteratorObjectFactory: UniffiObjectFactory<RoomMembersIteratorInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomMembersIteratorInterface {
      const instance = Object.create(RoomMembersIterator.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomMembersIterator';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roommembersiterator_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomMembersIteratorInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomMembersIteratorInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomMembersIteratorInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomMembersIterator'
      );
    },
  };
// FfiConverter for RoomMembersIteratorInterface
const FfiConverterTypeRoomMembersIterator = new FfiConverterObject(
  uniffiTypeRoomMembersIteratorObjectFactory
);

export interface RoomMessageEventContentWithoutRelationInterface {
  withMentions(
    mentions: Mentions
  ): RoomMessageEventContentWithoutRelationInterface;
}

export class RoomMessageEventContentWithoutRelation
  extends UniffiAbstractObject
  implements RoomMessageEventContentWithoutRelationInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomMessageEventContentWithoutRelation';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.bless(
        pointer
      );
  }

  public withMentions(
    mentions: Mentions
  ): RoomMessageEventContentWithoutRelationInterface {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(
            uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.clonePointer(
              this
            ),
            FfiConverterTypeMentions.lower(mentions),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.pointer(
          this
        );
      uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.freePointer(
        pointer
      );
      uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.unbless(
        ptr
      );
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomMessageEventContentWithoutRelation {
    return uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory: UniffiObjectFactory<RoomMessageEventContentWithoutRelationInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): RoomMessageEventContentWithoutRelationInterface {
      const instance = Object.create(
        RoomMessageEventContentWithoutRelation.prototype
      );
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomMessageEventContentWithoutRelation';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roommessageeventcontentwithoutrelation_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(
      obj: RoomMessageEventContentWithoutRelationInterface
    ): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: RoomMessageEventContentWithoutRelationInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(
      obj: any
    ): obj is RoomMessageEventContentWithoutRelationInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomMessageEventContentWithoutRelation'
      );
    },
  };
// FfiConverter for RoomMessageEventContentWithoutRelationInterface
const FfiConverterTypeRoomMessageEventContentWithoutRelation =
  new FfiConverterObject(
    uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory
  );

/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
export interface RoomPreviewInterface {
  /**
   * Forget the room if we had access to it, and it was left or banned.
   */
  forget(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Returns the room info the preview contains.
   */
  info() /*throws*/ : RoomPreviewInfo;
  /**
   * Get the user who created the invite, if any.
   */
  inviter(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMember | undefined>;
  /**
   * Leave the room if the room preview state is either joined, invited or
   * knocked.
   *
   * If rejecting an invite then also forget it as an extra layer of
   * protection against spam attacks.
   *
   * Will return an error otherwise.
   */
  leave(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Get the membership details for the current user.
   */
  ownMembershipDetails(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMemberWithSenderInfo | undefined>;
}

/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
export class RoomPreview
  extends UniffiAbstractObject
  implements RoomPreviewInterface
{
  readonly [uniffiTypeNameSymbol] = 'RoomPreview';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRoomPreviewObjectFactory.bless(pointer);
  }

  /**
   * Forget the room if we had access to it, and it was left or banned.
   */
  public async forget(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_forget(
            uniffiTypeRoomPreviewObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the room info the preview contains.
   */
  public info(): RoomPreviewInfo /*throws*/ {
    return FfiConverterTypeRoomPreviewInfo.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_info(
            uniffiTypeRoomPreviewObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the user who created the invite, if any.
   */
  public async inviter(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMember | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(
            uniffiTypeRoomPreviewObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeRoomMember.lift.bind(
          FfiConverterOptionalTypeRoomMember
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Leave the room if the room preview state is either joined, invited or
   * knocked.
   *
   * If rejecting an invite then also forget it as an extra layer of
   * protection against spam attacks.
   *
   * Will return an error otherwise.
   */
  public async leave(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(
            uniffiTypeRoomPreviewObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the membership details for the current user.
   */
  public async ownMembershipDetails(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RoomMemberWithSenderInfo | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_own_membership_details(
            uniffiTypeRoomPreviewObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeRoomMemberWithSenderInfo.lift.bind(
          FfiConverterOptionalTypeRoomMemberWithSenderInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRoomPreviewObjectFactory.pointer(this);
      uniffiTypeRoomPreviewObjectFactory.freePointer(pointer);
      uniffiTypeRoomPreviewObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RoomPreview {
    return uniffiTypeRoomPreviewObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRoomPreviewObjectFactory: UniffiObjectFactory<RoomPreviewInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RoomPreviewInterface {
      const instance = Object.create(RoomPreview.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RoomPreview';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_roompreview_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RoomPreviewInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RoomPreviewInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roompreview(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roompreview(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RoomPreviewInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RoomPreview'
      );
    },
  };
// FfiConverter for RoomPreviewInterface
const FfiConverterTypeRoomPreview = new FfiConverterObject(
  uniffiTypeRoomPreviewObjectFactory
);

export interface SendAttachmentJoinHandleInterface {
  /**
   * Cancel the current sending task.
   *
   * A subsequent call to [`Self::join`] will return immediately.
   */
  cancel(): void;
  /**
   * Wait until the attachment has been sent.
   *
   * If the sending had been cancelled, will return immediately.
   */
  join(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

export class SendAttachmentJoinHandle
  extends UniffiAbstractObject
  implements SendAttachmentJoinHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'SendAttachmentJoinHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSendAttachmentJoinHandleObjectFactory.bless(pointer);
  }

  /**
   * Cancel the current sending task.
   *
   * A subsequent call to [`Self::join`] will return immediately.
   */
  public cancel(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(
          uniffiTypeSendAttachmentJoinHandleObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Wait until the attachment has been sent.
   *
   * If the sending had been cancelled, will return immediately.
   */
  public async join(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(
            uniffiTypeSendAttachmentJoinHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRoomError.lift.bind(
          FfiConverterTypeRoomError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeSendAttachmentJoinHandleObjectFactory.pointer(this);
      uniffiTypeSendAttachmentJoinHandleObjectFactory.freePointer(pointer);
      uniffiTypeSendAttachmentJoinHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SendAttachmentJoinHandle {
    return uniffiTypeSendAttachmentJoinHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSendAttachmentJoinHandleObjectFactory: UniffiObjectFactory<SendAttachmentJoinHandleInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): SendAttachmentJoinHandleInterface {
      const instance = Object.create(SendAttachmentJoinHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SendAttachmentJoinHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sendattachmentjoinhandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SendAttachmentJoinHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: SendAttachmentJoinHandleInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SendAttachmentJoinHandleInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SendAttachmentJoinHandle'
      );
    },
  };
// FfiConverter for SendAttachmentJoinHandleInterface
const FfiConverterTypeSendAttachmentJoinHandle = new FfiConverterObject(
  uniffiTypeSendAttachmentJoinHandleObjectFactory
);

export interface SendGalleryJoinHandleInterface {
  /**
   * Cancel the current sending task.
   *
   * A subsequent call to [`Self::join`] will return immediately.
   */
  cancel(): void;
  /**
   * Wait until the gallery has been sent.
   *
   * If the sending had been cancelled, will return immediately.
   */
  join(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

export class SendGalleryJoinHandle
  extends UniffiAbstractObject
  implements SendGalleryJoinHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'SendGalleryJoinHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSendGalleryJoinHandleObjectFactory.bless(pointer);
  }

  /**
   * Cancel the current sending task.
   *
   * A subsequent call to [`Self::join`] will return immediately.
   */
  public cancel(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendgalleryjoinhandle_cancel(
          uniffiTypeSendGalleryJoinHandleObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Wait until the gallery has been sent.
   *
   * If the sending had been cancelled, will return immediately.
   */
  public async join(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendgalleryjoinhandle_join(
            uniffiTypeSendGalleryJoinHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeRoomError.lift.bind(
          FfiConverterTypeRoomError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeSendGalleryJoinHandleObjectFactory.pointer(this);
      uniffiTypeSendGalleryJoinHandleObjectFactory.freePointer(pointer);
      uniffiTypeSendGalleryJoinHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SendGalleryJoinHandle {
    return uniffiTypeSendGalleryJoinHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSendGalleryJoinHandleObjectFactory: UniffiObjectFactory<SendGalleryJoinHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SendGalleryJoinHandleInterface {
      const instance = Object.create(SendGalleryJoinHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SendGalleryJoinHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sendgalleryjoinhandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SendGalleryJoinHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SendGalleryJoinHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sendgalleryjoinhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sendgalleryjoinhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SendGalleryJoinHandleInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SendGalleryJoinHandle'
      );
    },
  };
// FfiConverter for SendGalleryJoinHandleInterface
const FfiConverterTypeSendGalleryJoinHandle = new FfiConverterObject(
  uniffiTypeSendGalleryJoinHandleObjectFactory
);

/**
 * A handle to perform actions onto a local echo.
 */
export interface SendHandleInterface {
  /**
   * Try to abort the sending of the current event.
   *
   * If this returns `true`, then the sending could be aborted, because the
   * event hasn't been sent yet. Otherwise, if this returns `false`, the
   * event had already been sent and could not be aborted.
   *
   * This has an effect only on the first call; subsequent calls will always
   * return `false`.
   */
  abort(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<boolean>;
  /**
   * Attempt to manually resend messages that failed to send due to issues
   * that should now have been fixed.
   *
   * This is useful for example, when there's a
   * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
   * the user may have re-verified on a different device and would now
   * like to send the failed message that's waiting on this device.
   *
   * # Arguments
   *
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo that should be unwedged.
   */
  tryResend(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

/**
 * A handle to perform actions onto a local echo.
 */
export class SendHandle
  extends UniffiAbstractObject
  implements SendHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'SendHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSendHandleObjectFactory.bless(pointer);
  }

  /**
   * Try to abort the sending of the current event.
   *
   * If this returns `true`, then the sending could be aborted, because the
   * event hasn't been sent yet. Otherwise, if this returns `false`, the
   * event had already been sent and could not be aborted.
   *
   * This has an effect only on the first call; subsequent calls will always
   * return `false`.
   */
  public async abort(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(
            uniffiTypeSendHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Attempt to manually resend messages that failed to send due to issues
   * that should now have been fixed.
   *
   * This is useful for example, when there's a
   * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
   * the user may have re-verified on a different device and would now
   * like to send the failed message that's waiting on this device.
   *
   * # Arguments
   *
   * * `transaction_id` - The send queue transaction identifier of the local
   * echo that should be unwedged.
   */
  public async tryResend(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(
            uniffiTypeSendHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSendHandleObjectFactory.pointer(this);
      uniffiTypeSendHandleObjectFactory.freePointer(pointer);
      uniffiTypeSendHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SendHandle {
    return uniffiTypeSendHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSendHandleObjectFactory: UniffiObjectFactory<SendHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SendHandleInterface {
      const instance = Object.create(SendHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SendHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sendhandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SendHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SendHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sendhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sendhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SendHandleInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'SendHandle'
      );
    },
  };
// FfiConverter for SendHandleInterface
const FfiConverterTypeSendHandle = new FfiConverterObject(
  uniffiTypeSendHandleObjectFactory
);

export interface SessionVerificationControllerInterface {
  /**
   * Accept the previously acknowledged verification request
   */
  acceptVerificationRequest(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Set this particular request as the currently active one and register for
   * events pertaining it.
   * * `sender_id` - The user requesting verification.
   * * `flow_id` - - The ID that uniquely identifies the verification flow.
   */
  acknowledgeVerificationRequest(
    senderId: string,
    flowId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Confirm that the short auth strings match on both sides.
   */
  approveVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Cancel the current verification request
   */
  cancelVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Reject the short auth string
   */
  declineVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Request verification for the current device
   */
  requestDeviceVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Request verification for the given user
   */
  requestUserVerification(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  setDelegate(
    delegate: SessionVerificationControllerDelegate | undefined
  ): void;
  /**
   * Transition the current verification request into a SAS verification
   * flow.
   */
  startSasVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
}

export class SessionVerificationController
  extends UniffiAbstractObject
  implements SessionVerificationControllerInterface
{
  readonly [uniffiTypeNameSymbol] = 'SessionVerificationController';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSessionVerificationControllerObjectFactory.bless(pointer);
  }

  /**
   * Accept the previously acknowledged verification request
   */
  public async acceptVerificationRequest(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Set this particular request as the currently active one and register for
   * events pertaining it.
   * * `sender_id` - The user requesting verification.
   * * `flow_id` - - The ID that uniquely identifies the verification flow.
   */
  public async acknowledgeVerificationRequest(
    senderId: string,
    flowId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            ),
            FfiConverterString.lower(senderId),
            FfiConverterString.lower(flowId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Confirm that the short auth strings match on both sides.
   */
  public async approveVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Cancel the current verification request
   */
  public async cancelVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Reject the short auth string
   */
  public async declineVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Request verification for the current device
   */
  public async requestDeviceVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_device_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Request verification for the given user
   */
  public async requestUserVerification(
    userId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_user_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            ),
            FfiConverterString.lower(userId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public setDelegate(
    delegate: SessionVerificationControllerDelegate | undefined
  ): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(
          uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
            this
          ),
          FfiConverterOptionalTypeSessionVerificationControllerDelegate.lower(
            delegate
          ),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Transition the current verification request into a SAS verification
   * flow.
   */
  public async startSasVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
            uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(
              this
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeSessionVerificationControllerObjectFactory.pointer(this);
      uniffiTypeSessionVerificationControllerObjectFactory.freePointer(pointer);
      uniffiTypeSessionVerificationControllerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SessionVerificationController {
    return uniffiTypeSessionVerificationControllerObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeSessionVerificationControllerObjectFactory: UniffiObjectFactory<SessionVerificationControllerInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): SessionVerificationControllerInterface {
      const instance = Object.create(SessionVerificationController.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SessionVerificationController';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sessionverificationcontroller_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(
      obj: SessionVerificationControllerInterface
    ): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: SessionVerificationControllerInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SessionVerificationControllerInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SessionVerificationController'
      );
    },
  };
// FfiConverter for SessionVerificationControllerInterface
const FfiConverterTypeSessionVerificationController = new FfiConverterObject(
  uniffiTypeSessionVerificationControllerObjectFactory
);

export interface SessionVerificationEmojiInterface {
  description(): string;
  symbol(): string;
}

export class SessionVerificationEmoji
  extends UniffiAbstractObject
  implements SessionVerificationEmojiInterface
{
  readonly [uniffiTypeNameSymbol] = 'SessionVerificationEmoji';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSessionVerificationEmojiObjectFactory.bless(pointer);
  }

  public description(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(
            uniffiTypeSessionVerificationEmojiObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public symbol(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(
            uniffiTypeSessionVerificationEmojiObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeSessionVerificationEmojiObjectFactory.pointer(this);
      uniffiTypeSessionVerificationEmojiObjectFactory.freePointer(pointer);
      uniffiTypeSessionVerificationEmojiObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SessionVerificationEmoji {
    return uniffiTypeSessionVerificationEmojiObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSessionVerificationEmojiObjectFactory: UniffiObjectFactory<SessionVerificationEmojiInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): SessionVerificationEmojiInterface {
      const instance = Object.create(SessionVerificationEmoji.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SessionVerificationEmoji';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sessionverificationemoji_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SessionVerificationEmojiInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: SessionVerificationEmojiInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SessionVerificationEmojiInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SessionVerificationEmoji'
      );
    },
  };
// FfiConverter for SessionVerificationEmojiInterface
const FfiConverterTypeSessionVerificationEmoji = new FfiConverterObject(
  uniffiTypeSessionVerificationEmojiObjectFactory
);

export interface SpanInterface {
  enter(): void;
  exit(): void;
  isNone(): boolean;
}

export class Span extends UniffiAbstractObject implements SpanInterface {
  readonly [uniffiTypeNameSymbol] = 'Span';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a span originating at the given callsite (file, line and column).
   *
   * The target should be something like a module path, and can be referenced
   * in the filter string given to `setup_tracing`. `level` and `target`
   * for a callsite are fixed at the first creation of a span for that
   * callsite and can not be changed afterwards, i.e. the level and
   * target passed for second and following creation of a span with the same
   * callsite will be ignored.
   *
   * This function leaks a little bit of memory for each unique (file +
   * line + level + target + name) it is called with. Please make sure that
   * the number of different combinations of those parameters this can be
   * called with is constant in the final executable.
   *
   * For a span to have an effect, you must `.enter()` it at the start of a
   * logical unit of work and `.exit()` it at the end of the same (including
   * on failure). Entering registers the span in thread-local storage, so
   * future calls to `log_event` on the same thread are able to attach the
   * events they create to the span, exiting unregisters it. For this to
   * work, exiting a span must be done on the same thread where it was
   * entered. It is possible to enter a span on multiple threads, in which
   * case it should also be exited on all of them individually; that is,
   * unless you *want* the span to be attached to all further events created
   * on that thread.
   */
  constructor(
    file: string,
    line: /*u32*/ number | undefined,
    level: LogLevel,
    target: string,
    name: string
  ) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_span_new(
          FfiConverterString.lower(file),
          FfiConverterOptionalUInt32.lower(line),
          FfiConverterTypeLogLevel.lower(level),
          FfiConverterString.lower(target),
          FfiConverterString.lower(name),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeSpanObjectFactory.bless(pointer);
  }

  public static current(): SpanInterface {
    return FfiConverterTypeSpan.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_span_current(
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public enter(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_span_enter(
          uniffiTypeSpanObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public exit(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_span_exit(
          uniffiTypeSpanObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public isNone(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_span_is_none(
            uniffiTypeSpanObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSpanObjectFactory.pointer(this);
      uniffiTypeSpanObjectFactory.freePointer(pointer);
      uniffiTypeSpanObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Span {
    return uniffiTypeSpanObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSpanObjectFactory: UniffiObjectFactory<SpanInterface> = {
  create(pointer: UnsafeMutableRawPointer): SpanInterface {
    const instance = Object.create(Span.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Span';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_span_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: SpanInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: SpanInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_span(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_span(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is SpanInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Span';
  },
};
// FfiConverter for SpanInterface
const FfiConverterTypeSpan = new FfiConverterObject(
  uniffiTypeSpanObjectFactory
);

/**
 * An object encapsulating the SSO login flow
 */
export interface SsoHandlerInterface {
  /**
   * Completes the SSO login process.
   */
  finish(
    callbackUrl: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Returns the URL for starting SSO authentication. The URL should be
   * opened in a web view. Once the web view succeeds, call `finish` with
   * the callback URL.
   */
  url(): string;
}

/**
 * An object encapsulating the SSO login flow
 */
export class SsoHandler
  extends UniffiAbstractObject
  implements SsoHandlerInterface
{
  readonly [uniffiTypeNameSymbol] = 'SsoHandler';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSsoHandlerObjectFactory.bless(pointer);
  }

  /**
   * Completes the SSO login process.
   */
  public async finish(
    callbackUrl: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(
            uniffiTypeSsoHandlerObjectFactory.clonePointer(this),
            FfiConverterString.lower(callbackUrl)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSsoError.lift.bind(
          FfiConverterTypeSsoError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the URL for starting SSO authentication. The URL should be
   * opened in a web view. Once the web view succeeds, call `finish` with
   * the callback URL.
   */
  public url(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(
            uniffiTypeSsoHandlerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSsoHandlerObjectFactory.pointer(this);
      uniffiTypeSsoHandlerObjectFactory.freePointer(pointer);
      uniffiTypeSsoHandlerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SsoHandler {
    return uniffiTypeSsoHandlerObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSsoHandlerObjectFactory: UniffiObjectFactory<SsoHandlerInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SsoHandlerInterface {
      const instance = Object.create(SsoHandler.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SsoHandler';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_ssohandler_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SsoHandlerInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SsoHandlerInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_ssohandler(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_ssohandler(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SsoHandlerInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'SsoHandler'
      );
    },
  };
// FfiConverter for SsoHandlerInterface
const FfiConverterTypeSsoHandler = new FfiConverterObject(
  uniffiTypeSsoHandlerObjectFactory
);

export interface SyncServiceInterface {
  roomListService(): RoomListServiceInterface;
  start(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  state(listener: SyncServiceStateObserver): TaskHandleInterface;
  stop(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
}

export class SyncService
  extends UniffiAbstractObject
  implements SyncServiceInterface
{
  readonly [uniffiTypeNameSymbol] = 'SyncService';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSyncServiceObjectFactory.bless(pointer);
  }

  public roomListService(): RoomListServiceInterface {
    return FfiConverterTypeRoomListService.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(
            uniffiTypeSyncServiceObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async start(asyncOpts_?: { signal: AbortSignal }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_start(
            uniffiTypeSyncServiceObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public state(listener: SyncServiceStateObserver): TaskHandleInterface {
    return FfiConverterTypeTaskHandle.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_state(
            uniffiTypeSyncServiceObjectFactory.clonePointer(this),
            FfiConverterTypeSyncServiceStateObserver.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async stop(asyncOpts_?: { signal: AbortSignal }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(
            uniffiTypeSyncServiceObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSyncServiceObjectFactory.pointer(this);
      uniffiTypeSyncServiceObjectFactory.freePointer(pointer);
      uniffiTypeSyncServiceObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SyncService {
    return uniffiTypeSyncServiceObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSyncServiceObjectFactory: UniffiObjectFactory<SyncServiceInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SyncServiceInterface {
      const instance = Object.create(SyncService.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SyncService';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_syncservice_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SyncServiceInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SyncServiceInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_syncservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_syncservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SyncServiceInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SyncService'
      );
    },
  };
// FfiConverter for SyncServiceInterface
const FfiConverterTypeSyncService = new FfiConverterObject(
  uniffiTypeSyncServiceObjectFactory
);

export interface SyncServiceBuilderInterface {
  finish(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<SyncServiceInterface>;
  withCrossProcessLock(): SyncServiceBuilderInterface;
  /**
   * Enable the "offline" mode for the [`SyncService`].
   */
  withOfflineMode(): SyncServiceBuilderInterface;
}

export class SyncServiceBuilder
  extends UniffiAbstractObject
  implements SyncServiceBuilderInterface
{
  readonly [uniffiTypeNameSymbol] = 'SyncServiceBuilder';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSyncServiceBuilderObjectFactory.bless(pointer);
  }

  public async finish(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<SyncServiceInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(
            uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeSyncService.lift.bind(
          FfiConverterTypeSyncService
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public withCrossProcessLock(): SyncServiceBuilderInterface {
    return FfiConverterTypeSyncServiceBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(
            uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Enable the "offline" mode for the [`SyncService`].
   */
  public withOfflineMode(): SyncServiceBuilderInterface {
    return FfiConverterTypeSyncServiceBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_offline_mode(
            uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSyncServiceBuilderObjectFactory.pointer(this);
      uniffiTypeSyncServiceBuilderObjectFactory.freePointer(pointer);
      uniffiTypeSyncServiceBuilderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SyncServiceBuilder {
    return uniffiTypeSyncServiceBuilderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSyncServiceBuilderObjectFactory: UniffiObjectFactory<SyncServiceBuilderInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SyncServiceBuilderInterface {
      const instance = Object.create(SyncServiceBuilder.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SyncServiceBuilder';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_syncservicebuilder_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SyncServiceBuilderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SyncServiceBuilderInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SyncServiceBuilderInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SyncServiceBuilder'
      );
    },
  };
// FfiConverter for SyncServiceBuilderInterface
const FfiConverterTypeSyncServiceBuilder = new FfiConverterObject(
  uniffiTypeSyncServiceBuilderObjectFactory
);

/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
export interface TaskHandleInterface {
  cancel(): void;
  /**
   * Check whether the handle is finished.
   */
  isFinished(): boolean;
}

/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
export class TaskHandle
  extends UniffiAbstractObject
  implements TaskHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'TaskHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTaskHandleObjectFactory.bless(pointer);
  }

  public cancel(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(
          uniffiTypeTaskHandleObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Check whether the handle is finished.
   */
  public isFinished(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(
            uniffiTypeTaskHandleObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTaskHandleObjectFactory.pointer(this);
      uniffiTypeTaskHandleObjectFactory.freePointer(pointer);
      uniffiTypeTaskHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TaskHandle {
    return uniffiTypeTaskHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTaskHandleObjectFactory: UniffiObjectFactory<TaskHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TaskHandleInterface {
      const instance = Object.create(TaskHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TaskHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_taskhandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TaskHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TaskHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_taskhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_taskhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TaskHandleInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'TaskHandle'
      );
    },
  };
// FfiConverter for TaskHandleInterface
const FfiConverterTypeTaskHandle = new FfiConverterObject(
  uniffiTypeTaskHandleObjectFactory
);

export interface ThreadSummaryInterface {
  latestEvent(): EmbeddedEventDetails;
}

export class ThreadSummary
  extends UniffiAbstractObject
  implements ThreadSummaryInterface
{
  readonly [uniffiTypeNameSymbol] = 'ThreadSummary';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeThreadSummaryObjectFactory.bless(pointer);
  }

  public latestEvent(): EmbeddedEventDetails {
    return FfiConverterTypeEmbeddedEventDetails.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_threadsummary_latest_event(
            uniffiTypeThreadSummaryObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeThreadSummaryObjectFactory.pointer(this);
      uniffiTypeThreadSummaryObjectFactory.freePointer(pointer);
      uniffiTypeThreadSummaryObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ThreadSummary {
    return uniffiTypeThreadSummaryObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeThreadSummaryObjectFactory: UniffiObjectFactory<ThreadSummaryInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ThreadSummaryInterface {
      const instance = Object.create(ThreadSummary.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ThreadSummary';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_threadsummary_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ThreadSummaryInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ThreadSummaryInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_threadsummary(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_threadsummary(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ThreadSummaryInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ThreadSummary'
      );
    },
  };
// FfiConverter for ThreadSummaryInterface
const FfiConverterTypeThreadSummary = new FfiConverterObject(
  uniffiTypeThreadSummaryObjectFactory
);

export interface TimelineInterface {
  addListener(
    listener: TimelineListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface>;
  createMessageContent(
    msgType: MessageType
  ): RoomMessageEventContentWithoutRelationInterface | undefined;
  createPoll(
    question: string,
    answers: Array<string>,
    maxSelections: /*u8*/ number,
    pollKind: PollKind,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Edits an event from the timeline.
   *
   * If it was a local event, this will *try* to edit it, if it was not
   * being sent already. If the event was a remote event, then it will be
   * redacted by sending an edit request to the server.
   *
   * Returns whether the edit did happen. It can only return false for
   * local events that are being processed.
   */
  edit(
    eventOrTransactionId: EventOrTransactionId,
    newContent: EditedContent,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  endPoll(
    pollStartEventId: string,
    text: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  fetchDetailsForEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  fetchMembers(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * Get the current timeline item for the given event ID, if any.
   *
   * Will return a remote event, *or* a local echo that has been sent but not
   * yet replaced by a remote echo.
   *
   * It's preferable to store the timeline items in the model for your UI, if
   * possible, instead of just storing IDs and coming back to the timeline
   * object to look up items.
   */
  getEventTimelineItemByEventId(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventTimelineItem>;
  /**
   * Load the reply details for the given event id.
   *
   * This will return an `InReplyToDetails` object that contains the details
   * which will either be ready or an error.
   */
  loadReplyDetails(
    eventIdStr: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<InReplyToDetailsInterface>;
  /**
   * Mark the room as read by trying to attach an *unthreaded* read receipt
   * to the latest room event.
   *
   * This works even if the latest event belongs to a thread, as a threaded
   * reply also belongs to the unthreaded timeline. No threaded receipt
   * will be sent here (see also #3123).
   */
  markAsRead(
    receiptType: ReceiptType,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Paginate backwards, whether we are in focused mode or in live mode.
   *
   * Returns whether we hit the start of the timeline or not.
   */
  paginateBackwards(
    numEvents: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Paginate forwards, whether we are in focused mode or in live mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  paginateForwards(
    numEvents: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Adds a new pinned event by sending an updated `m.room.pinned_events`
   * event containing the new event id.
   *
   * Returns `true` if we sent the request, `false` if the event was already
   * pinned.
   */
  pinEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Redacts an event from the timeline.
   *
   * Only works for events that exist as timeline items.
   *
   * If it was a local event, this will *try* to cancel it, if it was not
   * being sent already. If the event was a remote event, then it will be
   * redacted by sending a redaction request to the server.
   *
   * Will return an error if the event couldn't be redacted.
   */
  redactEvent(
    eventOrTransactionId: EventOrTransactionId,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  retryDecryption(sessionIds: Array<string>): void;
  /**
   * Queues an event in the room's send queue so it's processed for
   * sending later.
   *
   * Returns an abort handle that allows to abort sending, if it hasn't
   * happened yet.
   */
  send(
    msg: RoomMessageEventContentWithoutRelationInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendHandleInterface>;
  sendAudio(
    params: UploadParameters,
    audioInfo: AudioInfo,
    progressWatcher: ProgressWatcher | undefined
  ) /*throws*/ : SendAttachmentJoinHandleInterface;
  sendFile(
    params: UploadParameters,
    fileInfo: FileInfo,
    progressWatcher: ProgressWatcher | undefined
  ) /*throws*/ : SendAttachmentJoinHandleInterface;
  sendGallery(
    params: GalleryUploadParameters,
    itemInfos: Array<GalleryItemInfo>
  ) /*throws*/ : SendGalleryJoinHandleInterface;
  sendImage(
    params: UploadParameters,
    thumbnailPath: string | undefined,
    imageInfo: ImageInfo,
    progressWatcher: ProgressWatcher | undefined
  ) /*throws*/ : SendAttachmentJoinHandleInterface;
  sendLocation(
    body: string,
    geoUri: string,
    description: string | undefined,
    zoomLevel: /*u8*/ number | undefined,
    assetType: AssetType | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  sendPollResponse(
    pollStartEventId: string,
    answers: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  sendReadReceipt(
    receiptType: ReceiptType,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Send a reply.
   *
   * If the replied to event has a thread relation, it is forwarded on the
   * reply so that clients that support threads can render the reply
   * inside the thread.
   */
  sendReply(
    msg: RoomMessageEventContentWithoutRelationInterface,
    replyParams: ReplyParameters,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  sendVideo(
    params: UploadParameters,
    thumbnailPath: string | undefined,
    videoInfo: VideoInfo,
    progressWatcher: ProgressWatcher | undefined
  ) /*throws*/ : SendAttachmentJoinHandleInterface;
  sendVoiceMessage(
    params: UploadParameters,
    audioInfo: AudioInfo,
    waveform: Array</*u16*/ number>,
    progressWatcher: ProgressWatcher | undefined
  ) /*throws*/ : SendAttachmentJoinHandleInterface;
  subscribeToBackPaginationStatus(
    listener: PaginationStatusListener,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TaskHandleInterface>;
  /**
   * Toggle a reaction on an event.
   *
   * Adds or redacts a reaction based on the state of the reaction at the
   * time it is called.
   *
   * This method works both on local echoes and remote items.
   *
   * When redacting a previous reaction, the redaction reason is not set.
   *
   * Ensures that only one reaction is sent at a time to avoid race
   * conditions and spamming the homeserver with requests.
   */
  toggleReaction(
    itemId: EventOrTransactionId,
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Adds a new pinned event by sending an updated `m.room.pinned_events`
   * event without the event id we want to remove.
   *
   * Returns `true` if we sent the request, `false` if the event wasn't
   * pinned
   */
  unpinEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
}

export class Timeline
  extends UniffiAbstractObject
  implements TimelineInterface
{
  readonly [uniffiTypeNameSymbol] = 'Timeline';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineObjectFactory.bless(pointer);
  }

  public async addListener(
    listener: TimelineListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeTimelineListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public createMessageContent(
    msgType: MessageType
  ): RoomMessageEventContentWithoutRelationInterface | undefined {
    return FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeMessageType.lower(msgType),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async createPoll(
    question: string,
    answers: Array<string>,
    maxSelections: /*u8*/ number,
    pollKind: PollKind,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(question),
            FfiConverterArrayString.lower(answers),
            FfiConverterUInt8.lower(maxSelections),
            FfiConverterTypePollKind.lower(pollKind)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Edits an event from the timeline.
   *
   * If it was a local event, this will *try* to edit it, if it was not
   * being sent already. If the event was a remote event, then it will be
   * redacted by sending an edit request to the server.
   *
   * Returns whether the edit did happen. It can only return false for
   * local events that are being processed.
   */
  public async edit(
    eventOrTransactionId: EventOrTransactionId,
    newContent: EditedContent,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_edit(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeEventOrTransactionId.lower(eventOrTransactionId),
            FfiConverterTypeEditedContent.lower(newContent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async endPoll(
    pollStartEventId: string,
    text: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(pollStartEventId),
            FfiConverterString.lower(text)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async fetchDetailsForEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async fetchMembers(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(
            uniffiTypeTimelineObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the current timeline item for the given event ID, if any.
   *
   * Will return a remote event, *or* a local echo that has been sent but not
   * yet replaced by a remote echo.
   *
   * It's preferable to store the timeline items in the model for your UI, if
   * possible, instead of just storing IDs and coming back to the timeline
   * object to look up items.
   */
  public async getEventTimelineItemByEventId(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventTimelineItem> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeEventTimelineItem.lift.bind(
          FfiConverterTypeEventTimelineItem
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Load the reply details for the given event id.
   *
   * This will return an `InReplyToDetails` object that contains the details
   * which will either be ready or an error.
   */
  public async loadReplyDetails(
    eventIdStr: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<InReplyToDetailsInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventIdStr)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeInReplyToDetails.lift.bind(
          FfiConverterTypeInReplyToDetails
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Mark the room as read by trying to attach an *unthreaded* read receipt
   * to the latest room event.
   *
   * This works even if the latest event belongs to a thread, as a threaded
   * reply also belongs to the unthreaded timeline. No threaded receipt
   * will be sent here (see also #3123).
   */
  public async markAsRead(
    receiptType: ReceiptType,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeReceiptType.lower(receiptType)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Paginate backwards, whether we are in focused mode or in live mode.
   *
   * Returns whether we hit the start of the timeline or not.
   */
  public async paginateBackwards(
    numEvents: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterUInt16.lower(numEvents)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Paginate forwards, whether we are in focused mode or in live mode.
   *
   * Returns whether we hit the end of the timeline or not.
   */
  public async paginateForwards(
    numEvents: /*u16*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_forwards(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterUInt16.lower(numEvents)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Adds a new pinned event by sending an updated `m.room.pinned_events`
   * event containing the new event id.
   *
   * Returns `true` if we sent the request, `false` if the event was already
   * pinned.
   */
  public async pinEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Redacts an event from the timeline.
   *
   * Only works for events that exist as timeline items.
   *
   * If it was a local event, this will *try* to cancel it, if it was not
   * being sent already. If the event was a remote event, then it will be
   * redacted by sending a redaction request to the server.
   *
   * Will return an error if the event couldn't be redacted.
   */
  public async redactEvent(
    eventOrTransactionId: EventOrTransactionId,
    reason: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeEventOrTransactionId.lower(eventOrTransactionId),
            FfiConverterOptionalString.lower(reason)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public retryDecryption(sessionIds: Array<string>): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(
          uniffiTypeTimelineObjectFactory.clonePointer(this),
          FfiConverterArrayString.lower(sessionIds),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Queues an event in the room's send queue so it's processed for
   * sending later.
   *
   * Returns an abort handle that allows to abort sending, if it hasn't
   * happened yet.
   */
  public async send(
    msg: RoomMessageEventContentWithoutRelationInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeSendHandle.lift.bind(
          FfiConverterTypeSendHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public sendAudio(
    params: UploadParameters,
    audioInfo: AudioInfo,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandleInterface /*throws*/ {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(
          FfiConverterTypeRoomError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeUploadParameters.lower(params),
            FfiConverterTypeAudioInfo.lower(audioInfo),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sendFile(
    params: UploadParameters,
    fileInfo: FileInfo,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandleInterface /*throws*/ {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(
          FfiConverterTypeRoomError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeUploadParameters.lower(params),
            FfiConverterTypeFileInfo.lower(fileInfo),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sendGallery(
    params: GalleryUploadParameters,
    itemInfos: Array<GalleryItemInfo>
  ): SendGalleryJoinHandleInterface /*throws*/ {
    return FfiConverterTypeSendGalleryJoinHandle.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(
          FfiConverterTypeRoomError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_gallery(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeGalleryUploadParameters.lower(params),
            FfiConverterArrayTypeGalleryItemInfo.lower(itemInfos),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sendImage(
    params: UploadParameters,
    thumbnailPath: string | undefined,
    imageInfo: ImageInfo,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandleInterface /*throws*/ {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(
          FfiConverterTypeRoomError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeUploadParameters.lower(params),
            FfiConverterOptionalString.lower(thumbnailPath),
            FfiConverterTypeImageInfo.lower(imageInfo),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async sendLocation(
    body: string,
    geoUri: string,
    description: string | undefined,
    zoomLevel: /*u8*/ number | undefined,
    assetType: AssetType | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(body),
            FfiConverterString.lower(geoUri),
            FfiConverterOptionalString.lower(description),
            FfiConverterOptionalUInt8.lower(zoomLevel),
            FfiConverterOptionalTypeAssetType.lower(assetType)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sendPollResponse(
    pollStartEventId: string,
    answers: Array<string>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(pollStartEventId),
            FfiConverterArrayString.lower(answers)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sendReadReceipt(
    receiptType: ReceiptType,
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeReceiptType.lower(receiptType),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send a reply.
   *
   * If the replied to event has a thread relation, it is forwarded on the
   * reply so that clients that support threads can render the reply
   * inside the thread.
   */
  public async sendReply(
    msg: RoomMessageEventContentWithoutRelationInterface,
    replyParams: ReplyParameters,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg),
            FfiConverterTypeReplyParameters.lower(replyParams)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public sendVideo(
    params: UploadParameters,
    thumbnailPath: string | undefined,
    videoInfo: VideoInfo,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandleInterface /*throws*/ {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(
          FfiConverterTypeRoomError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeUploadParameters.lower(params),
            FfiConverterOptionalString.lower(thumbnailPath),
            FfiConverterTypeVideoInfo.lower(videoInfo),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public sendVoiceMessage(
    params: UploadParameters,
    audioInfo: AudioInfo,
    waveform: Array</*u16*/ number>,
    progressWatcher: ProgressWatcher | undefined
  ): SendAttachmentJoinHandleInterface /*throws*/ {
    return FfiConverterTypeSendAttachmentJoinHandle.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(
          FfiConverterTypeRoomError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeUploadParameters.lower(params),
            FfiConverterTypeAudioInfo.lower(audioInfo),
            FfiConverterArrayUInt16.lower(waveform),
            FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async subscribeToBackPaginationStatus(
    listener: PaginationStatusListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TaskHandleInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypePaginationStatusListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(
          FfiConverterTypeTaskHandle
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Toggle a reaction on an event.
   *
   * Adds or redacts a reaction based on the state of the reaction at the
   * time it is called.
   *
   * This method works both on local echoes and remote items.
   *
   * When redacting a previous reaction, the redaction reason is not set.
   *
   * Ensures that only one reaction is sent at a time to avoid race
   * conditions and spamming the homeserver with requests.
   */
  public async toggleReaction(
    itemId: EventOrTransactionId,
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterTypeEventOrTransactionId.lower(itemId),
            FfiConverterString.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Adds a new pinned event by sending an updated `m.room.pinned_events`
   * event without the event id we want to remove.
   *
   * Returns `true` if we sent the request, `false` if the event wasn't
   * pinned
   */
  public async unpinEvent(
    eventId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(
            uniffiTypeTimelineObjectFactory.clonePointer(this),
            FfiConverterString.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTimelineObjectFactory.pointer(this);
      uniffiTypeTimelineObjectFactory.freePointer(pointer);
      uniffiTypeTimelineObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Timeline {
    return uniffiTypeTimelineObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineObjectFactory: UniffiObjectFactory<TimelineInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineInterface {
      const instance = Object.create(Timeline.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Timeline';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timeline_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TimelineInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timeline(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timeline(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Timeline'
      );
    },
  };
// FfiConverter for TimelineInterface
const FfiConverterTypeTimeline = new FfiConverterObject(
  uniffiTypeTimelineObjectFactory
);

export interface TimelineDiffInterface {
  append(): Array<TimelineItemInterface> | undefined;
  change(): TimelineChange;
  insert(): InsertData | undefined;
  pushBack(): TimelineItemInterface | undefined;
  pushFront(): TimelineItemInterface | undefined;
  remove(): /*u32*/ number | undefined;
  reset(): Array<TimelineItemInterface> | undefined;
  set(): SetData | undefined;
  truncate(): /*u32*/ number | undefined;
}

export class TimelineDiff
  extends UniffiAbstractObject
  implements TimelineDiffInterface
{
  readonly [uniffiTypeNameSymbol] = 'TimelineDiff';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineDiffObjectFactory.bless(pointer);
  }

  public append(): Array<TimelineItemInterface> | undefined {
    return FfiConverterOptionalArrayTypeTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_append(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public change(): TimelineChange {
    return FfiConverterTypeTimelineChange.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_change(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insert(): InsertData | undefined {
    return FfiConverterOptionalTypeInsertData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_insert(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public pushBack(): TimelineItemInterface | undefined {
    return FfiConverterOptionalTypeTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_back(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public pushFront(): TimelineItemInterface | undefined {
    return FfiConverterOptionalTypeTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_front(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public remove(): /*u32*/ number | undefined {
    return FfiConverterOptionalUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_remove(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public reset(): Array<TimelineItemInterface> | undefined {
    return FfiConverterOptionalArrayTypeTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_reset(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public set(): SetData | undefined {
    return FfiConverterOptionalTypeSetData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_set(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public truncate(): /*u32*/ number | undefined {
    return FfiConverterOptionalUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelinediff_truncate(
            uniffiTypeTimelineDiffObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTimelineDiffObjectFactory.pointer(this);
      uniffiTypeTimelineDiffObjectFactory.freePointer(pointer);
      uniffiTypeTimelineDiffObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TimelineDiff {
    return uniffiTypeTimelineDiffObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineDiffObjectFactory: UniffiObjectFactory<TimelineDiffInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineDiffInterface {
      const instance = Object.create(TimelineDiff.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TimelineDiff';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timelinediff_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineDiffInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TimelineDiffInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelinediff(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelinediff(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineDiffInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'TimelineDiff'
      );
    },
  };
// FfiConverter for TimelineDiffInterface
const FfiConverterTypeTimelineDiff = new FfiConverterObject(
  uniffiTypeTimelineDiffObjectFactory
);

export interface TimelineEventInterface {
  eventId(): string;
  eventType() /*throws*/ : TimelineEventType;
  senderId(): string;
  timestamp(): Timestamp;
}

export class TimelineEvent
  extends UniffiAbstractObject
  implements TimelineEventInterface
{
  readonly [uniffiTypeNameSymbol] = 'TimelineEvent';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineEventObjectFactory.bless(pointer);
  }

  public eventId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(
            uniffiTypeTimelineEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public eventType(): TimelineEventType /*throws*/ {
    return FfiConverterTypeTimelineEventType.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(
            uniffiTypeTimelineEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public senderId(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(
            uniffiTypeTimelineEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public timestamp(): Timestamp {
    return FfiConverterTypeTimestamp.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(
            uniffiTypeTimelineEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTimelineEventObjectFactory.pointer(this);
      uniffiTypeTimelineEventObjectFactory.freePointer(pointer);
      uniffiTypeTimelineEventObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TimelineEvent {
    return uniffiTypeTimelineEventObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineEventObjectFactory: UniffiObjectFactory<TimelineEventInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineEventInterface {
      const instance = Object.create(TimelineEvent.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TimelineEvent';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timelineevent_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineEventInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TimelineEventInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelineevent(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelineevent(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineEventInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'TimelineEvent'
      );
    },
  };
// FfiConverter for TimelineEventInterface
const FfiConverterTypeTimelineEvent = new FfiConverterObject(
  uniffiTypeTimelineEventObjectFactory
);

export interface TimelineEventTypeFilterInterface {}

export class TimelineEventTypeFilter
  extends UniffiAbstractObject
  implements TimelineEventTypeFilterInterface
{
  readonly [uniffiTypeNameSymbol] = 'TimelineEventTypeFilter';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineEventTypeFilterObjectFactory.bless(pointer);
  }

  public static exclude(
    eventTypes: Array<FilterTimelineEventType>
  ): TimelineEventTypeFilterInterface {
    return FfiConverterTypeTimelineEventTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(
            FfiConverterArrayTypeFilterTimelineEventType.lower(eventTypes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static include(
    eventTypes: Array<FilterTimelineEventType>
  ): TimelineEventTypeFilterInterface {
    return FfiConverterTypeTimelineEventTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(
            FfiConverterArrayTypeFilterTimelineEventType.lower(eventTypes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeTimelineEventTypeFilterObjectFactory.pointer(this);
      uniffiTypeTimelineEventTypeFilterObjectFactory.freePointer(pointer);
      uniffiTypeTimelineEventTypeFilterObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TimelineEventTypeFilter {
    return uniffiTypeTimelineEventTypeFilterObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineEventTypeFilterObjectFactory: UniffiObjectFactory<TimelineEventTypeFilterInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineEventTypeFilterInterface {
      const instance = Object.create(TimelineEventTypeFilter.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TimelineEventTypeFilter';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timelineeventtypefilter_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineEventTypeFilterInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: TimelineEventTypeFilterInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineEventTypeFilterInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'TimelineEventTypeFilter'
      );
    },
  };
// FfiConverter for TimelineEventTypeFilterInterface
const FfiConverterTypeTimelineEventTypeFilter = new FfiConverterObject(
  uniffiTypeTimelineEventTypeFilterObjectFactory
);

export interface TimelineItemInterface {
  asEvent(): EventTimelineItem | undefined;
  asVirtual(): VirtualTimelineItem | undefined;
  fmtDebug(): string;
  /**
   * An opaque unique identifier for this timeline item.
   */
  uniqueId(): TimelineUniqueId;
}

export class TimelineItem
  extends UniffiAbstractObject
  implements TimelineItemInterface
{
  readonly [uniffiTypeNameSymbol] = 'TimelineItem';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimelineItemObjectFactory.bless(pointer);
  }

  public asEvent(): EventTimelineItem | undefined {
    return FfiConverterOptionalTypeEventTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(
            uniffiTypeTimelineItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asVirtual(): VirtualTimelineItem | undefined {
    return FfiConverterOptionalTypeVirtualTimelineItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(
            uniffiTypeTimelineItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public fmtDebug(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(
            uniffiTypeTimelineItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * An opaque unique identifier for this timeline item.
   */
  public uniqueId(): TimelineUniqueId {
    return FfiConverterTypeTimelineUniqueId.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(
            uniffiTypeTimelineItemObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTimelineItemObjectFactory.pointer(this);
      uniffiTypeTimelineItemObjectFactory.freePointer(pointer);
      uniffiTypeTimelineItemObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TimelineItem {
    return uniffiTypeTimelineItemObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimelineItemObjectFactory: UniffiObjectFactory<TimelineItemInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimelineItemInterface {
      const instance = Object.create(TimelineItem.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'TimelineItem';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timelineitem_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimelineItemInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TimelineItemInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelineitem(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelineitem(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimelineItemInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'TimelineItem'
      );
    },
  };
// FfiConverter for TimelineItemInterface
const FfiConverterTypeTimelineItem = new FfiConverterObject(
  uniffiTypeTimelineItemObjectFactory
);

export interface UnreadNotificationsCountInterface {
  hasNotifications(): boolean;
  highlightCount(): /*u32*/ number;
  notificationCount(): /*u32*/ number;
}

export class UnreadNotificationsCount
  extends UniffiAbstractObject
  implements UnreadNotificationsCountInterface
{
  readonly [uniffiTypeNameSymbol] = 'UnreadNotificationsCount';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUnreadNotificationsCountObjectFactory.bless(pointer);
  }

  public hasNotifications(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(
            uniffiTypeUnreadNotificationsCountObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public highlightCount(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(
            uniffiTypeUnreadNotificationsCountObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public notificationCount(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(
            uniffiTypeUnreadNotificationsCountObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeUnreadNotificationsCountObjectFactory.pointer(this);
      uniffiTypeUnreadNotificationsCountObjectFactory.freePointer(pointer);
      uniffiTypeUnreadNotificationsCountObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UnreadNotificationsCount {
    return uniffiTypeUnreadNotificationsCountObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUnreadNotificationsCountObjectFactory: UniffiObjectFactory<UnreadNotificationsCountInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): UnreadNotificationsCountInterface {
      const instance = Object.create(UnreadNotificationsCount.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'UnreadNotificationsCount';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_unreadnotificationscount_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: UnreadNotificationsCountInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: UnreadNotificationsCountInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is UnreadNotificationsCountInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'UnreadNotificationsCount'
      );
    },
  };
// FfiConverter for UnreadNotificationsCountInterface
const FfiConverterTypeUnreadNotificationsCount = new FfiConverterObject(
  uniffiTypeUnreadNotificationsCountObjectFactory
);

/**
 * The E2EE identity of a user.
 */
export interface UserIdentityInterface {
  /**
   * Was this identity previously verified, and is no longer?
   */
  hasVerificationViolation(): boolean;
  /**
   * Is the user identity considered to be verified.
   *
   * If the identity belongs to another user, our own user identity needs to
   * be verified as well for the identity to be considered to be verified.
   */
  isVerified(): boolean;
  /**
   * Get the public part of the Master key of this user identity.
   *
   * The public part of the Master key is usually used to uniquely identify
   * the identity.
   *
   * Returns None if the master key does not actually contain any keys.
   */
  masterKey(): string | undefined;
  /**
   * Remember this identity, ensuring it does not result in a pin violation.
   *
   * When we first see a user, we assume their cryptographic identity has not
   * been tampered with by the homeserver or another entity with
   * man-in-the-middle capabilities. We remember this identity and call this
   * action "pinning".
   *
   * If the identity presented for the user changes later on, the newly
   * presented identity is considered to be in "pin violation". This
   * method explicitly accepts the new identity, allowing it to replace
   * the previously pinned one and bringing it out of pin violation.
   *
   * UIs should display a warning to the user when encountering an identity
   * which is not verified and is in pin violation.
   */
  pin(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * True if we verified this identity at some point in the past.
   *
   * To reset this latch back to `false`, one must call
   * [`UserIdentity::withdraw_verification()`].
   */
  wasPreviouslyVerified(): boolean;
  /**
   * Remove the requirement for this identity to be verified.
   *
   * If an identity was previously verified and is not anymore it will be
   * reported to the user. In order to remove this notice users have to
   * verify again or to withdraw the verification requirement.
   */
  withdrawVerification(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
}

/**
 * The E2EE identity of a user.
 */
export class UserIdentity
  extends UniffiAbstractObject
  implements UserIdentityInterface
{
  readonly [uniffiTypeNameSymbol] = 'UserIdentity';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUserIdentityObjectFactory.bless(pointer);
  }

  /**
   * Was this identity previously verified, and is no longer?
   */
  public hasVerificationViolation(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_has_verification_violation(
            uniffiTypeUserIdentityObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Is the user identity considered to be verified.
   *
   * If the identity belongs to another user, our own user identity needs to
   * be verified as well for the identity to be considered to be verified.
   */
  public isVerified(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(
            uniffiTypeUserIdentityObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the public part of the Master key of this user identity.
   *
   * The public part of the Master key is usually used to uniquely identify
   * the identity.
   *
   * Returns None if the master key does not actually contain any keys.
   */
  public masterKey(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(
            uniffiTypeUserIdentityObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Remember this identity, ensuring it does not result in a pin violation.
   *
   * When we first see a user, we assume their cryptographic identity has not
   * been tampered with by the homeserver or another entity with
   * man-in-the-middle capabilities. We remember this identity and call this
   * action "pinning".
   *
   * If the identity presented for the user changes later on, the newly
   * presented identity is considered to be in "pin violation". This
   * method explicitly accepts the new identity, allowing it to replace
   * the previously pinned one and bringing it out of pin violation.
   *
   * UIs should display a warning to the user when encountering an identity
   * which is not verified and is in pin violation.
   */
  public async pin(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(
            uniffiTypeUserIdentityObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * True if we verified this identity at some point in the past.
   *
   * To reset this latch back to `false`, one must call
   * [`UserIdentity::withdraw_verification()`].
   */
  public wasPreviouslyVerified(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_was_previously_verified(
            uniffiTypeUserIdentityObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Remove the requirement for this identity to be verified.
   *
   * If an identity was previously verified and is not anymore it will be
   * reported to the user. In order to remove this notice users have to
   * verify again or to withdraw the verification requirement.
   */
  public async withdrawVerification(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_withdraw_verification(
            uniffiTypeUserIdentityObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(
          FfiConverterTypeClientError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeUserIdentityObjectFactory.pointer(this);
      uniffiTypeUserIdentityObjectFactory.freePointer(pointer);
      uniffiTypeUserIdentityObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UserIdentity {
    return uniffiTypeUserIdentityObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUserIdentityObjectFactory: UniffiObjectFactory<UserIdentityInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): UserIdentityInterface {
      const instance = Object.create(UserIdentity.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'UserIdentity';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_useridentity_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: UserIdentityInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: UserIdentityInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_useridentity(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_useridentity(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is UserIdentityInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'UserIdentity'
      );
    },
  };
// FfiConverter for UserIdentityInterface
const FfiConverterTypeUserIdentity = new FfiConverterObject(
  uniffiTypeUserIdentityObjectFactory
);

/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
export interface WidgetDriverInterface {
  run(
    room: RoomInterface,
    capabilitiesProvider: WidgetCapabilitiesProvider,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
}

/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
export class WidgetDriver
  extends UniffiAbstractObject
  implements WidgetDriverInterface
{
  readonly [uniffiTypeNameSymbol] = 'WidgetDriver';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeWidgetDriverObjectFactory.bless(pointer);
  }

  public async run(
    room: RoomInterface,
    capabilitiesProvider: WidgetCapabilitiesProvider,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(
            uniffiTypeWidgetDriverObjectFactory.clonePointer(this),
            FfiConverterTypeRoom.lower(room),
            FfiConverterTypeWidgetCapabilitiesProvider.lower(
              capabilitiesProvider
            )
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeWidgetDriverObjectFactory.pointer(this);
      uniffiTypeWidgetDriverObjectFactory.freePointer(pointer);
      uniffiTypeWidgetDriverObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is WidgetDriver {
    return uniffiTypeWidgetDriverObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeWidgetDriverObjectFactory: UniffiObjectFactory<WidgetDriverInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): WidgetDriverInterface {
      const instance = Object.create(WidgetDriver.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'WidgetDriver';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_widgetdriver_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: WidgetDriverInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: WidgetDriverInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_widgetdriver(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is WidgetDriverInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'WidgetDriver'
      );
    },
  };
// FfiConverter for WidgetDriverInterface
const FfiConverterTypeWidgetDriver = new FfiConverterObject(
  uniffiTypeWidgetDriverObjectFactory
);

/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
export interface WidgetDriverHandleInterface {
  /**
   * Receive a message from the widget driver.
   *
   * The message must be passed on to the widget.
   *
   * Returns `None` if the widget driver is no longer running.
   */
  recv(asyncOpts_?: { signal: AbortSignal }): Promise<string | undefined>;
  /**
   *
   * Returns `false` if the widget driver is no longer running.
   */
  send(msg: string, asyncOpts_?: { signal: AbortSignal }): Promise<boolean>;
}

/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
export class WidgetDriverHandle
  extends UniffiAbstractObject
  implements WidgetDriverHandleInterface
{
  readonly [uniffiTypeNameSymbol] = 'WidgetDriverHandle';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeWidgetDriverHandleObjectFactory.bless(pointer);
  }

  /**
   * Receive a message from the widget driver.
   *
   * The message must be passed on to the widget.
   *
   * Returns `None` if the widget driver is no longer running.
   */
  public async recv(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<string | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(
            uniffiTypeWidgetDriverHandleObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   *
   * Returns `false` if the widget driver is no longer running.
   */
  public async send(
    msg: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(
            uniffiTypeWidgetDriverHandleObjectFactory.clonePointer(this),
            FfiConverterString.lower(msg)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeWidgetDriverHandleObjectFactory.pointer(this);
      uniffiTypeWidgetDriverHandleObjectFactory.freePointer(pointer);
      uniffiTypeWidgetDriverHandleObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is WidgetDriverHandle {
    return uniffiTypeWidgetDriverHandleObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeWidgetDriverHandleObjectFactory: UniffiObjectFactory<WidgetDriverHandleInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): WidgetDriverHandleInterface {
      const instance = Object.create(WidgetDriverHandle.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'WidgetDriverHandle';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_widgetdriverhandle_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: WidgetDriverHandleInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: WidgetDriverHandleInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is WidgetDriverHandleInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'WidgetDriverHandle'
      );
    },
  };
// FfiConverter for WidgetDriverHandleInterface
const FfiConverterTypeWidgetDriverHandle = new FfiConverterObject(
  uniffiTypeWidgetDriverHandleObjectFactory
);

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for BackupSteadyStateListener | undefined
const FfiConverterOptionalTypeBackupSteadyStateListener =
  new FfiConverterOptional(FfiConverterTypeBackupSteadyStateListener);

// FfiConverter for ClientDelegate | undefined
const FfiConverterOptionalTypeClientDelegate = new FfiConverterOptional(
  FfiConverterTypeClientDelegate
);

// FfiConverter for NotificationSettingsDelegate | undefined
const FfiConverterOptionalTypeNotificationSettingsDelegate =
  new FfiConverterOptional(FfiConverterTypeNotificationSettingsDelegate);

// FfiConverter for ProgressWatcher | undefined
const FfiConverterOptionalTypeProgressWatcher = new FfiConverterOptional(
  FfiConverterTypeProgressWatcher
);

// FfiConverter for SessionVerificationControllerDelegate | undefined
const FfiConverterOptionalTypeSessionVerificationControllerDelegate =
  new FfiConverterOptional(
    FfiConverterTypeSessionVerificationControllerDelegate
  );

// FfiConverter for UniffiDuration | undefined
const FfiConverterOptionalDuration = new FfiConverterOptional(
  FfiConverterDuration
);

// FfiConverter for EventItemOrigin | undefined
const FfiConverterOptionalTypeEventItemOrigin = new FfiConverterOptional(
  FfiConverterTypeEventItemOrigin
);

// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(
  FfiConverterFloat64
);

// FfiConverter for /*i32*/number | undefined
const FfiConverterOptionalInt32 = new FfiConverterOptional(FfiConverterInt32);

// FfiConverter for AudioInfo | undefined
const FfiConverterOptionalTypeAudioInfo = new FfiConverterOptional(
  FfiConverterTypeAudioInfo
);

// FfiConverter for ComposerDraft | undefined
const FfiConverterOptionalTypeComposerDraft = new FfiConverterOptional(
  FfiConverterTypeComposerDraft
);

// FfiConverter for ElementCallWellKnown | undefined
const FfiConverterOptionalTypeElementCallWellKnown = new FfiConverterOptional(
  FfiConverterTypeElementCallWellKnown
);

// FfiConverter for EventTimelineItem | undefined
const FfiConverterOptionalTypeEventTimelineItem = new FfiConverterOptional(
  FfiConverterTypeEventTimelineItem
);

// FfiConverter for FileInfo | undefined
const FfiConverterOptionalTypeFileInfo = new FfiConverterOptional(
  FfiConverterTypeFileInfo
);

// FfiConverter for FormattedBody | undefined
const FfiConverterOptionalTypeFormattedBody = new FfiConverterOptional(
  FfiConverterTypeFormattedBody
);

// FfiConverter for ImageInfo | undefined
const FfiConverterOptionalTypeImageInfo = new FfiConverterOptional(
  FfiConverterTypeImageInfo
);

// FfiConverter for InsertData | undefined
const FfiConverterOptionalTypeInsertData = new FfiConverterOptional(
  FfiConverterTypeInsertData
);

// FfiConverter for MatrixEntity | undefined
const FfiConverterOptionalTypeMatrixEntity = new FfiConverterOptional(
  FfiConverterTypeMatrixEntity
);

// FfiConverter for MediaPreviewConfig | undefined
const FfiConverterOptionalTypeMediaPreviewConfig = new FfiConverterOptional(
  FfiConverterTypeMediaPreviewConfig
);

// FfiConverter for Mentions | undefined
const FfiConverterOptionalTypeMentions = new FfiConverterOptional(
  FfiConverterTypeMentions
);

// FfiConverter for NotificationItem | undefined
const FfiConverterOptionalTypeNotificationItem = new FfiConverterOptional(
  FfiConverterTypeNotificationItem
);

// FfiConverter for NotificationPowerLevels | undefined
const FfiConverterOptionalTypeNotificationPowerLevels =
  new FfiConverterOptional(FfiConverterTypeNotificationPowerLevels);

// FfiConverter for PassPhrase | undefined
const FfiConverterOptionalTypePassPhrase = new FfiConverterOptional(
  FfiConverterTypePassPhrase
);

// FfiConverter for PowerLevels | undefined
const FfiConverterOptionalTypePowerLevels = new FfiConverterOptional(
  FfiConverterTypePowerLevels
);

// FfiConverter for PredecessorRoom | undefined
const FfiConverterOptionalTypePredecessorRoom = new FfiConverterOptional(
  FfiConverterTypePredecessorRoom
);

// FfiConverter for ReplyParameters | undefined
const FfiConverterOptionalTypeReplyParameters = new FfiConverterOptional(
  FfiConverterTypeReplyParameters
);

// FfiConverter for ResolvedRoomAlias | undefined
const FfiConverterOptionalTypeResolvedRoomAlias = new FfiConverterOptional(
  FfiConverterTypeResolvedRoomAlias
);

// FfiConverter for RoomMember | undefined
const FfiConverterOptionalTypeRoomMember = new FfiConverterOptional(
  FfiConverterTypeRoomMember
);

// FfiConverter for RoomMemberWithSenderInfo | undefined
const FfiConverterOptionalTypeRoomMemberWithSenderInfo =
  new FfiConverterOptional(FfiConverterTypeRoomMemberWithSenderInfo);

// FfiConverter for SetData | undefined
const FfiConverterOptionalTypeSetData = new FfiConverterOptional(
  FfiConverterTypeSetData
);

// FfiConverter for SuccessorRoom | undefined
const FfiConverterOptionalTypeSuccessorRoom = new FfiConverterOptional(
  FfiConverterTypeSuccessorRoom
);

// FfiConverter for ThumbnailInfo | undefined
const FfiConverterOptionalTypeThumbnailInfo = new FfiConverterOptional(
  FfiConverterTypeThumbnailInfo
);

// FfiConverter for TracingFileConfiguration | undefined
const FfiConverterOptionalTypeTracingFileConfiguration =
  new FfiConverterOptional(FfiConverterTypeTracingFileConfiguration);

// FfiConverter for UnstableAudioDetailsContent | undefined
const FfiConverterOptionalTypeUnstableAudioDetailsContent =
  new FfiConverterOptional(FfiConverterTypeUnstableAudioDetailsContent);

// FfiConverter for UnstableVoiceContent | undefined
const FfiConverterOptionalTypeUnstableVoiceContent = new FfiConverterOptional(
  FfiConverterTypeUnstableVoiceContent
);

// FfiConverter for VideoInfo | undefined
const FfiConverterOptionalTypeVideoInfo = new FfiConverterOptional(
  FfiConverterTypeVideoInfo
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u16*/number | undefined
const FfiConverterOptionalUInt16 = new FfiConverterOptional(FfiConverterUInt16);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for /*u8*/number | undefined
const FfiConverterOptionalUInt8 = new FfiConverterOptional(FfiConverterUInt8);

// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer = new FfiConverterArray(
  FfiConverterArrayBuffer
);

// FfiConverter for Array<ConditionalPushRule>
const FfiConverterArrayTypeConditionalPushRule = new FfiConverterArray(
  FfiConverterTypeConditionalPushRule
);

// FfiConverter for Array<IdentityStatusChange>
const FfiConverterArrayTypeIdentityStatusChange = new FfiConverterArray(
  FfiConverterTypeIdentityStatusChange
);

// FfiConverter for Array<KnockRequest>
const FfiConverterArrayTypeKnockRequest = new FfiConverterArray(
  FfiConverterTypeKnockRequest
);

// FfiConverter for Array<LiveLocationShare>
const FfiConverterArrayTypeLiveLocationShare = new FfiConverterArray(
  FfiConverterTypeLiveLocationShare
);

// FfiConverter for Array<NotificationItemsRequest>
const FfiConverterArrayTypeNotificationItemsRequest = new FfiConverterArray(
  FfiConverterTypeNotificationItemsRequest
);

// FfiConverter for Array<PatternedPushRule>
const FfiConverterArrayTypePatternedPushRule = new FfiConverterArray(
  FfiConverterTypePatternedPushRule
);

// FfiConverter for Array<PollAnswer>
const FfiConverterArrayTypePollAnswer = new FfiConverterArray(
  FfiConverterTypePollAnswer
);

// FfiConverter for Array<Reaction>
const FfiConverterArrayTypeReaction = new FfiConverterArray(
  FfiConverterTypeReaction
);

// FfiConverter for Array<ReactionSenderData>
const FfiConverterArrayTypeReactionSenderData = new FfiConverterArray(
  FfiConverterTypeReactionSenderData
);

// FfiConverter for Array<RoomDescription>
const FfiConverterArrayTypeRoomDescription = new FfiConverterArray(
  FfiConverterTypeRoomDescription
);

// FfiConverter for Array<RoomHero>
const FfiConverterArrayTypeRoomHero = new FfiConverterArray(
  FfiConverterTypeRoomHero
);

// FfiConverter for Array<RoomMember>
const FfiConverterArrayTypeRoomMember = new FfiConverterArray(
  FfiConverterTypeRoomMember
);

// FfiConverter for Array<SimplePushRule>
const FfiConverterArrayTypeSimplePushRule = new FfiConverterArray(
  FfiConverterTypeSimplePushRule
);

// FfiConverter for Array<UserPowerLevelUpdate>
const FfiConverterArrayTypeUserPowerLevelUpdate = new FfiConverterArray(
  FfiConverterTypeUserPowerLevelUpdate
);

// FfiConverter for Array<UserProfile>
const FfiConverterArrayTypeUserProfile = new FfiConverterArray(
  FfiConverterTypeUserProfile
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array</*u16*/number>
const FfiConverterArrayUInt16 = new FfiConverterArray(FfiConverterUInt16);

// FfiConverter for Map<TagName, TagInfo>
const FfiConverterMapTypeTagNameTypeTagInfo = new FfiConverterMap(
  FfiConverterTypeTagName,
  FfiConverterTypeTagInfo
);

// FfiConverter for Map<string, Array<string>>
const FfiConverterMapStringArrayString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterArrayString
);

// FfiConverter for Timestamp | undefined
const FfiConverterOptionalTypeTimestamp = new FfiConverterOptional(
  FfiConverterTypeTimestamp
);

// FfiConverter for AccountManagementAction | undefined
const FfiConverterOptionalTypeAccountManagementAction =
  new FfiConverterOptional(FfiConverterTypeAccountManagementAction);

// FfiConverter for AssetType | undefined
const FfiConverterOptionalTypeAssetType = new FfiConverterOptional(
  FfiConverterTypeAssetType
);

// FfiConverter for AuthData | undefined
const FfiConverterOptionalTypeAuthData = new FfiConverterOptional(
  FfiConverterTypeAuthData
);

// FfiConverter for EventSendState | undefined
const FfiConverterOptionalTypeEventSendState = new FfiConverterOptional(
  FfiConverterTypeEventSendState
);

// FfiConverter for Intent | undefined
const FfiConverterOptionalTypeIntent = new FfiConverterOptional(
  FfiConverterTypeIntent
);

// FfiConverter for InviteAvatars | undefined
const FfiConverterOptionalTypeInviteAvatars = new FfiConverterOptional(
  FfiConverterTypeInviteAvatars
);

// FfiConverter for JoinRule | undefined
const FfiConverterOptionalTypeJoinRule = new FfiConverterOptional(
  FfiConverterTypeJoinRule
);

// FfiConverter for MediaPreviews | undefined
const FfiConverterOptionalTypeMediaPreviews = new FfiConverterOptional(
  FfiConverterTypeMediaPreviews
);

// FfiConverter for Membership | undefined
const FfiConverterOptionalTypeMembership = new FfiConverterOptional(
  FfiConverterTypeMembership
);

// FfiConverter for MembershipChange | undefined
const FfiConverterOptionalTypeMembershipChange = new FfiConverterOptional(
  FfiConverterTypeMembershipChange
);

// FfiConverter for OidcPrompt | undefined
const FfiConverterOptionalTypeOidcPrompt = new FfiConverterOptional(
  FfiConverterTypeOidcPrompt
);

// FfiConverter for PublicRoomJoinRule | undefined
const FfiConverterOptionalTypePublicRoomJoinRule = new FfiConverterOptional(
  FfiConverterTypePublicRoomJoinRule
);

// FfiConverter for PushFormat | undefined
const FfiConverterOptionalTypePushFormat = new FfiConverterOptional(
  FfiConverterTypePushFormat
);

// FfiConverter for RoomHistoryVisibility | undefined
const FfiConverterOptionalTypeRoomHistoryVisibility = new FfiConverterOptional(
  FfiConverterTypeRoomHistoryVisibility
);

// FfiConverter for RoomNotificationMode | undefined
const FfiConverterOptionalTypeRoomNotificationMode = new FfiConverterOptional(
  FfiConverterTypeRoomNotificationMode
);

// FfiConverter for ShieldState | undefined
const FfiConverterOptionalTypeShieldState = new FfiConverterOptional(
  FfiConverterTypeShieldState
);

// FfiConverter for VirtualTimelineItem | undefined
const FfiConverterOptionalTypeVirtualTimelineItem = new FfiConverterOptional(
  FfiConverterTypeVirtualTimelineItem
);

// FfiConverter for Map<string, /*i64*/bigint> | undefined
const FfiConverterOptionalMapStringInt64 = new FfiConverterOptional(
  FfiConverterMapStringInt64
);

// FfiConverter for IdentityResetHandleInterface | undefined
const FfiConverterOptionalTypeIdentityResetHandle = new FfiConverterOptional(
  FfiConverterTypeIdentityResetHandle
);

// FfiConverter for InReplyToDetailsInterface | undefined
const FfiConverterOptionalTypeInReplyToDetails = new FfiConverterOptional(
  FfiConverterTypeInReplyToDetails
);

// FfiConverter for MediaSourceInterface | undefined
const FfiConverterOptionalTypeMediaSource = new FfiConverterOptional(
  FfiConverterTypeMediaSource
);

// FfiConverter for RoomInterface | undefined
const FfiConverterOptionalTypeRoom = new FfiConverterOptional(
  FfiConverterTypeRoom
);

// FfiConverter for RoomMessageEventContentWithoutRelationInterface | undefined
const FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation =
  new FfiConverterOptional(
    FfiConverterTypeRoomMessageEventContentWithoutRelation
  );

// FfiConverter for SendHandleInterface | undefined
const FfiConverterOptionalTypeSendHandle = new FfiConverterOptional(
  FfiConverterTypeSendHandle
);

// FfiConverter for TaskHandleInterface | undefined
const FfiConverterOptionalTypeTaskHandle = new FfiConverterOptional(
  FfiConverterTypeTaskHandle
);

// FfiConverter for ThreadSummaryInterface | undefined
const FfiConverterOptionalTypeThreadSummary = new FfiConverterOptional(
  FfiConverterTypeThreadSummary
);

// FfiConverter for TimelineItemInterface | undefined
const FfiConverterOptionalTypeTimelineItem = new FfiConverterOptional(
  FfiConverterTypeTimelineItem
);

// FfiConverter for UserIdentityInterface | undefined
const FfiConverterOptionalTypeUserIdentity = new FfiConverterOptional(
  FfiConverterTypeUserIdentity
);

// FfiConverter for Array<RoomHero> | undefined
const FfiConverterOptionalArrayTypeRoomHero = new FfiConverterOptional(
  FfiConverterArrayTypeRoomHero
);

// FfiConverter for Array<RoomMember> | undefined
const FfiConverterOptionalArrayTypeRoomMember = new FfiConverterOptional(
  FfiConverterArrayTypeRoomMember
);

// FfiConverter for Array<string> | undefined
const FfiConverterOptionalArrayString = new FfiConverterOptional(
  FfiConverterArrayString
);

// FfiConverter for Array<Action>
const FfiConverterArrayTypeAction = new FfiConverterArray(
  FfiConverterTypeAction
);

// FfiConverter for Array<AllowRule>
const FfiConverterArrayTypeAllowRule = new FfiConverterArray(
  FfiConverterTypeAllowRule
);

// FfiConverter for Array<FilterTimelineEventType>
const FfiConverterArrayTypeFilterTimelineEventType = new FfiConverterArray(
  FfiConverterTypeFilterTimelineEventType
);

// FfiConverter for Array<GalleryItemInfo>
const FfiConverterArrayTypeGalleryItemInfo = new FfiConverterArray(
  FfiConverterTypeGalleryItemInfo
);

// FfiConverter for Array<GalleryItemType>
const FfiConverterArrayTypeGalleryItemType = new FfiConverterArray(
  FfiConverterTypeGalleryItemType
);

// FfiConverter for Array<Membership>
const FfiConverterArrayTypeMembership = new FfiConverterArray(
  FfiConverterTypeMembership
);

// FfiConverter for Array<OidcPrompt>
const FfiConverterArrayTypeOidcPrompt = new FfiConverterArray(
  FfiConverterTypeOidcPrompt
);

// FfiConverter for Array<PushCondition>
const FfiConverterArrayTypePushCondition = new FfiConverterArray(
  FfiConverterTypePushCondition
);

// FfiConverter for Array<RoomDirectorySearchEntryUpdate>
const FfiConverterArrayTypeRoomDirectorySearchEntryUpdate =
  new FfiConverterArray(FfiConverterTypeRoomDirectorySearchEntryUpdate);

// FfiConverter for Array<RoomListEntriesDynamicFilterKind>
const FfiConverterArrayTypeRoomListEntriesDynamicFilterKind =
  new FfiConverterArray(FfiConverterTypeRoomListEntriesDynamicFilterKind);

// FfiConverter for Array<RoomListEntriesUpdate>
const FfiConverterArrayTypeRoomListEntriesUpdate = new FfiConverterArray(
  FfiConverterTypeRoomListEntriesUpdate
);

// FfiConverter for Array<RoomMessageEventMessageType>
const FfiConverterArrayTypeRoomMessageEventMessageType = new FfiConverterArray(
  FfiConverterTypeRoomMessageEventMessageType
);

// FfiConverter for Array<SlidingSyncVersion>
const FfiConverterArrayTypeSlidingSyncVersion = new FfiConverterArray(
  FfiConverterTypeSlidingSyncVersion
);

// FfiConverter for Array<TraceLogPacks>
const FfiConverterArrayTypeTraceLogPacks = new FfiConverterArray(
  FfiConverterTypeTraceLogPacks
);

// FfiConverter for Array<WidgetEventFilter>
const FfiConverterArrayTypeWidgetEventFilter = new FfiConverterArray(
  FfiConverterTypeWidgetEventFilter
);

// FfiConverter for Array<RoomInterface>
const FfiConverterArrayTypeRoom = new FfiConverterArray(FfiConverterTypeRoom);

// FfiConverter for Array<SessionVerificationEmojiInterface>
const FfiConverterArrayTypeSessionVerificationEmoji = new FfiConverterArray(
  FfiConverterTypeSessionVerificationEmoji
);

// FfiConverter for Array<TimelineDiffInterface>
const FfiConverterArrayTypeTimelineDiff = new FfiConverterArray(
  FfiConverterTypeTimelineDiff
);

// FfiConverter for Array<TimelineItemInterface>
const FfiConverterArrayTypeTimelineItem = new FfiConverterArray(
  FfiConverterTypeTimelineItem
);

// FfiConverter for Array<TimelineItemInterface> | undefined
const FfiConverterOptionalArrayTypeTimelineItem = new FfiConverterOptional(
  FfiConverterArrayTypeTimelineItem
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_matrix_sdk_ffi_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message() !==
    1366
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit() !==
    33992
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_enable_sentry_logging() !==
    53125
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_enable_sentry_logging'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id() !==
    15808
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url() !==
    48529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions() !==
    30181
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_init_platform() !==
    11113
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_init_platform'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid() !==
    54845
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_log_event() !==
    62286
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_log_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known() !==
    21379
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver() !==
    34206
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink() !==
    13776
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink() !==
    46473
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html() !==
    37203
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote() !==
    8938
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown() !==
    58385
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote() !==
    20152
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new() !==
    57839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget() !==
    4988
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from() !==
    49710
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name() !==
    65010
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha() !==
    4038
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role() !==
    61777
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level() !==
    48532
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth() !==
    53440
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_account_data() !==
    50433
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_account_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_account_url() !==
    42373
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_account_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions() !==
    35296
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url() !==
    27867
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo() !==
    18126
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url() !==
    50226
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account() !==
    39890
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches() !==
    65177
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_create_room() !==
    52700
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_create_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt() !==
    19710
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account() !==
    20658
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher() !==
    45990
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_device_id() !==
    44340
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_device_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_display_name() !==
    56259
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues() !==
    30834
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_encryption() !==
    9657
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_encryption'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_fetch_media_preview_config() !==
    15595
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_fetch_media_preview_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room() !==
    5137
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_invite_avatars_display_policy() !==
    46953
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_invite_avatars_display_policy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_max_media_upload_size() !==
    12661
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_max_media_upload_size'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content() !==
    40308
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file() !==
    52604
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_preview_display_policy() !==
    19264
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_media_preview_display_policy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail() !==
    52601
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings() !==
    49769
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_profile() !==
    60062
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_profile'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms() !==
    22399
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_room() !==
    30376
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias() !==
    7674
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id() !==
    36348
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller() !==
    55934
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_url() !==
    50489
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_get_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_homeserver() !==
    26427
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_homeserver'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details() !==
    63487
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user() !==
    14588
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users() !==
    49620
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_is_report_room_api_supported() !==
    17934
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_is_report_room_api_supported'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available() !==
    23322
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id() !==
    64032
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias() !==
    18521
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_knock() !==
    48652
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_knock'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_login() !==
    33276
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_login'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email() !==
    11789
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback() !==
    32591
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_logout() !==
    42911
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_logout'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_notification_client() !==
    37308
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_notification_client'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_observe_account_data_event() !==
    13906
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_observe_account_data_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_observe_room_account_data_event() !==
    15699
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_observe_room_account_data_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar() !==
    29033
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities() !==
    39651
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias() !==
    3551
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_restore_session() !==
    56125
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_restore_session'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with() !==
    20927
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists() !==
    20359
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search() !==
    39855
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_rooms() !==
    29558
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_rooms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_search_users() !==
    42927
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_search_users'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_server() !==
    63276
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_server'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_session() !==
    8085
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_session'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data() !==
    18256
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate() !==
    46437
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name() !==
    15292
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_invite_avatars_display_policy() !==
    48457
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_invite_avatars_display_policy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_media_preview_display_policy() !==
    24080
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_media_preview_display_policy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy() !==
    2414
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher() !==
    41975
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_utd_delegate() !==
    37720
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_set_utd_delegate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version() !==
    4957
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login() !==
    34571
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users() !==
    23285
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_media_preview_config() !==
    47047
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_media_preview_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_room_info() !==
    41103
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_room_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status() !==
    57403
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_sync_service() !==
    52812
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_sync_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room() !==
    56986
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user() !==
    8489
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar() !==
    64486
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_upload_media() !==
    51195
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_upload_media'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc() !==
    28386
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_user_id() !==
    40531
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_user_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name() !==
    57725
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates() !==
    14763
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups() !==
    44502
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing() !==
    37167
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy() !==
    11959
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build() !==
    56018
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code() !==
    42452
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name() !==
    46627
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh() !==
    43839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates() !==
    47525
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification() !==
    2334
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock() !==
    42214
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_share_history_on_invite() !==
    3856
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_share_history_on_invite'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url() !==
    28347
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy() !==
    5659
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config() !==
    58783
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement() !==
    2776
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy() !==
    41183
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name() !==
    29096
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url() !==
    30022
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_cache_size() !==
    32604
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_cache_size'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_journal_size_limit() !==
    21378
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_journal_size_limit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_passphrase() !==
    55403
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_passphrase'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths() !==
    54230
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_pool_max_size() !==
    6011
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_pool_max_size'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate() !==
    8576
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder() !==
    39381
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained() !==
    6898
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent() !==
    13719
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username() !==
    45302
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server() !==
    45490
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state() !==
    51049
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener() !==
    14246
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key() !==
    58425
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery() !==
    18699
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key() !==
    11864
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups() !==
    55446
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery() !==
    64351
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device() !==
    27955
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recover() !==
    33712
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_recover'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset() !==
    12902
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state() !==
    54051
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener() !==
    36612
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity() !==
    13780
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key() !==
    20380
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity() !==
    20644
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state() !==
    29114
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener() !==
    59806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state() !==
    37503
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks() !==
    41585
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version() !==
    36573
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts() !==
    63396
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login() !==
    46090
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login() !==
    33501
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url() !==
    61326
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type() !==
    43501
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel() !==
    57622
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset() !==
    11997
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event() !==
    36106
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id() !==
    5876
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept() !==
    25656
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline() !==
    65054
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban() !==
    26242
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen() !==
    36036
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis() !==
    5211
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info() !==
    55450
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle() !==
    46057
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields() !==
    12518
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path() !==
    16357
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist() !==
    12883
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json() !==
    23306
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediasource_url() !==
    62692
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_mediasource_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification() !==
    2524
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notifications() !==
    30600
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notifications'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_room() !==
    26581
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device() !==
    37323
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device() !==
    21251
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules() !==
    60025
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode() !==
    36211
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings() !==
    55295
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules() !==
    19849
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode() !==
    18228
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled() !==
    12210
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled() !==
    533
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled() !==
    13304
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled() !==
    49857
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode() !==
    35399
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled() !==
    16823
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule() !==
    465
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode() !==
    9426
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate() !==
    57636
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled() !==
    11988
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled() !==
    31650
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode() !==
    4135
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled() !==
    56594
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room() !==
    47580
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_server_name() !==
    30173
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_server_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count() !==
    61905
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants() !==
    41533
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases() !==
    28555
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes() !==
    44206
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url() !==
    34637
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_ban_user() !==
    35046
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_ban_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban() !==
    64711
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite() !==
    62459
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick() !==
    12773
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin() !==
    8341
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other() !==
    13274
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own() !==
    57442
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message() !==
    36743
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state() !==
    19062
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification() !==
    18832
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias() !==
    19786
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft() !==
    39667
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage() !==
    13838
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key() !==
    18081
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_display_name() !==
    64194
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_edit() !==
    61956
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_edit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption() !==
    14669
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue() !==
    23914
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state() !==
    9101
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_forget() !==
    37840
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_forget'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels() !==
    54094
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility() !==
    412
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call() !==
    33588
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_heroes() !==
    22313
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_heroes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_id() !==
    61990
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend() !==
    39984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user() !==
    62239
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id() !==
    41133
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count() !==
    1023
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_inviter() !==
    18103
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_inviter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_direct() !==
    10462
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_direct'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted() !==
    63995
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_public() !==
    7336
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_public'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled() !==
    36591
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_space() !==
    16919
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_is_space'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_join() !==
    9240
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_join'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count() !==
    55835
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_kick_user() !==
    28600
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_kick_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state() !==
    16843
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_latest_event() !==
    39083
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_latest_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_leave() !==
    63688
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_leave'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft() !==
    38115
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read() !==
    57806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink() !==
    36705
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink() !==
    47781
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member() !==
    48980
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_member'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url() !==
    29492
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name() !==
    33206
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member_with_sender_info() !==
    64964
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_member_with_sender_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_members() !==
    42691
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_members'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync() !==
    3255
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_membership() !==
    45951
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_membership'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id() !==
    39510
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_predecessor_room() !==
    22093
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_predecessor_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_preview_room() !==
    60431
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_preview_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory() !==
    13924
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_raw_name() !==
    15453
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_raw_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_redact() !==
    45810
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_redact'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar() !==
    7230
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory() !==
    16926
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_report_content() !==
    16529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_report_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_report_room() !==
    8059
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_report_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels() !==
    63622
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string() !==
    37832
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_room_info() !==
    41146
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_room_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft() !==
    62232
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification() !==
    43366
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed() !==
    52926
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location() !==
    34248
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_send_raw() !==
    20486
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_send_raw'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite() !==
    64403
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority() !==
    48070
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_name() !==
    52127
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_topic() !==
    5576
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_topic'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag() !==
    2381
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share() !==
    11488
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share() !==
    19983
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes() !==
    8526
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests() !==
    30649
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares() !==
    57037
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates() !==
    48209
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications() !==
    38524
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_successor_room() !==
    27360
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_successor_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user() !==
    47787
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_timeline() !==
    51477
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_timeline'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration() !==
    35159
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_topic() !==
    59745
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_topic'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice() !==
    28642
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_unban_user() !==
    1803
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_unban_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias() !==
    25065
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility() !==
    26248
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules() !==
    49303
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users() !==
    52057
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility() !==
    64724
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar() !==
    19069
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend() !==
    33485
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page() !==
    34221
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages() !==
    2923
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page() !==
    29305
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results() !==
    30207
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search() !==
    24438
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters() !==
    36097
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state() !==
    21585
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_room() !==
    62491
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlist_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page() !==
    47748
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page() !==
    61352
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter() !==
    61202
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller() !==
    36258
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream() !==
    56632
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms() !==
    49704
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room() !==
    60695
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state() !==
    64650
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms() !==
    59765
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator() !==
    16821
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len() !==
    39835
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk() !==
    23186
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions() !==
    8867
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget() !==
    18179
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_info() !==
    9145
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roompreview_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter() !==
    1297
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave() !==
    21886
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details() !==
    46321
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel() !==
    62384
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join() !==
    1903
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_cancel() !==
    7014
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_cancel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_join() !==
    57901
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_join'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort() !==
    11570
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend() !==
    28691
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request() !==
    53466
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request() !==
    37982
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification() !==
    27140
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification() !==
    32994
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification() !==
    64345
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification() !==
    4777
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification() !==
    26149
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate() !==
    42324
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification() !==
    16328
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description() !==
    21346
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol() !==
    46075
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_span_enter() !==
    8900
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_span_enter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_span_exit() !==
    47924
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_span_exit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_span_is_none() !==
    33327
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_span_is_none'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish() !==
    64706
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url() !==
    10889
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service() !==
    26426
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_start() !==
    16010
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservice_start'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_state() !==
    61806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservice_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop() !==
    42435
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish() !==
    22814
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock() !==
    56326
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode() !==
    16958
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel() !==
    9124
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished() !==
    29008
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_threadsummary_latest_event() !==
    52917
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_threadsummary_latest_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener() !==
    18746
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content() !==
    21811
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll() !==
    37925
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_edit() !==
    42189
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_edit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll() !==
    32659
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event() !==
    54068
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members() !==
    37994
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id() !==
    33999
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details() !==
    54225
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read() !==
    16621
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards() !==
    36829
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards() !==
    30268
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event() !==
    41687
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event() !==
    48707
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption() !==
    21112
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send() !==
    9553
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio() !==
    22559
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file() !==
    4588
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_gallery() !==
    61071
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_gallery'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image() !==
    25436
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location() !==
    47400
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response() !==
    7453
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt() !==
    37532
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply() !==
    31468
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video() !==
    1445
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message() !==
    50042
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status() !==
    46161
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction() !==
    29303
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event() !==
    52414
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append() !==
    8453
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change() !==
    4562
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert() !==
    26630
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back() !==
    53464
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front() !==
    42084
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove() !==
    74
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset() !==
    34118
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set() !==
    13334
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate() !==
    34040
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id() !==
    11088
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type() !==
    12922
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id() !==
    18142
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp() !==
    50929
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event() !==
    6106
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual() !==
    50960
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug() !==
    38094
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id() !==
    39945
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications() !==
    33024
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count() !==
    35997
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count() !==
    35655
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation() !==
    2948
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified() !==
    61954
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key() !==
    4041
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin() !==
    62925
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified() !==
    41686
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification() !==
    3578
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run() !==
    7519
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv() !==
    2662
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send() !==
    18689
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new() !==
    27991
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json() !==
    10564
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url() !==
    11983
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes() !==
    32675
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_span_current() !==
    53698
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_span_current'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_span_new() !==
    14105
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_span_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude() !==
    53805
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include() !==
    25498
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_accountdatalistener_on_change() !==
    16189
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_accountdatalistener_on_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update() !==
    12849
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update() !==
    41052
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error() !==
    26350
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain() !==
    43954
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain() !==
    53223
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update() !==
    13538
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call() !==
    57311
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call() !==
    47519
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call() !==
    10077
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call() !==
    34519
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediapreviewconfiglistener_on_change() !==
    14770
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_mediapreviewconfiglistener_on_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change() !==
    51708
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update() !==
    65318
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress() !==
    41133
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update() !==
    9758
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update() !==
    64575
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomaccountdatalistener_on_change() !==
    58105
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomaccountdatalistener_on_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update() !==
    41968
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call() !==
    44934
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update() !==
    12576
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update() !==
    23169
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update() !==
    24823
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update() !==
    36937
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error() !==
    38224
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request() !==
    3417
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request() !==
    3733
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification() !==
    56833
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data() !==
    30840
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail() !==
    32164
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel() !==
    3367
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish() !==
    37905
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update() !==
    62231
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update() !==
    30147
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call() !==
    64299
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd() !==
    61791
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update() !==
    38998
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities() !==
    12846
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities'
    );
  }

  uniffiCallbackInterfaceAccountDataListener.register();
  uniffiCallbackInterfaceBackupStateListener.register();
  uniffiCallbackInterfaceBackupSteadyStateListener.register();
  uniffiCallbackInterfaceClientDelegate.register();
  uniffiCallbackInterfaceClientSessionDelegate.register();
  uniffiCallbackInterfaceEnableRecoveryProgressListener.register();
  uniffiCallbackInterfaceIdentityStatusChangeListener.register();
  uniffiCallbackInterfaceIgnoredUsersListener.register();
  uniffiCallbackInterfaceKnockRequestsListener.register();
  uniffiCallbackInterfaceLiveLocationShareListener.register();
  uniffiCallbackInterfaceMediaPreviewConfigListener.register();
  uniffiCallbackInterfaceNotificationSettingsDelegate.register();
  uniffiCallbackInterfacePaginationStatusListener.register();
  uniffiCallbackInterfaceProgressWatcher.register();
  uniffiCallbackInterfaceQrLoginProgressListener.register();
  uniffiCallbackInterfaceRecoveryStateListener.register();
  uniffiCallbackInterfaceRoomAccountDataListener.register();
  uniffiCallbackInterfaceRoomDirectorySearchEntriesListener.register();
  uniffiCallbackInterfaceRoomInfoListener.register();
  uniffiCallbackInterfaceRoomListEntriesListener.register();
  uniffiCallbackInterfaceRoomListLoadingStateListener.register();
  uniffiCallbackInterfaceRoomListServiceStateListener.register();
  uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.register();
  uniffiCallbackInterfaceSendQueueRoomErrorListener.register();
  uniffiCallbackInterfaceSessionVerificationControllerDelegate.register();
  uniffiCallbackInterfaceSyncServiceStateObserver.register();
  uniffiCallbackInterfaceTimelineListener.register();
  uniffiCallbackInterfaceTypingNotificationsListener.register();
  uniffiCallbackInterfaceUnableToDecryptDelegate.register();
  uniffiCallbackInterfaceVerificationStateListener.register();
  uniffiCallbackInterfaceWidgetCapabilitiesProvider.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAccountDataEvent,
    FfiConverterTypeAccountDataEventType,
    FfiConverterTypeAccountManagementAction,
    FfiConverterTypeAction,
    FfiConverterTypeAllowRule,
    FfiConverterTypeAssetType,
    FfiConverterTypeAudioInfo,
    FfiConverterTypeAudioMessageContent,
    FfiConverterTypeAuthData,
    FfiConverterTypeAuthDataPasswordDetails,
    FfiConverterTypeBackupState,
    FfiConverterTypeBackupUploadState,
    FfiConverterTypeClient,
    FfiConverterTypeClientBuilder,
    FfiConverterTypeClientProperties,
    FfiConverterTypeComparisonOperator,
    FfiConverterTypeComposerDraft,
    FfiConverterTypeComposerDraftType,
    FfiConverterTypeConditionalPushRule,
    FfiConverterTypeCreateRoomParameters,
    FfiConverterTypeCrossSigningResetAuthType,
    FfiConverterTypeDateDividerMode,
    FfiConverterTypeEditedContent,
    FfiConverterTypeElementCallWellKnown,
    FfiConverterTypeElementWellKnown,
    FfiConverterTypeEmbeddedEventDetails,
    FfiConverterTypeEmoteMessageContent,
    FfiConverterTypeEnableRecoveryProgress,
    FfiConverterTypeEncryptedMessage,
    FfiConverterTypeEncryption,
    FfiConverterTypeEncryptionSystem,
    FfiConverterTypeErrorKind,
    FfiConverterTypeEventOrTransactionId,
    FfiConverterTypeEventSendState,
    FfiConverterTypeEventTimelineItem,
    FfiConverterTypeEventTimelineItemDebugInfo,
    FfiConverterTypeFileInfo,
    FfiConverterTypeFileMessageContent,
    FfiConverterTypeFilterTimelineEventType,
    FfiConverterTypeFormattedBody,
    FfiConverterTypeGalleryItemInfo,
    FfiConverterTypeGalleryItemType,
    FfiConverterTypeGalleryMessageContent,
    FfiConverterTypeGalleryUploadParameters,
    FfiConverterTypeHomeserverLoginDetails,
    FfiConverterTypeHttpPusherData,
    FfiConverterTypeIdentityResetHandle,
    FfiConverterTypeIdentityStatusChange,
    FfiConverterTypeIgnoredUser,
    FfiConverterTypeImageInfo,
    FfiConverterTypeImageMessageContent,
    FfiConverterTypeInReplyToDetails,
    FfiConverterTypeInsertData,
    FfiConverterTypeIntent,
    FfiConverterTypeInviteAvatars,
    FfiConverterTypeJoinRule,
    FfiConverterTypeJsonValue,
    FfiConverterTypeKeyDerivationAlgorithm,
    FfiConverterTypeKnockRequest,
    FfiConverterTypeKnockRequestActions,
    FfiConverterTypeLastLocation,
    FfiConverterTypeLazyTimelineItemProvider,
    FfiConverterTypeLiveLocationShare,
    FfiConverterTypeLocationContent,
    FfiConverterTypeLogLevel,
    FfiConverterTypeMatrixEntity,
    FfiConverterTypeMatrixId,
    FfiConverterTypeMediaFileHandle,
    FfiConverterTypeMediaPreviewConfig,
    FfiConverterTypeMediaPreviews,
    FfiConverterTypeMediaSource,
    FfiConverterTypeMembership,
    FfiConverterTypeMembershipChange,
    FfiConverterTypeMembershipState,
    FfiConverterTypeMentions,
    FfiConverterTypeMessageContent,
    FfiConverterTypeMessageFormat,
    FfiConverterTypeMessageLikeEventContent,
    FfiConverterTypeMessageLikeEventType,
    FfiConverterTypeMessageType,
    FfiConverterTypeMsgLikeContent,
    FfiConverterTypeMsgLikeKind,
    FfiConverterTypeNoticeMessageContent,
    FfiConverterTypeNotificationClient,
    FfiConverterTypeNotificationEvent,
    FfiConverterTypeNotificationItem,
    FfiConverterTypeNotificationItemsRequest,
    FfiConverterTypeNotificationPowerLevels,
    FfiConverterTypeNotificationProcessSetup,
    FfiConverterTypeNotificationRoomInfo,
    FfiConverterTypeNotificationSenderInfo,
    FfiConverterTypeNotificationSettings,
    FfiConverterTypeNotifyType,
    FfiConverterTypeOidcConfiguration,
    FfiConverterTypeOidcCrossSigningResetInfo,
    FfiConverterTypeOidcPrompt,
    FfiConverterTypeOtherState,
    FfiConverterTypePassPhrase,
    FfiConverterTypePatternedPushRule,
    FfiConverterTypePollAnswer,
    FfiConverterTypePollData,
    FfiConverterTypePollKind,
    FfiConverterTypePowerLevels,
    FfiConverterTypePredecessorRoom,
    FfiConverterTypeProfileDetails,
    FfiConverterTypePublicRoomJoinRule,
    FfiConverterTypePushCondition,
    FfiConverterTypePushFormat,
    FfiConverterTypePusherIdentifiers,
    FfiConverterTypePusherKind,
    FfiConverterTypeQrCodeData,
    FfiConverterTypeQrLoginProgress,
    FfiConverterTypeQueueWedgeError,
    FfiConverterTypeReaction,
    FfiConverterTypeReactionSenderData,
    FfiConverterTypeReceipt,
    FfiConverterTypeReceiptType,
    FfiConverterTypeRecoveryState,
    FfiConverterTypeReplyParameters,
    FfiConverterTypeRequestConfig,
    FfiConverterTypeResolvedRoomAlias,
    FfiConverterTypeRoom,
    FfiConverterTypeRoomAccountDataEvent,
    FfiConverterTypeRoomAccountDataEventType,
    FfiConverterTypeRoomDescription,
    FfiConverterTypeRoomDirectorySearch,
    FfiConverterTypeRoomDirectorySearchEntriesResult,
    FfiConverterTypeRoomDirectorySearchEntryUpdate,
    FfiConverterTypeRoomHero,
    FfiConverterTypeRoomHistoryVisibility,
    FfiConverterTypeRoomInfo,
    FfiConverterTypeRoomList,
    FfiConverterTypeRoomListDynamicEntriesController,
    FfiConverterTypeRoomListEntriesDynamicFilterKind,
    FfiConverterTypeRoomListEntriesUpdate,
    FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult,
    FfiConverterTypeRoomListFilterCategory,
    FfiConverterTypeRoomListLoadingState,
    FfiConverterTypeRoomListLoadingStateResult,
    FfiConverterTypeRoomListService,
    FfiConverterTypeRoomListServiceState,
    FfiConverterTypeRoomListServiceSyncIndicator,
    FfiConverterTypeRoomLoadSettings,
    FfiConverterTypeRoomMember,
    FfiConverterTypeRoomMemberWithSenderInfo,
    FfiConverterTypeRoomMembersIterator,
    FfiConverterTypeRoomMessageEventContentWithoutRelation,
    FfiConverterTypeRoomMessageEventMessageType,
    FfiConverterTypeRoomNotificationMode,
    FfiConverterTypeRoomNotificationSettings,
    FfiConverterTypeRoomPowerLevels,
    FfiConverterTypeRoomPreset,
    FfiConverterTypeRoomPreview,
    FfiConverterTypeRoomPreviewInfo,
    FfiConverterTypeRoomType,
    FfiConverterTypeRoomVisibility,
    FfiConverterTypeRtcApplicationType,
    FfiConverterTypeRuleKind,
    FfiConverterTypeRuleset,
    FfiConverterTypeSearchUsersResults,
    FfiConverterTypeSecretStorageEncryptionAlgorithm,
    FfiConverterTypeSecretStorageV1AesHmacSha2Properties,
    FfiConverterTypeSendAttachmentJoinHandle,
    FfiConverterTypeSendGalleryJoinHandle,
    FfiConverterTypeSendHandle,
    FfiConverterTypeSession,
    FfiConverterTypeSessionVerificationController,
    FfiConverterTypeSessionVerificationData,
    FfiConverterTypeSessionVerificationEmoji,
    FfiConverterTypeSessionVerificationRequestDetails,
    FfiConverterTypeSetData,
    FfiConverterTypeShieldState,
    FfiConverterTypeSimplePushRule,
    FfiConverterTypeSlidingSyncVersion,
    FfiConverterTypeSlidingSyncVersionBuilder,
    FfiConverterTypeSpan,
    FfiConverterTypeSsoHandler,
    FfiConverterTypeStateEventContent,
    FfiConverterTypeStateEventType,
    FfiConverterTypeSuccessorRoom,
    FfiConverterTypeSyncService,
    FfiConverterTypeSyncServiceBuilder,
    FfiConverterTypeSyncServiceState,
    FfiConverterTypeTagInfo,
    FfiConverterTypeTagName,
    FfiConverterTypeTaskHandle,
    FfiConverterTypeTextMessageContent,
    FfiConverterTypeThreadSummary,
    FfiConverterTypeThumbnailInfo,
    FfiConverterTypeTimeline,
    FfiConverterTypeTimelineChange,
    FfiConverterTypeTimelineConfiguration,
    FfiConverterTypeTimelineDiff,
    FfiConverterTypeTimelineEvent,
    FfiConverterTypeTimelineEventType,
    FfiConverterTypeTimelineEventTypeFilter,
    FfiConverterTypeTimelineFilter,
    FfiConverterTypeTimelineFocus,
    FfiConverterTypeTimelineItem,
    FfiConverterTypeTimelineItemContent,
    FfiConverterTypeTimelineUniqueId,
    FfiConverterTypeTimestamp,
    FfiConverterTypeTraceLogPacks,
    FfiConverterTypeTracingConfiguration,
    FfiConverterTypeTracingFileConfiguration,
    FfiConverterTypeTransmissionProgress,
    FfiConverterTypeTweak,
    FfiConverterTypeUnableToDecryptInfo,
    FfiConverterTypeUnreadNotificationsCount,
    FfiConverterTypeUnstableAudioDetailsContent,
    FfiConverterTypeUnstableVoiceContent,
    FfiConverterTypeUploadParameters,
    FfiConverterTypeUploadSource,
    FfiConverterTypeUserIdentity,
    FfiConverterTypeUserPowerLevelUpdate,
    FfiConverterTypeUserProfile,
    FfiConverterTypeUserTagName,
    FfiConverterTypeVerificationState,
    FfiConverterTypeVideoInfo,
    FfiConverterTypeVideoMessageContent,
    FfiConverterTypeVirtualElementCallWidgetOptions,
    FfiConverterTypeVirtualTimelineItem,
    FfiConverterTypeWidgetCapabilities,
    FfiConverterTypeWidgetDriver,
    FfiConverterTypeWidgetDriverAndHandle,
    FfiConverterTypeWidgetDriverHandle,
    FfiConverterTypeWidgetEventFilter,
    FfiConverterTypeWidgetSettings,
  },
});
