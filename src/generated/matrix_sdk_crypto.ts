// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './matrix_sdk_crypto-ffi';
import {
  type UniffiByteArray,
  AbstractFfiConverterByteArray,
  FfiConverterInt32,
  RustBuffer,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Settings for decrypting messages
 */
export type DecryptionSettings = {
  /**
   * The trust level in the sender's device that is required to decrypt the
   * event. If the sender's device is not sufficiently trusted,
   * [`MegolmError::SenderIdentityNotTrusted`] will be returned.
   */
  senderDeviceTrustRequirement: TrustRequirement;
};

/**
 * Generated factory for {@link DecryptionSettings} record objects.
 */
export const DecryptionSettings = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<DecryptionSettings, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link DecryptionSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_crypto} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link DecryptionSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_crypto} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link matrix_sdk_crypto} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<DecryptionSettings>,
  });
})();

const FfiConverterTypeDecryptionSettings = (() => {
  type TypeName = DecryptionSettings;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        senderDeviceTrustRequirement:
          FfiConverterTypeTrustRequirement.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeTrustRequirement.write(
        value.senderDeviceTrustRequirement,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeTrustRequirement.allocationSize(
        value.senderDeviceTrustRequirement
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

/**
 * Strategy to collect the devices that should receive room keys for the
 * current discussion.
 */
export enum CollectStrategy {
  /**
   * Share with all (unblacklisted) devices.
   */
  AllDevices,
  /**
   * Share with all devices, except errors for *verified* users cause sharing
   * to fail with an error.
   *
   * In this strategy, if a verified user has an unsigned device,
   * key sharing will fail with a
   * [`SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`].
   * If a verified user has replaced their identity, key
   * sharing will fail with a
   * [`SessionRecipientCollectionError::VerifiedUserChangedIdentity`].
   *
   * Otherwise, keys are shared with unsigned devices as normal.
   *
   * Once the problematic devices are blacklisted or whitelisted the
   * caller can retry to share a second time.
   */
  ErrorOnVerifiedUserProblem,
  /**
   * Share based on identity. Only distribute to devices signed by their
   * owner. If a user has no published identity he will not receive
   * any room keys.
   */
  IdentityBasedStrategy,
  /**
   * Only share keys with devices that we "trust". A device is trusted if any
   * of the following is true:
   * - It was manually marked as trusted.
   * - It was marked as verified via interactive verification.
   * - It is signed by its owner identity, and this identity has been
   * trusted via interactive verification.
   * - It is the current own device of the user.
   */
  OnlyTrustedDevices,
}

const FfiConverterTypeCollectStrategy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = CollectStrategy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return CollectStrategy.AllDevices;
        case 2:
          return CollectStrategy.ErrorOnVerifiedUserProblem;
        case 3:
          return CollectStrategy.IdentityBasedStrategy;
        case 4:
          return CollectStrategy.OnlyTrustedDevices;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case CollectStrategy.AllDevices:
          return ordinalConverter.write(1, into);
        case CollectStrategy.ErrorOnVerifiedUserProblem:
          return ordinalConverter.write(2, into);
        case CollectStrategy.IdentityBasedStrategy:
          return ordinalConverter.write(3, into);
        case CollectStrategy.OnlyTrustedDevices:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The state of an identity - verified, pinned etc.
 */
export enum IdentityState {
  /**
   * The user is verified with us
   */
  Verified,
  /**
   * Either this is the first identity we have seen for this user, or the
   * user has acknowledged a change of identity explicitly e.g. by
   * clicking OK on a notification.
   */
  Pinned,
  /**
   * The user's identity has changed since it was pinned. The user should be
   * notified about this and given the opportunity to acknowledge the
   * change, which will make the new identity pinned.
   * When the user acknowledges the change, the app should call
   * [`crate::OtherUserIdentity::pin_current_master_key`].
   */
  PinViolation,
  /**
   * The user's identity has changed, and before that it was verified. This
   * is a serious problem. The user can either verify again to make this
   * identity verified, or withdraw verification
   * [`UserIdentity::withdraw_verification`] to make it pinned.
   */
  VerificationViolation,
}

const FfiConverterTypeIdentityState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = IdentityState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return IdentityState.Verified;
        case 2:
          return IdentityState.Pinned;
        case 3:
          return IdentityState.PinViolation;
        case 4:
          return IdentityState.VerificationViolation;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case IdentityState.Verified:
          return ordinalConverter.write(1, into);
        case IdentityState.Pinned:
          return ordinalConverter.write(2, into);
        case IdentityState.PinViolation:
          return ordinalConverter.write(3, into);
        case IdentityState.VerificationViolation:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The local trust state of a device.
 */
export enum LocalTrust {
  /**
   * The device has been verified and is trusted.
   */
  Verified,
  /**
   * The device been blacklisted from communicating.
   */
  BlackListed,
  /**
   * The trust state of the device is being ignored.
   */
  Ignored,
  /**
   * The trust state is unset.
   */
  Unset,
}

const FfiConverterTypeLocalTrust = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LocalTrust;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return LocalTrust.Verified;
        case 2:
          return LocalTrust.BlackListed;
        case 3:
          return LocalTrust.Ignored;
        case 4:
          return LocalTrust.Unset;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case LocalTrust.Verified:
          return ordinalConverter.write(1, into);
        case LocalTrust.BlackListed:
          return ordinalConverter.write(2, into);
        case LocalTrust.Ignored:
          return ordinalConverter.write(3, into);
        case LocalTrust.Unset:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: LoginQrCodeDecodeError
export enum LoginQrCodeDecodeError_Tags {
  NotEnoughData = 'NotEnoughData',
  NotUtf8 = 'NotUtf8',
  UrlParse = 'UrlParse',
  InvalidMode = 'InvalidMode',
  InvalidVersion = 'InvalidVersion',
  Base64 = 'Base64',
  InvalidPrefix = 'InvalidPrefix',
}
/**
 * Error type for the decoding of the [`QrCodeData`].
 */
export const LoginQrCodeDecodeError = (() => {
  /**
   * The QR code data is no long enough, it's missing some fields.
   */
  class NotEnoughData extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoginQrCodeDecodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = LoginQrCodeDecodeError_Tags.NotEnoughData;

    constructor(message: string) {
      super('LoginQrCodeDecodeError', 'NotEnoughData', message);
    }

    static instanceOf(e: any): e is NotEnoughData {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  /**
   * One of the URLs in the QR code data is not a valid UTF-8 encoded string.
   */
  class NotUtf8 extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoginQrCodeDecodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = LoginQrCodeDecodeError_Tags.NotUtf8;

    constructor(message: string) {
      super('LoginQrCodeDecodeError', 'NotUtf8', message);
    }

    static instanceOf(e: any): e is NotUtf8 {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  /**
   * One of the URLs in the QR code data could not be parsed.
   */
  class UrlParse extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoginQrCodeDecodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = LoginQrCodeDecodeError_Tags.UrlParse;

    constructor(message: string) {
      super('LoginQrCodeDecodeError', 'UrlParse', message);
    }

    static instanceOf(e: any): e is UrlParse {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  /**
   * The QR code data contains an invalid mode, we expect the login (0x03)
   * mode or the reciprocate mode (0x04).
   */
  class InvalidMode extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoginQrCodeDecodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = LoginQrCodeDecodeError_Tags.InvalidMode;

    constructor(message: string) {
      super('LoginQrCodeDecodeError', 'InvalidMode', message);
    }

    static instanceOf(e: any): e is InvalidMode {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  /**
   * The QR code data contains an unsupported version.
   */
  class InvalidVersion extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoginQrCodeDecodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = LoginQrCodeDecodeError_Tags.InvalidVersion;

    constructor(message: string) {
      super('LoginQrCodeDecodeError', 'InvalidVersion', message);
    }

    static instanceOf(e: any): e is InvalidVersion {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  /**
   * The base64 encoded variant of the QR code data is not a valid base64
   * string.
   */
  class Base64 extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoginQrCodeDecodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = LoginQrCodeDecodeError_Tags.Base64;

    constructor(message: string) {
      super('LoginQrCodeDecodeError', 'Base64', message);
    }

    static instanceOf(e: any): e is Base64 {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  /**
   * The QR code data doesn't contain the expected `MATRIX` prefix.
   */
  class InvalidPrefix extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoginQrCodeDecodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = LoginQrCodeDecodeError_Tags.InvalidPrefix;

    constructor(message: string) {
      super('LoginQrCodeDecodeError', 'InvalidPrefix', message);
    }

    static instanceOf(e: any): e is InvalidPrefix {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is LoginQrCodeDecodeError {
    return (e as any)[uniffiTypeNameSymbol] === 'LoginQrCodeDecodeError';
  }
  return {
    NotEnoughData,
    NotUtf8,
    UrlParse,
    InvalidMode,
    InvalidVersion,
    Base64,
    InvalidPrefix,
    instanceOf,
  };
})();

// Union type for LoginQrCodeDecodeError error type.

/**
 * Error type for the decoding of the [`QrCodeData`].
 */

export type LoginQrCodeDecodeError = InstanceType<
  (typeof LoginQrCodeDecodeError)[keyof Omit<
    typeof LoginQrCodeDecodeError,
    'instanceOf'
  >]
>;

const FfiConverterTypeLoginQrCodeDecodeError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = LoginQrCodeDecodeError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new LoginQrCodeDecodeError.NotEnoughData(
            FfiConverterString.read(from)
          );

        case 2:
          return new LoginQrCodeDecodeError.NotUtf8(
            FfiConverterString.read(from)
          );

        case 3:
          return new LoginQrCodeDecodeError.UrlParse(
            FfiConverterString.read(from)
          );

        case 4:
          return new LoginQrCodeDecodeError.InvalidMode(
            FfiConverterString.read(from)
          );

        case 5:
          return new LoginQrCodeDecodeError.InvalidVersion(
            FfiConverterString.read(from)
          );

        case 6:
          return new LoginQrCodeDecodeError.Base64(
            FfiConverterString.read(from)
          );

        case 7:
          return new LoginQrCodeDecodeError.InvalidPrefix(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

/**
 * The result of a signature check.
 */
export enum SignatureState {
  /**
   * The signature is missing.
   */
  Missing,
  /**
   * The signature is invalid.
   */
  Invalid,
  /**
   * The signature is valid but the device or user identity that created the
   * signature is not trusted.
   */
  ValidButNotTrusted,
  /**
   * The signature is valid and the device or user identity that created the
   * signature is trusted.
   */
  ValidAndTrusted,
}

const FfiConverterTypeSignatureState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SignatureState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SignatureState.Missing;
        case 2:
          return SignatureState.Invalid;
        case 3:
          return SignatureState.ValidButNotTrusted;
        case 4:
          return SignatureState.ValidAndTrusted;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case SignatureState.Missing:
          return ordinalConverter.write(1, into);
        case SignatureState.Invalid:
          return ordinalConverter.write(2, into);
        case SignatureState.ValidButNotTrusted:
          return ordinalConverter.write(3, into);
        case SignatureState.ValidAndTrusted:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The trust level in the sender's device that is required to decrypt an
 * event.
 */
export enum TrustRequirement {
  /**
   * Decrypt events from everyone regardless of trust.
   */
  Untrusted,
  /**
   * Only decrypt events from cross-signed devices or legacy sessions (Megolm
   * sessions created before we started collecting trust information).
   */
  CrossSignedOrLegacy,
  /**
   * Only decrypt events from cross-signed devices.
   */
  CrossSigned,
}

const FfiConverterTypeTrustRequirement = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TrustRequirement;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TrustRequirement.Untrusted;
        case 2:
          return TrustRequirement.CrossSignedOrLegacy;
        case 3:
          return TrustRequirement.CrossSigned;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case TrustRequirement.Untrusted:
          return ordinalConverter.write(1, into);
        case TrustRequirement.CrossSignedOrLegacy:
          return ordinalConverter.write(2, into);
        case TrustRequirement.CrossSigned:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Our best guess at the reason why an event can't be decrypted.
 */
export enum UtdCause {
  /**
   * We don't have an explanation for why this UTD happened - it is probably
   * a bug, or a network split between the two homeservers.
   *
   * For example:
   *
   * - the keys for this event are missing, but a key storage backup exists
   * and is working, so we should be able to find the keys in the backup.
   *
   * - the keys for this event are missing, and a key storage backup exists
   * on the server, but that backup is not working on this client even
   * though this device is verified.
   */
  Unknown,
  /**
   * We are missing the keys for this event, and the event was sent when we
   * were not a member of the room (or invited).
   */
  SentBeforeWeJoined,
  /**
   * The message was sent by a user identity we have not verified, but the
   * user was previously verified.
   */
  VerificationViolation,
  /**
   * The [`crate::TrustRequirement`] requires that the sending device be
   * signed by its owner, and it was not.
   */
  UnsignedDevice,
  /**
   * The [`crate::TrustRequirement`] requires that the sending device be
   * signed by its owner, and we were unable to securely find the device.
   *
   * This could be because the device has since been deleted, because we
   * haven't yet downloaded it from the server, or because the session
   * data was obtained from an insecure source (imported from a file,
   * obtained from a legacy (asymmetric) backup, unsafe key forward, etc.)
   */
  UnknownDevice,
  /**
   * We are missing the keys for this event, but it is a "device-historical"
   * message and there is no key storage backup on the server, presumably
   * because the user has turned it off.
   *
   * Device-historical means that the message was sent before the current
   * device existed (but the current user was probably a member of the room
   * at the time the message was sent). Not to
   * be confused with pre-join or pre-invite messages (see
   * [`UtdCause::SentBeforeWeJoined`] for that).
   *
   * Expected message to user: "History is not available on this device".
   */
  HistoricalMessageAndBackupIsDisabled,
  /**
   * The keys for this event are intentionally withheld.
   *
   * The sender has refused to share the key because our device does not meet
   * the sender's security requirements.
   */
  WithheldForUnverifiedOrInsecureDevice,
  /**
   * The keys for this event are missing, likely because the sender was
   * unable to share them (e.g., failure to establish an Olm 1:1
   * channel). Alternatively, the sender may have deliberately excluded
   * this device by cherry-picking and blocking it, in which case, no action
   * can be taken on our side.
   */
  WithheldBySender,
  /**
   * We are missing the keys for this event, but it is a "device-historical"
   * message, and even though a key storage backup does exist, we can't use
   * it because our device is unverified.
   *
   * Device-historical means that the message was sent before the current
   * device existed (but the current user was probably a member of the room
   * at the time the message was sent). Not to
   * be confused with pre-join or pre-invite messages (see
   * [`UtdCause::SentBeforeWeJoined`] for that).
   *
   * Expected message to user: "You need to verify this device".
   */
  HistoricalMessageAndDeviceIsUnverified,
}

const FfiConverterTypeUtdCause = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = UtdCause;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return UtdCause.Unknown;
        case 2:
          return UtdCause.SentBeforeWeJoined;
        case 3:
          return UtdCause.VerificationViolation;
        case 4:
          return UtdCause.UnsignedDevice;
        case 5:
          return UtdCause.UnknownDevice;
        case 6:
          return UtdCause.HistoricalMessageAndBackupIsDisabled;
        case 7:
          return UtdCause.WithheldForUnverifiedOrInsecureDevice;
        case 8:
          return UtdCause.WithheldBySender;
        case 9:
          return UtdCause.HistoricalMessageAndDeviceIsUnverified;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case UtdCause.Unknown:
          return ordinalConverter.write(1, into);
        case UtdCause.SentBeforeWeJoined:
          return ordinalConverter.write(2, into);
        case UtdCause.VerificationViolation:
          return ordinalConverter.write(3, into);
        case UtdCause.UnsignedDevice:
          return ordinalConverter.write(4, into);
        case UtdCause.UnknownDevice:
          return ordinalConverter.write(5, into);
        case UtdCause.HistoricalMessageAndBackupIsDisabled:
          return ordinalConverter.write(6, into);
        case UtdCause.WithheldForUnverifiedOrInsecureDevice:
          return ordinalConverter.write(7, into);
        case UtdCause.WithheldBySender:
          return ordinalConverter.write(8, into);
        case UtdCause.HistoricalMessageAndDeviceIsUnverified:
          return ordinalConverter.write(9, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_matrix_sdk_crypto_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeCollectStrategy,
    FfiConverterTypeDecryptionSettings,
    FfiConverterTypeIdentityState,
    FfiConverterTypeLocalTrust,
    FfiConverterTypeLoginQrCodeDecodeError,
    FfiConverterTypeSignatureState,
    FfiConverterTypeTrustRequirement,
    FfiConverterTypeUtdCause,
  },
});
