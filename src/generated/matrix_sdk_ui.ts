// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFutureFree,
  type UniffiCallbackInterfaceFree,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './matrix_sdk_ui-ffi';
import {
  type FfiConverter,
  AbstractFfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterInt32,
  RustBuffer,
  UniffiEnum,
  UniffiInternalError,
  rustCall,
  uniffiTypeNameSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

const stringToArrayBuffer = (s: string): ArrayBuffer =>
  rustCall((status) =>
    nativeModule().uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)
  );

const arrayBufferToString = (ab: ArrayBuffer): string =>
  rustCall((status) =>
    nativeModule().uniffi_internal_fn_func_ffi__arraybuffer_to_string(
      ab,
      status
    )
  );

const stringByteLength = (s: string): number =>
  rustCall((status) =>
    nativeModule().uniffi_internal_fn_func_ffi__string_to_byte_length(s, status)
  );

const FfiConverterString = (() => {
  const lengthConverter = FfiConverterInt32;
  type TypeName = string;
  class FFIConverter implements FfiConverter<ArrayBuffer, TypeName> {
    lift(value: ArrayBuffer): TypeName {
      return arrayBufferToString(value);
    }
    lower(value: TypeName): ArrayBuffer {
      return stringToArrayBuffer(value);
    }
    read(from: RustBuffer): TypeName {
      const length = lengthConverter.read(from);
      const bytes = from.readBytes(length);
      return arrayBufferToString(bytes);
    }
    write(value: TypeName, into: RustBuffer): void {
      const buffer = stringToArrayBuffer(value);
      const numBytes = buffer.byteLength;
      lengthConverter.write(numBytes, into);
      into.writeBytes(buffer);
    }
    allocationSize(value: TypeName): number {
      return lengthConverter.allocationSize(0) + stringByteLength(value);
    }
  }

  return new FFIConverter();
})();

/**
 * Where this event came.
 */
export enum EventItemOrigin {
  /**
   * The event was created locally.
   */
  Local,
  /**
   * The event came from a sync response.
   */
  Sync,
  /**
   * The event came from pagination.
   */
  Pagination,
}

const FfiConverterTypeEventItemOrigin = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EventItemOrigin;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return EventItemOrigin.Local;
        case 2:
          return EventItemOrigin.Sync;
        case 3:
          return EventItemOrigin.Pagination;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case EventItemOrigin.Local:
          return ordinalConverter.write(1, into);
        case EventItemOrigin.Sync:
          return ordinalConverter.write(2, into);
        case EventItemOrigin.Pagination:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: LiveBackPaginationStatus
export enum LiveBackPaginationStatus_Tags {
  Idle = 'Idle',
  Paginating = 'Paginating',
}
/**
 * Status for the back-pagination on a live timeline.
 */
export const LiveBackPaginationStatus = (() => {
  type Idle__interface = {
    tag: LiveBackPaginationStatus_Tags.Idle;
    inner: Readonly<{ hitStartOfTimeline: boolean }>;
  };

  /**
   * No back-pagination is happening right now.
   */
  class Idle_ extends UniffiEnum implements Idle__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LiveBackPaginationStatus';
    readonly tag = LiveBackPaginationStatus_Tags.Idle;
    readonly inner: Readonly<{ hitStartOfTimeline: boolean }>;
    constructor(inner: {
      /**
       * Have we hit the start of the timeline, i.e. back-paginating wouldn't
       * have any effect?
       */ hitStartOfTimeline: boolean;
    }) {
      super('LiveBackPaginationStatus', 'Idle');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Have we hit the start of the timeline, i.e. back-paginating wouldn't
       * have any effect?
       */ hitStartOfTimeline: boolean;
    }): Idle_ {
      return new Idle_(inner);
    }

    static instanceOf(obj: any): obj is Idle_ {
      return obj.tag === LiveBackPaginationStatus_Tags.Idle;
    }
  }

  type Paginating__interface = {
    tag: LiveBackPaginationStatus_Tags.Paginating;
  };

  /**
   * Back-pagination is already running in the background.
   */
  class Paginating_ extends UniffiEnum implements Paginating__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LiveBackPaginationStatus';
    readonly tag = LiveBackPaginationStatus_Tags.Paginating;
    constructor() {
      super('LiveBackPaginationStatus', 'Paginating');
    }

    static new(): Paginating_ {
      return new Paginating_();
    }

    static instanceOf(obj: any): obj is Paginating_ {
      return obj.tag === LiveBackPaginationStatus_Tags.Paginating;
    }
  }

  function instanceOf(obj: any): obj is LiveBackPaginationStatus {
    return obj[uniffiTypeNameSymbol] === 'LiveBackPaginationStatus';
  }

  return Object.freeze({
    instanceOf,
    Idle: Idle_,
    Paginating: Paginating_,
  });
})();

/**
 * Status for the back-pagination on a live timeline.
 */

export type LiveBackPaginationStatus = InstanceType<
  (typeof LiveBackPaginationStatus)[keyof Omit<
    typeof LiveBackPaginationStatus,
    'instanceOf'
  >]
>;

// FfiConverter for enum LiveBackPaginationStatus
const FfiConverterTypeLiveBackPaginationStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LiveBackPaginationStatus;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LiveBackPaginationStatus.Idle({
            hitStartOfTimeline: FfiConverterBool.read(from),
          });
        case 2:
          return new LiveBackPaginationStatus.Paginating();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LiveBackPaginationStatus_Tags.Idle: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.hitStartOfTimeline, into);
          return;
        }
        case LiveBackPaginationStatus_Tags.Paginating: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that LiveBackPaginationStatus_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LiveBackPaginationStatus_Tags.Idle: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterBool.allocationSize(inner.hitStartOfTimeline);
          return size;
        }
        case LiveBackPaginationStatus_Tags.Paginating: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * The type of change between the previous and current pinned events.
 */
export enum RoomPinnedEventsChange {
  /**
   * Only new event ids were added.
   */
  Added,
  /**
   * Only event ids were removed.
   */
  Removed,
  /**
   * Some change other than only adding or only removing ids happened.
   */
  Changed,
}

const FfiConverterTypeRoomPinnedEventsChange = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoomPinnedEventsChange;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RoomPinnedEventsChange.Added;
        case 2:
          return RoomPinnedEventsChange.Removed;
        case 3:
          return RoomPinnedEventsChange.Changed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RoomPinnedEventsChange.Added:
          return ordinalConverter.write(1, into);
        case RoomPinnedEventsChange.Removed:
          return ordinalConverter.write(2, into);
        case RoomPinnedEventsChange.Changed:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 26;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ffi_matrix_sdk_ui_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeEventItemOrigin,
    FfiConverterTypeLiveBackPaginationStatus,
    FfiConverterTypeRoomPinnedEventsChange,
  },
});
