// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(matrix_sdk_ffiFFI)
import matrix_sdk_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol ClientProtocol : AnyObject {
    
    /**
     * Aborts an existing OIDC login operation that might have been cancelled,
     * failed etc.
     */
    func abortOidcAuth(authorizationData: OidcAuthorizationData) async 
    
    /**
     * Get the content of the event of the given type out of the account data
     * store.
     *
     * It will be returned as a JSON string.
     */
    func accountData(eventType: String) async throws  -> String?
    
    func accountUrl(action: AccountManagementAction?) async throws  -> String?
    
    /**
     * Find all sliding sync versions that are available.
     *
     * Be careful: This method may hit the store and will send new requests for
     * each call. It can be costly to call it repeatedly.
     *
     * If `.well-known` or `/versions` is unreachable, it will simply move
     * potential sliding sync versions aside. No error will be reported.
     */
    func availableSlidingSyncVersions() async  -> [SlidingSyncVersion]
    
    /**
     * Sends a request to retrieve the avatar URL. Will fill the cache used by
     * [`Self::cached_avatar_url`] on success.
     */
    func avatarUrl() async throws  -> String?
    
    /**
     * Waits until an at least partially synced room is received, and returns
     * it.
     *
     * **Note: this function will loop endlessly until either it finds the room
     * or an externally set timeout happens.**
     */
    func awaitRoomRemoteEcho(roomId: String) async throws  -> Room
    
    /**
     * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
     */
    func cachedAvatarUrl() throws  -> String?
    
    /**
     * Lets the user know whether this is an `m.login.password` based
     * auth and if the account can actually be deactivated
     */
    func canDeactivateAccount()  -> Bool
    
    func createRoom(request: CreateRoomParameters) async throws  -> String
    
    /**
     * Creates a new room alias associated with the provided room id.
     */
    func createRoomAlias(roomAlias: String, roomId: String) async throws 
    
    /**
     * Login using JWT
     * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
     * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
     */
    func customLoginWithJwt(jwt: String, initialDeviceName: String?, deviceId: String?) async throws 
    
    /**
     * Deactivate this account definitively.
     * Similarly to `encryption::reset_identity` this
     * will only work with password-based authentication (`m.login.password`)
     *
     * # Arguments
     *
     * * `auth_data` - This request uses the [User-Interactive Authentication
     * API][uiaa]. The first request needs to set this to `None` and will
     * always fail and the same request needs to be made but this time with
     * some `auth_data` provided.
     */
    func deactivateAccount(authData: AuthData?, eraseData: Bool) async throws 
    
    /**
     * Deletes a pusher of given pusher ids
     */
    func deletePusher(identifiers: PusherIdentifiers) async throws 
    
    func deviceId() throws  -> String
    
    func displayName() async throws  -> String
    
    /**
     * Enables or disables all the room send queues at once.
     *
     * When connectivity is lost on a device, it is recommended to disable the
     * room sending queues.
     *
     * This can be controlled for individual rooms, using
     * [`Room::enable_send_queue`].
     */
    func enableAllSendQueues(enable: Bool) async 
    
    func encryption()  -> Encryption
    
    func getDmRoom(userId: String) throws  -> Room?
    
    func getMediaContent(mediaSource: MediaSource) async throws  -> Data
    
    func getMediaFile(mediaSource: MediaSource, filename: String?, mimeType: String, useCache: Bool, tempDir: String?) async throws  -> MediaFileHandle
    
    func getMediaThumbnail(mediaSource: MediaSource, width: UInt64, height: UInt64) async throws  -> Data
    
    func getNotificationSettings()  -> NotificationSettings
    
    func getProfile(userId: String) async throws  -> UserProfile
    
    func getRecentlyVisitedRooms() async throws  -> [String]
    
    /**
     * Given a room alias, get the preview of a room, to interact with it.
     */
    func getRoomPreviewFromRoomAlias(roomAlias: String) async throws  -> RoomPreview
    
    /**
     * Given a room id, get the preview of a room, to interact with it.
     *
     * The list of `via_servers` must be a list of servers that know
     * about the room and can resolve it, and that may appear as a `via`
     * parameter in e.g. a permalink URL. This list can be empty.
     */
    func getRoomPreviewFromRoomId(roomId: String, viaServers: [String]) async throws  -> RoomPreview
    
    func getSessionVerificationController() async throws  -> SessionVerificationController
    
    /**
     * Allows generic GET requests to be made through the SDKs internal HTTP
     * client
     */
    func getUrl(url: String) async throws  -> String
    
    /**
     * The homeserver this client is configured to use.
     */
    func homeserver()  -> String
    
    /**
     * Information about login options for the client's homeserver.
     */
    func homeserverLoginDetails() async  -> HomeserverLoginDetails
    
    func ignoreUser(userId: String) async throws 
    
    func ignoredUsers() async throws  -> [String]
    
    /**
     * Checks if a room alias is not in use yet.
     *
     * Returns:
     * - `Ok(true)` if the room alias is available.
     * - `Ok(false)` if it's not (the resolve alias request returned a `404`
     * status code).
     * - An `Err` otherwise.
     */
    func isRoomAliasAvailable(alias: String) async throws  -> Bool
    
    /**
     * Join a room by its ID.
     *
     * Use this method when the homeserver already knows of the given room ID.
     * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
     * server names for the homeserver to find the room.
     */
    func joinRoomById(roomId: String) async throws  -> Room
    
    /**
     * Join a room by its ID or alias.
     *
     * When supplying the room's ID, you can also supply a list of server names
     * for the homeserver to find the room. Typically these server names
     * come from a permalink's `via` parameters, or from resolving a room's
     * alias into an ID.
     */
    func joinRoomByIdOrAlias(roomIdOrAlias: String, serverNames: [String]) async throws  -> Room
    
    /**
     * Knock on a room to join it using its ID or alias.
     */
    func knock(roomIdOrAlias: String, reason: String?, serverNames: [String]) async throws  -> Room
    
    /**
     * Login using a username and password.
     */
    func login(username: String, password: String, initialDeviceName: String?, deviceId: String?) async throws 
    
    /**
     * Login using an email and password.
     */
    func loginWithEmail(email: String, password: String, initialDeviceName: String?, deviceId: String?) async throws 
    
    /**
     * Completes the OIDC login process.
     */
    func loginWithOidcCallback(authorizationData: OidcAuthorizationData, callbackUrl: String) async throws 
    
    /**
     * Log out the current user. This method returns an optional URL that
     * should be presented to the user to complete logout (in the case of
     * Session having been authenticated using OIDC).
     */
    func logout() async throws  -> String?
    
    func notificationClient(processSetup: NotificationProcessSetup) async throws  -> NotificationClient
    
    func removeAvatar() async throws 
    
    /**
     * Empty the server version and unstable features cache.
     *
     * Since the SDK caches server capabilities (versions and unstable
     * features), it's possible to have a stale entry in the cache. This
     * functions makes it possible to force reset it.
     */
    func resetServerCapabilities() async throws 
    
    /**
     * Resolves the given room alias to a room ID (and a list of servers), if
     * possible.
     */
    func resolveRoomAlias(roomAlias: String) async throws  -> ResolvedRoomAlias?
    
    /**
     * Restores the client from a `Session`.
     */
    func restoreSession(session: Session) async throws 
    
    /**
     * Checks if a room alias exists in the current homeserver.
     */
    func roomAliasExists(roomAlias: String) async throws  -> Bool
    
    func roomDirectorySearch()  -> RoomDirectorySearch
    
    func rooms()  -> [Room]
    
    func searchUsers(searchTerm: String, limit: UInt64) async throws  -> SearchUsersResults
    
    /**
     * The URL of the server.
     *
     * Not to be confused with the `Self::homeserver`. `server` is usually
     * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
     * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
     * homeserver (at the time of writing — 2024-08-28).
     *
     * This value is optional depending on how the `Client` has been built.
     * If it's been built from a homeserver URL directly, we don't know the
     * server. However, if the `Client` has been built from a server URL or
     * name, then the homeserver has been discovered, and we know both.
     */
    func server()  -> String?
    
    func session() throws  -> Session
    
    /**
     * Set the given account data content for the given event type.
     *
     * It should be supplied as a JSON string.
     */
    func setAccountData(eventType: String, content: String) async throws 
    
    func setDelegate(delegate: ClientDelegate?)  -> TaskHandle?
    
    func setDisplayName(name: String) async throws 
    
    /**
     * Registers a pusher with given parameters
     */
    func setPusher(identifiers: PusherIdentifiers, kind: PusherKind, appDisplayName: String, deviceDisplayName: String, profileTag: String?, lang: String) async throws 
    
    /**
     * The sliding sync version.
     */
    func slidingSyncVersion()  -> SlidingSyncVersion
    
    /**
     * Returns a handler to start the SSO login process.
     */
    func startSsoLogin(redirectUrl: String, idpId: String?) async throws  -> SsoHandler
    
    func subscribeToIgnoredUsers(listener: IgnoredUsersListener)  -> TaskHandle
    
    /**
     * Subscribe to the global enablement status of the send queue, at the
     * client-wide level.
     *
     * The given listener will be immediately called with the initial value of
     * the enablement status.
     */
    func subscribeToSendQueueStatus(listener: SendQueueRoomErrorListener)  -> TaskHandle
    
    func syncService()  -> SyncServiceBuilder
    
    func trackRecentlyVisitedRoom(room: String) async throws 
    
    func unignoreUser(userId: String) async throws 
    
    func uploadAvatar(mimeType: String, data: Data) async throws 
    
    func uploadMedia(mimeType: String, data: Data, progressWatcher: ProgressWatcher?) async throws  -> String
    
    /**
     * Requests the URL needed for opening a web view using OIDC. Once the web
     * view has succeeded, call `login_with_oidc_callback` with the callback it
     * returns. If a failure occurs and a callback isn't available, make sure
     * to call `abort_oidc_auth` to inform the client of this.
     */
    func urlForOidc(oidcConfiguration: OidcConfiguration, prompt: OidcPrompt) async throws  -> OidcAuthorizationData
    
    func userId() throws  -> String
    
    /**
     * The server name part of the current user ID
     */
    func userIdServerName() throws  -> String
    
}

open class Client:
    ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_client(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_client(pointer, $0) }
    }

    

    
    /**
     * Aborts an existing OIDC login operation that might have been cancelled,
     * failed etc.
     */
open func abortOidcAuth(authorizationData: OidcAuthorizationData)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOidcAuthorizationData_lower(authorizationData)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Get the content of the event of the given type out of the account data
     * store.
     *
     * It will be returned as a JSON string.
     */
open func accountData(eventType: String)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_account_data(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventType)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func accountUrl(action: AccountManagementAction?)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_account_url(
                    self.uniffiClonePointer(),
                    FfiConverterOptionTypeAccountManagementAction.lower(action)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Find all sliding sync versions that are available.
     *
     * Be careful: This method may hit the store and will send new requests for
     * each call. It can be costly to call it repeatedly.
     *
     * If `.well-known` or `/versions` is unreachable, it will simply move
     * potential sliding sync versions aside. No error will be reported.
     */
open func availableSlidingSyncVersions()async  -> [SlidingSyncVersion] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSlidingSyncVersion.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Sends a request to retrieve the avatar URL. Will fill the cache used by
     * [`Self::cached_avatar_url`] on success.
     */
open func avatarUrl()async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Waits until an at least partially synced room is received, and returns
     * it.
     *
     * **Note: this function will loop endlessly until either it finds the room
     * or an externally set timeout happens.**
     */
open func awaitRoomRemoteEcho(roomId: String)async throws  -> Room {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoom.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
     */
open func cachedAvatarUrl()throws  -> String? {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Lets the user know whether this is an `m.login.password` based
     * auth and if the account can actually be deactivated
     */
open func canDeactivateAccount() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(self.uniffiClonePointer(),$0
    )
})
}
    
open func createRoom(request: CreateRoomParameters)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_create_room(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateRoomParameters.lower(request)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Creates a new room alias associated with the provided room id.
     */
open func createRoomAlias(roomAlias: String, roomId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_create_room_alias(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomAlias),FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Login using JWT
     * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
     * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
     */
open func customLoginWithJwt(jwt: String, initialDeviceName: String?, deviceId: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(jwt),FfiConverterOptionString.lower(initialDeviceName),FfiConverterOptionString.lower(deviceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Deactivate this account definitively.
     * Similarly to `encryption::reset_identity` this
     * will only work with password-based authentication (`m.login.password`)
     *
     * # Arguments
     *
     * * `auth_data` - This request uses the [User-Interactive Authentication
     * API][uiaa]. The first request needs to set this to `None` and will
     * always fail and the same request needs to be made but this time with
     * some `auth_data` provided.
     */
open func deactivateAccount(authData: AuthData?, eraseData: Bool)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(
                    self.uniffiClonePointer(),
                    FfiConverterOptionTypeAuthData.lower(authData),FfiConverterBool.lower(eraseData)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Deletes a pusher of given pusher ids
     */
open func deletePusher(identifiers: PusherIdentifiers)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(
                    self.uniffiClonePointer(),
                    FfiConverterTypePusherIdentifiers.lower(identifiers)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func deviceId()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_device_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func displayName()async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_display_name(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Enables or disables all the room send queues at once.
     *
     * When connectivity is lost on a device, it is recommended to disable the
     * room sending queues.
     *
     * This can be controlled for individual rooms, using
     * [`Room::enable_send_queue`].
     */
open func enableAllSendQueues(enable: Bool)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(enable)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func encryption() -> Encryption {
    return try!  FfiConverterTypeEncryption.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_encryption(self.uniffiClonePointer(),$0
    )
})
}
    
open func getDmRoom(userId: String)throws  -> Room? {
    return try  FfiConverterOptionTypeRoom.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(self.uniffiClonePointer(),
        FfiConverterString.lower(userId),$0
    )
})
}
    
open func getMediaContent(mediaSource: MediaSource)async throws  -> Data {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMediaSource.lower(mediaSource)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func getMediaFile(mediaSource: MediaSource, filename: String?, mimeType: String, useCache: Bool, tempDir: String?)async throws  -> MediaFileHandle {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMediaSource.lower(mediaSource),FfiConverterOptionString.lower(filename),FfiConverterString.lower(mimeType),FfiConverterBool.lower(useCache),FfiConverterOptionString.lower(tempDir)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeMediaFileHandle.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func getMediaThumbnail(mediaSource: MediaSource, width: UInt64, height: UInt64)async throws  -> Data {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMediaSource.lower(mediaSource),FfiConverterUInt64.lower(width),FfiConverterUInt64.lower(height)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func getNotificationSettings() -> NotificationSettings {
    return try!  FfiConverterTypeNotificationSettings.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(self.uniffiClonePointer(),$0
    )
})
}
    
open func getProfile(userId: String)async throws  -> UserProfile {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_profile(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserProfile.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func getRecentlyVisitedRooms()async throws  -> [String] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Given a room alias, get the preview of a room, to interact with it.
     */
open func getRoomPreviewFromRoomAlias(roomAlias: String)async throws  -> RoomPreview {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomAlias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoomPreview.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Given a room id, get the preview of a room, to interact with it.
     *
     * The list of `via_servers` must be a list of servers that know
     * about the room and can resolve it, and that may appear as a `via`
     * parameter in e.g. a permalink URL. This list can be empty.
     */
open func getRoomPreviewFromRoomId(roomId: String, viaServers: [String])async throws  -> RoomPreview {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomId),FfiConverterSequenceString.lower(viaServers)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoomPreview.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func getSessionVerificationController()async throws  -> SessionVerificationController {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSessionVerificationController.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Allows generic GET requests to be made through the SDKs internal HTTP
     * client
     */
open func getUrl(url: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_url(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * The homeserver this client is configured to use.
     */
open func homeserver() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_homeserver(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Information about login options for the client's homeserver.
     */
open func homeserverLoginDetails()async  -> HomeserverLoginDetails {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeHomeserverLoginDetails.lift,
            errorHandler: nil
            
        )
}
    
open func ignoreUser(userId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func ignoredUsers()async throws  -> [String] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Checks if a room alias is not in use yet.
     *
     * Returns:
     * - `Ok(true)` if the room alias is available.
     * - `Ok(false)` if it's not (the resolve alias request returned a `404`
     * status code).
     * - An `Err` otherwise.
     */
open func isRoomAliasAvailable(alias: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(alias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Join a room by its ID.
     *
     * Use this method when the homeserver already knows of the given room ID.
     * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
     * server names for the homeserver to find the room.
     */
open func joinRoomById(roomId: String)async throws  -> Room {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoom.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Join a room by its ID or alias.
     *
     * When supplying the room's ID, you can also supply a list of server names
     * for the homeserver to find the room. Typically these server names
     * come from a permalink's `via` parameters, or from resolving a room's
     * alias into an ID.
     */
open func joinRoomByIdOrAlias(roomIdOrAlias: String, serverNames: [String])async throws  -> Room {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomIdOrAlias),FfiConverterSequenceString.lower(serverNames)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoom.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Knock on a room to join it using its ID or alias.
     */
open func knock(roomIdOrAlias: String, reason: String?, serverNames: [String])async throws  -> Room {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_knock(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomIdOrAlias),FfiConverterOptionString.lower(reason),FfiConverterSequenceString.lower(serverNames)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoom.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Login using a username and password.
     */
open func login(username: String, password: String, initialDeviceName: String?, deviceId: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_login(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(username),FfiConverterString.lower(password),FfiConverterOptionString.lower(initialDeviceName),FfiConverterOptionString.lower(deviceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Login using an email and password.
     */
open func loginWithEmail(email: String, password: String, initialDeviceName: String?, deviceId: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(email),FfiConverterString.lower(password),FfiConverterOptionString.lower(initialDeviceName),FfiConverterOptionString.lower(deviceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Completes the OIDC login process.
     */
open func loginWithOidcCallback(authorizationData: OidcAuthorizationData, callbackUrl: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOidcAuthorizationData_lower(authorizationData),FfiConverterString.lower(callbackUrl)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeOidcError.lift
        )
}
    
    /**
     * Log out the current user. This method returns an optional URL that
     * should be presented to the user to complete logout (in the case of
     * Session having been authenticated using OIDC).
     */
open func logout()async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_logout(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func notificationClient(processSetup: NotificationProcessSetup)async throws  -> NotificationClient {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_notification_client(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNotificationProcessSetup.lower(processSetup)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNotificationClient.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func removeAvatar()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Empty the server version and unstable features cache.
     *
     * Since the SDK caches server capabilities (versions and unstable
     * features), it's possible to have a stale entry in the cache. This
     * functions makes it possible to force reset it.
     */
open func resetServerCapabilities()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_reset_server_capabilities(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Resolves the given room alias to a room ID (and a list of servers), if
     * possible.
     */
open func resolveRoomAlias(roomAlias: String)async throws  -> ResolvedRoomAlias? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomAlias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeResolvedRoomAlias.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Restores the client from a `Session`.
     */
open func restoreSession(session: Session)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_restore_session(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSession.lower(session)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Checks if a room alias exists in the current homeserver.
     */
open func roomAliasExists(roomAlias: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomAlias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func roomDirectorySearch() -> RoomDirectorySearch {
    return try!  FfiConverterTypeRoomDirectorySearch.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(self.uniffiClonePointer(),$0
    )
})
}
    
open func rooms() -> [Room] {
    return try!  FfiConverterSequenceTypeRoom.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_rooms(self.uniffiClonePointer(),$0
    )
})
}
    
open func searchUsers(searchTerm: String, limit: UInt64)async throws  -> SearchUsersResults {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_search_users(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(searchTerm),FfiConverterUInt64.lower(limit)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSearchUsersResults.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * The URL of the server.
     *
     * Not to be confused with the `Self::homeserver`. `server` is usually
     * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
     * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
     * homeserver (at the time of writing — 2024-08-28).
     *
     * This value is optional depending on how the `Client` has been built.
     * If it's been built from a homeserver URL directly, we don't know the
     * server. However, if the `Client` has been built from a server URL or
     * name, then the homeserver has been discovered, and we know both.
     */
open func server() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_server(self.uniffiClonePointer(),$0
    )
})
}
    
open func session()throws  -> Session {
    return try  FfiConverterTypeSession.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_session(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Set the given account data content for the given event type.
     *
     * It should be supplied as a JSON string.
     */
open func setAccountData(eventType: String, content: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventType),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setDelegate(delegate: ClientDelegate?) -> TaskHandle? {
    return try!  FfiConverterOptionTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(self.uniffiClonePointer(),
        FfiConverterOptionCallbackInterfaceClientDelegate.lower(delegate),$0
    )
})
}
    
open func setDisplayName(name: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Registers a pusher with given parameters
     */
open func setPusher(identifiers: PusherIdentifiers, kind: PusherKind, appDisplayName: String, deviceDisplayName: String, profileTag: String?, lang: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(
                    self.uniffiClonePointer(),
                    FfiConverterTypePusherIdentifiers.lower(identifiers),FfiConverterTypePusherKind.lower(kind),FfiConverterString.lower(appDisplayName),FfiConverterString.lower(deviceDisplayName),FfiConverterOptionString.lower(profileTag),FfiConverterString.lower(lang)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * The sliding sync version.
     */
open func slidingSyncVersion() -> SlidingSyncVersion {
    return try!  FfiConverterTypeSlidingSyncVersion.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns a handler to start the SSO login process.
     */
open func startSsoLogin(redirectUrl: String, idpId: String?)async throws  -> SsoHandler {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(redirectUrl),FfiConverterOptionString.lower(idpId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSsoHandler.lift,
            errorHandler: FfiConverterTypeSsoError.lift
        )
}
    
open func subscribeToIgnoredUsers(listener: IgnoredUsersListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceIgnoredUsersListener.lower(listener),$0
    )
})
}
    
    /**
     * Subscribe to the global enablement status of the send queue, at the
     * client-wide level.
     *
     * The given listener will be immediately called with the initial value of
     * the enablement status.
     */
open func subscribeToSendQueueStatus(listener: SendQueueRoomErrorListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceSendQueueRoomErrorListener.lower(listener),$0
    )
})
}
    
open func syncService() -> SyncServiceBuilder {
    return try!  FfiConverterTypeSyncServiceBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_sync_service(self.uniffiClonePointer(),$0
    )
})
}
    
open func trackRecentlyVisitedRoom(room: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(room)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func unignoreUser(userId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func uploadAvatar(mimeType: String, data: Data)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(mimeType),FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func uploadMedia(mimeType: String, data: Data, progressWatcher: ProgressWatcher?)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_upload_media(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(mimeType),FfiConverterData.lower(data),FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Requests the URL needed for opening a web view using OIDC. Once the web
     * view has succeeded, call `login_with_oidc_callback` with the callback it
     * returns. If a failure occurs and a callback isn't available, make sure
     * to call `abort_oidc_auth` to inform the client of this.
     */
open func urlForOidc(oidcConfiguration: OidcConfiguration, prompt: OidcPrompt)async throws  -> OidcAuthorizationData {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOidcConfiguration.lower(oidcConfiguration),FfiConverterTypeOidcPrompt.lower(prompt)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeOidcAuthorizationData_lift,
            errorHandler: FfiConverterTypeOidcError.lift
        )
}
    
open func userId()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_user_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The server name part of the current user ID
     */
open func userIdServerName()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}




public protocol ClientBuilderProtocol : AnyObject {
    
    func addRootCertificates(certificates: [Data])  -> ClientBuilder
    
    /**
     * Automatically create a backup version if no backup exists.
     */
    func autoEnableBackups(autoEnableBackups: Bool)  -> ClientBuilder
    
    func autoEnableCrossSigning(autoEnableCrossSigning: Bool)  -> ClientBuilder
    
    /**
     * Select a strategy to download room keys from the backup. By default
     * we download after a decryption failure.
     *
     * Take a look at the [`BackupDownloadStrategy`] enum for more options.
     */
    func backupDownloadStrategy(backupDownloadStrategy: BackupDownloadStrategy)  -> ClientBuilder
    
    func build() async throws  -> Client
    
    /**
     * Finish the building of the client and attempt to log in using the
     * provided [`QrCodeData`].
     *
     * This method will build the client and immediately attempt to log the
     * client in using the provided [`QrCodeData`] using the login
     * mechanism described in [MSC4108]. As such this methods requires OIDC
     * support as well as sliding sync support.
     *
     * The usage of the progress_listener is required to transfer the
     * [`CheckCode`] to the existing client.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    func buildWithQrCode(qrCodeData: QrCodeData, oidcConfiguration: OidcConfiguration, progressListener: QrLoginProgressListener) async throws  -> Client
    
    func crossProcessStoreLocksHolderName(holderName: String)  -> ClientBuilder
    
    func disableAutomaticTokenRefresh()  -> ClientBuilder
    
    /**
     * Don't trust any system root certificates, only trust the certificates
     * provided through
     * [`add_root_certificates`][ClientBuilder::add_root_certificates].
     */
    func disableBuiltInRootCertificates()  -> ClientBuilder
    
    func disableSslVerification()  -> ClientBuilder
    
    func enableOidcRefreshLock()  -> ClientBuilder
    
    func homeserverUrl(url: String)  -> ClientBuilder
    
    func passphrase(passphrase: String?)  -> ClientBuilder
    
    func proxy(url: String)  -> ClientBuilder
    
    /**
     * Add a default request config to this client.
     */
    func requestConfig(config: RequestConfig)  -> ClientBuilder
    
    /**
     * Set the trust requirement to be used when decrypting events.
     */
    func roomDecryptionTrustRequirement(trustRequirement: TrustRequirement)  -> ClientBuilder
    
    /**
     * Set the strategy to be used for picking recipient devices when sending
     * an encrypted message.
     */
    func roomKeyRecipientStrategy(strategy: CollectStrategy)  -> ClientBuilder
    
    func serverName(serverName: String)  -> ClientBuilder
    
    func serverNameOrHomeserverUrl(serverNameOrUrl: String)  -> ClientBuilder
    
    /**
     * Sets the paths that the client will use to store its data and caches.
     * Both paths **must** be unique per session as the SDK stores aren't
     * capable of handling multiple users, however it is valid to use the
     * same path for both stores on a single session.
     *
     * Leaving this unset tells the client to use an in-memory data store.
     */
    func sessionPaths(dataPath: String, cachePath: String)  -> ClientBuilder
    
    func setSessionDelegate(sessionDelegate: ClientSessionDelegate)  -> ClientBuilder
    
    func slidingSyncVersionBuilder(versionBuilder: SlidingSyncVersionBuilder)  -> ClientBuilder
    
    /**
     * Whether to use the event cache persistent storage or not.
     *
     * This is a temporary feature flag, for testing the event cache's
     * persistent storage. Follow new developments in https://github.com/matrix-org/matrix-rust-sdk/issues/3280.
     *
     * This is disabled by default. When disabled, a one-time cleanup is
     * performed when creating the client, and it will clear all the events
     * previously stored in the event cache.
     *
     * When enabled, it will attempt to store events in the event cache as
     * they're received, and reuse them when reconstructing timelines.
     */
    func useEventCachePersistentStorage(value: Bool)  -> ClientBuilder
    
    func userAgent(userAgent: String)  -> ClientBuilder
    
    func username(username: String)  -> ClientBuilder
    
}

open class ClientBuilder:
    ClientBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_clientbuilder(pointer, $0) }
    }

    

    
open func addRootCertificates(certificates: [Data]) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(self.uniffiClonePointer(),
        FfiConverterSequenceData.lower(certificates),$0
    )
})
}
    
    /**
     * Automatically create a backup version if no backup exists.
     */
open func autoEnableBackups(autoEnableBackups: Bool) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(self.uniffiClonePointer(),
        FfiConverterBool.lower(autoEnableBackups),$0
    )
})
}
    
open func autoEnableCrossSigning(autoEnableCrossSigning: Bool) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(self.uniffiClonePointer(),
        FfiConverterBool.lower(autoEnableCrossSigning),$0
    )
})
}
    
    /**
     * Select a strategy to download room keys from the backup. By default
     * we download after a decryption failure.
     *
     * Take a look at the [`BackupDownloadStrategy`] enum for more options.
     */
open func backupDownloadStrategy(backupDownloadStrategy: BackupDownloadStrategy) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(self.uniffiClonePointer(),
        FfiConverterTypeBackupDownloadStrategy_lower(backupDownloadStrategy),$0
    )
})
}
    
open func build()async throws  -> Client {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeClient.lift,
            errorHandler: FfiConverterTypeClientBuildError.lift
        )
}
    
    /**
     * Finish the building of the client and attempt to log in using the
     * provided [`QrCodeData`].
     *
     * This method will build the client and immediately attempt to log the
     * client in using the provided [`QrCodeData`] using the login
     * mechanism described in [MSC4108]. As such this methods requires OIDC
     * support as well as sliding sync support.
     *
     * The usage of the progress_listener is required to transfer the
     * [`CheckCode`] to the existing client.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
open func buildWithQrCode(qrCodeData: QrCodeData, oidcConfiguration: OidcConfiguration, progressListener: QrLoginProgressListener)async throws  -> Client {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build_with_qr_code(
                    self.uniffiClonePointer(),
                    FfiConverterTypeQrCodeData.lower(qrCodeData),FfiConverterTypeOidcConfiguration.lower(oidcConfiguration),FfiConverterCallbackInterfaceQrLoginProgressListener.lower(progressListener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeClient.lift,
            errorHandler: FfiConverterTypeHumanQrLoginError.lift
        )
}
    
open func crossProcessStoreLocksHolderName(holderName: String) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(self.uniffiClonePointer(),
        FfiConverterString.lower(holderName),$0
    )
})
}
    
open func disableAutomaticTokenRefresh() -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Don't trust any system root certificates, only trust the certificates
     * provided through
     * [`add_root_certificates`][ClientBuilder::add_root_certificates].
     */
open func disableBuiltInRootCertificates() -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(self.uniffiClonePointer(),$0
    )
})
}
    
open func disableSslVerification() -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(self.uniffiClonePointer(),$0
    )
})
}
    
open func enableOidcRefreshLock() -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(self.uniffiClonePointer(),$0
    )
})
}
    
open func homeserverUrl(url: String) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
})
}
    
open func passphrase(passphrase: String?) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_passphrase(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(passphrase),$0
    )
})
}
    
open func proxy(url: String) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
})
}
    
    /**
     * Add a default request config to this client.
     */
open func requestConfig(config: RequestConfig) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(self.uniffiClonePointer(),
        FfiConverterTypeRequestConfig.lower(config),$0
    )
})
}
    
    /**
     * Set the trust requirement to be used when decrypting events.
     */
open func roomDecryptionTrustRequirement(trustRequirement: TrustRequirement) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_decryption_trust_requirement(self.uniffiClonePointer(),
        FfiConverterTypeTrustRequirement_lower(trustRequirement),$0
    )
})
}
    
    /**
     * Set the strategy to be used for picking recipient devices when sending
     * an encrypted message.
     */
open func roomKeyRecipientStrategy(strategy: CollectStrategy) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(self.uniffiClonePointer(),
        FfiConverterTypeCollectStrategy_lower(strategy),$0
    )
})
}
    
open func serverName(serverName: String) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(self.uniffiClonePointer(),
        FfiConverterString.lower(serverName),$0
    )
})
}
    
open func serverNameOrHomeserverUrl(serverNameOrUrl: String) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(self.uniffiClonePointer(),
        FfiConverterString.lower(serverNameOrUrl),$0
    )
})
}
    
    /**
     * Sets the paths that the client will use to store its data and caches.
     * Both paths **must** be unique per session as the SDK stores aren't
     * capable of handling multiple users, however it is valid to use the
     * same path for both stores on a single session.
     *
     * Leaving this unset tells the client to use an in-memory data store.
     */
open func sessionPaths(dataPath: String, cachePath: String) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_paths(self.uniffiClonePointer(),
        FfiConverterString.lower(dataPath),
        FfiConverterString.lower(cachePath),$0
    )
})
}
    
open func setSessionDelegate(sessionDelegate: ClientSessionDelegate) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceClientSessionDelegate.lower(sessionDelegate),$0
    )
})
}
    
open func slidingSyncVersionBuilder(versionBuilder: SlidingSyncVersionBuilder) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(self.uniffiClonePointer(),
        FfiConverterTypeSlidingSyncVersionBuilder.lower(versionBuilder),$0
    )
})
}
    
    /**
     * Whether to use the event cache persistent storage or not.
     *
     * This is a temporary feature flag, for testing the event cache's
     * persistent storage. Follow new developments in https://github.com/matrix-org/matrix-rust-sdk/issues/3280.
     *
     * This is disabled by default. When disabled, a one-time cleanup is
     * performed when creating the client, and it will clear all the events
     * previously stored in the event cache.
     *
     * When enabled, it will attempt to store events in the event cache as
     * they're received, and reuse them when reconstructing timelines.
     */
open func useEventCachePersistentStorage(value: Bool) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_use_event_cache_persistent_storage(self.uniffiClonePointer(),
        FfiConverterBool.lower(value),$0
    )
})
}
    
open func userAgent(userAgent: String) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(self.uniffiClonePointer(),
        FfiConverterString.lower(userAgent),$0
    )
})
}
    
open func username(username: String) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(self.uniffiClonePointer(),
        FfiConverterString.lower(username),$0
    )
})
}
    

}

public struct FfiConverterTypeClientBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
    return try FfiConverterTypeClientBuilder.lift(pointer)
}

public func FfiConverterTypeClientBuilder_lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientBuilder.lower(value)
}




public protocol EncryptionProtocol : AnyObject {
    
    /**
     * Does a backup exist on the server?
     *
     * Because the homeserver doesn't notify us about changes to the backup
     * version, the [`BackupState`] and its listener are a bit crippled.
     * The `BackupState::Unknown` state might mean there is no backup at all or
     * a backup exists but we don't have access to it.
     *
     * Therefore it is necessary to poll the server for an answer every time
     * you want to differentiate between those two states.
     */
    func backupExistsOnServer() async throws  -> Bool
    
    func backupState()  -> BackupState
    
    func backupStateListener(listener: BackupStateListener)  -> TaskHandle
    
    /**
     * Get the public curve25519 key of our own device in base64. This is
     * usually what is called the identity key of the device.
     */
    func curve25519Key() async  -> String?
    
    func disableRecovery() async throws 
    
    /**
     * Get the public ed25519 key of our own device. This is usually what is
     * called the fingerprint of the device.
     */
    func ed25519Key() async  -> String?
    
    func enableBackups() async throws 
    
    func enableRecovery(waitForBackupsToUpload: Bool, passphrase: String?, progressListener: EnableRecoveryProgressListener) async throws  -> String
    
    func isLastDevice() async throws  -> Bool
    
    func recover(recoveryKey: String) async throws 
    
    func recoverAndReset(oldRecoveryKey: String) async throws  -> String
    
    func recoveryState()  -> RecoveryState
    
    func recoveryStateListener(listener: RecoveryStateListener)  -> TaskHandle
    
    /**
     * Completely reset the current user's crypto identity: reset the cross
     * signing keys, delete the existing backup and recovery key.
     */
    func resetIdentity() async throws  -> IdentityResetHandle?
    
    func resetRecoveryKey() async throws  -> String
    
    /**
     * Get the E2EE identity of a user.
     *
     * This method always tries to fetch the identity from the store, which we
     * only have if the user is tracked, meaning that we are both members
     * of the same encrypted room. If no user is found locally, a request will
     * be made to the homeserver.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user that the identity belongs to.
     *
     * Returns a `UserIdentity` if one is found. Returns an error if there
     * was an issue with the crypto store or with the request to the
     * homeserver.
     *
     * This will always return `None` if the client hasn't been logged in.
     */
    func userIdentity(userId: String) async throws  -> UserIdentity?
    
    func verificationState()  -> VerificationState
    
    func verificationStateListener(listener: VerificationStateListener)  -> TaskHandle
    
    func waitForBackupUploadSteadyState(progressListener: BackupSteadyStateListener?) async throws 
    
    /**
     * Waits for end-to-end encryption initialization tasks to finish, if any
     * was running in the background.
     */
    func waitForE2eeInitializationTasks() async 
    
}

open class Encryption:
    EncryptionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_encryption(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_encryption(pointer, $0) }
    }

    

    
    /**
     * Does a backup exist on the server?
     *
     * Because the homeserver doesn't notify us about changes to the backup
     * version, the [`BackupState`] and its listener are a bit crippled.
     * The `BackupState::Unknown` state might mean there is no backup at all or
     * a backup exists but we don't have access to it.
     *
     * Therefore it is necessary to poll the server for an answer every time
     * you want to differentiate between those two states.
     */
open func backupExistsOnServer()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func backupState() -> BackupState {
    return try!  FfiConverterTypeBackupState.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func backupStateListener(listener: BackupStateListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceBackupStateListener.lower(listener),$0
    )
})
}
    
    /**
     * Get the public curve25519 key of our own device in base64. This is
     * usually what is called the identity key of the device.
     */
open func curve25519Key()async  -> String? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: nil
            
        )
}
    
open func disableRecovery()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRecoveryError.lift
        )
}
    
    /**
     * Get the public ed25519 key of our own device. This is usually what is
     * called the fingerprint of the device.
     */
open func ed25519Key()async  -> String? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: nil
            
        )
}
    
open func enableBackups()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRecoveryError.lift
        )
}
    
open func enableRecovery(waitForBackupsToUpload: Bool, passphrase: String?, progressListener: EnableRecoveryProgressListener)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(waitForBackupsToUpload),FfiConverterOptionString.lower(passphrase),FfiConverterCallbackInterfaceEnableRecoveryProgressListener.lower(progressListener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeRecoveryError.lift
        )
}
    
open func isLastDevice()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeRecoveryError.lift
        )
}
    
open func recover(recoveryKey: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_recover(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(recoveryKey)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRecoveryError.lift
        )
}
    
open func recoverAndReset(oldRecoveryKey: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(oldRecoveryKey)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeRecoveryError.lift
        )
}
    
open func recoveryState() -> RecoveryState {
    return try!  FfiConverterTypeRecoveryState.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func recoveryStateListener(listener: RecoveryStateListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceRecoveryStateListener.lower(listener),$0
    )
})
}
    
    /**
     * Completely reset the current user's crypto identity: reset the cross
     * signing keys, delete the existing backup and recovery key.
     */
open func resetIdentity()async throws  -> IdentityResetHandle? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeIdentityResetHandle.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func resetRecoveryKey()async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeRecoveryError.lift
        )
}
    
    /**
     * Get the E2EE identity of a user.
     *
     * This method always tries to fetch the identity from the store, which we
     * only have if the user is tracked, meaning that we are both members
     * of the same encrypted room. If no user is found locally, a request will
     * be made to the homeserver.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user that the identity belongs to.
     *
     * Returns a `UserIdentity` if one is found. Returns an error if there
     * was an issue with the crypto store or with the request to the
     * homeserver.
     *
     * This will always return `None` if the client hasn't been logged in.
     */
open func userIdentity(userId: String)async throws  -> UserIdentity? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUserIdentity.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func verificationState() -> VerificationState {
    return try!  FfiConverterTypeVerificationState.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func verificationStateListener(listener: VerificationStateListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceVerificationStateListener.lower(listener),$0
    )
})
}
    
open func waitForBackupUploadSteadyState(progressListener: BackupSteadyStateListener?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(
                    self.uniffiClonePointer(),
                    FfiConverterOptionCallbackInterfaceBackupSteadyStateListener.lower(progressListener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSteadyStateError.lift
        )
}
    
    /**
     * Waits for end-to-end encryption initialization tasks to finish, if any
     * was running in the background.
     */
open func waitForE2eeInitializationTasks()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

public struct FfiConverterTypeEncryption: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Encryption

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Encryption {
        return Encryption(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Encryption) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Encryption {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Encryption, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeEncryption_lift(_ pointer: UnsafeMutableRawPointer) throws -> Encryption {
    return try FfiConverterTypeEncryption.lift(pointer)
}

public func FfiConverterTypeEncryption_lower(_ value: Encryption) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEncryption.lower(value)
}




public protocol HomeserverLoginDetailsProtocol : AnyObject {
    
    /**
     * The sliding sync version.
     */
    func slidingSyncVersion()  -> SlidingSyncVersion
    
    /**
     * The prompts advertised by the authentication issuer for use in the login
     * URL.
     */
    func supportedOidcPrompts()  -> [OidcPrompt]
    
    /**
     * Whether the current homeserver supports login using OIDC.
     */
    func supportsOidcLogin()  -> Bool
    
    /**
     * Whether the current homeserver supports the password login flow.
     */
    func supportsPasswordLogin()  -> Bool
    
    /**
     * The URL of the currently configured homeserver.
     */
    func url()  -> String
    
}

open class HomeserverLoginDetails:
    HomeserverLoginDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(pointer, $0) }
    }

    

    
    /**
     * The sliding sync version.
     */
open func slidingSyncVersion() -> SlidingSyncVersion {
    return try!  FfiConverterTypeSlidingSyncVersion.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The prompts advertised by the authentication issuer for use in the login
     * URL.
     */
open func supportedOidcPrompts() -> [OidcPrompt] {
    return try!  FfiConverterSequenceTypeOidcPrompt.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Whether the current homeserver supports login using OIDC.
     */
open func supportsOidcLogin() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Whether the current homeserver supports the password login flow.
     */
open func supportsPasswordLogin() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The URL of the currently configured homeserver.
     */
open func url() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeHomeserverLoginDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeserverLoginDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeserverLoginDetails {
        return HomeserverLoginDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeserverLoginDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeserverLoginDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeserverLoginDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeHomeserverLoginDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeserverLoginDetails {
    return try FfiConverterTypeHomeserverLoginDetails.lift(pointer)
}

public func FfiConverterTypeHomeserverLoginDetails_lower(_ value: HomeserverLoginDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeserverLoginDetails.lower(value)
}




public protocol IdentityResetHandleProtocol : AnyObject {
    
    /**
     * Get the underlying [`CrossSigningResetAuthType`] this identity reset
     * process is using.
     */
    func authType()  -> CrossSigningResetAuthType
    
    func cancel() async 
    
    /**
     * This method starts the identity reset process and
     * will go through the following steps:
     *
     * 1. Disable backing up room keys and delete the active backup
     * 2. Disable recovery and delete secret storage
     * 3. Go through the cross-signing key reset flow
     * 4. Finally, re-enable key backups only if they were enabled before
     */
    func reset(auth: AuthData?) async throws 
    
}

open class IdentityResetHandle:
    IdentityResetHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_identityresethandle(pointer, $0) }
    }

    

    
    /**
     * Get the underlying [`CrossSigningResetAuthType`] this identity reset
     * process is using.
     */
open func authType() -> CrossSigningResetAuthType {
    return try!  FfiConverterTypeCrossSigningResetAuthType.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(self.uniffiClonePointer(),$0
    )
})
}
    
open func cancel()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * This method starts the identity reset process and
     * will go through the following steps:
     *
     * 1. Disable backing up room keys and delete the active backup
     * 2. Disable recovery and delete secret storage
     * 3. Go through the cross-signing key reset flow
     * 4. Finally, re-enable key backups only if they were enabled before
     */
open func reset(auth: AuthData?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(
                    self.uniffiClonePointer(),
                    FfiConverterOptionTypeAuthData.lower(auth)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeIdentityResetHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IdentityResetHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IdentityResetHandle {
        return IdentityResetHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IdentityResetHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityResetHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IdentityResetHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeIdentityResetHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> IdentityResetHandle {
    return try FfiConverterTypeIdentityResetHandle.lift(pointer)
}

public func FfiConverterTypeIdentityResetHandle_lower(_ value: IdentityResetHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIdentityResetHandle.lower(value)
}




public protocol InReplyToDetailsProtocol : AnyObject {
    
    func event()  -> RepliedToEventDetails
    
    func eventId()  -> String
    
}

open class InReplyToDetails:
    InReplyToDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(pointer, $0) }
    }

    

    
open func event() -> RepliedToEventDetails {
    return try!  FfiConverterTypeRepliedToEventDetails.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(self.uniffiClonePointer(),$0
    )
})
}
    
open func eventId() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeInReplyToDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InReplyToDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InReplyToDetails {
        return InReplyToDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InReplyToDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InReplyToDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InReplyToDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeInReplyToDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> InReplyToDetails {
    return try FfiConverterTypeInReplyToDetails.lift(pointer)
}

public func FfiConverterTypeInReplyToDetails_lower(_ value: InReplyToDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInReplyToDetails.lower(value)
}




/**
 * A set of actions to perform for a knock request.
 */
public protocol KnockRequestActionsProtocol : AnyObject {
    
    /**
     * Accepts the knock request by inviting the user to the room.
     */
    func accept() async throws 
    
    /**
     * Declines the knock request by kicking the user from the room with an
     * optional reason.
     */
    func decline(reason: String?) async throws 
    
    /**
     * Declines the knock request by banning the user from the room with an
     * optional reason.
     */
    func declineAndBan(reason: String?) async throws 
    
    /**
     * Marks the knock request as 'seen'.
     *
     * **IMPORTANT**: this won't update the current reference to this request,
     * a new one with the updated value should be emitted instead.
     */
    func markAsSeen() async throws 
    
}

/**
 * A set of actions to perform for a knock request.
 */
open class KnockRequestActions:
    KnockRequestActionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(pointer, $0) }
    }

    

    
    /**
     * Accepts the knock request by inviting the user to the room.
     */
open func accept()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Declines the knock request by kicking the user from the room with an
     * optional reason.
     */
open func decline(reason: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Declines the knock request by banning the user from the room with an
     * optional reason.
     */
open func declineAndBan(reason: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Marks the knock request as 'seen'.
     *
     * **IMPORTANT**: this won't update the current reference to this request,
     * a new one with the updated value should be emitted instead.
     */
open func markAsSeen()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeKnockRequestActions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = KnockRequestActions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> KnockRequestActions {
        return KnockRequestActions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: KnockRequestActions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KnockRequestActions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: KnockRequestActions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeKnockRequestActions_lift(_ pointer: UnsafeMutableRawPointer) throws -> KnockRequestActions {
    return try FfiConverterTypeKnockRequestActions.lift(pointer)
}

public func FfiConverterTypeKnockRequestActions_lower(_ value: KnockRequestActions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKnockRequestActions.lower(value)
}




/**
 * Wrapper to retrieve some timeline item info lazily.
 */
public protocol LazyTimelineItemProviderProtocol : AnyObject {
    
    /**
     * Returns some debug information for this event timeline item.
     */
    func debugInfo()  -> EventTimelineItemDebugInfo
    
    /**
     * For local echoes, return the associated send handle; returns `None` for
     * remote echoes.
     */
    func getSendHandle()  -> SendHandle?
    
    /**
     * Returns the shields for this event timeline item.
     */
    func getShields(strict: Bool)  -> ShieldState?
    
}

/**
 * Wrapper to retrieve some timeline item info lazily.
 */
open class LazyTimelineItemProvider:
    LazyTimelineItemProviderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(pointer, $0) }
    }

    

    
    /**
     * Returns some debug information for this event timeline item.
     */
open func debugInfo() -> EventTimelineItemDebugInfo {
    return try!  FfiConverterTypeEventTimelineItemDebugInfo.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * For local echoes, return the associated send handle; returns `None` for
     * remote echoes.
     */
open func getSendHandle() -> SendHandle? {
    return try!  FfiConverterOptionTypeSendHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the shields for this event timeline item.
     */
open func getShields(strict: Bool) -> ShieldState? {
    return try!  FfiConverterOptionTypeShieldState.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(self.uniffiClonePointer(),
        FfiConverterBool.lower(strict),$0
    )
})
}
    

}

public struct FfiConverterTypeLazyTimelineItemProvider: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LazyTimelineItemProvider

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LazyTimelineItemProvider {
        return LazyTimelineItemProvider(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LazyTimelineItemProvider) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LazyTimelineItemProvider {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LazyTimelineItemProvider, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeLazyTimelineItemProvider_lift(_ pointer: UnsafeMutableRawPointer) throws -> LazyTimelineItemProvider {
    return try FfiConverterTypeLazyTimelineItemProvider.lift(pointer)
}

public func FfiConverterTypeLazyTimelineItemProvider_lower(_ value: LazyTimelineItemProvider) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLazyTimelineItemProvider.lower(value)
}




/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
public protocol MediaFileHandleProtocol : AnyObject {
    
    /**
     * Get the media file's path.
     */
    func path() throws  -> String
    
    func persist(path: String) throws  -> Bool
    
}

/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
open class MediaFileHandle:
    MediaFileHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(pointer, $0) }
    }

    

    
    /**
     * Get the media file's path.
     */
open func path()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(self.uniffiClonePointer(),$0
    )
})
}
    
open func persist(path: String)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(self.uniffiClonePointer(),
        FfiConverterString.lower(path),$0
    )
})
}
    

}

public struct FfiConverterTypeMediaFileHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MediaFileHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaFileHandle {
        return MediaFileHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MediaFileHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaFileHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MediaFileHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMediaFileHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaFileHandle {
    return try FfiConverterTypeMediaFileHandle.lift(pointer)
}

public func FfiConverterTypeMediaFileHandle_lower(_ value: MediaFileHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMediaFileHandle.lower(value)
}




public protocol MediaSourceProtocol : AnyObject {
    
    func toJson()  -> String
    
    func url()  -> String
    
}

open class MediaSource:
    MediaSourceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_mediasource(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_mediasource(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> MediaSource {
    return try  FfiConverterTypeMediaSource.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
public static func fromUrl(url: String)throws  -> MediaSource {
    return try  FfiConverterTypeMediaSource.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(
        FfiConverterString.lower(url),$0
    )
})
}
    

    
open func toJson() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func url() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_mediasource_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeMediaSource: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MediaSource

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaSource {
        return MediaSource(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MediaSource) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaSource {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MediaSource, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMediaSource_lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaSource {
    return try FfiConverterTypeMediaSource.lift(pointer)
}

public func FfiConverterTypeMediaSource_lower(_ value: MediaSource) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMediaSource.lower(value)
}




public protocol NotificationClientProtocol : AnyObject {
    
    /**
     * See also documentation of
     * `MatrixNotificationClient::get_notification`.
     */
    func getNotification(roomId: String, eventId: String) async throws  -> NotificationItem?
    
}

open class NotificationClient:
    NotificationClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_notificationclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_notificationclient(pointer, $0) }
    }

    

    
    /**
     * See also documentation of
     * `MatrixNotificationClient::get_notification`.
     */
open func getNotification(roomId: String, eventId: String)async throws  -> NotificationItem? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomId),FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeNotificationItem.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeNotificationClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotificationClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationClient {
        return NotificationClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotificationClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotificationClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNotificationClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationClient {
    return try FfiConverterTypeNotificationClient.lift(pointer)
}

public func FfiConverterTypeNotificationClient_lower(_ value: NotificationClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotificationClient.lower(value)
}




public protocol NotificationSettingsProtocol : AnyObject {
    
    /**
     * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    func canHomeserverPushEncryptedEventToDevice() async  -> Bool
    
    /**
     * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    func canPushEncryptedEventToDevice() async  -> Bool
    
    /**
     * Get whether some enabled keyword rules exist.
     */
    func containsKeywordsRules() async  -> Bool
    
    /**
     * Get the default room notification mode
     *
     * The mode will depend on the associated `PushRule` based on whether the
     * room is encrypted or not, and on the number of members.
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chats involving two
     * people
     */
    func getDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool) async  -> RoomNotificationMode
    
    /**
     * Get the notification settings for a room.
     *
     * # Arguments
     *
     * * `room_id` - the room ID
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    func getRoomNotificationSettings(roomId: String, isEncrypted: Bool, isOneToOne: Bool) async throws  -> RoomNotificationSettings
    
    /**
     * Get all room IDs for which a user-defined rule exists.
     */
    func getRoomsWithUserDefinedRules(enabled: Bool?) async  -> [String]
    
    /**
     * Get the user defined room notification mode
     */
    func getUserDefinedRoomNotificationMode(roomId: String) async throws  -> RoomNotificationMode?
    
    /**
     * Get whether the `.m.rule.call` push rule is enabled
     */
    func isCallEnabled() async throws  -> Bool
    
    /**
     * Get whether the `.m.rule.invite_for_me` push rule is enabled
     */
    func isInviteForMeEnabled() async throws  -> Bool
    
    /**
     * Get whether room mentions are enabled.
     */
    func isRoomMentionEnabled() async throws  -> Bool
    
    /**
     * Get whether user mentions are enabled.
     */
    func isUserMentionEnabled() async throws  -> Bool
    
    /**
     * Restore the default notification mode for a room
     */
    func restoreDefaultRoomNotificationMode(roomId: String) async throws 
    
    /**
     * Set whether the `.m.rule.call` push rule is enabled
     */
    func setCallEnabled(enabled: Bool) async throws 
    
    /**
     * Set the default room notification mode
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the mode is for encrypted rooms
     * * `is_one_to_one` - whether the mode is for direct chats involving two
     * people
     * * `mode` - the new default mode
     */
    func setDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool, mode: RoomNotificationMode) async throws 
    
    func setDelegate(delegate: NotificationSettingsDelegate?) 
    
    /**
     * Set whether the `.m.rule.invite_for_me` push rule is enabled
     */
    func setInviteForMeEnabled(enabled: Bool) async throws 
    
    /**
     * Set whether room mentions are enabled.
     */
    func setRoomMentionEnabled(enabled: Bool) async throws 
    
    /**
     * Set the notification mode for a room.
     */
    func setRoomNotificationMode(roomId: String, mode: RoomNotificationMode) async throws 
    
    /**
     * Set whether user mentions are enabled.
     */
    func setUserMentionEnabled(enabled: Bool) async throws 
    
    /**
     * Unmute a room.
     *
     * # Arguments
     *
     * * `room_id` - the room to unmute
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    func unmuteRoom(roomId: String, isEncrypted: Bool, isOneToOne: Bool) async throws 
    
}

open class NotificationSettings:
    NotificationSettingsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_notificationsettings(pointer, $0) }
    }

    

    
    /**
     * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
open func canHomeserverPushEncryptedEventToDevice()async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
open func canPushEncryptedEventToDevice()async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get whether some enabled keyword rules exist.
     */
open func containsKeywordsRules()async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get the default room notification mode
     *
     * The mode will depend on the associated `PushRule` based on whether the
     * room is encrypted or not, and on the number of members.
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chats involving two
     * people
     */
open func getDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool)async  -> RoomNotificationMode {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isEncrypted),FfiConverterBool.lower(isOneToOne)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomNotificationMode.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get the notification settings for a room.
     *
     * # Arguments
     *
     * * `room_id` - the room ID
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
open func getRoomNotificationSettings(roomId: String, isEncrypted: Bool, isOneToOne: Bool)async throws  -> RoomNotificationSettings {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomId),FfiConverterBool.lower(isEncrypted),FfiConverterBool.lower(isOneToOne)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomNotificationSettings.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Get all room IDs for which a user-defined rule exists.
     */
open func getRoomsWithUserDefinedRules(enabled: Bool?)async  -> [String] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
                    self.uniffiClonePointer(),
                    FfiConverterOptionBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get the user defined room notification mode
     */
open func getUserDefinedRoomNotificationMode(roomId: String)async throws  -> RoomNotificationMode? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeRoomNotificationMode.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Get whether the `.m.rule.call` push rule is enabled
     */
open func isCallEnabled()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Get whether the `.m.rule.invite_for_me` push rule is enabled
     */
open func isInviteForMeEnabled()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Get whether room mentions are enabled.
     */
open func isRoomMentionEnabled()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Get whether user mentions are enabled.
     */
open func isUserMentionEnabled()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Restore the default notification mode for a room
     */
open func restoreDefaultRoomNotificationMode(roomId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Set whether the `.m.rule.call` push rule is enabled
     */
open func setCallEnabled(enabled: Bool)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Set the default room notification mode
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the mode is for encrypted rooms
     * * `is_one_to_one` - whether the mode is for direct chats involving two
     * people
     * * `mode` - the new default mode
     */
open func setDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool, mode: RoomNotificationMode)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isEncrypted),FfiConverterBool.lower(isOneToOne),FfiConverterTypeRoomNotificationMode.lower(mode)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
open func setDelegate(delegate: NotificationSettingsDelegate?) {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(self.uniffiClonePointer(),
        FfiConverterOptionCallbackInterfaceNotificationSettingsDelegate.lower(delegate),$0
    )
}
}
    
    /**
     * Set whether the `.m.rule.invite_for_me` push rule is enabled
     */
open func setInviteForMeEnabled(enabled: Bool)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Set whether room mentions are enabled.
     */
open func setRoomMentionEnabled(enabled: Bool)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Set the notification mode for a room.
     */
open func setRoomNotificationMode(roomId: String, mode: RoomNotificationMode)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomId),FfiConverterTypeRoomNotificationMode.lower(mode)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Set whether user mentions are enabled.
     */
open func setUserMentionEnabled(enabled: Bool)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    
    /**
     * Unmute a room.
     *
     * # Arguments
     *
     * * `room_id` - the room to unmute
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
open func unmuteRoom(roomId: String, isEncrypted: Bool, isOneToOne: Bool)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(roomId),FfiConverterBool.lower(isEncrypted),FfiConverterBool.lower(isOneToOne)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError.lift
        )
}
    

}

public struct FfiConverterTypeNotificationSettings: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NotificationSettings

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationSettings {
        return NotificationSettings(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NotificationSettings) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationSettings {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NotificationSettings, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNotificationSettings_lift(_ pointer: UnsafeMutableRawPointer) throws -> NotificationSettings {
    return try FfiConverterTypeNotificationSettings.lift(pointer)
}

public func FfiConverterTypeNotificationSettings_lower(_ value: NotificationSettings) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNotificationSettings.lower(value)
}




/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
public protocol QrCodeDataProtocol : AnyObject {
    
}

/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
open class QrCodeData:
    QrCodeDataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_qrcodedata(pointer, $0) }
    }

    
    /**
     * Attempt to decode a slice of bytes into a [`QrCodeData`] object.
     *
     * The slice of bytes would generally be returned by a QR code decoder.
     */
public static func fromBytes(bytes: Data)throws  -> QrCodeData {
    return try  FfiConverterTypeQrCodeData.lift(try rustCallWithError(FfiConverterTypeQrCodeDecodeError.lift) {
    uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    

    

}

public struct FfiConverterTypeQrCodeData: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = QrCodeData

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> QrCodeData {
        return QrCodeData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: QrCodeData) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCodeData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: QrCodeData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeQrCodeData_lift(_ pointer: UnsafeMutableRawPointer) throws -> QrCodeData {
    return try FfiConverterTypeQrCodeData.lift(pointer)
}

public func FfiConverterTypeQrCodeData_lower(_ value: QrCodeData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeQrCodeData.lower(value)
}




public protocol RoomProtocol : AnyObject {
    
    func activeMembersCount()  -> UInt64
    
    /**
     * Returns a Vec of userId's that participate in the room call.
     *
     * MatrixRTC memberships with application "m.call" and scope "m.room" are
     * considered. A user can occur twice if they join with two devices.
     * convert to a set depending if the different users are required or the
     * amount of sessions.
     *
     * The vector is ordered by oldest membership user to newest.
     */
    func activeRoomCallParticipants()  -> [String]
    
    func alternativeAliases()  -> [String]
    
    func applyPowerLevelChanges(changes: RoomPowerLevelChanges) async throws 
    
    func avatarUrl()  -> String?
    
    func banUser(userId: String, reason: String?) async throws 
    
    func canUserBan(userId: String) async throws  -> Bool
    
    func canUserInvite(userId: String) async throws  -> Bool
    
    func canUserKick(userId: String) async throws  -> Bool
    
    func canUserPinUnpin(userId: String) async throws  -> Bool
    
    func canUserRedactOther(userId: String) async throws  -> Bool
    
    func canUserRedactOwn(userId: String) async throws  -> Bool
    
    func canUserSendMessage(userId: String, message: MessageLikeEventType) async throws  -> Bool
    
    func canUserSendState(userId: String, stateEvent: StateEventType) async throws  -> Bool
    
    func canUserTriggerRoomNotification(userId: String) async throws  -> Bool
    
    func canonicalAlias()  -> String?
    
    /**
     * Remove the `ComposerDraft` stored in the state store for this room.
     */
    func clearComposerDraft() async throws 
    
    /**
     * Clear the event cache storage for the current room.
     *
     * This will remove all the information related to the event cache, in
     * memory and in the persisted storage, if enabled.
     */
    func clearEventCacheStorage() async throws 
    
    /**
     * Forces the currently active room key, which is used to encrypt messages,
     * to be rotated.
     *
     * A new room key will be crated and shared with all the room members the
     * next time a message will be sent. You don't have to call this method,
     * room keys will be rotated automatically when necessary. This method is
     * still useful for debugging purposes.
     */
    func discardRoomKey() async throws 
    
    /**
     * Returns the room's name from the state event if available, otherwise
     * compute a room name based on the room's nature (DM or not) and number of
     * members.
     */
    func displayName()  -> String?
    
    /**
     * Edit an event given its event id.
     *
     * Useful outside the context of a timeline, or when a timeline doesn't
     * have the full content of an event.
     */
    func edit(eventId: String, newContent: RoomMessageEventContentWithoutRelation) async throws 
    
    /**
     * Enable or disable the send queue for that particular room.
     */
    func enableSendQueue(enable: Bool) 
    
    func getPowerLevels() async throws  -> RoomPowerLevels
    
    /**
     * Is there a non expired membership with application "m.call" and scope
     * "m.room" in this room.
     */
    func hasActiveRoomCall()  -> Bool
    
    /**
     * Returns the room heroes for this room.
     */
    func heroes()  -> [RoomHero]
    
    func id()  -> String
    
    /**
     * Set the local trust for the given devices to `LocalTrust::Ignored`
     * and resend messages that failed to send because said devices are
     * unverified (in response to
     * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
     * # Arguments
     *
     * * `devices` - The map of users identifiers to device identifiers
     * received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    func ignoreDeviceTrustAndResend(devices: [String: [String]], sendHandle: SendHandle) async throws 
    
    /**
     * Ignores a user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user to ignore.
     */
    func ignoreUser(userId: String) async throws 
    
    func inviteUserById(userId: String) async throws 
    
    func invitedMembersCount()  -> UInt64
    
    /**
     * For rooms one is invited to, retrieves the room member information for
     * the user who invited the logged-in user to a room.
     */
    func inviter() async  -> RoomMember?
    
    func isDirect()  -> Bool
    
    func isEncrypted() throws  -> Bool
    
    func isPublic()  -> Bool
    
    /**
     * Returns whether the send queue for that particular room is enabled or
     * not.
     */
    func isSendQueueEnabled()  -> Bool
    
    func isSpace()  -> Bool
    
    func isTombstoned()  -> Bool
    
    /**
     * Join this room.
     *
     * Only invited and left rooms can be joined via this method.
     */
    func join() async throws 
    
    func joinedMembersCount()  -> UInt64
    
    func kickUser(userId: String, reason: String?) async throws 
    
    /**
     * Leave this room.
     *
     * Only invited and joined rooms can be left.
     */
    func leave() async throws 
    
    /**
     * Retrieve the `ComposerDraft` stored in the state store for this room.
     */
    func loadComposerDraft() async throws  -> ComposerDraft?
    
    /**
     * Mark a room as read, by attaching a read receipt on the latest event.
     *
     * Note: this does NOT unset the unread flag; it's the caller's
     * responsibility to do so, if needs be.
     */
    func markAsRead(receiptType: ReceiptType) async throws 
    
    func matrixToEventPermalink(eventId: String) async throws  -> String
    
    func matrixToPermalink() async throws  -> String
    
    func member(userId: String) async throws  -> RoomMember
    
    func memberAvatarUrl(userId: String) async throws  -> String?
    
    func memberDisplayName(userId: String) async throws  -> String?
    
    func members() async throws  -> RoomMembersIterator
    
    func membersNoSync() async throws  -> RoomMembersIterator
    
    func membership()  -> Membership
    
    /**
     * A timeline instance that can be configured to only include RoomMessage
     * type events and filter those further based on their message type.
     *
     * Virtual timeline items will still be provided and the
     * `default_event_filter` will be applied before everything else.
     *
     * # Arguments
     *
     * * `internal_id_prefix` - An optional String that will be prepended to
     * all the timeline item's internal IDs, making it possible to
     * distinguish different timeline instances from each other.
     *
     * * `allowed_message_types` - A list of `RoomMessageEventMessageType` that
     * will be allowed to appear in the timeline
     */
    func messageFilteredTimeline(internalIdPrefix: String?, allowedMessageTypes: [RoomMessageEventMessageType], dateDividerMode: DateDividerMode) async throws  -> Timeline
    
    func ownUserId()  -> String
    
    func pinnedEventsTimeline(internalIdPrefix: String?, maxEventsToLoad: UInt16, maxConcurrentRequests: UInt16) async throws  -> Timeline
    
    /**
     * The raw name as present in the room state event.
     */
    func rawName()  -> String?
    
    /**
     * Redacts an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to redact
     *
     * * `reason` - The reason for the event being redacted (optional). its
     * transaction ID (optional). If not given one is created.
     */
    func redact(eventId: String, reason: String?) async throws 
    
    /**
     * Removes the current room avatar
     */
    func removeAvatar() async throws 
    
    /**
     * Reports an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to report
     *
     * * `reason` - The reason for the event being reported (optional).
     *
     * * `score` - The score to rate this content as where -100 is most
     * offensive and 0 is inoffensive (optional).
     */
    func reportContent(eventId: String, score: Int32?, reason: String?) async throws 
    
    func resetPowerLevels() async throws  -> RoomPowerLevels
    
    /**
     * Return a debug representation for the internal room events data
     * structure, one line per entry in the resulting vector.
     */
    func roomEventsDebugString() async throws  -> [String]
    
    func roomInfo() async throws  -> RoomInfo
    
    /**
     * Store the given `ComposerDraft` in the state store using the current
     * room id, as identifier.
     */
    func saveComposerDraft(draft: ComposerDraft) async throws 
    
    /**
     * Send a call notification event in the current room.
     *
     * This is only supposed to be used in **custom** situations where the user
     * explicitly chooses to send a `m.call.notify` event to invite/notify
     * someone explicitly in unusual conditions. The default should be to
     * use `send_call_notification_if_necessary` just before a new room call is
     * created/joined.
     *
     * One example could be that the UI allows to start a call with a subset of
     * users of the room members first. And then later on the user can
     * invite more users to the call.
     */
    func sendCallNotification(callId: String, application: RtcApplicationType, notifyType: NotifyType, mentions: Mentions) async throws 
    
    /**
     * This will only send a call notification event if appropriate.
     *
     * This function is supposed to be called whenever the user creates a room
     * call. It will send a `m.call.notify` event if:
     * - there is not yet a running call.
     *
     * It will configure the notify type: ring or notify based on:
     * - is this a DM room -> ring
     * - is this a group with more than one other member -> notify
     */
    func sendCallNotificationIfNeeded() async throws 
    
    /**
     * Send a raw event to the room.
     *
     * # Arguments
     *
     * * `event_type` - The type of the event to send.
     *
     * * `content` - The content of the event to send encoded as JSON string.
     */
    func sendRaw(eventType: String, content: String) async throws 
    
    func setIsFavourite(isFavourite: Bool, tagOrder: Double?) async throws 
    
    func setIsLowPriority(isLowPriority: Bool, tagOrder: Double?) async throws 
    
    /**
     * Sets a new name to the room.
     */
    func setName(name: String) async throws 
    
    /**
     * Sets a new topic in the room.
     */
    func setTopic(topic: String) async throws 
    
    /**
     * Set (or unset) a flag on the room to indicate that the user has
     * explicitly marked it as unread.
     */
    func setUnreadFlag(newValue: Bool) async throws 
    
    func subscribeToIdentityStatusChanges(listener: IdentityStatusChangeListener)  -> TaskHandle
    
    /**
     * Subscribes to requests to join this room (knock member events), using a
     * `listener` to be notified of the changes.
     *
     * The current requests to join the room will be emitted immediately
     * when subscribing, along with a [`TaskHandle`] to cancel the
     * subscription.
     */
    func subscribeToKnockRequests(listener: KnockRequestsListener) async throws  -> TaskHandle
    
    func subscribeToRoomInfoUpdates(listener: RoomInfoListener)  -> TaskHandle
    
    func subscribeToTypingNotifications(listener: TypingNotificationsListener)  -> TaskHandle
    
    func suggestedRoleForUser(userId: String) async throws  -> RoomMemberRole
    
    func timeline() async throws  -> Timeline
    
    /**
     * Returns a timeline focused on the given event.
     *
     * Note: this timeline is independent from that returned with
     * [`Self::timeline`], and as such it is not cached.
     */
    func timelineFocusedOnEvent(eventId: String, numContextEvents: UInt16, internalIdPrefix: String?) async throws  -> Timeline
    
    func topic()  -> String?
    
    func typingNotice(isTyping: Bool) async throws 
    
    func unbanUser(userId: String, reason: String?) async throws 
    
    func updatePowerLevelsForUsers(updates: [UserPowerLevelUpdate]) async throws 
    
    /**
     * Upload and set the room's avatar.
     *
     * This will upload the data produced by the reader to the homeserver's
     * content repository, and set the room's avatar to the MXC URI for the
     * uploaded file.
     *
     * # Arguments
     *
     * * `mime_type` - The mime description of the avatar, for example
     * image/jpeg
     * * `data` - The raw data that will be uploaded to the homeserver's
     * content repository
     * * `media_info` - The media info used as avatar image info.
     */
    func uploadAvatar(mimeType: String, data: Data, mediaInfo: ImageInfo?) async throws 
    
    /**
     * Remove verification requirements for the given users and
     * resend messages that failed to send because their identities were no
     * longer verified (in response to
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
     *
     * # Arguments
     *
     * * `user_ids` - The list of users identifiers received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    func withdrawVerificationAndResend(userIds: [String], sendHandle: SendHandle) async throws 
    
}

open class Room:
    RoomProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_room(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_room(pointer, $0) }
    }

    

    
open func activeMembersCount() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns a Vec of userId's that participate in the room call.
     *
     * MatrixRTC memberships with application "m.call" and scope "m.room" are
     * considered. A user can occur twice if they join with two devices.
     * convert to a set depending if the different users are required or the
     * amount of sessions.
     *
     * The vector is ordered by oldest membership user to newest.
     */
open func activeRoomCallParticipants() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(self.uniffiClonePointer(),$0
    )
})
}
    
open func alternativeAliases() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(self.uniffiClonePointer(),$0
    )
})
}
    
open func applyPowerLevelChanges(changes: RoomPowerLevelChanges)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRoomPowerLevelChanges_lower(changes)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func avatarUrl() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(self.uniffiClonePointer(),$0
    )
})
}
    
open func banUser(userId: String, reason: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_ban_user(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canUserBan(userId: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_ban(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canUserInvite(userId: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_invite(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canUserKick(userId: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_kick(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canUserPinUnpin(userId: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_pin_unpin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canUserRedactOther(userId: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_other(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canUserRedactOwn(userId: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_own(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canUserSendMessage(userId: String, message: MessageLikeEventType)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_message(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId),FfiConverterTypeMessageLikeEventType.lower(message)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canUserSendState(userId: String, stateEvent: StateEventType)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_state(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId),FfiConverterTypeStateEventType.lower(stateEvent)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canUserTriggerRoomNotification(userId: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_can_user_trigger_room_notification(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func canonicalAlias() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Remove the `ComposerDraft` stored in the state store for this room.
     */
open func clearComposerDraft()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Clear the event cache storage for the current room.
     *
     * This will remove all the information related to the event cache, in
     * memory and in the persisted storage, if enabled.
     */
open func clearEventCacheStorage()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Forces the currently active room key, which is used to encrypt messages,
     * to be rotated.
     *
     * A new room key will be crated and shared with all the room members the
     * next time a message will be sent. You don't have to call this method,
     * room keys will be rotated automatically when necessary. This method is
     * still useful for debugging purposes.
     */
open func discardRoomKey()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Returns the room's name from the state event if available, otherwise
     * compute a room name based on the room's nature (DM or not) and number of
     * members.
     */
open func displayName() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_display_name(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Edit an event given its event id.
     *
     * Useful outside the context of a timeline, or when a timeline doesn't
     * have the full content of an event.
     */
open func edit(eventId: String, newContent: RoomMessageEventContentWithoutRelation)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_edit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventId),FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(newContent)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Enable or disable the send queue for that particular room.
     */
open func enableSendQueue(enable: Bool) {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(self.uniffiClonePointer(),
        FfiConverterBool.lower(enable),$0
    )
}
}
    
open func getPowerLevels()async throws  -> RoomPowerLevels {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomPowerLevels.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Is there a non expired membership with application "m.call" and scope
     * "m.room" in this room.
     */
open func hasActiveRoomCall() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the room heroes for this room.
     */
open func heroes() -> [RoomHero] {
    return try!  FfiConverterSequenceTypeRoomHero.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_heroes(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Set the local trust for the given devices to `LocalTrust::Ignored`
     * and resend messages that failed to send because said devices are
     * unverified (in response to
     * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
     * # Arguments
     *
     * * `devices` - The map of users identifiers to device identifiers
     * received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
open func ignoreDeviceTrustAndResend(devices: [String: [String]], sendHandle: SendHandle)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(
                    self.uniffiClonePointer(),
                    FfiConverterDictionaryStringSequenceString.lower(devices),FfiConverterTypeSendHandle.lower(sendHandle)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Ignores a user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user to ignore.
     */
open func ignoreUser(userId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func inviteUserById(userId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func invitedMembersCount() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * For rooms one is invited to, retrieves the room member information for
     * the user who invited the logged-in user to a room.
     */
open func inviter()async  -> RoomMember? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_inviter(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeRoomMember.lift,
            errorHandler: nil
            
        )
}
    
open func isDirect() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_is_direct(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEncrypted()throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(self.uniffiClonePointer(),$0
    )
})
}
    
open func isPublic() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_is_public(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns whether the send queue for that particular room is enabled or
     * not.
     */
open func isSendQueueEnabled() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(self.uniffiClonePointer(),$0
    )
})
}
    
open func isSpace() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_is_space(self.uniffiClonePointer(),$0
    )
})
}
    
open func isTombstoned() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_is_tombstoned(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Join this room.
     *
     * Only invited and left rooms can be joined via this method.
     */
open func join()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_join(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func joinedMembersCount() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(self.uniffiClonePointer(),$0
    )
})
}
    
open func kickUser(userId: String, reason: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_kick_user(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Leave this room.
     *
     * Only invited and joined rooms can be left.
     */
open func leave()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_leave(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Retrieve the `ComposerDraft` stored in the state store for this room.
     */
open func loadComposerDraft()async throws  -> ComposerDraft? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeComposerDraft.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Mark a room as read, by attaching a read receipt on the latest event.
     *
     * Note: this does NOT unset the unread flag; it's the caller's
     * responsibility to do so, if needs be.
     */
open func markAsRead(receiptType: ReceiptType)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(
                    self.uniffiClonePointer(),
                    FfiConverterTypeReceiptType.lower(receiptType)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func matrixToEventPermalink(eventId: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func matrixToPermalink()async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func member(userId: String)async throws  -> RoomMember {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_member(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomMember.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func memberAvatarUrl(userId: String)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func memberDisplayName(userId: String)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func members()async throws  -> RoomMembersIterator {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_members(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoomMembersIterator.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func membersNoSync()async throws  -> RoomMembersIterator {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoomMembersIterator.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func membership() -> Membership {
    return try!  FfiConverterTypeMembership.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_membership(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * A timeline instance that can be configured to only include RoomMessage
     * type events and filter those further based on their message type.
     *
     * Virtual timeline items will still be provided and the
     * `default_event_filter` will be applied before everything else.
     *
     * # Arguments
     *
     * * `internal_id_prefix` - An optional String that will be prepended to
     * all the timeline item's internal IDs, making it possible to
     * distinguish different timeline instances from each other.
     *
     * * `allowed_message_types` - A list of `RoomMessageEventMessageType` that
     * will be allowed to appear in the timeline
     */
open func messageFilteredTimeline(internalIdPrefix: String?, allowedMessageTypes: [RoomMessageEventMessageType], dateDividerMode: DateDividerMode)async throws  -> Timeline {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_message_filtered_timeline(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(internalIdPrefix),FfiConverterSequenceTypeRoomMessageEventMessageType.lower(allowedMessageTypes),FfiConverterTypeDateDividerMode.lower(dateDividerMode)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeTimeline.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func ownUserId() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func pinnedEventsTimeline(internalIdPrefix: String?, maxEventsToLoad: UInt16, maxConcurrentRequests: UInt16)async throws  -> Timeline {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_pinned_events_timeline(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(internalIdPrefix),FfiConverterUInt16.lower(maxEventsToLoad),FfiConverterUInt16.lower(maxConcurrentRequests)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeTimeline.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * The raw name as present in the room state event.
     */
open func rawName() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_raw_name(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Redacts an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to redact
     *
     * * `reason` - The reason for the event being redacted (optional). its
     * transaction ID (optional). If not given one is created.
     */
open func redact(eventId: String, reason: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_redact(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Removes the current room avatar
     */
open func removeAvatar()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Reports an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to report
     *
     * * `reason` - The reason for the event being reported (optional).
     *
     * * `score` - The score to rate this content as where -100 is most
     * offensive and 0 is inoffensive (optional).
     */
open func reportContent(eventId: String, score: Int32?, reason: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_report_content(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventId),FfiConverterOptionInt32.lower(score),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func resetPowerLevels()async throws  -> RoomPowerLevels {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomPowerLevels.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Return a debug representation for the internal room events data
     * structure, one line per entry in the resulting vector.
     */
open func roomEventsDebugString()async throws  -> [String] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func roomInfo()async throws  -> RoomInfo {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_room_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomInfo.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Store the given `ComposerDraft` in the state store using the current
     * room id, as identifier.
     */
open func saveComposerDraft(draft: ComposerDraft)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(
                    self.uniffiClonePointer(),
                    FfiConverterTypeComposerDraft.lower(draft)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Send a call notification event in the current room.
     *
     * This is only supposed to be used in **custom** situations where the user
     * explicitly chooses to send a `m.call.notify` event to invite/notify
     * someone explicitly in unusual conditions. The default should be to
     * use `send_call_notification_if_necessary` just before a new room call is
     * created/joined.
     *
     * One example could be that the UI allows to start a call with a subset of
     * users of the room members first. And then later on the user can
     * invite more users to the call.
     */
open func sendCallNotification(callId: String, application: RtcApplicationType, notifyType: NotifyType, mentions: Mentions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(callId),FfiConverterTypeRtcApplicationType.lower(application),FfiConverterTypeNotifyType.lower(notifyType),FfiConverterTypeMentions.lower(mentions)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * This will only send a call notification event if appropriate.
     *
     * This function is supposed to be called whenever the user creates a room
     * call. It will send a `m.call.notify` event if:
     * - there is not yet a running call.
     *
     * It will configure the notify type: ring or notify based on:
     * - is this a DM room -> ring
     * - is this a group with more than one other member -> notify
     */
open func sendCallNotificationIfNeeded()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification_if_needed(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Send a raw event to the room.
     *
     * # Arguments
     *
     * * `event_type` - The type of the event to send.
     *
     * * `content` - The content of the event to send encoded as JSON string.
     */
open func sendRaw(eventType: String, content: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_send_raw(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventType),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setIsFavourite(isFavourite: Bool, tagOrder: Double?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isFavourite),FfiConverterOptionDouble.lower(tagOrder)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setIsLowPriority(isLowPriority: Bool, tagOrder: Double?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isLowPriority),FfiConverterOptionDouble.lower(tagOrder)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Sets a new name to the room.
     */
open func setName(name: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Sets a new topic in the room.
     */
open func setTopic(topic: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_topic(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(topic)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Set (or unset) a flag on the room to indicate that the user has
     * explicitly marked it as unread.
     */
open func setUnreadFlag(newValue: Bool)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(newValue)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func subscribeToIdentityStatusChanges(listener: IdentityStatusChangeListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceIdentityStatusChangeListener.lower(listener),$0
    )
})
}
    
    /**
     * Subscribes to requests to join this room (knock member events), using a
     * `listener` to be notified of the changes.
     *
     * The current requests to join the room will be emitted immediately
     * when subscribing, along with a [`TaskHandle`] to cancel the
     * subscription.
     */
open func subscribeToKnockRequests(listener: KnockRequestsListener)async throws  -> TaskHandle {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceKnockRequestsListener.lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeTaskHandle.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func subscribeToRoomInfoUpdates(listener: RoomInfoListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceRoomInfoListener.lower(listener),$0
    )
})
}
    
open func subscribeToTypingNotifications(listener: TypingNotificationsListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceTypingNotificationsListener.lower(listener),$0
    )
})
}
    
open func suggestedRoleForUser(userId: String)async throws  -> RoomMemberRole {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomMemberRole_lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func timeline()async throws  -> Timeline {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_timeline(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeTimeline.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Returns a timeline focused on the given event.
     *
     * Note: this timeline is independent from that returned with
     * [`Self::timeline`], and as such it is not cached.
     */
open func timelineFocusedOnEvent(eventId: String, numContextEvents: UInt16, internalIdPrefix: String?)async throws  -> Timeline {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_timeline_focused_on_event(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventId),FfiConverterUInt16.lower(numContextEvents),FfiConverterOptionString.lower(internalIdPrefix)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeTimeline.lift,
            errorHandler: FfiConverterTypeFocusEventError.lift
        )
}
    
open func topic() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_topic(self.uniffiClonePointer(),$0
    )
})
}
    
open func typingNotice(isTyping: Bool)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(isTyping)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func unbanUser(userId: String, reason: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_unban_user(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(userId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func updatePowerLevelsForUsers(updates: [UserPowerLevelUpdate])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeUserPowerLevelUpdate.lower(updates)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Upload and set the room's avatar.
     *
     * This will upload the data produced by the reader to the homeserver's
     * content repository, and set the room's avatar to the MXC URI for the
     * uploaded file.
     *
     * # Arguments
     *
     * * `mime_type` - The mime description of the avatar, for example
     * image/jpeg
     * * `data` - The raw data that will be uploaded to the homeserver's
     * content repository
     * * `media_info` - The media info used as avatar image info.
     */
open func uploadAvatar(mimeType: String, data: Data, mediaInfo: ImageInfo?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(mimeType),FfiConverterData.lower(data),FfiConverterOptionTypeImageInfo.lower(mediaInfo)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Remove verification requirements for the given users and
     * resend messages that failed to send because their identities were no
     * longer verified (in response to
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
     *
     * # Arguments
     *
     * * `user_ids` - The list of users identifiers received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
open func withdrawVerificationAndResend(userIds: [String], sendHandle: SendHandle)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(userIds),FfiConverterTypeSendHandle.lower(sendHandle)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeRoom: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Room

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Room {
        return Room(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Room) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Room {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Room, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoom_lift(_ pointer: UnsafeMutableRawPointer) throws -> Room {
    return try FfiConverterTypeRoom.lift(pointer)
}

public func FfiConverterTypeRoom_lower(_ value: Room) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoom.lower(value)
}




/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
public protocol RoomDirectorySearchProtocol : AnyObject {
    
    /**
     * Get whether the search is at the last page.
     */
    func isAtLastPage() async throws  -> Bool
    
    /**
     * Get the number of pages that have been loaded so far.
     */
    func loadedPages() async throws  -> UInt32
    
    /**
     * Asks the server for the next page of the current search.
     */
    func nextPage() async throws 
    
    /**
     * Registers a callback to receive new search results when starting a
     * search or getting new paginated results.
     */
    func results(listener: RoomDirectorySearchEntriesListener) async  -> TaskHandle
    
    /**
     * Starts a filtered search for the server.
     *
     * If the `filter` is not provided it will search for all the rooms.
     * You can specify a `batch_size` to control the number of rooms to fetch
     * per request.
     *
     * If the `via_server` is not provided it will search in the current
     * homeserver by default.
     *
     * This method will clear the current search results and start a new one.
     */
    func search(filter: String?, batchSize: UInt32, viaServerName: String?) async throws 
    
}

/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
open class RoomDirectorySearch:
    RoomDirectorySearchProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(pointer, $0) }
    }

    

    
    /**
     * Get whether the search is at the last page.
     */
open func isAtLastPage()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Get the number of pages that have been loaded so far.
     */
open func loadedPages()async throws  -> UInt32 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u32,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u32,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Asks the server for the next page of the current search.
     */
open func nextPage()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Registers a callback to receive new search results when starting a
     * search or getting new paginated results.
     */
open func results(listener: RoomDirectorySearchEntriesListener)async  -> TaskHandle {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener.lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeTaskHandle.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Starts a filtered search for the server.
     *
     * If the `filter` is not provided it will search for all the rooms.
     * You can specify a `batch_size` to control the number of rooms to fetch
     * per request.
     *
     * If the `via_server` is not provided it will search in the current
     * homeserver by default.
     *
     * This method will clear the current search results and start a new one.
     */
open func search(filter: String?, batchSize: UInt32, viaServerName: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(filter),FfiConverterUInt32.lower(batchSize),FfiConverterOptionString.lower(viaServerName)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeRoomDirectorySearch: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomDirectorySearch

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomDirectorySearch {
        return RoomDirectorySearch(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomDirectorySearch) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomDirectorySearch {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomDirectorySearch, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoomDirectorySearch_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomDirectorySearch {
    return try FfiConverterTypeRoomDirectorySearch.lift(pointer)
}

public func FfiConverterTypeRoomDirectorySearch_lower(_ value: RoomDirectorySearch) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomDirectorySearch.lower(value)
}




public protocol RoomListProtocol : AnyObject {
    
    func entriesWithDynamicAdapters(pageSize: UInt32, listener: RoomListEntriesListener)  -> RoomListEntriesWithDynamicAdaptersResult
    
    func loadingState(listener: RoomListLoadingStateListener) throws  -> RoomListLoadingStateResult
    
    func room(roomId: String) throws  -> RoomListItem
    
}

open class RoomList:
    RoomListProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomlist(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlist(pointer, $0) }
    }

    

    
open func entriesWithDynamicAdapters(pageSize: UInt32, listener: RoomListEntriesListener) -> RoomListEntriesWithDynamicAdaptersResult {
    return try!  FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(pageSize),
        FfiConverterCallbackInterfaceRoomListEntriesListener.lower(listener),$0
    )
})
}
    
open func loadingState(listener: RoomListLoadingStateListener)throws  -> RoomListLoadingStateResult {
    return try  FfiConverterTypeRoomListLoadingStateResult.lift(try rustCallWithError(FfiConverterTypeRoomListError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceRoomListLoadingStateListener.lower(listener),$0
    )
})
}
    
open func room(roomId: String)throws  -> RoomListItem {
    return try  FfiConverterTypeRoomListItem.lift(try rustCallWithError(FfiConverterTypeRoomListError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlist_room(self.uniffiClonePointer(),
        FfiConverterString.lower(roomId),$0
    )
})
}
    

}

public struct FfiConverterTypeRoomList: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomList

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomList {
        return RoomList(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomList) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomList {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomList, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoomList_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomList {
    return try FfiConverterTypeRoomList.lift(pointer)
}

public func FfiConverterTypeRoomList_lower(_ value: RoomList) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomList.lower(value)
}




public protocol RoomListDynamicEntriesControllerProtocol : AnyObject {
    
    func addOnePage() 
    
    func resetToOnePage() 
    
    func setFilter(kind: RoomListEntriesDynamicFilterKind)  -> Bool
    
}

open class RoomListDynamicEntriesController:
    RoomListDynamicEntriesControllerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(pointer, $0) }
    }

    

    
open func addOnePage() {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(self.uniffiClonePointer(),$0
    )
}
}
    
open func resetToOnePage() {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(self.uniffiClonePointer(),$0
    )
}
}
    
open func setFilter(kind: RoomListEntriesDynamicFilterKind) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(self.uniffiClonePointer(),
        FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(kind),$0
    )
})
}
    

}

public struct FfiConverterTypeRoomListDynamicEntriesController: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomListDynamicEntriesController

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListDynamicEntriesController {
        return RoomListDynamicEntriesController(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomListDynamicEntriesController) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListDynamicEntriesController {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomListDynamicEntriesController, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoomListDynamicEntriesController_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListDynamicEntriesController {
    return try FfiConverterTypeRoomListDynamicEntriesController.lift(pointer)
}

public func FfiConverterTypeRoomListDynamicEntriesController_lower(_ value: RoomListDynamicEntriesController) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomListDynamicEntriesController.lower(value)
}




public protocol RoomListEntriesWithDynamicAdaptersResultProtocol : AnyObject {
    
    func controller()  -> RoomListDynamicEntriesController
    
    func entriesStream()  -> TaskHandle
    
}

open class RoomListEntriesWithDynamicAdaptersResult:
    RoomListEntriesWithDynamicAdaptersResultProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(pointer, $0) }
    }

    

    
open func controller() -> RoomListDynamicEntriesController {
    return try!  FfiConverterTypeRoomListDynamicEntriesController.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(self.uniffiClonePointer(),$0
    )
})
}
    
open func entriesStream() -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomListEntriesWithDynamicAdaptersResult

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListEntriesWithDynamicAdaptersResult {
        return RoomListEntriesWithDynamicAdaptersResult(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomListEntriesWithDynamicAdaptersResult) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesWithDynamicAdaptersResult {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomListEntriesWithDynamicAdaptersResult, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListEntriesWithDynamicAdaptersResult {
    return try FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(pointer)
}

public func FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult_lower(_ value: RoomListEntriesWithDynamicAdaptersResult) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lower(value)
}




public protocol RoomListItemProtocol : AnyObject {
    
    func avatarUrl()  -> String?
    
    func canonicalAlias()  -> String?
    
    /**
     * Returns the room's name from the state event if available, otherwise
     * compute a room name based on the room's nature (DM or not) and number of
     * members.
     */
    func displayName()  -> String?
    
    /**
     * Build a full `Room` FFI object, filling its associated timeline.
     *
     * An error will be returned if the room is a state different than joined
     * or if its internal timeline hasn't been initialized.
     */
    func fullRoom() throws  -> Room
    
    func id()  -> String
    
    /**
     * Initializes the timeline for this room using the provided parameters.
     *
     * * `event_type_filter` - An optional [`TimelineEventTypeFilter`] to be
     * used to filter timeline events besides the default timeline filter. If
     * `None` is passed, only the default timeline filter will be used.
     * * `internal_id_prefix` - An optional String that will be prepended to
     * all the timeline item's internal IDs, making it possible to
     * distinguish different timeline instances from each other.
     */
    func initTimeline(eventTypeFilter: TimelineEventTypeFilter?, internalIdPrefix: String?) async throws 
    
    /**
     * Builds a `Room` FFI from an invited room without initializing its
     * internal timeline.
     *
     * An error will be returned if the room is a state different than invited.
     *
     * ⚠️ Holding on to this room instance after it has been joined is not
     * safe. Use `full_room` instead.
     */
    func invitedRoom() throws  -> Room
    
    func isDirect()  -> Bool
    
    /**
     * Checks whether the room is encrypted or not.
     *
     * **Note**: this info may not be reliable if you don't set up
     * `m.room.encryption` as required state.
     */
    func isEncrypted() async  -> Bool
    
    /**
     * Checks whether the Room's timeline has been initialized before.
     */
    func isTimelineInitialized()  -> Bool
    
    func latestEvent() async  -> EventTimelineItem?
    
    /**
     * The room's current membership state.
     */
    func membership()  -> Membership
    
    /**
     * Builds a `RoomPreview` from a room list item. This is intended for
     * invited or knocked rooms.
     *
     * An error will be returned if the room is in a state other than invited
     * or knocked.
     */
    func previewRoom(via: [String]) async throws  -> RoomPreview
    
    func roomInfo() async throws  -> RoomInfo
    
}

open class RoomListItem:
    RoomListItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomlistitem(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistitem(pointer, $0) }
    }

    

    
open func avatarUrl() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_avatar_url(self.uniffiClonePointer(),$0
    )
})
}
    
open func canonicalAlias() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_canonical_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the room's name from the state event if available, otherwise
     * compute a room name based on the room's nature (DM or not) and number of
     * members.
     */
open func displayName() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_display_name(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Build a full `Room` FFI object, filling its associated timeline.
     *
     * An error will be returned if the room is a state different than joined
     * or if its internal timeline hasn't been initialized.
     */
open func fullRoom()throws  -> Room {
    return try  FfiConverterTypeRoom.lift(try rustCallWithError(FfiConverterTypeRoomListError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_full_room(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Initializes the timeline for this room using the provided parameters.
     *
     * * `event_type_filter` - An optional [`TimelineEventTypeFilter`] to be
     * used to filter timeline events besides the default timeline filter. If
     * `None` is passed, only the default timeline filter will be used.
     * * `internal_id_prefix` - An optional String that will be prepended to
     * all the timeline item's internal IDs, making it possible to
     * distinguish different timeline instances from each other.
     */
open func initTimeline(eventTypeFilter: TimelineEventTypeFilter?, internalIdPrefix: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomlistitem_init_timeline(
                    self.uniffiClonePointer(),
                    FfiConverterOptionTypeTimelineEventTypeFilter.lower(eventTypeFilter),FfiConverterOptionString.lower(internalIdPrefix)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRoomListError.lift
        )
}
    
    /**
     * Builds a `Room` FFI from an invited room without initializing its
     * internal timeline.
     *
     * An error will be returned if the room is a state different than invited.
     *
     * ⚠️ Holding on to this room instance after it has been joined is not
     * safe. Use `full_room` instead.
     */
open func invitedRoom()throws  -> Room {
    return try  FfiConverterTypeRoom.lift(try rustCallWithError(FfiConverterTypeRoomListError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_invited_room(self.uniffiClonePointer(),$0
    )
})
}
    
open func isDirect() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_direct(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Checks whether the room is encrypted or not.
     *
     * **Note**: this info may not be reliable if you don't set up
     * `m.room.encryption` as required state.
     */
open func isEncrypted()async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_encrypted(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Checks whether the Room's timeline has been initialized before.
     */
open func isTimelineInitialized() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_is_timeline_initialized(self.uniffiClonePointer(),$0
    )
})
}
    
open func latestEvent()async  -> EventTimelineItem? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomlistitem_latest_event(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeEventTimelineItem.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * The room's current membership state.
     */
open func membership() -> Membership {
    return try!  FfiConverterTypeMembership.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistitem_membership(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Builds a `RoomPreview` from a room list item. This is intended for
     * invited or knocked rooms.
     *
     * An error will be returned if the room is in a state other than invited
     * or knocked.
     */
open func previewRoom(via: [String])async throws  -> RoomPreview {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomlistitem_preview_room(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(via)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoomPreview.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func roomInfo()async throws  -> RoomInfo {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomlistitem_room_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomInfo.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeRoomListItem: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomListItem

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListItem {
        return RoomListItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomListItem) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomListItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoomListItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListItem {
    return try FfiConverterTypeRoomListItem.lift(pointer)
}

public func FfiConverterTypeRoomListItem_lower(_ value: RoomListItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomListItem.lower(value)
}




public protocol RoomListServiceProtocol : AnyObject {
    
    func allRooms() async throws  -> RoomList
    
    func room(roomId: String) throws  -> RoomListItem
    
    func state(listener: RoomListServiceStateListener)  -> TaskHandle
    
    func subscribeToRooms(roomIds: [String]) throws 
    
    func syncIndicator(delayBeforeShowingInMs: UInt32, delayBeforeHidingInMs: UInt32, listener: RoomListServiceSyncIndicatorListener)  -> TaskHandle
    
}

open class RoomListService:
    RoomListServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistservice(pointer, $0) }
    }

    

    
open func allRooms()async throws  -> RoomList {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRoomList.lift,
            errorHandler: FfiConverterTypeRoomListError.lift
        )
}
    
open func room(roomId: String)throws  -> RoomListItem {
    return try  FfiConverterTypeRoomListItem.lift(try rustCallWithError(FfiConverterTypeRoomListError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(self.uniffiClonePointer(),
        FfiConverterString.lower(roomId),$0
    )
})
}
    
open func state(listener: RoomListServiceStateListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceRoomListServiceStateListener.lower(listener),$0
    )
})
}
    
open func subscribeToRooms(roomIds: [String])throws  {try rustCallWithError(FfiConverterTypeRoomListError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(roomIds),$0
    )
}
}
    
open func syncIndicator(delayBeforeShowingInMs: UInt32, delayBeforeHidingInMs: UInt32, listener: RoomListServiceSyncIndicatorListener) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(delayBeforeShowingInMs),
        FfiConverterUInt32.lower(delayBeforeHidingInMs),
        FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener.lower(listener),$0
    )
})
}
    

}

public struct FfiConverterTypeRoomListService: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomListService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListService {
        return RoomListService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomListService) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomListService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoomListService_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomListService {
    return try FfiConverterTypeRoomListService.lift(pointer)
}

public func FfiConverterTypeRoomListService_lower(_ value: RoomListService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomListService.lower(value)
}




public protocol RoomMembersIteratorProtocol : AnyObject {
    
    func len()  -> UInt32
    
    func nextChunk(chunkSize: UInt32)  -> [RoomMember]?
    
}

open class RoomMembersIterator:
    RoomMembersIteratorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(pointer, $0) }
    }

    

    
open func len() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(self.uniffiClonePointer(),$0
    )
})
}
    
open func nextChunk(chunkSize: UInt32) -> [RoomMember]? {
    return try!  FfiConverterOptionSequenceTypeRoomMember.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chunkSize),$0
    )
})
}
    

}

public struct FfiConverterTypeRoomMembersIterator: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomMembersIterator

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMembersIterator {
        return RoomMembersIterator(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomMembersIterator) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMembersIterator {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomMembersIterator, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoomMembersIterator_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMembersIterator {
    return try FfiConverterTypeRoomMembersIterator.lift(pointer)
}

public func FfiConverterTypeRoomMembersIterator_lower(_ value: RoomMembersIterator) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomMembersIterator.lower(value)
}




public protocol RoomMessageEventContentWithoutRelationProtocol : AnyObject {
    
    func withMentions(mentions: Mentions)  -> RoomMessageEventContentWithoutRelation
    
}

open class RoomMessageEventContentWithoutRelation:
    RoomMessageEventContentWithoutRelationProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(pointer, $0) }
    }

    

    
open func withMentions(mentions: Mentions) -> RoomMessageEventContentWithoutRelation {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(self.uniffiClonePointer(),
        FfiConverterTypeMentions.lower(mentions),$0
    )
})
}
    

}

public struct FfiConverterTypeRoomMessageEventContentWithoutRelation: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomMessageEventContentWithoutRelation

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMessageEventContentWithoutRelation {
        return RoomMessageEventContentWithoutRelation(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomMessageEventContentWithoutRelation) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMessageEventContentWithoutRelation {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomMessageEventContentWithoutRelation, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMessageEventContentWithoutRelation {
    return try FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(pointer)
}

public func FfiConverterTypeRoomMessageEventContentWithoutRelation_lower(_ value: RoomMessageEventContentWithoutRelation) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(value)
}




/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
public protocol RoomPreviewProtocol : AnyObject {
    
    /**
     * Returns the room info the preview contains.
     */
    func info() throws  -> RoomPreviewInfo
    
    /**
     * Get the user who created the invite, if any.
     */
    func inviter() async  -> RoomMember?
    
    /**
     * Leave the room if the room preview state is either joined, invited or
     * knocked.
     *
     * Will return an error otherwise.
     */
    func leave() async throws 
    
}

/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
open class RoomPreview:
    RoomPreviewProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roompreview(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roompreview(pointer, $0) }
    }

    

    
    /**
     * Returns the room info the preview contains.
     */
open func info()throws  -> RoomPreviewInfo {
    return try  FfiConverterTypeRoomPreviewInfo.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompreview_info(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the user who created the invite, if any.
     */
open func inviter()async  -> RoomMember? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeRoomMember.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Leave the room if the room preview state is either joined, invited or
     * knocked.
     *
     * Will return an error otherwise.
     */
open func leave()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeRoomPreview: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomPreview

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomPreview {
        return RoomPreview(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomPreview) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPreview {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomPreview, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRoomPreview_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomPreview {
    return try FfiConverterTypeRoomPreview.lift(pointer)
}

public func FfiConverterTypeRoomPreview_lower(_ value: RoomPreview) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomPreview.lower(value)
}




public protocol SendAttachmentJoinHandleProtocol : AnyObject {
    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */
    func cancel() 
    
    /**
     * Wait until the attachment has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
    func join() async throws 
    
}

open class SendAttachmentJoinHandle:
    SendAttachmentJoinHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(pointer, $0) }
    }

    

    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */
open func cancel() {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Wait until the attachment has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
open func join()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRoomError.lift
        )
}
    

}

public struct FfiConverterTypeSendAttachmentJoinHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SendAttachmentJoinHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SendAttachmentJoinHandle {
        return SendAttachmentJoinHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SendAttachmentJoinHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendAttachmentJoinHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SendAttachmentJoinHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSendAttachmentJoinHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> SendAttachmentJoinHandle {
    return try FfiConverterTypeSendAttachmentJoinHandle.lift(pointer)
}

public func FfiConverterTypeSendAttachmentJoinHandle_lower(_ value: SendAttachmentJoinHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSendAttachmentJoinHandle.lower(value)
}




/**
 * A handle to perform actions onto a local echo.
 */
public protocol SendHandleProtocol : AnyObject {
    
    /**
     * Try to abort the sending of the current event.
     *
     * If this returns `true`, then the sending could be aborted, because the
     * event hasn't been sent yet. Otherwise, if this returns `false`, the
     * event had already been sent and could not be aborted.
     *
     * This has an effect only on the first call; subsequent calls will always
     * return `false`.
     */
    func abort() async throws  -> Bool
    
    /**
     * Attempt to manually resend messages that failed to send due to issues
     * that should now have been fixed.
     *
     * This is useful for example, when there's a
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
     * the user may have re-verified on a different device and would now
     * like to send the failed message that's waiting on this device.
     *
     * # Arguments
     *
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo that should be unwedged.
     */
    func tryResend() async throws 
    
}

/**
 * A handle to perform actions onto a local echo.
 */
open class SendHandle:
    SendHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sendhandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sendhandle(pointer, $0) }
    }

    

    
    /**
     * Try to abort the sending of the current event.
     *
     * If this returns `true`, then the sending could be aborted, because the
     * event hasn't been sent yet. Otherwise, if this returns `false`, the
     * event had already been sent and could not be aborted.
     *
     * This has an effect only on the first call; subsequent calls will always
     * return `false`.
     */
open func abort()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Attempt to manually resend messages that failed to send due to issues
     * that should now have been fixed.
     *
     * This is useful for example, when there's a
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
     * the user may have re-verified on a different device and would now
     * like to send the failed message that's waiting on this device.
     *
     * # Arguments
     *
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo that should be unwedged.
     */
open func tryResend()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeSendHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SendHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SendHandle {
        return SendHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SendHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SendHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSendHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> SendHandle {
    return try FfiConverterTypeSendHandle.lift(pointer)
}

public func FfiConverterTypeSendHandle_lower(_ value: SendHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSendHandle.lower(value)
}




public protocol SessionVerificationControllerProtocol : AnyObject {
    
    /**
     * Accept the previously acknowledged verification request
     */
    func acceptVerificationRequest() async throws 
    
    /**
     * Set this particular request as the currently active one and register for
     * events pertaining it.
     * * `sender_id` - The user requesting verification.
     * * `flow_id` - - The ID that uniquely identifies the verification flow.
     */
    func acknowledgeVerificationRequest(senderId: String, flowId: String) async throws 
    
    /**
     * Confirm that the short auth strings match on both sides.
     */
    func approveVerification() async throws 
    
    /**
     * Cancel the current verification request
     */
    func cancelVerification() async throws 
    
    /**
     * Reject the short auth string
     */
    func declineVerification() async throws 
    
    /**
     * Request verification for the current device
     */
    func requestVerification() async throws 
    
    func setDelegate(delegate: SessionVerificationControllerDelegate?) 
    
    /**
     * Transition the current verification request into a SAS verification
     * flow.
     */
    func startSasVerification() async throws 
    
}

open class SessionVerificationController:
    SessionVerificationControllerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(pointer, $0) }
    }

    

    
    /**
     * Accept the previously acknowledged verification request
     */
open func acceptVerificationRequest()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Set this particular request as the currently active one and register for
     * events pertaining it.
     * * `sender_id` - The user requesting verification.
     * * `flow_id` - - The ID that uniquely identifies the verification flow.
     */
open func acknowledgeVerificationRequest(senderId: String, flowId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(senderId),FfiConverterString.lower(flowId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Confirm that the short auth strings match on both sides.
     */
open func approveVerification()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Cancel the current verification request
     */
open func cancelVerification()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Reject the short auth string
     */
open func declineVerification()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Request verification for the current device
     */
open func requestVerification()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_verification(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func setDelegate(delegate: SessionVerificationControllerDelegate?) {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(self.uniffiClonePointer(),
        FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate.lower(delegate),$0
    )
}
}
    
    /**
     * Transition the current verification request into a SAS verification
     * flow.
     */
open func startSasVerification()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeSessionVerificationController: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationController

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationController {
        return SessionVerificationController(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationController) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationController {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationController, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSessionVerificationController_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationController {
    return try FfiConverterTypeSessionVerificationController.lift(pointer)
}

public func FfiConverterTypeSessionVerificationController_lower(_ value: SessionVerificationController) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionVerificationController.lower(value)
}




public protocol SessionVerificationEmojiProtocol : AnyObject {
    
    func description()  -> String
    
    func symbol()  -> String
    
}

open class SessionVerificationEmoji:
    SessionVerificationEmojiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(pointer, $0) }
    }

    

    
open func description() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(self.uniffiClonePointer(),$0
    )
})
}
    
open func symbol() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeSessionVerificationEmoji: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationEmoji

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationEmoji {
        return SessionVerificationEmoji(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationEmoji) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationEmoji {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationEmoji, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSessionVerificationEmoji_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationEmoji {
    return try FfiConverterTypeSessionVerificationEmoji.lift(pointer)
}

public func FfiConverterTypeSessionVerificationEmoji_lower(_ value: SessionVerificationEmoji) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionVerificationEmoji.lower(value)
}




public protocol SpanProtocol : AnyObject {
    
    func enter() 
    
    func exit() 
    
    func isNone()  -> Bool
    
}

open class Span:
    SpanProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_span(self.pointer, $0) }
    }
    /**
     * Create a span originating at the given callsite (file, line and column).
     *
     * The target should be something like a module path, and can be referenced
     * in the filter string given to `setup_tracing`. `level` and `target`
     * for a callsite are fixed at the first creation of a span for that
     * callsite and can not be changed afterwards, i.e. the level and
     * target passed for second and following creation of a span with the same
     * callsite will be ignored.
     *
     * This function leaks a little bit of memory for each unique (file +
     * line + level + target + name) it is called with. Please make sure that
     * the number of different combinations of those parameters this can be
     * called with is constant in the final executable.
     *
     * For a span to have an effect, you must `.enter()` it at the start of a
     * logical unit of work and `.exit()` it at the end of the same (including
     * on failure). Entering registers the span in thread-local storage, so
     * future calls to `log_event` on the same thread are able to attach the
     * events they create to the span, exiting unregisters it. For this to
     * work, exiting a span must be done on the same thread where it was
     * entered. It is possible to enter a span on multiple threads, in which
     * case it should also be exited on all of them individually; that is,
     * unless you *want* the span to be attached to all further events created
     * on that thread.
     */
public convenience init(file: String, line: UInt32?, level: LogLevel, target: String, name: String) {
    let pointer =
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_span_new(
        FfiConverterString.lower(file),
        FfiConverterOptionUInt32.lower(line),
        FfiConverterTypeLogLevel.lower(level),
        FfiConverterString.lower(target),
        FfiConverterString.lower(name),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_span(pointer, $0) }
    }

    
public static func current() -> Span {
    return try!  FfiConverterTypeSpan.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_span_current($0
    )
})
}
    

    
open func enter() {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_span_enter(self.uniffiClonePointer(),$0
    )
}
}
    
open func exit() {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_span_exit(self.uniffiClonePointer(),$0
    )
}
}
    
open func isNone() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_span_is_none(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeSpan: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Span

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Span {
        return Span(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Span) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Span {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Span, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSpan_lift(_ pointer: UnsafeMutableRawPointer) throws -> Span {
    return try FfiConverterTypeSpan.lift(pointer)
}

public func FfiConverterTypeSpan_lower(_ value: Span) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSpan.lower(value)
}




/**
 * An object encapsulating the SSO login flow
 */
public protocol SsoHandlerProtocol : AnyObject {
    
    /**
     * Completes the SSO login process.
     */
    func finish(callbackUrl: String) async throws 
    
    /**
     * Returns the URL for starting SSO authentication. The URL should be
     * opened in a web view. Once the web view succeeds, call `finish` with
     * the callback URL.
     */
    func url()  -> String
    
}

/**
 * An object encapsulating the SSO login flow
 */
open class SsoHandler:
    SsoHandlerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_ssohandler(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_ssohandler(pointer, $0) }
    }

    

    
    /**
     * Completes the SSO login process.
     */
open func finish(callbackUrl: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(callbackUrl)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSsoError.lift
        )
}
    
    /**
     * Returns the URL for starting SSO authentication. The URL should be
     * opened in a web view. Once the web view succeeds, call `finish` with
     * the callback URL.
     */
open func url() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeSsoHandler: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SsoHandler

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SsoHandler {
        return SsoHandler(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SsoHandler) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SsoHandler {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SsoHandler, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSsoHandler_lift(_ pointer: UnsafeMutableRawPointer) throws -> SsoHandler {
    return try FfiConverterTypeSsoHandler.lift(pointer)
}

public func FfiConverterTypeSsoHandler_lower(_ value: SsoHandler) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSsoHandler.lower(value)
}




public protocol SyncServiceProtocol : AnyObject {
    
    func roomListService()  -> RoomListService
    
    func start() async 
    
    func state(listener: SyncServiceStateObserver)  -> TaskHandle
    
    func stop() async throws 
    
}

open class SyncService:
    SyncServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_syncservice(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_syncservice(pointer, $0) }
    }

    

    
open func roomListService() -> RoomListService {
    return try!  FfiConverterTypeRoomListService.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(self.uniffiClonePointer(),$0
    )
})
}
    
open func start()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_syncservice_start(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func state(listener: SyncServiceStateObserver) -> TaskHandle {
    return try!  FfiConverterTypeTaskHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_syncservice_state(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceSyncServiceStateObserver.lower(listener),$0
    )
})
}
    
open func stop()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeSyncService: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncService {
        return SyncService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncService) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSyncService_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncService {
    return try FfiConverterTypeSyncService.lift(pointer)
}

public func FfiConverterTypeSyncService_lower(_ value: SyncService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncService.lower(value)
}




public protocol SyncServiceBuilderProtocol : AnyObject {
    
    func finish() async throws  -> SyncService
    
    func withCrossProcessLock()  -> SyncServiceBuilder
    
    func withUtdHook(delegate: UnableToDecryptDelegate) async  -> SyncServiceBuilder
    
}

open class SyncServiceBuilder:
    SyncServiceBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(pointer, $0) }
    }

    

    
open func finish()async throws  -> SyncService {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSyncService.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func withCrossProcessLock() -> SyncServiceBuilder {
    return try!  FfiConverterTypeSyncServiceBuilder.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(self.uniffiClonePointer(),$0
    )
})
}
    
open func withUtdHook(delegate: UnableToDecryptDelegate)async  -> SyncServiceBuilder {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_utd_hook(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceUnableToDecryptDelegate.lower(delegate)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSyncServiceBuilder.lift,
            errorHandler: nil
            
        )
}
    

}

public struct FfiConverterTypeSyncServiceBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncServiceBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncServiceBuilder {
        return SyncServiceBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncServiceBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncServiceBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncServiceBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSyncServiceBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncServiceBuilder {
    return try FfiConverterTypeSyncServiceBuilder.lift(pointer)
}

public func FfiConverterTypeSyncServiceBuilder_lower(_ value: SyncServiceBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncServiceBuilder.lower(value)
}




/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
public protocol TaskHandleProtocol : AnyObject {
    
    func cancel() 
    
    /**
     * Check whether the handle is finished.
     */
    func isFinished()  -> Bool
    
}

/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
open class TaskHandle:
    TaskHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_taskhandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_taskhandle(pointer, $0) }
    }

    

    
open func cancel() {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Check whether the handle is finished.
     */
open func isFinished() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeTaskHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TaskHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TaskHandle {
        return TaskHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TaskHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TaskHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTaskHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> TaskHandle {
    return try FfiConverterTypeTaskHandle.lift(pointer)
}

public func FfiConverterTypeTaskHandle_lower(_ value: TaskHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTaskHandle.lower(value)
}




public protocol TimelineProtocol : AnyObject {
    
    func addListener(listener: TimelineListener) async  -> TaskHandle
    
    func createMessageContent(msgType: MessageType)  -> RoomMessageEventContentWithoutRelation?
    
    func createPoll(question: String, answers: [String], maxSelections: UInt8, pollKind: PollKind) async throws 
    
    /**
     * Edits an event from the timeline.
     *
     * If it was a local event, this will *try* to edit it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending an edit request to the server.
     *
     * Returns whether the edit did happen. It can only return false for
     * local events that are being processed.
     */
    func edit(eventOrTransactionId: EventOrTransactionId, newContent: EditedContent) async throws 
    
    func endPoll(pollStartEventId: String, text: String) throws 
    
    func fetchDetailsForEvent(eventId: String) async throws 
    
    func fetchMembers() async 
    
    /**
     * Paginate forwards, when in focused mode.
     *
     * Returns whether we hit the end of the timeline or not.
     */
    func focusedPaginateForwards(numEvents: UInt16) async throws  -> Bool
    
    /**
     * Get the current timeline item for the given event ID, if any.
     *
     * Will return a remote event, *or* a local echo that has been sent but not
     * yet replaced by a remote echo.
     *
     * It's preferable to store the timeline items in the model for your UI, if
     * possible, instead of just storing IDs and coming back to the timeline
     * object to look up items.
     */
    func getEventTimelineItemByEventId(eventId: String) async throws  -> EventTimelineItem
    
    /**
     * Load the reply details for the given event id.
     *
     * This will return an `InReplyToDetails` object that contains the details
     * which will either be ready or an error.
     */
    func loadReplyDetails(eventIdStr: String) async throws  -> InReplyToDetails
    
    /**
     * Mark the room as read by trying to attach an *unthreaded* read receipt
     * to the latest room event.
     *
     * This works even if the latest event belongs to a thread, as a threaded
     * reply also belongs to the unthreaded timeline. No threaded receipt
     * will be sent here (see also #3123).
     */
    func markAsRead(receiptType: ReceiptType) async throws 
    
    /**
     * Paginate backwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the end of the timeline or not.
     */
    func paginateBackwards(numEvents: UInt16) async throws  -> Bool
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event containing the new event id.
     *
     * Returns `true` if we sent the request, `false` if the event was already
     * pinned.
     */
    func pinEvent(eventId: String) async throws  -> Bool
    
    /**
     * Redacts an event from the timeline.
     *
     * Only works for events that exist as timeline items.
     *
     * If it was a local event, this will *try* to cancel it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending a redaction request to the server.
     *
     * Will return an error if the event couldn't be redacted.
     */
    func redactEvent(eventOrTransactionId: EventOrTransactionId, reason: String?) async throws 
    
    func retryDecryption(sessionIds: [String]) 
    
    /**
     * Queues an event in the room's send queue so it's processed for
     * sending later.
     *
     * Returns an abort handle that allows to abort sending, if it hasn't
     * happened yet.
     */
    func send(msg: RoomMessageEventContentWithoutRelation) async throws  -> SendHandle
    
    func sendAudio(url: String, audioInfo: AudioInfo, caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool)  -> SendAttachmentJoinHandle
    
    func sendFile(url: String, fileInfo: FileInfo, caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool)  -> SendAttachmentJoinHandle
    
    func sendImage(url: String, thumbnailUrl: String?, imageInfo: ImageInfo, caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool)  -> SendAttachmentJoinHandle
    
    func sendLocation(body: String, geoUri: String, description: String?, zoomLevel: UInt8?, assetType: AssetType?) async 
    
    func sendPollResponse(pollStartEventId: String, answers: [String]) async throws 
    
    func sendReadReceipt(receiptType: ReceiptType, eventId: String) async throws 
    
    func sendReply(msg: RoomMessageEventContentWithoutRelation, eventId: String) async throws 
    
    func sendVideo(url: String, thumbnailUrl: String?, videoInfo: VideoInfo, caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool)  -> SendAttachmentJoinHandle
    
    func sendVoiceMessage(url: String, audioInfo: AudioInfo, waveform: [UInt16], caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool)  -> SendAttachmentJoinHandle
    
    func subscribeToBackPaginationStatus(listener: PaginationStatusListener) async throws  -> TaskHandle
    
    /**
     * Toggle a reaction on an event.
     *
     * Adds or redacts a reaction based on the state of the reaction at the
     * time it is called.
     *
     * This method works both on local echoes and remote items.
     *
     * When redacting a previous reaction, the redaction reason is not set.
     *
     * Ensures that only one reaction is sent at a time to avoid race
     * conditions and spamming the homeserver with requests.
     */
    func toggleReaction(itemId: EventOrTransactionId, key: String) async throws 
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event without the event id we want to remove.
     *
     * Returns `true` if we sent the request, `false` if the event wasn't
     * pinned
     */
    func unpinEvent(eventId: String) async throws  -> Bool
    
}

open class Timeline:
    TimelineProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_timeline(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timeline(pointer, $0) }
    }

    

    
open func addListener(listener: TimelineListener)async  -> TaskHandle {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceTimelineListener.lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeTaskHandle.lift,
            errorHandler: nil
            
        )
}
    
open func createMessageContent(msgType: MessageType) -> RoomMessageEventContentWithoutRelation? {
    return try!  FfiConverterOptionTypeRoomMessageEventContentWithoutRelation.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(self.uniffiClonePointer(),
        FfiConverterTypeMessageType.lower(msgType),$0
    )
})
}
    
open func createPoll(question: String, answers: [String], maxSelections: UInt8, pollKind: PollKind)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(question),FfiConverterSequenceString.lower(answers),FfiConverterUInt8.lower(maxSelections),FfiConverterTypePollKind.lower(pollKind)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Edits an event from the timeline.
     *
     * If it was a local event, this will *try* to edit it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending an edit request to the server.
     *
     * Returns whether the edit did happen. It can only return false for
     * local events that are being processed.
     */
open func edit(eventOrTransactionId: EventOrTransactionId, newContent: EditedContent)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_edit(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventOrTransactionId.lower(eventOrTransactionId),FfiConverterTypeEditedContent.lower(newContent)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func endPoll(pollStartEventId: String, text: String)throws  {try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(self.uniffiClonePointer(),
        FfiConverterString.lower(pollStartEventId),
        FfiConverterString.lower(text),$0
    )
}
}
    
open func fetchDetailsForEvent(eventId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func fetchMembers()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Paginate forwards, when in focused mode.
     *
     * Returns whether we hit the end of the timeline or not.
     */
open func focusedPaginateForwards(numEvents: UInt16)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_focused_paginate_forwards(
                    self.uniffiClonePointer(),
                    FfiConverterUInt16.lower(numEvents)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Get the current timeline item for the given event ID, if any.
     *
     * Will return a remote event, *or* a local echo that has been sent but not
     * yet replaced by a remote echo.
     *
     * It's preferable to store the timeline items in the model for your UI, if
     * possible, instead of just storing IDs and coming back to the timeline
     * object to look up items.
     */
open func getEventTimelineItemByEventId(eventId: String)async throws  -> EventTimelineItem {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEventTimelineItem.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Load the reply details for the given event id.
     *
     * This will return an `InReplyToDetails` object that contains the details
     * which will either be ready or an error.
     */
open func loadReplyDetails(eventIdStr: String)async throws  -> InReplyToDetails {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventIdStr)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeInReplyToDetails.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Mark the room as read by trying to attach an *unthreaded* read receipt
     * to the latest room event.
     *
     * This works even if the latest event belongs to a thread, as a threaded
     * reply also belongs to the unthreaded timeline. No threaded receipt
     * will be sent here (see also #3123).
     */
open func markAsRead(receiptType: ReceiptType)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(
                    self.uniffiClonePointer(),
                    FfiConverterTypeReceiptType.lower(receiptType)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Paginate backwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the end of the timeline or not.
     */
open func paginateBackwards(numEvents: UInt16)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(
                    self.uniffiClonePointer(),
                    FfiConverterUInt16.lower(numEvents)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event containing the new event id.
     *
     * Returns `true` if we sent the request, `false` if the event was already
     * pinned.
     */
open func pinEvent(eventId: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Redacts an event from the timeline.
     *
     * Only works for events that exist as timeline items.
     *
     * If it was a local event, this will *try* to cancel it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending a redaction request to the server.
     *
     * Will return an error if the event couldn't be redacted.
     */
open func redactEvent(eventOrTransactionId: EventOrTransactionId, reason: String?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventOrTransactionId.lower(eventOrTransactionId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func retryDecryption(sessionIds: [String]) {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(sessionIds),$0
    )
}
}
    
    /**
     * Queues an event in the room's send queue so it's processed for
     * sending later.
     *
     * Returns an abort handle that allows to abort sending, if it hasn't
     * happened yet.
     */
open func send(msg: RoomMessageEventContentWithoutRelation)async throws  -> SendHandle {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSendHandle.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func sendAudio(url: String, audioInfo: AudioInfo, caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool) -> SendAttachmentJoinHandle {
    return try!  FfiConverterTypeSendAttachmentJoinHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(self.uniffiClonePointer(),
        FfiConverterString.lower(url),
        FfiConverterTypeAudioInfo.lower(audioInfo),
        FfiConverterOptionString.lower(caption),
        FfiConverterOptionTypeFormattedBody.lower(formattedCaption),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),
        FfiConverterBool.lower(useSendQueue),$0
    )
})
}
    
open func sendFile(url: String, fileInfo: FileInfo, caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool) -> SendAttachmentJoinHandle {
    return try!  FfiConverterTypeSendAttachmentJoinHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(self.uniffiClonePointer(),
        FfiConverterString.lower(url),
        FfiConverterTypeFileInfo.lower(fileInfo),
        FfiConverterOptionString.lower(caption),
        FfiConverterOptionTypeFormattedBody.lower(formattedCaption),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),
        FfiConverterBool.lower(useSendQueue),$0
    )
})
}
    
open func sendImage(url: String, thumbnailUrl: String?, imageInfo: ImageInfo, caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool) -> SendAttachmentJoinHandle {
    return try!  FfiConverterTypeSendAttachmentJoinHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(self.uniffiClonePointer(),
        FfiConverterString.lower(url),
        FfiConverterOptionString.lower(thumbnailUrl),
        FfiConverterTypeImageInfo.lower(imageInfo),
        FfiConverterOptionString.lower(caption),
        FfiConverterOptionTypeFormattedBody.lower(formattedCaption),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),
        FfiConverterBool.lower(useSendQueue),$0
    )
})
}
    
open func sendLocation(body: String, geoUri: String, description: String?, zoomLevel: UInt8?, assetType: AssetType?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(body),FfiConverterString.lower(geoUri),FfiConverterOptionString.lower(description),FfiConverterOptionUInt8.lower(zoomLevel),FfiConverterOptionTypeAssetType.lower(assetType)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func sendPollResponse(pollStartEventId: String, answers: [String])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(pollStartEventId),FfiConverterSequenceString.lower(answers)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func sendReadReceipt(receiptType: ReceiptType, eventId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(
                    self.uniffiClonePointer(),
                    FfiConverterTypeReceiptType.lower(receiptType),FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func sendReply(msg: RoomMessageEventContentWithoutRelation, eventId: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg),FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
open func sendVideo(url: String, thumbnailUrl: String?, videoInfo: VideoInfo, caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool) -> SendAttachmentJoinHandle {
    return try!  FfiConverterTypeSendAttachmentJoinHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(self.uniffiClonePointer(),
        FfiConverterString.lower(url),
        FfiConverterOptionString.lower(thumbnailUrl),
        FfiConverterTypeVideoInfo.lower(videoInfo),
        FfiConverterOptionString.lower(caption),
        FfiConverterOptionTypeFormattedBody.lower(formattedCaption),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),
        FfiConverterBool.lower(useSendQueue),$0
    )
})
}
    
open func sendVoiceMessage(url: String, audioInfo: AudioInfo, waveform: [UInt16], caption: String?, formattedCaption: FormattedBody?, progressWatcher: ProgressWatcher?, useSendQueue: Bool) -> SendAttachmentJoinHandle {
    return try!  FfiConverterTypeSendAttachmentJoinHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(self.uniffiClonePointer(),
        FfiConverterString.lower(url),
        FfiConverterTypeAudioInfo.lower(audioInfo),
        FfiConverterSequenceUInt16.lower(waveform),
        FfiConverterOptionString.lower(caption),
        FfiConverterOptionTypeFormattedBody.lower(formattedCaption),
        FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher),
        FfiConverterBool.lower(useSendQueue),$0
    )
})
}
    
open func subscribeToBackPaginationStatus(listener: PaginationStatusListener)async throws  -> TaskHandle {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfacePaginationStatusListener.lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeTaskHandle.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Toggle a reaction on an event.
     *
     * Adds or redacts a reaction based on the state of the reaction at the
     * time it is called.
     *
     * This method works both on local echoes and remote items.
     *
     * When redacting a previous reaction, the redaction reason is not set.
     *
     * Ensures that only one reaction is sent at a time to avoid race
     * conditions and spamming the homeserver with requests.
     */
open func toggleReaction(itemId: EventOrTransactionId, key: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventOrTransactionId.lower(itemId),FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event without the event id we want to remove.
     *
     * Returns `true` if we sent the request, `false` if the event wasn't
     * pinned
     */
open func unpinEvent(eventId: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeTimeline: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Timeline

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Timeline {
        return Timeline(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Timeline) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timeline {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Timeline, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTimeline_lift(_ pointer: UnsafeMutableRawPointer) throws -> Timeline {
    return try FfiConverterTypeTimeline.lift(pointer)
}

public func FfiConverterTypeTimeline_lower(_ value: Timeline) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimeline.lower(value)
}




public protocol TimelineDiffProtocol : AnyObject {
    
    func append()  -> [TimelineItem]?
    
    func change()  -> TimelineChange
    
    func insert()  -> InsertData?
    
    func pushBack()  -> TimelineItem?
    
    func pushFront()  -> TimelineItem?
    
    func remove()  -> UInt32?
    
    func reset()  -> [TimelineItem]?
    
    func set()  -> SetData?
    
    func truncate()  -> UInt32?
    
}

open class TimelineDiff:
    TimelineDiffProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_timelinediff(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelinediff(pointer, $0) }
    }

    

    
open func append() -> [TimelineItem]? {
    return try!  FfiConverterOptionSequenceTypeTimelineItem.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_append(self.uniffiClonePointer(),$0
    )
})
}
    
open func change() -> TimelineChange {
    return try!  FfiConverterTypeTimelineChange.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_change(self.uniffiClonePointer(),$0
    )
})
}
    
open func insert() -> InsertData? {
    return try!  FfiConverterOptionTypeInsertData.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_insert(self.uniffiClonePointer(),$0
    )
})
}
    
open func pushBack() -> TimelineItem? {
    return try!  FfiConverterOptionTypeTimelineItem.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_back(self.uniffiClonePointer(),$0
    )
})
}
    
open func pushFront() -> TimelineItem? {
    return try!  FfiConverterOptionTypeTimelineItem.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_front(self.uniffiClonePointer(),$0
    )
})
}
    
open func remove() -> UInt32? {
    return try!  FfiConverterOptionUInt32.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_remove(self.uniffiClonePointer(),$0
    )
})
}
    
open func reset() -> [TimelineItem]? {
    return try!  FfiConverterOptionSequenceTypeTimelineItem.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_reset(self.uniffiClonePointer(),$0
    )
})
}
    
open func set() -> SetData? {
    return try!  FfiConverterOptionTypeSetData.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_set(self.uniffiClonePointer(),$0
    )
})
}
    
open func truncate() -> UInt32? {
    return try!  FfiConverterOptionUInt32.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelinediff_truncate(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeTimelineDiff: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineDiff

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineDiff {
        return TimelineDiff(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineDiff) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineDiff {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineDiff, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTimelineDiff_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineDiff {
    return try FfiConverterTypeTimelineDiff.lift(pointer)
}

public func FfiConverterTypeTimelineDiff_lower(_ value: TimelineDiff) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineDiff.lower(value)
}




public protocol TimelineEventProtocol : AnyObject {
    
    func eventId()  -> String
    
    func eventType() throws  -> TimelineEventType
    
    func senderId()  -> String
    
    func timestamp()  -> UInt64
    
}

open class TimelineEvent:
    TimelineEventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_timelineevent(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineevent(pointer, $0) }
    }

    

    
open func eventId() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func eventType()throws  -> TimelineEventType {
    return try  FfiConverterTypeTimelineEventType.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(self.uniffiClonePointer(),$0
    )
})
}
    
open func senderId() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func timestamp() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeTimelineEvent: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineEvent

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineEvent {
        return TimelineEvent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineEvent) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEvent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineEvent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTimelineEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineEvent {
    return try FfiConverterTypeTimelineEvent.lift(pointer)
}

public func FfiConverterTypeTimelineEvent_lower(_ value: TimelineEvent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineEvent.lower(value)
}




public protocol TimelineEventTypeFilterProtocol : AnyObject {
    
}

open class TimelineEventTypeFilter:
    TimelineEventTypeFilterProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(pointer, $0) }
    }

    
public static func exclude(eventTypes: [FilterTimelineEventType]) -> TimelineEventTypeFilter {
    return try!  FfiConverterTypeTimelineEventTypeFilter.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(
        FfiConverterSequenceTypeFilterTimelineEventType.lower(eventTypes),$0
    )
})
}
    
public static func include(eventTypes: [FilterTimelineEventType]) -> TimelineEventTypeFilter {
    return try!  FfiConverterTypeTimelineEventTypeFilter.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(
        FfiConverterSequenceTypeFilterTimelineEventType.lower(eventTypes),$0
    )
})
}
    

    

}

public struct FfiConverterTypeTimelineEventTypeFilter: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineEventTypeFilter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineEventTypeFilter {
        return TimelineEventTypeFilter(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineEventTypeFilter) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEventTypeFilter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineEventTypeFilter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTimelineEventTypeFilter_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineEventTypeFilter {
    return try FfiConverterTypeTimelineEventTypeFilter.lift(pointer)
}

public func FfiConverterTypeTimelineEventTypeFilter_lower(_ value: TimelineEventTypeFilter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineEventTypeFilter.lower(value)
}




public protocol TimelineItemProtocol : AnyObject {
    
    func asEvent()  -> EventTimelineItem?
    
    func asVirtual()  -> VirtualTimelineItem?
    
    func fmtDebug()  -> String
    
    /**
     * An opaque unique identifier for this timeline item.
     */
    func uniqueId()  -> TimelineUniqueId
    
}

open class TimelineItem:
    TimelineItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_timelineitem(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineitem(pointer, $0) }
    }

    

    
open func asEvent() -> EventTimelineItem? {
    return try!  FfiConverterOptionTypeEventTimelineItem.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(self.uniffiClonePointer(),$0
    )
})
}
    
open func asVirtual() -> VirtualTimelineItem? {
    return try!  FfiConverterOptionTypeVirtualTimelineItem.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(self.uniffiClonePointer(),$0
    )
})
}
    
open func fmtDebug() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * An opaque unique identifier for this timeline item.
     */
open func uniqueId() -> TimelineUniqueId {
    return try!  FfiConverterTypeTimelineUniqueId.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeTimelineItem: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineItem

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItem {
        return TimelineItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineItem) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTimelineItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItem {
    return try FfiConverterTypeTimelineItem.lift(pointer)
}

public func FfiConverterTypeTimelineItem_lower(_ value: TimelineItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineItem.lower(value)
}




public protocol UnreadNotificationsCountProtocol : AnyObject {
    
    func hasNotifications()  -> Bool
    
    func highlightCount()  -> UInt32
    
    func notificationCount()  -> UInt32
    
}

open class UnreadNotificationsCount:
    UnreadNotificationsCountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(pointer, $0) }
    }

    

    
open func hasNotifications() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(self.uniffiClonePointer(),$0
    )
})
}
    
open func highlightCount() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(self.uniffiClonePointer(),$0
    )
})
}
    
open func notificationCount() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeUnreadNotificationsCount: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnreadNotificationsCount

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnreadNotificationsCount {
        return UnreadNotificationsCount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnreadNotificationsCount) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnreadNotificationsCount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnreadNotificationsCount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUnreadNotificationsCount_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnreadNotificationsCount {
    return try FfiConverterTypeUnreadNotificationsCount.lift(pointer)
}

public func FfiConverterTypeUnreadNotificationsCount_lower(_ value: UnreadNotificationsCount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnreadNotificationsCount.lower(value)
}




/**
 * The E2EE identity of a user.
 */
public protocol UserIdentityProtocol : AnyObject {
    
    /**
     * Is the user identity considered to be verified.
     *
     * If the identity belongs to another user, our own user identity needs to
     * be verified as well for the identity to be considered to be verified.
     */
    func isVerified()  -> Bool
    
    /**
     * Get the public part of the Master key of this user identity.
     *
     * The public part of the Master key is usually used to uniquely identify
     * the identity.
     *
     * Returns None if the master key does not actually contain any keys.
     */
    func masterKey()  -> String?
    
    /**
     * Remember this identity, ensuring it does not result in a pin violation.
     *
     * When we first see a user, we assume their cryptographic identity has not
     * been tampered with by the homeserver or another entity with
     * man-in-the-middle capabilities. We remember this identity and call this
     * action "pinning".
     *
     * If the identity presented for the user changes later on, the newly
     * presented identity is considered to be in "pin violation". This
     * method explicitly accepts the new identity, allowing it to replace
     * the previously pinned one and bringing it out of pin violation.
     *
     * UIs should display a warning to the user when encountering an identity
     * which is not verified and is in pin violation.
     */
    func pin() async throws 
    
}

/**
 * The E2EE identity of a user.
 */
open class UserIdentity:
    UserIdentityProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_useridentity(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_useridentity(pointer, $0) }
    }

    

    
    /**
     * Is the user identity considered to be verified.
     *
     * If the identity belongs to another user, our own user identity needs to
     * be verified as well for the identity to be considered to be verified.
     */
open func isVerified() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the public part of the Master key of this user identity.
     *
     * The public part of the Master key is usually used to uniquely identify
     * the identity.
     *
     * Returns None if the master key does not actually contain any keys.
     */
open func masterKey() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Remember this identity, ensuring it does not result in a pin violation.
     *
     * When we first see a user, we assume their cryptographic identity has not
     * been tampered with by the homeserver or another entity with
     * man-in-the-middle capabilities. We remember this identity and call this
     * action "pinning".
     *
     * If the identity presented for the user changes later on, the newly
     * presented identity is considered to be in "pin violation". This
     * method explicitly accepts the new identity, allowing it to replace
     * the previously pinned one and bringing it out of pin violation.
     *
     * UIs should display a warning to the user when encountering an identity
     * which is not verified and is in pin violation.
     */
open func pin()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
}
    

}

public struct FfiConverterTypeUserIdentity: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UserIdentity

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UserIdentity {
        return UserIdentity(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UserIdentity) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserIdentity {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UserIdentity, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUserIdentity_lift(_ pointer: UnsafeMutableRawPointer) throws -> UserIdentity {
    return try FfiConverterTypeUserIdentity.lift(pointer)
}

public func FfiConverterTypeUserIdentity_lower(_ value: UserIdentity) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUserIdentity.lower(value)
}




/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
public protocol WidgetDriverProtocol : AnyObject {
    
    func run(room: Room, capabilitiesProvider: WidgetCapabilitiesProvider) async 
    
}

/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
open class WidgetDriver:
    WidgetDriverProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_widgetdriver(pointer, $0) }
    }

    

    
open func run(room: Room, capabilitiesProvider: WidgetCapabilitiesProvider)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRoom.lower(room),FfiConverterCallbackInterfaceWidgetCapabilitiesProvider.lower(capabilitiesProvider)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

public struct FfiConverterTypeWidgetDriver: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WidgetDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WidgetDriver {
        return WidgetDriver(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WidgetDriver) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WidgetDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWidgetDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> WidgetDriver {
    return try FfiConverterTypeWidgetDriver.lift(pointer)
}

public func FfiConverterTypeWidgetDriver_lower(_ value: WidgetDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWidgetDriver.lower(value)
}




/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
public protocol WidgetDriverHandleProtocol : AnyObject {
    
    /**
     * Receive a message from the widget driver.
     *
     * The message must be passed on to the widget.
     *
     * Returns `None` if the widget driver is no longer running.
     */
    func recv() async  -> String?
    
    /**
     *
     * Returns `false` if the widget driver is no longer running.
     */
    func send(msg: String) async  -> Bool
    
}

/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
open class WidgetDriverHandle:
    WidgetDriverHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(pointer, $0) }
    }

    

    
    /**
     * Receive a message from the widget driver.
     *
     * The message must be passed on to the widget.
     *
     * Returns `None` if the widget driver is no longer running.
     */
open func recv()async  -> String? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     *
     * Returns `false` if the widget driver is no longer running.
     */
open func send(msg: String)async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(msg)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    

}

public struct FfiConverterTypeWidgetDriverHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WidgetDriverHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WidgetDriverHandle {
        return WidgetDriverHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WidgetDriverHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetDriverHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WidgetDriverHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWidgetDriverHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> WidgetDriverHandle {
    return try FfiConverterTypeWidgetDriverHandle.lift(pointer)
}

public func FfiConverterTypeWidgetDriverHandle_lower(_ value: WidgetDriverHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWidgetDriverHandle.lower(value)
}


public struct AudioInfo {
    public var duration: TimeInterval?
    public var size: UInt64?
    public var mimetype: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: TimeInterval?, size: UInt64?, mimetype: String?) {
        self.duration = duration
        self.size = size
        self.mimetype = mimetype
    }
}



extension AudioInfo: Equatable, Hashable {
    public static func ==(lhs: AudioInfo, rhs: AudioInfo) -> Bool {
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.mimetype != rhs.mimetype {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(duration)
        hasher.combine(size)
        hasher.combine(mimetype)
    }
}


public struct FfiConverterTypeAudioInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioInfo {
        return
            try AudioInfo(
                duration: FfiConverterOptionDuration.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf), 
                mimetype: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AudioInfo, into buf: inout [UInt8]) {
        FfiConverterOptionDuration.write(value.duration, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
    }
}


public func FfiConverterTypeAudioInfo_lift(_ buf: RustBuffer) throws -> AudioInfo {
    return try FfiConverterTypeAudioInfo.lift(buf)
}

public func FfiConverterTypeAudioInfo_lower(_ value: AudioInfo) -> RustBuffer {
    return FfiConverterTypeAudioInfo.lower(value)
}


public struct AudioMessageContent {
    /**
     * The computed filename, for use in a client.
     */
    public var filename: String
    public var caption: String?
    public var formattedCaption: FormattedBody?
    public var source: MediaSource
    public var info: AudioInfo?
    public var audio: UnstableAudioDetailsContent?
    public var voice: UnstableVoiceContent?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The computed filename, for use in a client.
         */filename: String, caption: String?, formattedCaption: FormattedBody?, source: MediaSource, info: AudioInfo?, audio: UnstableAudioDetailsContent?, voice: UnstableVoiceContent?) {
        self.filename = filename
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.source = source
        self.info = info
        self.audio = audio
        self.voice = voice
    }
}



public struct FfiConverterTypeAudioMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioMessageContent {
        return
            try AudioMessageContent(
                filename: FfiConverterString.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                source: FfiConverterTypeMediaSource.read(from: &buf), 
                info: FfiConverterOptionTypeAudioInfo.read(from: &buf), 
                audio: FfiConverterOptionTypeUnstableAudioDetailsContent.read(from: &buf), 
                voice: FfiConverterOptionTypeUnstableVoiceContent.read(from: &buf)
        )
    }

    public static func write(_ value: AudioMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeAudioInfo.write(value.info, into: &buf)
        FfiConverterOptionTypeUnstableAudioDetailsContent.write(value.audio, into: &buf)
        FfiConverterOptionTypeUnstableVoiceContent.write(value.voice, into: &buf)
    }
}


public func FfiConverterTypeAudioMessageContent_lift(_ buf: RustBuffer) throws -> AudioMessageContent {
    return try FfiConverterTypeAudioMessageContent.lift(buf)
}

public func FfiConverterTypeAudioMessageContent_lower(_ value: AudioMessageContent) -> RustBuffer {
    return FfiConverterTypeAudioMessageContent.lower(value)
}


public struct AuthDataPasswordDetails {
    /**
     * One of the user's identifiers.
     */
    public var identifier: String
    /**
     * The plaintext password.
     */
    public var password: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * One of the user's identifiers.
         */identifier: String, 
        /**
         * The plaintext password.
         */password: String) {
        self.identifier = identifier
        self.password = password
    }
}



extension AuthDataPasswordDetails: Equatable, Hashable {
    public static func ==(lhs: AuthDataPasswordDetails, rhs: AuthDataPasswordDetails) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(password)
    }
}


public struct FfiConverterTypeAuthDataPasswordDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthDataPasswordDetails {
        return
            try AuthDataPasswordDetails(
                identifier: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AuthDataPasswordDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
    }
}


public func FfiConverterTypeAuthDataPasswordDetails_lift(_ buf: RustBuffer) throws -> AuthDataPasswordDetails {
    return try FfiConverterTypeAuthDataPasswordDetails.lift(buf)
}

public func FfiConverterTypeAuthDataPasswordDetails_lower(_ value: AuthDataPasswordDetails) -> RustBuffer {
    return FfiConverterTypeAuthDataPasswordDetails.lower(value)
}


public struct ClientProperties {
    /**
     * The client_id provides the widget with the option to behave differently
     * for different clients. e.g org.example.ios.
     */
    public var clientId: String
    /**
     * The language tag the client is set to e.g. en-us. (Undefined and invalid
     * becomes: `en-US`)
     */
    public var languageTag: String?
    /**
     * A string describing the theme (dark, light) or org.example.dark.
     * (default: `light`)
     */
    public var theme: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The client_id provides the widget with the option to behave differently
         * for different clients. e.g org.example.ios.
         */clientId: String, 
        /**
         * The language tag the client is set to e.g. en-us. (Undefined and invalid
         * becomes: `en-US`)
         */languageTag: String?, 
        /**
         * A string describing the theme (dark, light) or org.example.dark.
         * (default: `light`)
         */theme: String?) {
        self.clientId = clientId
        self.languageTag = languageTag
        self.theme = theme
    }
}



extension ClientProperties: Equatable, Hashable {
    public static func ==(lhs: ClientProperties, rhs: ClientProperties) -> Bool {
        if lhs.clientId != rhs.clientId {
            return false
        }
        if lhs.languageTag != rhs.languageTag {
            return false
        }
        if lhs.theme != rhs.theme {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clientId)
        hasher.combine(languageTag)
        hasher.combine(theme)
    }
}


public struct FfiConverterTypeClientProperties: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientProperties {
        return
            try ClientProperties(
                clientId: FfiConverterString.read(from: &buf), 
                languageTag: FfiConverterOptionString.read(from: &buf), 
                theme: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ClientProperties, into buf: inout [UInt8]) {
        FfiConverterString.write(value.clientId, into: &buf)
        FfiConverterOptionString.write(value.languageTag, into: &buf)
        FfiConverterOptionString.write(value.theme, into: &buf)
    }
}


public func FfiConverterTypeClientProperties_lift(_ buf: RustBuffer) throws -> ClientProperties {
    return try FfiConverterTypeClientProperties.lift(buf)
}

public func FfiConverterTypeClientProperties_lower(_ value: ClientProperties) -> RustBuffer {
    return FfiConverterTypeClientProperties.lower(value)
}


/**
 * Current draft of the composer for the room.
 */
public struct ComposerDraft {
    /**
     * The draft content in plain text.
     */
    public var plainText: String
    /**
     * If the message is formatted in HTML, the HTML representation of the
     * message.
     */
    public var htmlText: String?
    /**
     * The type of draft.
     */
    public var draftType: ComposerDraftType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The draft content in plain text.
         */plainText: String, 
        /**
         * If the message is formatted in HTML, the HTML representation of the
         * message.
         */htmlText: String?, 
        /**
         * The type of draft.
         */draftType: ComposerDraftType) {
        self.plainText = plainText
        self.htmlText = htmlText
        self.draftType = draftType
    }
}



extension ComposerDraft: Equatable, Hashable {
    public static func ==(lhs: ComposerDraft, rhs: ComposerDraft) -> Bool {
        if lhs.plainText != rhs.plainText {
            return false
        }
        if lhs.htmlText != rhs.htmlText {
            return false
        }
        if lhs.draftType != rhs.draftType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plainText)
        hasher.combine(htmlText)
        hasher.combine(draftType)
    }
}


public struct FfiConverterTypeComposerDraft: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComposerDraft {
        return
            try ComposerDraft(
                plainText: FfiConverterString.read(from: &buf), 
                htmlText: FfiConverterOptionString.read(from: &buf), 
                draftType: FfiConverterTypeComposerDraftType.read(from: &buf)
        )
    }

    public static func write(_ value: ComposerDraft, into buf: inout [UInt8]) {
        FfiConverterString.write(value.plainText, into: &buf)
        FfiConverterOptionString.write(value.htmlText, into: &buf)
        FfiConverterTypeComposerDraftType.write(value.draftType, into: &buf)
    }
}


public func FfiConverterTypeComposerDraft_lift(_ buf: RustBuffer) throws -> ComposerDraft {
    return try FfiConverterTypeComposerDraft.lift(buf)
}

public func FfiConverterTypeComposerDraft_lower(_ value: ComposerDraft) -> RustBuffer {
    return FfiConverterTypeComposerDraft.lower(value)
}


public struct CreateRoomParameters {
    public var name: String?
    public var topic: String?
    public var isEncrypted: Bool
    public var isDirect: Bool
    public var visibility: RoomVisibility
    public var preset: RoomPreset
    public var invite: [String]?
    public var avatar: String?
    public var powerLevelContentOverride: PowerLevels?
    public var joinRuleOverride: JoinRule?
    public var canonicalAlias: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, topic: String? = nil, isEncrypted: Bool, isDirect: Bool = false, visibility: RoomVisibility, preset: RoomPreset, invite: [String]? = nil, avatar: String? = nil, powerLevelContentOverride: PowerLevels? = nil, joinRuleOverride: JoinRule? = nil, canonicalAlias: String? = nil) {
        self.name = name
        self.topic = topic
        self.isEncrypted = isEncrypted
        self.isDirect = isDirect
        self.visibility = visibility
        self.preset = preset
        self.invite = invite
        self.avatar = avatar
        self.powerLevelContentOverride = powerLevelContentOverride
        self.joinRuleOverride = joinRuleOverride
        self.canonicalAlias = canonicalAlias
    }
}



extension CreateRoomParameters: Equatable, Hashable {
    public static func ==(lhs: CreateRoomParameters, rhs: CreateRoomParameters) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.topic != rhs.topic {
            return false
        }
        if lhs.isEncrypted != rhs.isEncrypted {
            return false
        }
        if lhs.isDirect != rhs.isDirect {
            return false
        }
        if lhs.visibility != rhs.visibility {
            return false
        }
        if lhs.preset != rhs.preset {
            return false
        }
        if lhs.invite != rhs.invite {
            return false
        }
        if lhs.avatar != rhs.avatar {
            return false
        }
        if lhs.powerLevelContentOverride != rhs.powerLevelContentOverride {
            return false
        }
        if lhs.joinRuleOverride != rhs.joinRuleOverride {
            return false
        }
        if lhs.canonicalAlias != rhs.canonicalAlias {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(topic)
        hasher.combine(isEncrypted)
        hasher.combine(isDirect)
        hasher.combine(visibility)
        hasher.combine(preset)
        hasher.combine(invite)
        hasher.combine(avatar)
        hasher.combine(powerLevelContentOverride)
        hasher.combine(joinRuleOverride)
        hasher.combine(canonicalAlias)
    }
}


public struct FfiConverterTypeCreateRoomParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateRoomParameters {
        return
            try CreateRoomParameters(
                name: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                isEncrypted: FfiConverterBool.read(from: &buf), 
                isDirect: FfiConverterBool.read(from: &buf), 
                visibility: FfiConverterTypeRoomVisibility.read(from: &buf), 
                preset: FfiConverterTypeRoomPreset.read(from: &buf), 
                invite: FfiConverterOptionSequenceString.read(from: &buf), 
                avatar: FfiConverterOptionString.read(from: &buf), 
                powerLevelContentOverride: FfiConverterOptionTypePowerLevels.read(from: &buf), 
                joinRuleOverride: FfiConverterOptionTypeJoinRule.read(from: &buf), 
                canonicalAlias: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CreateRoomParameters, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterBool.write(value.isEncrypted, into: &buf)
        FfiConverterBool.write(value.isDirect, into: &buf)
        FfiConverterTypeRoomVisibility.write(value.visibility, into: &buf)
        FfiConverterTypeRoomPreset.write(value.preset, into: &buf)
        FfiConverterOptionSequenceString.write(value.invite, into: &buf)
        FfiConverterOptionString.write(value.avatar, into: &buf)
        FfiConverterOptionTypePowerLevels.write(value.powerLevelContentOverride, into: &buf)
        FfiConverterOptionTypeJoinRule.write(value.joinRuleOverride, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
    }
}


public func FfiConverterTypeCreateRoomParameters_lift(_ buf: RustBuffer) throws -> CreateRoomParameters {
    return try FfiConverterTypeCreateRoomParameters.lift(buf)
}

public func FfiConverterTypeCreateRoomParameters_lower(_ value: CreateRoomParameters) -> RustBuffer {
    return FfiConverterTypeCreateRoomParameters.lower(value)
}


/**
 * Well-known settings specific to ElementCall
 */
public struct ElementCallWellKnown {
    public var widgetUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(widgetUrl: String) {
        self.widgetUrl = widgetUrl
    }
}



extension ElementCallWellKnown: Equatable, Hashable {
    public static func ==(lhs: ElementCallWellKnown, rhs: ElementCallWellKnown) -> Bool {
        if lhs.widgetUrl != rhs.widgetUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(widgetUrl)
    }
}


public struct FfiConverterTypeElementCallWellKnown: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElementCallWellKnown {
        return
            try ElementCallWellKnown(
                widgetUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ElementCallWellKnown, into buf: inout [UInt8]) {
        FfiConverterString.write(value.widgetUrl, into: &buf)
    }
}


public func FfiConverterTypeElementCallWellKnown_lift(_ buf: RustBuffer) throws -> ElementCallWellKnown {
    return try FfiConverterTypeElementCallWellKnown.lift(buf)
}

public func FfiConverterTypeElementCallWellKnown_lower(_ value: ElementCallWellKnown) -> RustBuffer {
    return FfiConverterTypeElementCallWellKnown.lower(value)
}


/**
 * Element specific well-known settings
 */
public struct ElementWellKnown {
    public var call: ElementCallWellKnown?
    public var registrationHelperUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(call: ElementCallWellKnown?, registrationHelperUrl: String?) {
        self.call = call
        self.registrationHelperUrl = registrationHelperUrl
    }
}



extension ElementWellKnown: Equatable, Hashable {
    public static func ==(lhs: ElementWellKnown, rhs: ElementWellKnown) -> Bool {
        if lhs.call != rhs.call {
            return false
        }
        if lhs.registrationHelperUrl != rhs.registrationHelperUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(call)
        hasher.combine(registrationHelperUrl)
    }
}


public struct FfiConverterTypeElementWellKnown: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElementWellKnown {
        return
            try ElementWellKnown(
                call: FfiConverterOptionTypeElementCallWellKnown.read(from: &buf), 
                registrationHelperUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ElementWellKnown, into buf: inout [UInt8]) {
        FfiConverterOptionTypeElementCallWellKnown.write(value.call, into: &buf)
        FfiConverterOptionString.write(value.registrationHelperUrl, into: &buf)
    }
}


public func FfiConverterTypeElementWellKnown_lift(_ buf: RustBuffer) throws -> ElementWellKnown {
    return try FfiConverterTypeElementWellKnown.lift(buf)
}

public func FfiConverterTypeElementWellKnown_lower(_ value: ElementWellKnown) -> RustBuffer {
    return FfiConverterTypeElementWellKnown.lower(value)
}


public struct EmoteMessageContent {
    public var body: String
    public var formatted: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?) {
        self.body = body
        self.formatted = formatted
    }
}



extension EmoteMessageContent: Equatable, Hashable {
    public static func ==(lhs: EmoteMessageContent, rhs: EmoteMessageContent) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.formatted != rhs.formatted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(formatted)
    }
}


public struct FfiConverterTypeEmoteMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmoteMessageContent {
        return
            try EmoteMessageContent(
                body: FfiConverterString.read(from: &buf), 
                formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: EmoteMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
    }
}


public func FfiConverterTypeEmoteMessageContent_lift(_ buf: RustBuffer) throws -> EmoteMessageContent {
    return try FfiConverterTypeEmoteMessageContent.lift(buf)
}

public func FfiConverterTypeEmoteMessageContent_lower(_ value: EmoteMessageContent) -> RustBuffer {
    return FfiConverterTypeEmoteMessageContent.lower(value)
}


public struct EventTimelineItem {
    /**
     * Indicates that an event is remote.
     */
    public var isRemote: Bool
    public var eventOrTransactionId: EventOrTransactionId
    public var sender: String
    public var senderProfile: ProfileDetails
    public var isOwn: Bool
    public var isEditable: Bool
    public var content: TimelineItemContent
    public var timestamp: UInt64
    public var reactions: [Reaction]
    public var localSendState: EventSendState?
    public var readReceipts: [String: Receipt]
    public var origin: EventItemOrigin?
    public var canBeRepliedTo: Bool
    public var lazyProvider: LazyTimelineItemProvider

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Indicates that an event is remote.
         */isRemote: Bool, eventOrTransactionId: EventOrTransactionId, sender: String, senderProfile: ProfileDetails, isOwn: Bool, isEditable: Bool, content: TimelineItemContent, timestamp: UInt64, reactions: [Reaction], localSendState: EventSendState?, readReceipts: [String: Receipt], origin: EventItemOrigin?, canBeRepliedTo: Bool, lazyProvider: LazyTimelineItemProvider) {
        self.isRemote = isRemote
        self.eventOrTransactionId = eventOrTransactionId
        self.sender = sender
        self.senderProfile = senderProfile
        self.isOwn = isOwn
        self.isEditable = isEditable
        self.content = content
        self.timestamp = timestamp
        self.reactions = reactions
        self.localSendState = localSendState
        self.readReceipts = readReceipts
        self.origin = origin
        self.canBeRepliedTo = canBeRepliedTo
        self.lazyProvider = lazyProvider
    }
}



public struct FfiConverterTypeEventTimelineItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItem {
        return
            try EventTimelineItem(
                isRemote: FfiConverterBool.read(from: &buf), 
                eventOrTransactionId: FfiConverterTypeEventOrTransactionId.read(from: &buf), 
                sender: FfiConverterString.read(from: &buf), 
                senderProfile: FfiConverterTypeProfileDetails.read(from: &buf), 
                isOwn: FfiConverterBool.read(from: &buf), 
                isEditable: FfiConverterBool.read(from: &buf), 
                content: FfiConverterTypeTimelineItemContent.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                reactions: FfiConverterSequenceTypeReaction.read(from: &buf), 
                localSendState: FfiConverterOptionTypeEventSendState.read(from: &buf), 
                readReceipts: FfiConverterDictionaryStringTypeReceipt.read(from: &buf), 
                origin: FfiConverterOptionTypeEventItemOrigin.read(from: &buf), 
                canBeRepliedTo: FfiConverterBool.read(from: &buf), 
                lazyProvider: FfiConverterTypeLazyTimelineItemProvider.read(from: &buf)
        )
    }

    public static func write(_ value: EventTimelineItem, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isRemote, into: &buf)
        FfiConverterTypeEventOrTransactionId.write(value.eventOrTransactionId, into: &buf)
        FfiConverterString.write(value.sender, into: &buf)
        FfiConverterTypeProfileDetails.write(value.senderProfile, into: &buf)
        FfiConverterBool.write(value.isOwn, into: &buf)
        FfiConverterBool.write(value.isEditable, into: &buf)
        FfiConverterTypeTimelineItemContent.write(value.content, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterSequenceTypeReaction.write(value.reactions, into: &buf)
        FfiConverterOptionTypeEventSendState.write(value.localSendState, into: &buf)
        FfiConverterDictionaryStringTypeReceipt.write(value.readReceipts, into: &buf)
        FfiConverterOptionTypeEventItemOrigin.write(value.origin, into: &buf)
        FfiConverterBool.write(value.canBeRepliedTo, into: &buf)
        FfiConverterTypeLazyTimelineItemProvider.write(value.lazyProvider, into: &buf)
    }
}


public func FfiConverterTypeEventTimelineItem_lift(_ buf: RustBuffer) throws -> EventTimelineItem {
    return try FfiConverterTypeEventTimelineItem.lift(buf)
}

public func FfiConverterTypeEventTimelineItem_lower(_ value: EventTimelineItem) -> RustBuffer {
    return FfiConverterTypeEventTimelineItem.lower(value)
}


public struct EventTimelineItemDebugInfo {
    public var model: String
    public var originalJson: String?
    public var latestEditJson: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(model: String, originalJson: String?, latestEditJson: String?) {
        self.model = model
        self.originalJson = originalJson
        self.latestEditJson = latestEditJson
    }
}



extension EventTimelineItemDebugInfo: Equatable, Hashable {
    public static func ==(lhs: EventTimelineItemDebugInfo, rhs: EventTimelineItemDebugInfo) -> Bool {
        if lhs.model != rhs.model {
            return false
        }
        if lhs.originalJson != rhs.originalJson {
            return false
        }
        if lhs.latestEditJson != rhs.latestEditJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(model)
        hasher.combine(originalJson)
        hasher.combine(latestEditJson)
    }
}


public struct FfiConverterTypeEventTimelineItemDebugInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItemDebugInfo {
        return
            try EventTimelineItemDebugInfo(
                model: FfiConverterString.read(from: &buf), 
                originalJson: FfiConverterOptionString.read(from: &buf), 
                latestEditJson: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: EventTimelineItemDebugInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.model, into: &buf)
        FfiConverterOptionString.write(value.originalJson, into: &buf)
        FfiConverterOptionString.write(value.latestEditJson, into: &buf)
    }
}


public func FfiConverterTypeEventTimelineItemDebugInfo_lift(_ buf: RustBuffer) throws -> EventTimelineItemDebugInfo {
    return try FfiConverterTypeEventTimelineItemDebugInfo.lift(buf)
}

public func FfiConverterTypeEventTimelineItemDebugInfo_lower(_ value: EventTimelineItemDebugInfo) -> RustBuffer {
    return FfiConverterTypeEventTimelineItemDebugInfo.lower(value)
}


public struct FileInfo {
    public var mimetype: String?
    public var size: UInt64?
    public var thumbnailInfo: ThumbnailInfo?
    public var thumbnailSource: MediaSource?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimetype: String?, size: UInt64?, thumbnailInfo: ThumbnailInfo?, thumbnailSource: MediaSource?) {
        self.mimetype = mimetype
        self.size = size
        self.thumbnailInfo = thumbnailInfo
        self.thumbnailSource = thumbnailSource
    }
}



public struct FfiConverterTypeFileInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileInfo {
        return
            try FileInfo(
                mimetype: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf), 
                thumbnailInfo: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
                thumbnailSource: FfiConverterOptionTypeMediaSource.read(from: &buf)
        )
    }

    public static func write(_ value: FileInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.thumbnailInfo, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.thumbnailSource, into: &buf)
    }
}


public func FfiConverterTypeFileInfo_lift(_ buf: RustBuffer) throws -> FileInfo {
    return try FfiConverterTypeFileInfo.lift(buf)
}

public func FfiConverterTypeFileInfo_lower(_ value: FileInfo) -> RustBuffer {
    return FfiConverterTypeFileInfo.lower(value)
}


public struct FileMessageContent {
    /**
     * The computed filename, for use in a client.
     */
    public var filename: String
    public var caption: String?
    public var formattedCaption: FormattedBody?
    public var source: MediaSource
    public var info: FileInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The computed filename, for use in a client.
         */filename: String, caption: String?, formattedCaption: FormattedBody?, source: MediaSource, info: FileInfo?) {
        self.filename = filename
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.source = source
        self.info = info
    }
}



public struct FfiConverterTypeFileMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMessageContent {
        return
            try FileMessageContent(
                filename: FfiConverterString.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                source: FfiConverterTypeMediaSource.read(from: &buf), 
                info: FfiConverterOptionTypeFileInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FileMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeFileInfo.write(value.info, into: &buf)
    }
}


public func FfiConverterTypeFileMessageContent_lift(_ buf: RustBuffer) throws -> FileMessageContent {
    return try FfiConverterTypeFileMessageContent.lift(buf)
}

public func FfiConverterTypeFileMessageContent_lower(_ value: FileMessageContent) -> RustBuffer {
    return FfiConverterTypeFileMessageContent.lower(value)
}


public struct FormattedBody {
    public var format: MessageFormat
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(format: MessageFormat, body: String) {
        self.format = format
        self.body = body
    }
}



extension FormattedBody: Equatable, Hashable {
    public static func ==(lhs: FormattedBody, rhs: FormattedBody) -> Bool {
        if lhs.format != rhs.format {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(format)
        hasher.combine(body)
    }
}


public struct FfiConverterTypeFormattedBody: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FormattedBody {
        return
            try FormattedBody(
                format: FfiConverterTypeMessageFormat.read(from: &buf), 
                body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FormattedBody, into buf: inout [UInt8]) {
        FfiConverterTypeMessageFormat.write(value.format, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
    }
}


public func FfiConverterTypeFormattedBody_lift(_ buf: RustBuffer) throws -> FormattedBody {
    return try FfiConverterTypeFormattedBody.lift(buf)
}

public func FfiConverterTypeFormattedBody_lower(_ value: FormattedBody) -> RustBuffer {
    return FfiConverterTypeFormattedBody.lower(value)
}


public struct HttpPusherData {
    public var url: String
    public var format: PushFormat?
    public var defaultPayload: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, format: PushFormat?, defaultPayload: String?) {
        self.url = url
        self.format = format
        self.defaultPayload = defaultPayload
    }
}



extension HttpPusherData: Equatable, Hashable {
    public static func ==(lhs: HttpPusherData, rhs: HttpPusherData) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.defaultPayload != rhs.defaultPayload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(format)
        hasher.combine(defaultPayload)
    }
}


public struct FfiConverterTypeHttpPusherData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpPusherData {
        return
            try HttpPusherData(
                url: FfiConverterString.read(from: &buf), 
                format: FfiConverterOptionTypePushFormat.read(from: &buf), 
                defaultPayload: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HttpPusherData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionTypePushFormat.write(value.format, into: &buf)
        FfiConverterOptionString.write(value.defaultPayload, into: &buf)
    }
}


public func FfiConverterTypeHttpPusherData_lift(_ buf: RustBuffer) throws -> HttpPusherData {
    return try FfiConverterTypeHttpPusherData.lift(buf)
}

public func FfiConverterTypeHttpPusherData_lower(_ value: HttpPusherData) -> RustBuffer {
    return FfiConverterTypeHttpPusherData.lower(value)
}


public struct IdentityStatusChange {
    /**
     * The user ID of the user whose identity status changed
     */
    public var userId: String
    /**
     * The new state of the identity of the user.
     */
    public var changedTo: IdentityState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user ID of the user whose identity status changed
         */userId: String, 
        /**
         * The new state of the identity of the user.
         */changedTo: IdentityState) {
        self.userId = userId
        self.changedTo = changedTo
    }
}



extension IdentityStatusChange: Equatable, Hashable {
    public static func ==(lhs: IdentityStatusChange, rhs: IdentityStatusChange) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.changedTo != rhs.changedTo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(changedTo)
    }
}


public struct FfiConverterTypeIdentityStatusChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityStatusChange {
        return
            try IdentityStatusChange(
                userId: FfiConverterString.read(from: &buf), 
                changedTo: FfiConverterTypeIdentityState.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityStatusChange, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterTypeIdentityState.write(value.changedTo, into: &buf)
    }
}


public func FfiConverterTypeIdentityStatusChange_lift(_ buf: RustBuffer) throws -> IdentityStatusChange {
    return try FfiConverterTypeIdentityStatusChange.lift(buf)
}

public func FfiConverterTypeIdentityStatusChange_lower(_ value: IdentityStatusChange) -> RustBuffer {
    return FfiConverterTypeIdentityStatusChange.lower(value)
}


public struct ImageInfo {
    public var height: UInt64?
    public var width: UInt64?
    public var mimetype: String?
    public var size: UInt64?
    public var thumbnailInfo: ThumbnailInfo?
    public var thumbnailSource: MediaSource?
    public var blurhash: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt64?, width: UInt64?, mimetype: String?, size: UInt64?, thumbnailInfo: ThumbnailInfo?, thumbnailSource: MediaSource?, blurhash: String?) {
        self.height = height
        self.width = width
        self.mimetype = mimetype
        self.size = size
        self.thumbnailInfo = thumbnailInfo
        self.thumbnailSource = thumbnailSource
        self.blurhash = blurhash
    }
}



public struct FfiConverterTypeImageInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageInfo {
        return
            try ImageInfo(
                height: FfiConverterOptionUInt64.read(from: &buf), 
                width: FfiConverterOptionUInt64.read(from: &buf), 
                mimetype: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf), 
                thumbnailInfo: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
                thumbnailSource: FfiConverterOptionTypeMediaSource.read(from: &buf), 
                blurhash: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ImageInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.height, into: &buf)
        FfiConverterOptionUInt64.write(value.width, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.thumbnailInfo, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.thumbnailSource, into: &buf)
        FfiConverterOptionString.write(value.blurhash, into: &buf)
    }
}


public func FfiConverterTypeImageInfo_lift(_ buf: RustBuffer) throws -> ImageInfo {
    return try FfiConverterTypeImageInfo.lift(buf)
}

public func FfiConverterTypeImageInfo_lower(_ value: ImageInfo) -> RustBuffer {
    return FfiConverterTypeImageInfo.lower(value)
}


public struct ImageMessageContent {
    /**
     * The computed filename, for use in a client.
     */
    public var filename: String
    public var caption: String?
    public var formattedCaption: FormattedBody?
    public var source: MediaSource
    public var info: ImageInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The computed filename, for use in a client.
         */filename: String, caption: String?, formattedCaption: FormattedBody?, source: MediaSource, info: ImageInfo?) {
        self.filename = filename
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.source = source
        self.info = info
    }
}



public struct FfiConverterTypeImageMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageMessageContent {
        return
            try ImageMessageContent(
                filename: FfiConverterString.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                source: FfiConverterTypeMediaSource.read(from: &buf), 
                info: FfiConverterOptionTypeImageInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ImageMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeImageInfo.write(value.info, into: &buf)
    }
}


public func FfiConverterTypeImageMessageContent_lift(_ buf: RustBuffer) throws -> ImageMessageContent {
    return try FfiConverterTypeImageMessageContent.lift(buf)
}

public func FfiConverterTypeImageMessageContent_lower(_ value: ImageMessageContent) -> RustBuffer {
    return FfiConverterTypeImageMessageContent.lower(value)
}


public struct InsertData {
    public var index: UInt32
    public var item: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt32, item: TimelineItem) {
        self.index = index
        self.item = item
    }
}



public struct FfiConverterTypeInsertData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InsertData {
        return
            try InsertData(
                index: FfiConverterUInt32.read(from: &buf), 
                item: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: InsertData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterTypeTimelineItem.write(value.item, into: &buf)
    }
}


public func FfiConverterTypeInsertData_lift(_ buf: RustBuffer) throws -> InsertData {
    return try FfiConverterTypeInsertData.lift(buf)
}

public func FfiConverterTypeInsertData_lower(_ value: InsertData) -> RustBuffer {
    return FfiConverterTypeInsertData.lower(value)
}


/**
 * An FFI representation of a request to join a room.
 */
public struct KnockRequest {
    /**
     * The event id of the event that contains the `knock` membership change.
     */
    public var eventId: String
    /**
     * The user id of the user who's requesting to join the room.
     */
    public var userId: String
    /**
     * The room id of the room whose access was requested.
     */
    public var roomId: String
    /**
     * The optional display name of the user who's requesting to join the room.
     */
    public var displayName: String?
    /**
     * The optional avatar url of the user who's requesting to join the room.
     */
    public var avatarUrl: String?
    /**
     * An optional reason why the user wants join the room.
     */
    public var reason: String?
    /**
     * The timestamp when this request was created.
     */
    public var timestamp: UInt64?
    /**
     * Whether the knock request has been marked as `seen` so it can be
     * filtered by the client.
     */
    public var isSeen: Bool
    /**
     * A set of actions to perform for this knock request.
     */
    public var actions: KnockRequestActions

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The event id of the event that contains the `knock` membership change.
         */eventId: String, 
        /**
         * The user id of the user who's requesting to join the room.
         */userId: String, 
        /**
         * The room id of the room whose access was requested.
         */roomId: String, 
        /**
         * The optional display name of the user who's requesting to join the room.
         */displayName: String?, 
        /**
         * The optional avatar url of the user who's requesting to join the room.
         */avatarUrl: String?, 
        /**
         * An optional reason why the user wants join the room.
         */reason: String?, 
        /**
         * The timestamp when this request was created.
         */timestamp: UInt64?, 
        /**
         * Whether the knock request has been marked as `seen` so it can be
         * filtered by the client.
         */isSeen: Bool, 
        /**
         * A set of actions to perform for this knock request.
         */actions: KnockRequestActions) {
        self.eventId = eventId
        self.userId = userId
        self.roomId = roomId
        self.displayName = displayName
        self.avatarUrl = avatarUrl
        self.reason = reason
        self.timestamp = timestamp
        self.isSeen = isSeen
        self.actions = actions
    }
}



public struct FfiConverterTypeKnockRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KnockRequest {
        return
            try KnockRequest(
                eventId: FfiConverterString.read(from: &buf), 
                userId: FfiConverterString.read(from: &buf), 
                roomId: FfiConverterString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                reason: FfiConverterOptionString.read(from: &buf), 
                timestamp: FfiConverterOptionUInt64.read(from: &buf), 
                isSeen: FfiConverterBool.read(from: &buf), 
                actions: FfiConverterTypeKnockRequestActions.read(from: &buf)
        )
    }

    public static func write(_ value: KnockRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.eventId, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterOptionString.write(value.reason, into: &buf)
        FfiConverterOptionUInt64.write(value.timestamp, into: &buf)
        FfiConverterBool.write(value.isSeen, into: &buf)
        FfiConverterTypeKnockRequestActions.write(value.actions, into: &buf)
    }
}


public func FfiConverterTypeKnockRequest_lift(_ buf: RustBuffer) throws -> KnockRequest {
    return try FfiConverterTypeKnockRequest.lift(buf)
}

public func FfiConverterTypeKnockRequest_lower(_ value: KnockRequest) -> RustBuffer {
    return FfiConverterTypeKnockRequest.lower(value)
}


public struct LocationContent {
    public var body: String
    public var geoUri: String
    public var description: String?
    public var zoomLevel: UInt8?
    public var asset: AssetType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, geoUri: String, description: String?, zoomLevel: UInt8?, asset: AssetType?) {
        self.body = body
        self.geoUri = geoUri
        self.description = description
        self.zoomLevel = zoomLevel
        self.asset = asset
    }
}



extension LocationContent: Equatable, Hashable {
    public static func ==(lhs: LocationContent, rhs: LocationContent) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.geoUri != rhs.geoUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.zoomLevel != rhs.zoomLevel {
            return false
        }
        if lhs.asset != rhs.asset {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(geoUri)
        hasher.combine(description)
        hasher.combine(zoomLevel)
        hasher.combine(asset)
    }
}


public struct FfiConverterTypeLocationContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocationContent {
        return
            try LocationContent(
                body: FfiConverterString.read(from: &buf), 
                geoUri: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                zoomLevel: FfiConverterOptionUInt8.read(from: &buf), 
                asset: FfiConverterOptionTypeAssetType.read(from: &buf)
        )
    }

    public static func write(_ value: LocationContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterString.write(value.geoUri, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionUInt8.write(value.zoomLevel, into: &buf)
        FfiConverterOptionTypeAssetType.write(value.asset, into: &buf)
    }
}


public func FfiConverterTypeLocationContent_lift(_ buf: RustBuffer) throws -> LocationContent {
    return try FfiConverterTypeLocationContent.lift(buf)
}

public func FfiConverterTypeLocationContent_lower(_ value: LocationContent) -> RustBuffer {
    return FfiConverterTypeLocationContent.lower(value)
}


/**
 * A Matrix entity that can be a room, room alias, user, or event, and a list
 * of via servers.
 */
public struct MatrixEntity {
    public var id: MatrixId
    public var via: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: MatrixId, via: [String]) {
        self.id = id
        self.via = via
    }
}



extension MatrixEntity: Equatable, Hashable {
    public static func ==(lhs: MatrixEntity, rhs: MatrixEntity) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.via != rhs.via {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(via)
    }
}


public struct FfiConverterTypeMatrixEntity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixEntity {
        return
            try MatrixEntity(
                id: FfiConverterTypeMatrixId.read(from: &buf), 
                via: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: MatrixEntity, into buf: inout [UInt8]) {
        FfiConverterTypeMatrixId.write(value.id, into: &buf)
        FfiConverterSequenceString.write(value.via, into: &buf)
    }
}


public func FfiConverterTypeMatrixEntity_lift(_ buf: RustBuffer) throws -> MatrixEntity {
    return try FfiConverterTypeMatrixEntity.lift(buf)
}

public func FfiConverterTypeMatrixEntity_lower(_ value: MatrixEntity) -> RustBuffer {
    return FfiConverterTypeMatrixEntity.lower(value)
}


public struct Mentions {
    public var userIds: [String]
    public var room: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userIds: [String], room: Bool) {
        self.userIds = userIds
        self.room = room
    }
}



extension Mentions: Equatable, Hashable {
    public static func ==(lhs: Mentions, rhs: Mentions) -> Bool {
        if lhs.userIds != rhs.userIds {
            return false
        }
        if lhs.room != rhs.room {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userIds)
        hasher.combine(room)
    }
}


public struct FfiConverterTypeMentions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mentions {
        return
            try Mentions(
                userIds: FfiConverterSequenceString.read(from: &buf), 
                room: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Mentions, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.userIds, into: &buf)
        FfiConverterBool.write(value.room, into: &buf)
    }
}


public func FfiConverterTypeMentions_lift(_ buf: RustBuffer) throws -> Mentions {
    return try FfiConverterTypeMentions.lift(buf)
}

public func FfiConverterTypeMentions_lower(_ value: Mentions) -> RustBuffer {
    return FfiConverterTypeMentions.lower(value)
}


public struct MessageContent {
    public var msgType: MessageType
    public var body: String
    public var inReplyTo: InReplyToDetails?
    public var threadRoot: String?
    public var isEdited: Bool
    public var mentions: Mentions?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(msgType: MessageType, body: String, inReplyTo: InReplyToDetails?, threadRoot: String?, isEdited: Bool, mentions: Mentions?) {
        self.msgType = msgType
        self.body = body
        self.inReplyTo = inReplyTo
        self.threadRoot = threadRoot
        self.isEdited = isEdited
        self.mentions = mentions
    }
}



public struct FfiConverterTypeMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContent {
        return
            try MessageContent(
                msgType: FfiConverterTypeMessageType.read(from: &buf), 
                body: FfiConverterString.read(from: &buf), 
                inReplyTo: FfiConverterOptionTypeInReplyToDetails.read(from: &buf), 
                threadRoot: FfiConverterOptionString.read(from: &buf), 
                isEdited: FfiConverterBool.read(from: &buf), 
                mentions: FfiConverterOptionTypeMentions.read(from: &buf)
        )
    }

    public static func write(_ value: MessageContent, into buf: inout [UInt8]) {
        FfiConverterTypeMessageType.write(value.msgType, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeInReplyToDetails.write(value.inReplyTo, into: &buf)
        FfiConverterOptionString.write(value.threadRoot, into: &buf)
        FfiConverterBool.write(value.isEdited, into: &buf)
        FfiConverterOptionTypeMentions.write(value.mentions, into: &buf)
    }
}


public func FfiConverterTypeMessageContent_lift(_ buf: RustBuffer) throws -> MessageContent {
    return try FfiConverterTypeMessageContent.lift(buf)
}

public func FfiConverterTypeMessageContent_lower(_ value: MessageContent) -> RustBuffer {
    return FfiConverterTypeMessageContent.lower(value)
}


public struct NoticeMessageContent {
    public var body: String
    public var formatted: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?) {
        self.body = body
        self.formatted = formatted
    }
}



extension NoticeMessageContent: Equatable, Hashable {
    public static func ==(lhs: NoticeMessageContent, rhs: NoticeMessageContent) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.formatted != rhs.formatted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(formatted)
    }
}


public struct FfiConverterTypeNoticeMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoticeMessageContent {
        return
            try NoticeMessageContent(
                body: FfiConverterString.read(from: &buf), 
                formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: NoticeMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
    }
}


public func FfiConverterTypeNoticeMessageContent_lift(_ buf: RustBuffer) throws -> NoticeMessageContent {
    return try FfiConverterTypeNoticeMessageContent.lift(buf)
}

public func FfiConverterTypeNoticeMessageContent_lower(_ value: NoticeMessageContent) -> RustBuffer {
    return FfiConverterTypeNoticeMessageContent.lower(value)
}


public struct NotificationItem {
    public var event: NotificationEvent
    public var senderInfo: NotificationSenderInfo
    public var roomInfo: NotificationRoomInfo
    /**
     * Is the notification supposed to be at the "noisy" level?
     * Can be `None` if we couldn't determine this, because we lacked
     * information to create a push context.
     */
    public var isNoisy: Bool?
    public var hasMention: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(event: NotificationEvent, senderInfo: NotificationSenderInfo, roomInfo: NotificationRoomInfo, 
        /**
         * Is the notification supposed to be at the "noisy" level?
         * Can be `None` if we couldn't determine this, because we lacked
         * information to create a push context.
         */isNoisy: Bool?, hasMention: Bool?) {
        self.event = event
        self.senderInfo = senderInfo
        self.roomInfo = roomInfo
        self.isNoisy = isNoisy
        self.hasMention = hasMention
    }
}



public struct FfiConverterTypeNotificationItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationItem {
        return
            try NotificationItem(
                event: FfiConverterTypeNotificationEvent.read(from: &buf), 
                senderInfo: FfiConverterTypeNotificationSenderInfo.read(from: &buf), 
                roomInfo: FfiConverterTypeNotificationRoomInfo.read(from: &buf), 
                isNoisy: FfiConverterOptionBool.read(from: &buf), 
                hasMention: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationItem, into buf: inout [UInt8]) {
        FfiConverterTypeNotificationEvent.write(value.event, into: &buf)
        FfiConverterTypeNotificationSenderInfo.write(value.senderInfo, into: &buf)
        FfiConverterTypeNotificationRoomInfo.write(value.roomInfo, into: &buf)
        FfiConverterOptionBool.write(value.isNoisy, into: &buf)
        FfiConverterOptionBool.write(value.hasMention, into: &buf)
    }
}


public func FfiConverterTypeNotificationItem_lift(_ buf: RustBuffer) throws -> NotificationItem {
    return try FfiConverterTypeNotificationItem.lift(buf)
}

public func FfiConverterTypeNotificationItem_lower(_ value: NotificationItem) -> RustBuffer {
    return FfiConverterTypeNotificationItem.lower(value)
}


public struct NotificationPowerLevels {
    public var room: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: Int32) {
        self.room = room
    }
}



extension NotificationPowerLevels: Equatable, Hashable {
    public static func ==(lhs: NotificationPowerLevels, rhs: NotificationPowerLevels) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
    }
}


public struct FfiConverterTypeNotificationPowerLevels: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationPowerLevels {
        return
            try NotificationPowerLevels(
                room: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationPowerLevels, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.room, into: &buf)
    }
}


public func FfiConverterTypeNotificationPowerLevels_lift(_ buf: RustBuffer) throws -> NotificationPowerLevels {
    return try FfiConverterTypeNotificationPowerLevels.lift(buf)
}

public func FfiConverterTypeNotificationPowerLevels_lower(_ value: NotificationPowerLevels) -> RustBuffer {
    return FfiConverterTypeNotificationPowerLevels.lower(value)
}


public struct NotificationRoomInfo {
    public var displayName: String
    public var avatarUrl: String?
    public var canonicalAlias: String?
    public var joinedMembersCount: UInt64
    public var isEncrypted: Bool?
    public var isDirect: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: String, avatarUrl: String?, canonicalAlias: String?, joinedMembersCount: UInt64, isEncrypted: Bool?, isDirect: Bool) {
        self.displayName = displayName
        self.avatarUrl = avatarUrl
        self.canonicalAlias = canonicalAlias
        self.joinedMembersCount = joinedMembersCount
        self.isEncrypted = isEncrypted
        self.isDirect = isDirect
    }
}



extension NotificationRoomInfo: Equatable, Hashable {
    public static func ==(lhs: NotificationRoomInfo, rhs: NotificationRoomInfo) -> Bool {
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        if lhs.canonicalAlias != rhs.canonicalAlias {
            return false
        }
        if lhs.joinedMembersCount != rhs.joinedMembersCount {
            return false
        }
        if lhs.isEncrypted != rhs.isEncrypted {
            return false
        }
        if lhs.isDirect != rhs.isDirect {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(displayName)
        hasher.combine(avatarUrl)
        hasher.combine(canonicalAlias)
        hasher.combine(joinedMembersCount)
        hasher.combine(isEncrypted)
        hasher.combine(isDirect)
    }
}


public struct FfiConverterTypeNotificationRoomInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationRoomInfo {
        return
            try NotificationRoomInfo(
                displayName: FfiConverterString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                canonicalAlias: FfiConverterOptionString.read(from: &buf), 
                joinedMembersCount: FfiConverterUInt64.read(from: &buf), 
                isEncrypted: FfiConverterOptionBool.read(from: &buf), 
                isDirect: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationRoomInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
        FfiConverterUInt64.write(value.joinedMembersCount, into: &buf)
        FfiConverterOptionBool.write(value.isEncrypted, into: &buf)
        FfiConverterBool.write(value.isDirect, into: &buf)
    }
}


public func FfiConverterTypeNotificationRoomInfo_lift(_ buf: RustBuffer) throws -> NotificationRoomInfo {
    return try FfiConverterTypeNotificationRoomInfo.lift(buf)
}

public func FfiConverterTypeNotificationRoomInfo_lower(_ value: NotificationRoomInfo) -> RustBuffer {
    return FfiConverterTypeNotificationRoomInfo.lower(value)
}


public struct NotificationSenderInfo {
    public var displayName: String?
    public var avatarUrl: String?
    public var isNameAmbiguous: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: String?, avatarUrl: String?, isNameAmbiguous: Bool) {
        self.displayName = displayName
        self.avatarUrl = avatarUrl
        self.isNameAmbiguous = isNameAmbiguous
    }
}



extension NotificationSenderInfo: Equatable, Hashable {
    public static func ==(lhs: NotificationSenderInfo, rhs: NotificationSenderInfo) -> Bool {
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        if lhs.isNameAmbiguous != rhs.isNameAmbiguous {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(displayName)
        hasher.combine(avatarUrl)
        hasher.combine(isNameAmbiguous)
    }
}


public struct FfiConverterTypeNotificationSenderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationSenderInfo {
        return
            try NotificationSenderInfo(
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                isNameAmbiguous: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationSenderInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterBool.write(value.isNameAmbiguous, into: &buf)
    }
}


public func FfiConverterTypeNotificationSenderInfo_lift(_ buf: RustBuffer) throws -> NotificationSenderInfo {
    return try FfiConverterTypeNotificationSenderInfo.lift(buf)
}

public func FfiConverterTypeNotificationSenderInfo_lower(_ value: NotificationSenderInfo) -> RustBuffer {
    return FfiConverterTypeNotificationSenderInfo.lower(value)
}


/**
 * The configuration to use when authenticating with OIDC.
 */
public struct OidcConfiguration {
    /**
     * The name of the client that will be shown during OIDC authentication.
     */
    public var clientName: String?
    /**
     * The redirect URI that will be used when OIDC authentication is
     * successful.
     */
    public var redirectUri: String
    /**
     * A URI that contains information about the client.
     */
    public var clientUri: String?
    /**
     * A URI that contains the client's logo.
     */
    public var logoUri: String?
    /**
     * A URI that contains the client's terms of service.
     */
    public var tosUri: String?
    /**
     * A URI that contains the client's privacy policy.
     */
    public var policyUri: String?
    /**
     * An array of e-mail addresses of people responsible for this client.
     */
    public var contacts: [String]?
    /**
     * Pre-configured registrations for use with issuers that don't support
     * dynamic client registration.
     */
    public var staticRegistrations: [String: String]
    /**
     * A file path where any dynamic registrations should be stored.
     *
     * Suggested value: `{base_path}/oidc/registrations.json`
     */
    public var dynamicRegistrationsFile: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The name of the client that will be shown during OIDC authentication.
         */clientName: String?, 
        /**
         * The redirect URI that will be used when OIDC authentication is
         * successful.
         */redirectUri: String, 
        /**
         * A URI that contains information about the client.
         */clientUri: String?, 
        /**
         * A URI that contains the client's logo.
         */logoUri: String?, 
        /**
         * A URI that contains the client's terms of service.
         */tosUri: String?, 
        /**
         * A URI that contains the client's privacy policy.
         */policyUri: String?, 
        /**
         * An array of e-mail addresses of people responsible for this client.
         */contacts: [String]?, 
        /**
         * Pre-configured registrations for use with issuers that don't support
         * dynamic client registration.
         */staticRegistrations: [String: String], 
        /**
         * A file path where any dynamic registrations should be stored.
         *
         * Suggested value: `{base_path}/oidc/registrations.json`
         */dynamicRegistrationsFile: String) {
        self.clientName = clientName
        self.redirectUri = redirectUri
        self.clientUri = clientUri
        self.logoUri = logoUri
        self.tosUri = tosUri
        self.policyUri = policyUri
        self.contacts = contacts
        self.staticRegistrations = staticRegistrations
        self.dynamicRegistrationsFile = dynamicRegistrationsFile
    }
}



extension OidcConfiguration: Equatable, Hashable {
    public static func ==(lhs: OidcConfiguration, rhs: OidcConfiguration) -> Bool {
        if lhs.clientName != rhs.clientName {
            return false
        }
        if lhs.redirectUri != rhs.redirectUri {
            return false
        }
        if lhs.clientUri != rhs.clientUri {
            return false
        }
        if lhs.logoUri != rhs.logoUri {
            return false
        }
        if lhs.tosUri != rhs.tosUri {
            return false
        }
        if lhs.policyUri != rhs.policyUri {
            return false
        }
        if lhs.contacts != rhs.contacts {
            return false
        }
        if lhs.staticRegistrations != rhs.staticRegistrations {
            return false
        }
        if lhs.dynamicRegistrationsFile != rhs.dynamicRegistrationsFile {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clientName)
        hasher.combine(redirectUri)
        hasher.combine(clientUri)
        hasher.combine(logoUri)
        hasher.combine(tosUri)
        hasher.combine(policyUri)
        hasher.combine(contacts)
        hasher.combine(staticRegistrations)
        hasher.combine(dynamicRegistrationsFile)
    }
}


public struct FfiConverterTypeOidcConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcConfiguration {
        return
            try OidcConfiguration(
                clientName: FfiConverterOptionString.read(from: &buf), 
                redirectUri: FfiConverterString.read(from: &buf), 
                clientUri: FfiConverterOptionString.read(from: &buf), 
                logoUri: FfiConverterOptionString.read(from: &buf), 
                tosUri: FfiConverterOptionString.read(from: &buf), 
                policyUri: FfiConverterOptionString.read(from: &buf), 
                contacts: FfiConverterOptionSequenceString.read(from: &buf), 
                staticRegistrations: FfiConverterDictionaryStringString.read(from: &buf), 
                dynamicRegistrationsFile: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OidcConfiguration, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.clientName, into: &buf)
        FfiConverterString.write(value.redirectUri, into: &buf)
        FfiConverterOptionString.write(value.clientUri, into: &buf)
        FfiConverterOptionString.write(value.logoUri, into: &buf)
        FfiConverterOptionString.write(value.tosUri, into: &buf)
        FfiConverterOptionString.write(value.policyUri, into: &buf)
        FfiConverterOptionSequenceString.write(value.contacts, into: &buf)
        FfiConverterDictionaryStringString.write(value.staticRegistrations, into: &buf)
        FfiConverterString.write(value.dynamicRegistrationsFile, into: &buf)
    }
}


public func FfiConverterTypeOidcConfiguration_lift(_ buf: RustBuffer) throws -> OidcConfiguration {
    return try FfiConverterTypeOidcConfiguration.lift(buf)
}

public func FfiConverterTypeOidcConfiguration_lower(_ value: OidcConfiguration) -> RustBuffer {
    return FfiConverterTypeOidcConfiguration.lower(value)
}


public struct OidcCrossSigningResetInfo {
    /**
     * The URL where the user can approve the reset of the cross-signing keys.
     */
    public var approvalUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The URL where the user can approve the reset of the cross-signing keys.
         */approvalUrl: String) {
        self.approvalUrl = approvalUrl
    }
}



extension OidcCrossSigningResetInfo: Equatable, Hashable {
    public static func ==(lhs: OidcCrossSigningResetInfo, rhs: OidcCrossSigningResetInfo) -> Bool {
        if lhs.approvalUrl != rhs.approvalUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(approvalUrl)
    }
}


public struct FfiConverterTypeOidcCrossSigningResetInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcCrossSigningResetInfo {
        return
            try OidcCrossSigningResetInfo(
                approvalUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OidcCrossSigningResetInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.approvalUrl, into: &buf)
    }
}


public func FfiConverterTypeOidcCrossSigningResetInfo_lift(_ buf: RustBuffer) throws -> OidcCrossSigningResetInfo {
    return try FfiConverterTypeOidcCrossSigningResetInfo.lift(buf)
}

public func FfiConverterTypeOidcCrossSigningResetInfo_lower(_ value: OidcCrossSigningResetInfo) -> RustBuffer {
    return FfiConverterTypeOidcCrossSigningResetInfo.lower(value)
}


public struct PollAnswer {
    public var id: String
    public var text: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, text: String) {
        self.id = id
        self.text = text
    }
}



extension PollAnswer: Equatable, Hashable {
    public static func ==(lhs: PollAnswer, rhs: PollAnswer) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(text)
    }
}


public struct FfiConverterTypePollAnswer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollAnswer {
        return
            try PollAnswer(
                id: FfiConverterString.read(from: &buf), 
                text: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PollAnswer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
    }
}


public func FfiConverterTypePollAnswer_lift(_ buf: RustBuffer) throws -> PollAnswer {
    return try FfiConverterTypePollAnswer.lift(buf)
}

public func FfiConverterTypePollAnswer_lower(_ value: PollAnswer) -> RustBuffer {
    return FfiConverterTypePollAnswer.lower(value)
}


public struct PollData {
    public var question: String
    public var answers: [String]
    public var maxSelections: UInt8
    public var pollKind: PollKind

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(question: String, answers: [String], maxSelections: UInt8, pollKind: PollKind) {
        self.question = question
        self.answers = answers
        self.maxSelections = maxSelections
        self.pollKind = pollKind
    }
}



extension PollData: Equatable, Hashable {
    public static func ==(lhs: PollData, rhs: PollData) -> Bool {
        if lhs.question != rhs.question {
            return false
        }
        if lhs.answers != rhs.answers {
            return false
        }
        if lhs.maxSelections != rhs.maxSelections {
            return false
        }
        if lhs.pollKind != rhs.pollKind {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(question)
        hasher.combine(answers)
        hasher.combine(maxSelections)
        hasher.combine(pollKind)
    }
}


public struct FfiConverterTypePollData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollData {
        return
            try PollData(
                question: FfiConverterString.read(from: &buf), 
                answers: FfiConverterSequenceString.read(from: &buf), 
                maxSelections: FfiConverterUInt8.read(from: &buf), 
                pollKind: FfiConverterTypePollKind.read(from: &buf)
        )
    }

    public static func write(_ value: PollData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.question, into: &buf)
        FfiConverterSequenceString.write(value.answers, into: &buf)
        FfiConverterUInt8.write(value.maxSelections, into: &buf)
        FfiConverterTypePollKind.write(value.pollKind, into: &buf)
    }
}


public func FfiConverterTypePollData_lift(_ buf: RustBuffer) throws -> PollData {
    return try FfiConverterTypePollData.lift(buf)
}

public func FfiConverterTypePollData_lower(_ value: PollData) -> RustBuffer {
    return FfiConverterTypePollData.lower(value)
}


public struct PowerLevels {
    public var usersDefault: Int32?
    public var eventsDefault: Int32?
    public var stateDefault: Int32?
    public var ban: Int32?
    public var kick: Int32?
    public var redact: Int32?
    public var invite: Int32?
    public var notifications: NotificationPowerLevels?
    public var users: [String: Int32]
    public var events: [String: Int32]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(usersDefault: Int32?, eventsDefault: Int32?, stateDefault: Int32?, ban: Int32?, kick: Int32?, redact: Int32?, invite: Int32?, notifications: NotificationPowerLevels?, users: [String: Int32], events: [String: Int32]) {
        self.usersDefault = usersDefault
        self.eventsDefault = eventsDefault
        self.stateDefault = stateDefault
        self.ban = ban
        self.kick = kick
        self.redact = redact
        self.invite = invite
        self.notifications = notifications
        self.users = users
        self.events = events
    }
}



extension PowerLevels: Equatable, Hashable {
    public static func ==(lhs: PowerLevels, rhs: PowerLevels) -> Bool {
        if lhs.usersDefault != rhs.usersDefault {
            return false
        }
        if lhs.eventsDefault != rhs.eventsDefault {
            return false
        }
        if lhs.stateDefault != rhs.stateDefault {
            return false
        }
        if lhs.ban != rhs.ban {
            return false
        }
        if lhs.kick != rhs.kick {
            return false
        }
        if lhs.redact != rhs.redact {
            return false
        }
        if lhs.invite != rhs.invite {
            return false
        }
        if lhs.notifications != rhs.notifications {
            return false
        }
        if lhs.users != rhs.users {
            return false
        }
        if lhs.events != rhs.events {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(usersDefault)
        hasher.combine(eventsDefault)
        hasher.combine(stateDefault)
        hasher.combine(ban)
        hasher.combine(kick)
        hasher.combine(redact)
        hasher.combine(invite)
        hasher.combine(notifications)
        hasher.combine(users)
        hasher.combine(events)
    }
}


public struct FfiConverterTypePowerLevels: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PowerLevels {
        return
            try PowerLevels(
                usersDefault: FfiConverterOptionInt32.read(from: &buf), 
                eventsDefault: FfiConverterOptionInt32.read(from: &buf), 
                stateDefault: FfiConverterOptionInt32.read(from: &buf), 
                ban: FfiConverterOptionInt32.read(from: &buf), 
                kick: FfiConverterOptionInt32.read(from: &buf), 
                redact: FfiConverterOptionInt32.read(from: &buf), 
                invite: FfiConverterOptionInt32.read(from: &buf), 
                notifications: FfiConverterOptionTypeNotificationPowerLevels.read(from: &buf), 
                users: FfiConverterDictionaryStringInt32.read(from: &buf), 
                events: FfiConverterDictionaryStringInt32.read(from: &buf)
        )
    }

    public static func write(_ value: PowerLevels, into buf: inout [UInt8]) {
        FfiConverterOptionInt32.write(value.usersDefault, into: &buf)
        FfiConverterOptionInt32.write(value.eventsDefault, into: &buf)
        FfiConverterOptionInt32.write(value.stateDefault, into: &buf)
        FfiConverterOptionInt32.write(value.ban, into: &buf)
        FfiConverterOptionInt32.write(value.kick, into: &buf)
        FfiConverterOptionInt32.write(value.redact, into: &buf)
        FfiConverterOptionInt32.write(value.invite, into: &buf)
        FfiConverterOptionTypeNotificationPowerLevels.write(value.notifications, into: &buf)
        FfiConverterDictionaryStringInt32.write(value.users, into: &buf)
        FfiConverterDictionaryStringInt32.write(value.events, into: &buf)
    }
}


public func FfiConverterTypePowerLevels_lift(_ buf: RustBuffer) throws -> PowerLevels {
    return try FfiConverterTypePowerLevels.lift(buf)
}

public func FfiConverterTypePowerLevels_lower(_ value: PowerLevels) -> RustBuffer {
    return FfiConverterTypePowerLevels.lower(value)
}


public struct PusherIdentifiers {
    public var pushkey: String
    public var appId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pushkey: String, appId: String) {
        self.pushkey = pushkey
        self.appId = appId
    }
}



extension PusherIdentifiers: Equatable, Hashable {
    public static func ==(lhs: PusherIdentifiers, rhs: PusherIdentifiers) -> Bool {
        if lhs.pushkey != rhs.pushkey {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pushkey)
        hasher.combine(appId)
    }
}


public struct FfiConverterTypePusherIdentifiers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherIdentifiers {
        return
            try PusherIdentifiers(
                pushkey: FfiConverterString.read(from: &buf), 
                appId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PusherIdentifiers, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pushkey, into: &buf)
        FfiConverterString.write(value.appId, into: &buf)
    }
}


public func FfiConverterTypePusherIdentifiers_lift(_ buf: RustBuffer) throws -> PusherIdentifiers {
    return try FfiConverterTypePusherIdentifiers.lift(buf)
}

public func FfiConverterTypePusherIdentifiers_lower(_ value: PusherIdentifiers) -> RustBuffer {
    return FfiConverterTypePusherIdentifiers.lower(value)
}


public struct Reaction {
    public var key: String
    public var senders: [ReactionSenderData]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, senders: [ReactionSenderData]) {
        self.key = key
        self.senders = senders
    }
}



extension Reaction: Equatable, Hashable {
    public static func ==(lhs: Reaction, rhs: Reaction) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.senders != rhs.senders {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(senders)
    }
}


public struct FfiConverterTypeReaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reaction {
        return
            try Reaction(
                key: FfiConverterString.read(from: &buf), 
                senders: FfiConverterSequenceTypeReactionSenderData.read(from: &buf)
        )
    }

    public static func write(_ value: Reaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterSequenceTypeReactionSenderData.write(value.senders, into: &buf)
    }
}


public func FfiConverterTypeReaction_lift(_ buf: RustBuffer) throws -> Reaction {
    return try FfiConverterTypeReaction.lift(buf)
}

public func FfiConverterTypeReaction_lower(_ value: Reaction) -> RustBuffer {
    return FfiConverterTypeReaction.lower(value)
}


public struct ReactionSenderData {
    public var senderId: String
    public var timestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(senderId: String, timestamp: UInt64) {
        self.senderId = senderId
        self.timestamp = timestamp
    }
}



extension ReactionSenderData: Equatable, Hashable {
    public static func ==(lhs: ReactionSenderData, rhs: ReactionSenderData) -> Bool {
        if lhs.senderId != rhs.senderId {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(senderId)
        hasher.combine(timestamp)
    }
}


public struct FfiConverterTypeReactionSenderData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReactionSenderData {
        return
            try ReactionSenderData(
                senderId: FfiConverterString.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ReactionSenderData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.senderId, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeReactionSenderData_lift(_ buf: RustBuffer) throws -> ReactionSenderData {
    return try FfiConverterTypeReactionSenderData.lift(buf)
}

public func FfiConverterTypeReactionSenderData_lower(_ value: ReactionSenderData) -> RustBuffer {
    return FfiConverterTypeReactionSenderData.lower(value)
}


public struct Receipt {
    public var timestamp: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timestamp: UInt64?) {
        self.timestamp = timestamp
    }
}



extension Receipt: Equatable, Hashable {
    public static func ==(lhs: Receipt, rhs: Receipt) -> Bool {
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(timestamp)
    }
}


public struct FfiConverterTypeReceipt: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Receipt {
        return
            try Receipt(
                timestamp: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Receipt, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeReceipt_lift(_ buf: RustBuffer) throws -> Receipt {
    return try FfiConverterTypeReceipt.lift(buf)
}

public func FfiConverterTypeReceipt_lower(_ value: Receipt) -> RustBuffer {
    return FfiConverterTypeReceipt.lower(value)
}


/**
 * The config to use for HTTP requests by default in this client.
 */
public struct RequestConfig {
    /**
     * Max number of retries.
     */
    public var retryLimit: UInt64?
    /**
     * Timeout for a request in milliseconds.
     */
    public var timeout: UInt64?
    /**
     * Max number of concurrent requests. No value means no limits.
     */
    public var maxConcurrentRequests: UInt64?
    /**
     * Base delay between retries.
     */
    public var retryTimeout: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Max number of retries.
         */retryLimit: UInt64?, 
        /**
         * Timeout for a request in milliseconds.
         */timeout: UInt64?, 
        /**
         * Max number of concurrent requests. No value means no limits.
         */maxConcurrentRequests: UInt64?, 
        /**
         * Base delay between retries.
         */retryTimeout: UInt64?) {
        self.retryLimit = retryLimit
        self.timeout = timeout
        self.maxConcurrentRequests = maxConcurrentRequests
        self.retryTimeout = retryTimeout
    }
}



extension RequestConfig: Equatable, Hashable {
    public static func ==(lhs: RequestConfig, rhs: RequestConfig) -> Bool {
        if lhs.retryLimit != rhs.retryLimit {
            return false
        }
        if lhs.timeout != rhs.timeout {
            return false
        }
        if lhs.maxConcurrentRequests != rhs.maxConcurrentRequests {
            return false
        }
        if lhs.retryTimeout != rhs.retryTimeout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(retryLimit)
        hasher.combine(timeout)
        hasher.combine(maxConcurrentRequests)
        hasher.combine(retryTimeout)
    }
}


public struct FfiConverterTypeRequestConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestConfig {
        return
            try RequestConfig(
                retryLimit: FfiConverterOptionUInt64.read(from: &buf), 
                timeout: FfiConverterOptionUInt64.read(from: &buf), 
                maxConcurrentRequests: FfiConverterOptionUInt64.read(from: &buf), 
                retryTimeout: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RequestConfig, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.retryLimit, into: &buf)
        FfiConverterOptionUInt64.write(value.timeout, into: &buf)
        FfiConverterOptionUInt64.write(value.maxConcurrentRequests, into: &buf)
        FfiConverterOptionUInt64.write(value.retryTimeout, into: &buf)
    }
}


public func FfiConverterTypeRequestConfig_lift(_ buf: RustBuffer) throws -> RequestConfig {
    return try FfiConverterTypeRequestConfig.lift(buf)
}

public func FfiConverterTypeRequestConfig_lower(_ value: RequestConfig) -> RustBuffer {
    return FfiConverterTypeRequestConfig.lower(value)
}


/**
 * Information about a room, that was resolved from a room alias.
 */
public struct ResolvedRoomAlias {
    /**
     * The room ID that the alias resolved to.
     */
    public var roomId: String
    /**
     * A list of servers that can be used to find the room by its room ID.
     */
    public var servers: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The room ID that the alias resolved to.
         */roomId: String, 
        /**
         * A list of servers that can be used to find the room by its room ID.
         */servers: [String]) {
        self.roomId = roomId
        self.servers = servers
    }
}



extension ResolvedRoomAlias: Equatable, Hashable {
    public static func ==(lhs: ResolvedRoomAlias, rhs: ResolvedRoomAlias) -> Bool {
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.servers != rhs.servers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(roomId)
        hasher.combine(servers)
    }
}


public struct FfiConverterTypeResolvedRoomAlias: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResolvedRoomAlias {
        return
            try ResolvedRoomAlias(
                roomId: FfiConverterString.read(from: &buf), 
                servers: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ResolvedRoomAlias, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterSequenceString.write(value.servers, into: &buf)
    }
}


public func FfiConverterTypeResolvedRoomAlias_lift(_ buf: RustBuffer) throws -> ResolvedRoomAlias {
    return try FfiConverterTypeResolvedRoomAlias.lift(buf)
}

public func FfiConverterTypeResolvedRoomAlias_lower(_ value: ResolvedRoomAlias) -> RustBuffer {
    return FfiConverterTypeResolvedRoomAlias.lower(value)
}


public struct RoomDescription {
    public var roomId: String
    public var name: String?
    public var topic: String?
    public var alias: String?
    public var avatarUrl: String?
    public var joinRule: PublicRoomJoinRule?
    public var isWorldReadable: Bool
    public var joinedMembers: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(roomId: String, name: String?, topic: String?, alias: String?, avatarUrl: String?, joinRule: PublicRoomJoinRule?, isWorldReadable: Bool, joinedMembers: UInt64) {
        self.roomId = roomId
        self.name = name
        self.topic = topic
        self.alias = alias
        self.avatarUrl = avatarUrl
        self.joinRule = joinRule
        self.isWorldReadable = isWorldReadable
        self.joinedMembers = joinedMembers
    }
}



extension RoomDescription: Equatable, Hashable {
    public static func ==(lhs: RoomDescription, rhs: RoomDescription) -> Bool {
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.topic != rhs.topic {
            return false
        }
        if lhs.alias != rhs.alias {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        if lhs.joinRule != rhs.joinRule {
            return false
        }
        if lhs.isWorldReadable != rhs.isWorldReadable {
            return false
        }
        if lhs.joinedMembers != rhs.joinedMembers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(roomId)
        hasher.combine(name)
        hasher.combine(topic)
        hasher.combine(alias)
        hasher.combine(avatarUrl)
        hasher.combine(joinRule)
        hasher.combine(isWorldReadable)
        hasher.combine(joinedMembers)
    }
}


public struct FfiConverterTypeRoomDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomDescription {
        return
            try RoomDescription(
                roomId: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                alias: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                joinRule: FfiConverterOptionTypePublicRoomJoinRule.read(from: &buf), 
                isWorldReadable: FfiConverterBool.read(from: &buf), 
                joinedMembers: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoomDescription, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterOptionString.write(value.alias, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterOptionTypePublicRoomJoinRule.write(value.joinRule, into: &buf)
        FfiConverterBool.write(value.isWorldReadable, into: &buf)
        FfiConverterUInt64.write(value.joinedMembers, into: &buf)
    }
}


public func FfiConverterTypeRoomDescription_lift(_ buf: RustBuffer) throws -> RoomDescription {
    return try FfiConverterTypeRoomDescription.lift(buf)
}

public func FfiConverterTypeRoomDescription_lower(_ value: RoomDescription) -> RustBuffer {
    return FfiConverterTypeRoomDescription.lower(value)
}


public struct RoomDirectorySearchEntriesResult {
    public var entriesStream: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entriesStream: TaskHandle) {
        self.entriesStream = entriesStream
    }
}



public struct FfiConverterTypeRoomDirectorySearchEntriesResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomDirectorySearchEntriesResult {
        return
            try RoomDirectorySearchEntriesResult(
                entriesStream: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: RoomDirectorySearchEntriesResult, into buf: inout [UInt8]) {
        FfiConverterTypeTaskHandle.write(value.entriesStream, into: &buf)
    }
}


public func FfiConverterTypeRoomDirectorySearchEntriesResult_lift(_ buf: RustBuffer) throws -> RoomDirectorySearchEntriesResult {
    return try FfiConverterTypeRoomDirectorySearchEntriesResult.lift(buf)
}

public func FfiConverterTypeRoomDirectorySearchEntriesResult_lower(_ value: RoomDirectorySearchEntriesResult) -> RustBuffer {
    return FfiConverterTypeRoomDirectorySearchEntriesResult.lower(value)
}


/**
 * Information about a member considered to be a room hero.
 */
public struct RoomHero {
    /**
     * The user ID of the hero.
     */
    public var userId: String
    /**
     * The display name of the hero.
     */
    public var displayName: String?
    /**
     * The avatar URL of the hero.
     */
    public var avatarUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user ID of the hero.
         */userId: String, 
        /**
         * The display name of the hero.
         */displayName: String?, 
        /**
         * The avatar URL of the hero.
         */avatarUrl: String?) {
        self.userId = userId
        self.displayName = displayName
        self.avatarUrl = avatarUrl
    }
}



extension RoomHero: Equatable, Hashable {
    public static func ==(lhs: RoomHero, rhs: RoomHero) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(displayName)
        hasher.combine(avatarUrl)
    }
}


public struct FfiConverterTypeRoomHero: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomHero {
        return
            try RoomHero(
                userId: FfiConverterString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: RoomHero, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
    }
}


public func FfiConverterTypeRoomHero_lift(_ buf: RustBuffer) throws -> RoomHero {
    return try FfiConverterTypeRoomHero.lift(buf)
}

public func FfiConverterTypeRoomHero_lower(_ value: RoomHero) -> RustBuffer {
    return FfiConverterTypeRoomHero.lower(value)
}


public struct RoomInfo {
    public var id: String
    public var creator: String?
    /**
     * The room's name from the room state event if received from sync, or one
     * that's been computed otherwise.
     */
    public var displayName: String?
    /**
     * Room name as defined by the room state event only.
     */
    public var rawName: String?
    public var topic: String?
    public var avatarUrl: String?
    public var isDirect: Bool
    public var isPublic: Bool
    public var isSpace: Bool
    public var isTombstoned: Bool
    public var isFavourite: Bool
    public var canonicalAlias: String?
    public var alternativeAliases: [String]
    public var membership: Membership
    /**
     * Member who invited the current user to a room that's in the invited
     * state.
     *
     * Can be missing if the room membership invite event is missing from the
     * store.
     */
    public var inviter: RoomMember?
    public var heroes: [RoomHero]
    public var activeMembersCount: UInt64
    public var invitedMembersCount: UInt64
    public var joinedMembersCount: UInt64
    public var userPowerLevels: [String: Int64]
    public var highlightCount: UInt64
    public var notificationCount: UInt64
    public var cachedUserDefinedNotificationMode: RoomNotificationMode?
    public var hasRoomCall: Bool
    public var activeRoomCallParticipants: [String]
    /**
     * Whether this room has been explicitly marked as unread
     */
    public var isMarkedUnread: Bool
    /**
     * "Interesting" messages received in that room, independently of the
     * notification settings.
     */
    public var numUnreadMessages: UInt64
    /**
     * Events that will notify the user, according to their
     * notification settings.
     */
    public var numUnreadNotifications: UInt64
    /**
     * Events causing mentions/highlights for the user, according to their
     * notification settings.
     */
    public var numUnreadMentions: UInt64
    /**
     * The currently pinned event ids.
     */
    public var pinnedEventIds: [String]
    /**
     * The join rule for this room, if known.
     */
    public var joinRule: JoinRule?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, creator: String?, 
        /**
         * The room's name from the room state event if received from sync, or one
         * that's been computed otherwise.
         */displayName: String?, 
        /**
         * Room name as defined by the room state event only.
         */rawName: String?, topic: String?, avatarUrl: String?, isDirect: Bool, isPublic: Bool, isSpace: Bool, isTombstoned: Bool, isFavourite: Bool, canonicalAlias: String?, alternativeAliases: [String], membership: Membership, 
        /**
         * Member who invited the current user to a room that's in the invited
         * state.
         *
         * Can be missing if the room membership invite event is missing from the
         * store.
         */inviter: RoomMember?, heroes: [RoomHero], activeMembersCount: UInt64, invitedMembersCount: UInt64, joinedMembersCount: UInt64, userPowerLevels: [String: Int64], highlightCount: UInt64, notificationCount: UInt64, cachedUserDefinedNotificationMode: RoomNotificationMode?, hasRoomCall: Bool, activeRoomCallParticipants: [String], 
        /**
         * Whether this room has been explicitly marked as unread
         */isMarkedUnread: Bool, 
        /**
         * "Interesting" messages received in that room, independently of the
         * notification settings.
         */numUnreadMessages: UInt64, 
        /**
         * Events that will notify the user, according to their
         * notification settings.
         */numUnreadNotifications: UInt64, 
        /**
         * Events causing mentions/highlights for the user, according to their
         * notification settings.
         */numUnreadMentions: UInt64, 
        /**
         * The currently pinned event ids.
         */pinnedEventIds: [String], 
        /**
         * The join rule for this room, if known.
         */joinRule: JoinRule?) {
        self.id = id
        self.creator = creator
        self.displayName = displayName
        self.rawName = rawName
        self.topic = topic
        self.avatarUrl = avatarUrl
        self.isDirect = isDirect
        self.isPublic = isPublic
        self.isSpace = isSpace
        self.isTombstoned = isTombstoned
        self.isFavourite = isFavourite
        self.canonicalAlias = canonicalAlias
        self.alternativeAliases = alternativeAliases
        self.membership = membership
        self.inviter = inviter
        self.heroes = heroes
        self.activeMembersCount = activeMembersCount
        self.invitedMembersCount = invitedMembersCount
        self.joinedMembersCount = joinedMembersCount
        self.userPowerLevels = userPowerLevels
        self.highlightCount = highlightCount
        self.notificationCount = notificationCount
        self.cachedUserDefinedNotificationMode = cachedUserDefinedNotificationMode
        self.hasRoomCall = hasRoomCall
        self.activeRoomCallParticipants = activeRoomCallParticipants
        self.isMarkedUnread = isMarkedUnread
        self.numUnreadMessages = numUnreadMessages
        self.numUnreadNotifications = numUnreadNotifications
        self.numUnreadMentions = numUnreadMentions
        self.pinnedEventIds = pinnedEventIds
        self.joinRule = joinRule
    }
}



extension RoomInfo: Equatable, Hashable {
    public static func ==(lhs: RoomInfo, rhs: RoomInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.creator != rhs.creator {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.rawName != rhs.rawName {
            return false
        }
        if lhs.topic != rhs.topic {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        if lhs.isDirect != rhs.isDirect {
            return false
        }
        if lhs.isPublic != rhs.isPublic {
            return false
        }
        if lhs.isSpace != rhs.isSpace {
            return false
        }
        if lhs.isTombstoned != rhs.isTombstoned {
            return false
        }
        if lhs.isFavourite != rhs.isFavourite {
            return false
        }
        if lhs.canonicalAlias != rhs.canonicalAlias {
            return false
        }
        if lhs.alternativeAliases != rhs.alternativeAliases {
            return false
        }
        if lhs.membership != rhs.membership {
            return false
        }
        if lhs.inviter != rhs.inviter {
            return false
        }
        if lhs.heroes != rhs.heroes {
            return false
        }
        if lhs.activeMembersCount != rhs.activeMembersCount {
            return false
        }
        if lhs.invitedMembersCount != rhs.invitedMembersCount {
            return false
        }
        if lhs.joinedMembersCount != rhs.joinedMembersCount {
            return false
        }
        if lhs.userPowerLevels != rhs.userPowerLevels {
            return false
        }
        if lhs.highlightCount != rhs.highlightCount {
            return false
        }
        if lhs.notificationCount != rhs.notificationCount {
            return false
        }
        if lhs.cachedUserDefinedNotificationMode != rhs.cachedUserDefinedNotificationMode {
            return false
        }
        if lhs.hasRoomCall != rhs.hasRoomCall {
            return false
        }
        if lhs.activeRoomCallParticipants != rhs.activeRoomCallParticipants {
            return false
        }
        if lhs.isMarkedUnread != rhs.isMarkedUnread {
            return false
        }
        if lhs.numUnreadMessages != rhs.numUnreadMessages {
            return false
        }
        if lhs.numUnreadNotifications != rhs.numUnreadNotifications {
            return false
        }
        if lhs.numUnreadMentions != rhs.numUnreadMentions {
            return false
        }
        if lhs.pinnedEventIds != rhs.pinnedEventIds {
            return false
        }
        if lhs.joinRule != rhs.joinRule {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(creator)
        hasher.combine(displayName)
        hasher.combine(rawName)
        hasher.combine(topic)
        hasher.combine(avatarUrl)
        hasher.combine(isDirect)
        hasher.combine(isPublic)
        hasher.combine(isSpace)
        hasher.combine(isTombstoned)
        hasher.combine(isFavourite)
        hasher.combine(canonicalAlias)
        hasher.combine(alternativeAliases)
        hasher.combine(membership)
        hasher.combine(inviter)
        hasher.combine(heroes)
        hasher.combine(activeMembersCount)
        hasher.combine(invitedMembersCount)
        hasher.combine(joinedMembersCount)
        hasher.combine(userPowerLevels)
        hasher.combine(highlightCount)
        hasher.combine(notificationCount)
        hasher.combine(cachedUserDefinedNotificationMode)
        hasher.combine(hasRoomCall)
        hasher.combine(activeRoomCallParticipants)
        hasher.combine(isMarkedUnread)
        hasher.combine(numUnreadMessages)
        hasher.combine(numUnreadNotifications)
        hasher.combine(numUnreadMentions)
        hasher.combine(pinnedEventIds)
        hasher.combine(joinRule)
    }
}


public struct FfiConverterTypeRoomInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomInfo {
        return
            try RoomInfo(
                id: FfiConverterString.read(from: &buf), 
                creator: FfiConverterOptionString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                rawName: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                isDirect: FfiConverterBool.read(from: &buf), 
                isPublic: FfiConverterBool.read(from: &buf), 
                isSpace: FfiConverterBool.read(from: &buf), 
                isTombstoned: FfiConverterBool.read(from: &buf), 
                isFavourite: FfiConverterBool.read(from: &buf), 
                canonicalAlias: FfiConverterOptionString.read(from: &buf), 
                alternativeAliases: FfiConverterSequenceString.read(from: &buf), 
                membership: FfiConverterTypeMembership.read(from: &buf), 
                inviter: FfiConverterOptionTypeRoomMember.read(from: &buf), 
                heroes: FfiConverterSequenceTypeRoomHero.read(from: &buf), 
                activeMembersCount: FfiConverterUInt64.read(from: &buf), 
                invitedMembersCount: FfiConverterUInt64.read(from: &buf), 
                joinedMembersCount: FfiConverterUInt64.read(from: &buf), 
                userPowerLevels: FfiConverterDictionaryStringInt64.read(from: &buf), 
                highlightCount: FfiConverterUInt64.read(from: &buf), 
                notificationCount: FfiConverterUInt64.read(from: &buf), 
                cachedUserDefinedNotificationMode: FfiConverterOptionTypeRoomNotificationMode.read(from: &buf), 
                hasRoomCall: FfiConverterBool.read(from: &buf), 
                activeRoomCallParticipants: FfiConverterSequenceString.read(from: &buf), 
                isMarkedUnread: FfiConverterBool.read(from: &buf), 
                numUnreadMessages: FfiConverterUInt64.read(from: &buf), 
                numUnreadNotifications: FfiConverterUInt64.read(from: &buf), 
                numUnreadMentions: FfiConverterUInt64.read(from: &buf), 
                pinnedEventIds: FfiConverterSequenceString.read(from: &buf), 
                joinRule: FfiConverterOptionTypeJoinRule.read(from: &buf)
        )
    }

    public static func write(_ value: RoomInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.creator, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.rawName, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterBool.write(value.isDirect, into: &buf)
        FfiConverterBool.write(value.isPublic, into: &buf)
        FfiConverterBool.write(value.isSpace, into: &buf)
        FfiConverterBool.write(value.isTombstoned, into: &buf)
        FfiConverterBool.write(value.isFavourite, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
        FfiConverterSequenceString.write(value.alternativeAliases, into: &buf)
        FfiConverterTypeMembership.write(value.membership, into: &buf)
        FfiConverterOptionTypeRoomMember.write(value.inviter, into: &buf)
        FfiConverterSequenceTypeRoomHero.write(value.heroes, into: &buf)
        FfiConverterUInt64.write(value.activeMembersCount, into: &buf)
        FfiConverterUInt64.write(value.invitedMembersCount, into: &buf)
        FfiConverterUInt64.write(value.joinedMembersCount, into: &buf)
        FfiConverterDictionaryStringInt64.write(value.userPowerLevels, into: &buf)
        FfiConverterUInt64.write(value.highlightCount, into: &buf)
        FfiConverterUInt64.write(value.notificationCount, into: &buf)
        FfiConverterOptionTypeRoomNotificationMode.write(value.cachedUserDefinedNotificationMode, into: &buf)
        FfiConverterBool.write(value.hasRoomCall, into: &buf)
        FfiConverterSequenceString.write(value.activeRoomCallParticipants, into: &buf)
        FfiConverterBool.write(value.isMarkedUnread, into: &buf)
        FfiConverterUInt64.write(value.numUnreadMessages, into: &buf)
        FfiConverterUInt64.write(value.numUnreadNotifications, into: &buf)
        FfiConverterUInt64.write(value.numUnreadMentions, into: &buf)
        FfiConverterSequenceString.write(value.pinnedEventIds, into: &buf)
        FfiConverterOptionTypeJoinRule.write(value.joinRule, into: &buf)
    }
}


public func FfiConverterTypeRoomInfo_lift(_ buf: RustBuffer) throws -> RoomInfo {
    return try FfiConverterTypeRoomInfo.lift(buf)
}

public func FfiConverterTypeRoomInfo_lower(_ value: RoomInfo) -> RustBuffer {
    return FfiConverterTypeRoomInfo.lower(value)
}


public struct RoomListLoadingStateResult {
    public var state: RoomListLoadingState
    public var stateStream: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: RoomListLoadingState, stateStream: TaskHandle) {
        self.state = state
        self.stateStream = stateStream
    }
}



public struct FfiConverterTypeRoomListLoadingStateResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListLoadingStateResult {
        return
            try RoomListLoadingStateResult(
                state: FfiConverterTypeRoomListLoadingState.read(from: &buf), 
                stateStream: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: RoomListLoadingStateResult, into buf: inout [UInt8]) {
        FfiConverterTypeRoomListLoadingState.write(value.state, into: &buf)
        FfiConverterTypeTaskHandle.write(value.stateStream, into: &buf)
    }
}


public func FfiConverterTypeRoomListLoadingStateResult_lift(_ buf: RustBuffer) throws -> RoomListLoadingStateResult {
    return try FfiConverterTypeRoomListLoadingStateResult.lift(buf)
}

public func FfiConverterTypeRoomListLoadingStateResult_lower(_ value: RoomListLoadingStateResult) -> RustBuffer {
    return FfiConverterTypeRoomListLoadingStateResult.lower(value)
}


public struct RoomMember {
    public var userId: String
    public var displayName: String?
    public var avatarUrl: String?
    public var membership: MembershipState
    public var isNameAmbiguous: Bool
    public var powerLevel: Int64
    public var normalizedPowerLevel: Int64
    public var isIgnored: Bool
    public var suggestedRoleForPowerLevel: RoomMemberRole

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, displayName: String?, avatarUrl: String?, membership: MembershipState, isNameAmbiguous: Bool, powerLevel: Int64, normalizedPowerLevel: Int64, isIgnored: Bool, suggestedRoleForPowerLevel: RoomMemberRole) {
        self.userId = userId
        self.displayName = displayName
        self.avatarUrl = avatarUrl
        self.membership = membership
        self.isNameAmbiguous = isNameAmbiguous
        self.powerLevel = powerLevel
        self.normalizedPowerLevel = normalizedPowerLevel
        self.isIgnored = isIgnored
        self.suggestedRoleForPowerLevel = suggestedRoleForPowerLevel
    }
}



extension RoomMember: Equatable, Hashable {
    public static func ==(lhs: RoomMember, rhs: RoomMember) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        if lhs.membership != rhs.membership {
            return false
        }
        if lhs.isNameAmbiguous != rhs.isNameAmbiguous {
            return false
        }
        if lhs.powerLevel != rhs.powerLevel {
            return false
        }
        if lhs.normalizedPowerLevel != rhs.normalizedPowerLevel {
            return false
        }
        if lhs.isIgnored != rhs.isIgnored {
            return false
        }
        if lhs.suggestedRoleForPowerLevel != rhs.suggestedRoleForPowerLevel {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(displayName)
        hasher.combine(avatarUrl)
        hasher.combine(membership)
        hasher.combine(isNameAmbiguous)
        hasher.combine(powerLevel)
        hasher.combine(normalizedPowerLevel)
        hasher.combine(isIgnored)
        hasher.combine(suggestedRoleForPowerLevel)
    }
}


public struct FfiConverterTypeRoomMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMember {
        return
            try RoomMember(
                userId: FfiConverterString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                membership: FfiConverterTypeMembershipState.read(from: &buf), 
                isNameAmbiguous: FfiConverterBool.read(from: &buf), 
                powerLevel: FfiConverterInt64.read(from: &buf), 
                normalizedPowerLevel: FfiConverterInt64.read(from: &buf), 
                isIgnored: FfiConverterBool.read(from: &buf), 
                suggestedRoleForPowerLevel: FfiConverterTypeRoomMemberRole.read(from: &buf)
        )
    }

    public static func write(_ value: RoomMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterTypeMembershipState.write(value.membership, into: &buf)
        FfiConverterBool.write(value.isNameAmbiguous, into: &buf)
        FfiConverterInt64.write(value.powerLevel, into: &buf)
        FfiConverterInt64.write(value.normalizedPowerLevel, into: &buf)
        FfiConverterBool.write(value.isIgnored, into: &buf)
        FfiConverterTypeRoomMemberRole.write(value.suggestedRoleForPowerLevel, into: &buf)
    }
}


public func FfiConverterTypeRoomMember_lift(_ buf: RustBuffer) throws -> RoomMember {
    return try FfiConverterTypeRoomMember.lift(buf)
}

public func FfiConverterTypeRoomMember_lower(_ value: RoomMember) -> RustBuffer {
    return FfiConverterTypeRoomMember.lower(value)
}


/**
 * `RoomNotificationSettings` represents the current settings for a `Room`
 */
public struct RoomNotificationSettings {
    /**
     * The room notification mode
     */
    public var mode: RoomNotificationMode
    /**
     * Whether the mode is the default one
     */
    public var isDefault: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The room notification mode
         */mode: RoomNotificationMode, 
        /**
         * Whether the mode is the default one
         */isDefault: Bool) {
        self.mode = mode
        self.isDefault = isDefault
    }
}



extension RoomNotificationSettings: Equatable, Hashable {
    public static func ==(lhs: RoomNotificationSettings, rhs: RoomNotificationSettings) -> Bool {
        if lhs.mode != rhs.mode {
            return false
        }
        if lhs.isDefault != rhs.isDefault {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mode)
        hasher.combine(isDefault)
    }
}


public struct FfiConverterTypeRoomNotificationSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomNotificationSettings {
        return
            try RoomNotificationSettings(
                mode: FfiConverterTypeRoomNotificationMode.read(from: &buf), 
                isDefault: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RoomNotificationSettings, into buf: inout [UInt8]) {
        FfiConverterTypeRoomNotificationMode.write(value.mode, into: &buf)
        FfiConverterBool.write(value.isDefault, into: &buf)
    }
}


public func FfiConverterTypeRoomNotificationSettings_lift(_ buf: RustBuffer) throws -> RoomNotificationSettings {
    return try FfiConverterTypeRoomNotificationSettings.lift(buf)
}

public func FfiConverterTypeRoomNotificationSettings_lower(_ value: RoomNotificationSettings) -> RustBuffer {
    return FfiConverterTypeRoomNotificationSettings.lower(value)
}


public struct RoomPowerLevels {
    /**
     * The level required to ban a user.
     */
    public var ban: Int64
    /**
     * The level required to invite a user.
     */
    public var invite: Int64
    /**
     * The level required to kick a user.
     */
    public var kick: Int64
    /**
     * The level required to redact an event.
     */
    public var redact: Int64
    /**
     * The default level required to send message events.
     */
    public var eventsDefault: Int64
    /**
     * The default level required to send state events.
     */
    public var stateDefault: Int64
    /**
     * The default power level for every user in the room.
     */
    public var usersDefault: Int64
    /**
     * The level required to change the room's name.
     */
    public var roomName: Int64
    /**
     * The level required to change the room's avatar.
     */
    public var roomAvatar: Int64
    /**
     * The level required to change the room's topic.
     */
    public var roomTopic: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The level required to ban a user.
         */ban: Int64, 
        /**
         * The level required to invite a user.
         */invite: Int64, 
        /**
         * The level required to kick a user.
         */kick: Int64, 
        /**
         * The level required to redact an event.
         */redact: Int64, 
        /**
         * The default level required to send message events.
         */eventsDefault: Int64, 
        /**
         * The default level required to send state events.
         */stateDefault: Int64, 
        /**
         * The default power level for every user in the room.
         */usersDefault: Int64, 
        /**
         * The level required to change the room's name.
         */roomName: Int64, 
        /**
         * The level required to change the room's avatar.
         */roomAvatar: Int64, 
        /**
         * The level required to change the room's topic.
         */roomTopic: Int64) {
        self.ban = ban
        self.invite = invite
        self.kick = kick
        self.redact = redact
        self.eventsDefault = eventsDefault
        self.stateDefault = stateDefault
        self.usersDefault = usersDefault
        self.roomName = roomName
        self.roomAvatar = roomAvatar
        self.roomTopic = roomTopic
    }
}



extension RoomPowerLevels: Equatable, Hashable {
    public static func ==(lhs: RoomPowerLevels, rhs: RoomPowerLevels) -> Bool {
        if lhs.ban != rhs.ban {
            return false
        }
        if lhs.invite != rhs.invite {
            return false
        }
        if lhs.kick != rhs.kick {
            return false
        }
        if lhs.redact != rhs.redact {
            return false
        }
        if lhs.eventsDefault != rhs.eventsDefault {
            return false
        }
        if lhs.stateDefault != rhs.stateDefault {
            return false
        }
        if lhs.usersDefault != rhs.usersDefault {
            return false
        }
        if lhs.roomName != rhs.roomName {
            return false
        }
        if lhs.roomAvatar != rhs.roomAvatar {
            return false
        }
        if lhs.roomTopic != rhs.roomTopic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ban)
        hasher.combine(invite)
        hasher.combine(kick)
        hasher.combine(redact)
        hasher.combine(eventsDefault)
        hasher.combine(stateDefault)
        hasher.combine(usersDefault)
        hasher.combine(roomName)
        hasher.combine(roomAvatar)
        hasher.combine(roomTopic)
    }
}


public struct FfiConverterTypeRoomPowerLevels: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPowerLevels {
        return
            try RoomPowerLevels(
                ban: FfiConverterInt64.read(from: &buf), 
                invite: FfiConverterInt64.read(from: &buf), 
                kick: FfiConverterInt64.read(from: &buf), 
                redact: FfiConverterInt64.read(from: &buf), 
                eventsDefault: FfiConverterInt64.read(from: &buf), 
                stateDefault: FfiConverterInt64.read(from: &buf), 
                usersDefault: FfiConverterInt64.read(from: &buf), 
                roomName: FfiConverterInt64.read(from: &buf), 
                roomAvatar: FfiConverterInt64.read(from: &buf), 
                roomTopic: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoomPowerLevels, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.ban, into: &buf)
        FfiConverterInt64.write(value.invite, into: &buf)
        FfiConverterInt64.write(value.kick, into: &buf)
        FfiConverterInt64.write(value.redact, into: &buf)
        FfiConverterInt64.write(value.eventsDefault, into: &buf)
        FfiConverterInt64.write(value.stateDefault, into: &buf)
        FfiConverterInt64.write(value.usersDefault, into: &buf)
        FfiConverterInt64.write(value.roomName, into: &buf)
        FfiConverterInt64.write(value.roomAvatar, into: &buf)
        FfiConverterInt64.write(value.roomTopic, into: &buf)
    }
}


public func FfiConverterTypeRoomPowerLevels_lift(_ buf: RustBuffer) throws -> RoomPowerLevels {
    return try FfiConverterTypeRoomPowerLevels.lift(buf)
}

public func FfiConverterTypeRoomPowerLevels_lower(_ value: RoomPowerLevels) -> RustBuffer {
    return FfiConverterTypeRoomPowerLevels.lower(value)
}


/**
 * The preview of a room, be it invited/joined/left, or not.
 */
public struct RoomPreviewInfo {
    /**
     * The room id for this room.
     */
    public var roomId: String
    /**
     * The canonical alias for the room.
     */
    public var canonicalAlias: String?
    /**
     * The room's name, if set.
     */
    public var name: String?
    /**
     * The room's topic, if set.
     */
    public var topic: String?
    /**
     * The MXC URI to the room's avatar, if set.
     */
    public var avatarUrl: String?
    /**
     * The number of joined members.
     */
    public var numJoinedMembers: UInt64
    /**
     * The number of active members, if known (joined + invited).
     */
    public var numActiveMembers: UInt64?
    /**
     * The room type (space, custom) or nothing, if it's a regular room.
     */
    public var roomType: RoomType
    /**
     * Is the history world-readable for this room?
     */
    public var isHistoryWorldReadable: Bool?
    /**
     * The membership state for the current user, if known.
     */
    public var membership: Membership?
    /**
     * The join rule for this room (private, public, knock, etc.).
     */
    public var joinRule: JoinRule
    /**
     * Whether the room is direct or not, if known.
     */
    public var isDirect: Bool?
    /**
     * Room heroes.
     */
    public var heroes: [RoomHero]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The room id for this room.
         */roomId: String, 
        /**
         * The canonical alias for the room.
         */canonicalAlias: String?, 
        /**
         * The room's name, if set.
         */name: String?, 
        /**
         * The room's topic, if set.
         */topic: String?, 
        /**
         * The MXC URI to the room's avatar, if set.
         */avatarUrl: String?, 
        /**
         * The number of joined members.
         */numJoinedMembers: UInt64, 
        /**
         * The number of active members, if known (joined + invited).
         */numActiveMembers: UInt64?, 
        /**
         * The room type (space, custom) or nothing, if it's a regular room.
         */roomType: RoomType, 
        /**
         * Is the history world-readable for this room?
         */isHistoryWorldReadable: Bool?, 
        /**
         * The membership state for the current user, if known.
         */membership: Membership?, 
        /**
         * The join rule for this room (private, public, knock, etc.).
         */joinRule: JoinRule, 
        /**
         * Whether the room is direct or not, if known.
         */isDirect: Bool?, 
        /**
         * Room heroes.
         */heroes: [RoomHero]?) {
        self.roomId = roomId
        self.canonicalAlias = canonicalAlias
        self.name = name
        self.topic = topic
        self.avatarUrl = avatarUrl
        self.numJoinedMembers = numJoinedMembers
        self.numActiveMembers = numActiveMembers
        self.roomType = roomType
        self.isHistoryWorldReadable = isHistoryWorldReadable
        self.membership = membership
        self.joinRule = joinRule
        self.isDirect = isDirect
        self.heroes = heroes
    }
}



extension RoomPreviewInfo: Equatable, Hashable {
    public static func ==(lhs: RoomPreviewInfo, rhs: RoomPreviewInfo) -> Bool {
        if lhs.roomId != rhs.roomId {
            return false
        }
        if lhs.canonicalAlias != rhs.canonicalAlias {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.topic != rhs.topic {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        if lhs.numJoinedMembers != rhs.numJoinedMembers {
            return false
        }
        if lhs.numActiveMembers != rhs.numActiveMembers {
            return false
        }
        if lhs.roomType != rhs.roomType {
            return false
        }
        if lhs.isHistoryWorldReadable != rhs.isHistoryWorldReadable {
            return false
        }
        if lhs.membership != rhs.membership {
            return false
        }
        if lhs.joinRule != rhs.joinRule {
            return false
        }
        if lhs.isDirect != rhs.isDirect {
            return false
        }
        if lhs.heroes != rhs.heroes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(roomId)
        hasher.combine(canonicalAlias)
        hasher.combine(name)
        hasher.combine(topic)
        hasher.combine(avatarUrl)
        hasher.combine(numJoinedMembers)
        hasher.combine(numActiveMembers)
        hasher.combine(roomType)
        hasher.combine(isHistoryWorldReadable)
        hasher.combine(membership)
        hasher.combine(joinRule)
        hasher.combine(isDirect)
        hasher.combine(heroes)
    }
}


public struct FfiConverterTypeRoomPreviewInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPreviewInfo {
        return
            try RoomPreviewInfo(
                roomId: FfiConverterString.read(from: &buf), 
                canonicalAlias: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                numJoinedMembers: FfiConverterUInt64.read(from: &buf), 
                numActiveMembers: FfiConverterOptionUInt64.read(from: &buf), 
                roomType: FfiConverterTypeRoomType.read(from: &buf), 
                isHistoryWorldReadable: FfiConverterOptionBool.read(from: &buf), 
                membership: FfiConverterOptionTypeMembership.read(from: &buf), 
                joinRule: FfiConverterTypeJoinRule.read(from: &buf), 
                isDirect: FfiConverterOptionBool.read(from: &buf), 
                heroes: FfiConverterOptionSequenceTypeRoomHero.read(from: &buf)
        )
    }

    public static func write(_ value: RoomPreviewInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterUInt64.write(value.numJoinedMembers, into: &buf)
        FfiConverterOptionUInt64.write(value.numActiveMembers, into: &buf)
        FfiConverterTypeRoomType.write(value.roomType, into: &buf)
        FfiConverterOptionBool.write(value.isHistoryWorldReadable, into: &buf)
        FfiConverterOptionTypeMembership.write(value.membership, into: &buf)
        FfiConverterTypeJoinRule.write(value.joinRule, into: &buf)
        FfiConverterOptionBool.write(value.isDirect, into: &buf)
        FfiConverterOptionSequenceTypeRoomHero.write(value.heroes, into: &buf)
    }
}


public func FfiConverterTypeRoomPreviewInfo_lift(_ buf: RustBuffer) throws -> RoomPreviewInfo {
    return try FfiConverterTypeRoomPreviewInfo.lift(buf)
}

public func FfiConverterTypeRoomPreviewInfo_lower(_ value: RoomPreviewInfo) -> RustBuffer {
    return FfiConverterTypeRoomPreviewInfo.lower(value)
}


public struct SearchUsersResults {
    public var results: [UserProfile]
    public var limited: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(results: [UserProfile], limited: Bool) {
        self.results = results
        self.limited = limited
    }
}



extension SearchUsersResults: Equatable, Hashable {
    public static func ==(lhs: SearchUsersResults, rhs: SearchUsersResults) -> Bool {
        if lhs.results != rhs.results {
            return false
        }
        if lhs.limited != rhs.limited {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(results)
        hasher.combine(limited)
    }
}


public struct FfiConverterTypeSearchUsersResults: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchUsersResults {
        return
            try SearchUsersResults(
                results: FfiConverterSequenceTypeUserProfile.read(from: &buf), 
                limited: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SearchUsersResults, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeUserProfile.write(value.results, into: &buf)
        FfiConverterBool.write(value.limited, into: &buf)
    }
}


public func FfiConverterTypeSearchUsersResults_lift(_ buf: RustBuffer) throws -> SearchUsersResults {
    return try FfiConverterTypeSearchUsersResults.lift(buf)
}

public func FfiConverterTypeSearchUsersResults_lower(_ value: SearchUsersResults) -> RustBuffer {
    return FfiConverterTypeSearchUsersResults.lower(value)
}


public struct Session {
    /**
     * The access token used for this session.
     */
    public var accessToken: String
    /**
     * The token used for [refreshing the access token], if any.
     *
     * [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
     */
    public var refreshToken: String?
    /**
     * The user the access token was issued for.
     */
    public var userId: String
    /**
     * The ID of the client device.
     */
    public var deviceId: String
    /**
     * The URL for the homeserver used for this session.
     */
    public var homeserverUrl: String
    /**
     * Additional data for this session if OpenID Connect was used for
     * authentication.
     */
    public var oidcData: String?
    /**
     * The sliding sync version used for this session.
     */
    public var slidingSyncVersion: SlidingSyncVersion

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The access token used for this session.
         */accessToken: String, 
        /**
         * The token used for [refreshing the access token], if any.
         *
         * [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
         */refreshToken: String?, 
        /**
         * The user the access token was issued for.
         */userId: String, 
        /**
         * The ID of the client device.
         */deviceId: String, 
        /**
         * The URL for the homeserver used for this session.
         */homeserverUrl: String, 
        /**
         * Additional data for this session if OpenID Connect was used for
         * authentication.
         */oidcData: String?, 
        /**
         * The sliding sync version used for this session.
         */slidingSyncVersion: SlidingSyncVersion) {
        self.accessToken = accessToken
        self.refreshToken = refreshToken
        self.userId = userId
        self.deviceId = deviceId
        self.homeserverUrl = homeserverUrl
        self.oidcData = oidcData
        self.slidingSyncVersion = slidingSyncVersion
    }
}



extension Session: Equatable, Hashable {
    public static func ==(lhs: Session, rhs: Session) -> Bool {
        if lhs.accessToken != rhs.accessToken {
            return false
        }
        if lhs.refreshToken != rhs.refreshToken {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.homeserverUrl != rhs.homeserverUrl {
            return false
        }
        if lhs.oidcData != rhs.oidcData {
            return false
        }
        if lhs.slidingSyncVersion != rhs.slidingSyncVersion {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accessToken)
        hasher.combine(refreshToken)
        hasher.combine(userId)
        hasher.combine(deviceId)
        hasher.combine(homeserverUrl)
        hasher.combine(oidcData)
        hasher.combine(slidingSyncVersion)
    }
}


public struct FfiConverterTypeSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        return
            try Session(
                accessToken: FfiConverterString.read(from: &buf), 
                refreshToken: FfiConverterOptionString.read(from: &buf), 
                userId: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                homeserverUrl: FfiConverterString.read(from: &buf), 
                oidcData: FfiConverterOptionString.read(from: &buf), 
                slidingSyncVersion: FfiConverterTypeSlidingSyncVersion.read(from: &buf)
        )
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        FfiConverterString.write(value.accessToken, into: &buf)
        FfiConverterOptionString.write(value.refreshToken, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterString.write(value.homeserverUrl, into: &buf)
        FfiConverterOptionString.write(value.oidcData, into: &buf)
        FfiConverterTypeSlidingSyncVersion.write(value.slidingSyncVersion, into: &buf)
    }
}


public func FfiConverterTypeSession_lift(_ buf: RustBuffer) throws -> Session {
    return try FfiConverterTypeSession.lift(buf)
}

public func FfiConverterTypeSession_lower(_ value: Session) -> RustBuffer {
    return FfiConverterTypeSession.lower(value)
}


/**
 * Details about the incoming verification request
 */
public struct SessionVerificationRequestDetails {
    public var senderId: String
    public var flowId: String
    public var deviceId: String
    public var displayName: String?
    /**
     * First time this device was seen in milliseconds since epoch.
     */
    public var firstSeenTimestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(senderId: String, flowId: String, deviceId: String, displayName: String?, 
        /**
         * First time this device was seen in milliseconds since epoch.
         */firstSeenTimestamp: UInt64) {
        self.senderId = senderId
        self.flowId = flowId
        self.deviceId = deviceId
        self.displayName = displayName
        self.firstSeenTimestamp = firstSeenTimestamp
    }
}



extension SessionVerificationRequestDetails: Equatable, Hashable {
    public static func ==(lhs: SessionVerificationRequestDetails, rhs: SessionVerificationRequestDetails) -> Bool {
        if lhs.senderId != rhs.senderId {
            return false
        }
        if lhs.flowId != rhs.flowId {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.firstSeenTimestamp != rhs.firstSeenTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(senderId)
        hasher.combine(flowId)
        hasher.combine(deviceId)
        hasher.combine(displayName)
        hasher.combine(firstSeenTimestamp)
    }
}


public struct FfiConverterTypeSessionVerificationRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationRequestDetails {
        return
            try SessionVerificationRequestDetails(
                senderId: FfiConverterString.read(from: &buf), 
                flowId: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                firstSeenTimestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SessionVerificationRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.senderId, into: &buf)
        FfiConverterString.write(value.flowId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterUInt64.write(value.firstSeenTimestamp, into: &buf)
    }
}


public func FfiConverterTypeSessionVerificationRequestDetails_lift(_ buf: RustBuffer) throws -> SessionVerificationRequestDetails {
    return try FfiConverterTypeSessionVerificationRequestDetails.lift(buf)
}

public func FfiConverterTypeSessionVerificationRequestDetails_lower(_ value: SessionVerificationRequestDetails) -> RustBuffer {
    return FfiConverterTypeSessionVerificationRequestDetails.lower(value)
}


public struct SetData {
    public var index: UInt32
    public var item: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt32, item: TimelineItem) {
        self.index = index
        self.item = item
    }
}



public struct FfiConverterTypeSetData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetData {
        return
            try SetData(
                index: FfiConverterUInt32.read(from: &buf), 
                item: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: SetData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.index, into: &buf)
        FfiConverterTypeTimelineItem.write(value.item, into: &buf)
    }
}


public func FfiConverterTypeSetData_lift(_ buf: RustBuffer) throws -> SetData {
    return try FfiConverterTypeSetData.lift(buf)
}

public func FfiConverterTypeSetData_lower(_ value: SetData) -> RustBuffer {
    return FfiConverterTypeSetData.lower(value)
}


public struct TextMessageContent {
    public var body: String
    public var formatted: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?) {
        self.body = body
        self.formatted = formatted
    }
}



extension TextMessageContent: Equatable, Hashable {
    public static func ==(lhs: TextMessageContent, rhs: TextMessageContent) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.formatted != rhs.formatted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(formatted)
    }
}


public struct FfiConverterTypeTextMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TextMessageContent {
        return
            try TextMessageContent(
                body: FfiConverterString.read(from: &buf), 
                formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: TextMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
    }
}


public func FfiConverterTypeTextMessageContent_lift(_ buf: RustBuffer) throws -> TextMessageContent {
    return try FfiConverterTypeTextMessageContent.lift(buf)
}

public func FfiConverterTypeTextMessageContent_lower(_ value: TextMessageContent) -> RustBuffer {
    return FfiConverterTypeTextMessageContent.lower(value)
}


public struct ThumbnailInfo {
    public var height: UInt64?
    public var width: UInt64?
    public var mimetype: String?
    public var size: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt64?, width: UInt64?, mimetype: String?, size: UInt64?) {
        self.height = height
        self.width = width
        self.mimetype = mimetype
        self.size = size
    }
}



extension ThumbnailInfo: Equatable, Hashable {
    public static func ==(lhs: ThumbnailInfo, rhs: ThumbnailInfo) -> Bool {
        if lhs.height != rhs.height {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.mimetype != rhs.mimetype {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(height)
        hasher.combine(width)
        hasher.combine(mimetype)
        hasher.combine(size)
    }
}


public struct FfiConverterTypeThumbnailInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThumbnailInfo {
        return
            try ThumbnailInfo(
                height: FfiConverterOptionUInt64.read(from: &buf), 
                width: FfiConverterOptionUInt64.read(from: &buf), 
                mimetype: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ThumbnailInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.height, into: &buf)
        FfiConverterOptionUInt64.write(value.width, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
    }
}


public func FfiConverterTypeThumbnailInfo_lift(_ buf: RustBuffer) throws -> ThumbnailInfo {
    return try FfiConverterTypeThumbnailInfo.lift(buf)
}

public func FfiConverterTypeThumbnailInfo_lower(_ value: ThumbnailInfo) -> RustBuffer {
    return FfiConverterTypeThumbnailInfo.lower(value)
}


public struct TimelineUniqueId {
    public var id: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String) {
        self.id = id
    }
}



extension TimelineUniqueId: Equatable, Hashable {
    public static func ==(lhs: TimelineUniqueId, rhs: TimelineUniqueId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}


public struct FfiConverterTypeTimelineUniqueId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineUniqueId {
        return
            try TimelineUniqueId(
                id: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TimelineUniqueId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
    }
}


public func FfiConverterTypeTimelineUniqueId_lift(_ buf: RustBuffer) throws -> TimelineUniqueId {
    return try FfiConverterTypeTimelineUniqueId.lift(buf)
}

public func FfiConverterTypeTimelineUniqueId_lower(_ value: TimelineUniqueId) -> RustBuffer {
    return FfiConverterTypeTimelineUniqueId.lower(value)
}


public struct TracingConfiguration {
    /**
     * A filter line following the [RUST_LOG format].
     *
     * [RUST_LOG format]: https://rust-lang-nursery.github.io/rust-cookbook/development_tools/debugging/config_log.html
     */
    public var filter: String
    /**
     * Whether to log to stdout, or in the logcat on Android.
     */
    public var writeToStdoutOrSystem: Bool
    /**
     * If set, configures rotated log files where to write additional logs.
     */
    public var writeToFiles: TracingFileConfiguration?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A filter line following the [RUST_LOG format].
         *
         * [RUST_LOG format]: https://rust-lang-nursery.github.io/rust-cookbook/development_tools/debugging/config_log.html
         */filter: String, 
        /**
         * Whether to log to stdout, or in the logcat on Android.
         */writeToStdoutOrSystem: Bool, 
        /**
         * If set, configures rotated log files where to write additional logs.
         */writeToFiles: TracingFileConfiguration?) {
        self.filter = filter
        self.writeToStdoutOrSystem = writeToStdoutOrSystem
        self.writeToFiles = writeToFiles
    }
}



extension TracingConfiguration: Equatable, Hashable {
    public static func ==(lhs: TracingConfiguration, rhs: TracingConfiguration) -> Bool {
        if lhs.filter != rhs.filter {
            return false
        }
        if lhs.writeToStdoutOrSystem != rhs.writeToStdoutOrSystem {
            return false
        }
        if lhs.writeToFiles != rhs.writeToFiles {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(filter)
        hasher.combine(writeToStdoutOrSystem)
        hasher.combine(writeToFiles)
    }
}


public struct FfiConverterTypeTracingConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TracingConfiguration {
        return
            try TracingConfiguration(
                filter: FfiConverterString.read(from: &buf), 
                writeToStdoutOrSystem: FfiConverterBool.read(from: &buf), 
                writeToFiles: FfiConverterOptionTypeTracingFileConfiguration.read(from: &buf)
        )
    }

    public static func write(_ value: TracingConfiguration, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filter, into: &buf)
        FfiConverterBool.write(value.writeToStdoutOrSystem, into: &buf)
        FfiConverterOptionTypeTracingFileConfiguration.write(value.writeToFiles, into: &buf)
    }
}


public func FfiConverterTypeTracingConfiguration_lift(_ buf: RustBuffer) throws -> TracingConfiguration {
    return try FfiConverterTypeTracingConfiguration.lift(buf)
}

public func FfiConverterTypeTracingConfiguration_lower(_ value: TracingConfiguration) -> RustBuffer {
    return FfiConverterTypeTracingConfiguration.lower(value)
}


/**
 * Configuration to save logs to (rotated) log-files.
 */
public struct TracingFileConfiguration {
    /**
     * Base location for all the log files.
     */
    public var path: String
    /**
     * Prefix for the log files' names.
     */
    public var filePrefix: String
    /**
     * Optional suffix for the log file's names.
     */
    public var fileSuffix: String?
    /**
     * Maximum number of rotated files.
     *
     * If not set, there's no max limit, i.e. the number of log files is
     * unlimited.
     */
    public var maxFiles: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Base location for all the log files.
         */path: String, 
        /**
         * Prefix for the log files' names.
         */filePrefix: String, 
        /**
         * Optional suffix for the log file's names.
         */fileSuffix: String?, 
        /**
         * Maximum number of rotated files.
         *
         * If not set, there's no max limit, i.e. the number of log files is
         * unlimited.
         */maxFiles: UInt64?) {
        self.path = path
        self.filePrefix = filePrefix
        self.fileSuffix = fileSuffix
        self.maxFiles = maxFiles
    }
}



extension TracingFileConfiguration: Equatable, Hashable {
    public static func ==(lhs: TracingFileConfiguration, rhs: TracingFileConfiguration) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.filePrefix != rhs.filePrefix {
            return false
        }
        if lhs.fileSuffix != rhs.fileSuffix {
            return false
        }
        if lhs.maxFiles != rhs.maxFiles {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(filePrefix)
        hasher.combine(fileSuffix)
        hasher.combine(maxFiles)
    }
}


public struct FfiConverterTypeTracingFileConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TracingFileConfiguration {
        return
            try TracingFileConfiguration(
                path: FfiConverterString.read(from: &buf), 
                filePrefix: FfiConverterString.read(from: &buf), 
                fileSuffix: FfiConverterOptionString.read(from: &buf), 
                maxFiles: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TracingFileConfiguration, into buf: inout [UInt8]) {
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.filePrefix, into: &buf)
        FfiConverterOptionString.write(value.fileSuffix, into: &buf)
        FfiConverterOptionUInt64.write(value.maxFiles, into: &buf)
    }
}


public func FfiConverterTypeTracingFileConfiguration_lift(_ buf: RustBuffer) throws -> TracingFileConfiguration {
    return try FfiConverterTypeTracingFileConfiguration.lift(buf)
}

public func FfiConverterTypeTracingFileConfiguration_lower(_ value: TracingFileConfiguration) -> RustBuffer {
    return FfiConverterTypeTracingFileConfiguration.lower(value)
}


public struct TransmissionProgress {
    public var current: UInt64
    public var total: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(current: UInt64, total: UInt64) {
        self.current = current
        self.total = total
    }
}



extension TransmissionProgress: Equatable, Hashable {
    public static func ==(lhs: TransmissionProgress, rhs: TransmissionProgress) -> Bool {
        if lhs.current != rhs.current {
            return false
        }
        if lhs.total != rhs.total {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(current)
        hasher.combine(total)
    }
}


public struct FfiConverterTypeTransmissionProgress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransmissionProgress {
        return
            try TransmissionProgress(
                current: FfiConverterUInt64.read(from: &buf), 
                total: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TransmissionProgress, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.current, into: &buf)
        FfiConverterUInt64.write(value.total, into: &buf)
    }
}


public func FfiConverterTypeTransmissionProgress_lift(_ buf: RustBuffer) throws -> TransmissionProgress {
    return try FfiConverterTypeTransmissionProgress.lift(buf)
}

public func FfiConverterTypeTransmissionProgress_lower(_ value: TransmissionProgress) -> RustBuffer {
    return FfiConverterTypeTransmissionProgress.lower(value)
}


public struct UnableToDecryptInfo {
    /**
     * The identifier of the event that couldn't get decrypted.
     */
    public var eventId: String
    /**
     * If the event could be decrypted late (that is, the event was encrypted
     * at first, but could be decrypted later on), then this indicates the
     * time it took to decrypt the event. If it is not set, this is
     * considered a definite UTD.
     *
     * If set, this is in milliseconds.
     */
    public var timeToDecryptMs: UInt64?
    /**
     * What we know about what caused this UTD. E.g. was this event sent when
     * we were not a member of this room?
     */
    public var cause: UtdCause
    /**
     * The difference between the event creation time (`origin_server_ts`) and
     * the time our device was created. If negative, this event was sent
     * *before* our device was created.
     */
    public var eventLocalAgeMillis: Int64
    /**
     * Whether the user had verified their own identity at the point they
     * received the UTD event.
     */
    public var userTrustsOwnIdentity: Bool
    /**
     * The homeserver of the user that sent the undecryptable event.
     */
    public var senderHomeserver: String
    /**
     * Our local user's own homeserver, or `None` if the client is not logged
     * in.
     */
    public var ownHomeserver: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The identifier of the event that couldn't get decrypted.
         */eventId: String, 
        /**
         * If the event could be decrypted late (that is, the event was encrypted
         * at first, but could be decrypted later on), then this indicates the
         * time it took to decrypt the event. If it is not set, this is
         * considered a definite UTD.
         *
         * If set, this is in milliseconds.
         */timeToDecryptMs: UInt64?, 
        /**
         * What we know about what caused this UTD. E.g. was this event sent when
         * we were not a member of this room?
         */cause: UtdCause, 
        /**
         * The difference between the event creation time (`origin_server_ts`) and
         * the time our device was created. If negative, this event was sent
         * *before* our device was created.
         */eventLocalAgeMillis: Int64, 
        /**
         * Whether the user had verified their own identity at the point they
         * received the UTD event.
         */userTrustsOwnIdentity: Bool, 
        /**
         * The homeserver of the user that sent the undecryptable event.
         */senderHomeserver: String, 
        /**
         * Our local user's own homeserver, or `None` if the client is not logged
         * in.
         */ownHomeserver: String?) {
        self.eventId = eventId
        self.timeToDecryptMs = timeToDecryptMs
        self.cause = cause
        self.eventLocalAgeMillis = eventLocalAgeMillis
        self.userTrustsOwnIdentity = userTrustsOwnIdentity
        self.senderHomeserver = senderHomeserver
        self.ownHomeserver = ownHomeserver
    }
}



extension UnableToDecryptInfo: Equatable, Hashable {
    public static func ==(lhs: UnableToDecryptInfo, rhs: UnableToDecryptInfo) -> Bool {
        if lhs.eventId != rhs.eventId {
            return false
        }
        if lhs.timeToDecryptMs != rhs.timeToDecryptMs {
            return false
        }
        if lhs.cause != rhs.cause {
            return false
        }
        if lhs.eventLocalAgeMillis != rhs.eventLocalAgeMillis {
            return false
        }
        if lhs.userTrustsOwnIdentity != rhs.userTrustsOwnIdentity {
            return false
        }
        if lhs.senderHomeserver != rhs.senderHomeserver {
            return false
        }
        if lhs.ownHomeserver != rhs.ownHomeserver {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(eventId)
        hasher.combine(timeToDecryptMs)
        hasher.combine(cause)
        hasher.combine(eventLocalAgeMillis)
        hasher.combine(userTrustsOwnIdentity)
        hasher.combine(senderHomeserver)
        hasher.combine(ownHomeserver)
    }
}


public struct FfiConverterTypeUnableToDecryptInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnableToDecryptInfo {
        return
            try UnableToDecryptInfo(
                eventId: FfiConverterString.read(from: &buf), 
                timeToDecryptMs: FfiConverterOptionUInt64.read(from: &buf), 
                cause: FfiConverterTypeUtdCause.read(from: &buf), 
                eventLocalAgeMillis: FfiConverterInt64.read(from: &buf), 
                userTrustsOwnIdentity: FfiConverterBool.read(from: &buf), 
                senderHomeserver: FfiConverterString.read(from: &buf), 
                ownHomeserver: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UnableToDecryptInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.eventId, into: &buf)
        FfiConverterOptionUInt64.write(value.timeToDecryptMs, into: &buf)
        FfiConverterTypeUtdCause.write(value.cause, into: &buf)
        FfiConverterInt64.write(value.eventLocalAgeMillis, into: &buf)
        FfiConverterBool.write(value.userTrustsOwnIdentity, into: &buf)
        FfiConverterString.write(value.senderHomeserver, into: &buf)
        FfiConverterOptionString.write(value.ownHomeserver, into: &buf)
    }
}


public func FfiConverterTypeUnableToDecryptInfo_lift(_ buf: RustBuffer) throws -> UnableToDecryptInfo {
    return try FfiConverterTypeUnableToDecryptInfo.lift(buf)
}

public func FfiConverterTypeUnableToDecryptInfo_lower(_ value: UnableToDecryptInfo) -> RustBuffer {
    return FfiConverterTypeUnableToDecryptInfo.lower(value)
}


public struct UnstableAudioDetailsContent {
    public var duration: TimeInterval
    public var waveform: [UInt16]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: TimeInterval, waveform: [UInt16]) {
        self.duration = duration
        self.waveform = waveform
    }
}



extension UnstableAudioDetailsContent: Equatable, Hashable {
    public static func ==(lhs: UnstableAudioDetailsContent, rhs: UnstableAudioDetailsContent) -> Bool {
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.waveform != rhs.waveform {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(duration)
        hasher.combine(waveform)
    }
}


public struct FfiConverterTypeUnstableAudioDetailsContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstableAudioDetailsContent {
        return
            try UnstableAudioDetailsContent(
                duration: FfiConverterDuration.read(from: &buf), 
                waveform: FfiConverterSequenceUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: UnstableAudioDetailsContent, into buf: inout [UInt8]) {
        FfiConverterDuration.write(value.duration, into: &buf)
        FfiConverterSequenceUInt16.write(value.waveform, into: &buf)
    }
}


public func FfiConverterTypeUnstableAudioDetailsContent_lift(_ buf: RustBuffer) throws -> UnstableAudioDetailsContent {
    return try FfiConverterTypeUnstableAudioDetailsContent.lift(buf)
}

public func FfiConverterTypeUnstableAudioDetailsContent_lower(_ value: UnstableAudioDetailsContent) -> RustBuffer {
    return FfiConverterTypeUnstableAudioDetailsContent.lower(value)
}


public struct UnstableVoiceContent {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension UnstableVoiceContent: Equatable, Hashable {
    public static func ==(lhs: UnstableVoiceContent, rhs: UnstableVoiceContent) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


public struct FfiConverterTypeUnstableVoiceContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstableVoiceContent {
        return
            UnstableVoiceContent()
    }

    public static func write(_ value: UnstableVoiceContent, into buf: inout [UInt8]) {
    }
}


public func FfiConverterTypeUnstableVoiceContent_lift(_ buf: RustBuffer) throws -> UnstableVoiceContent {
    return try FfiConverterTypeUnstableVoiceContent.lift(buf)
}

public func FfiConverterTypeUnstableVoiceContent_lower(_ value: UnstableVoiceContent) -> RustBuffer {
    return FfiConverterTypeUnstableVoiceContent.lower(value)
}


/**
 * An update for a particular user's power level within the room.
 */
public struct UserPowerLevelUpdate {
    /**
     * The user ID of the user to update.
     */
    public var userId: String
    /**
     * The power level to assign to the user.
     */
    public var powerLevel: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user ID of the user to update.
         */userId: String, 
        /**
         * The power level to assign to the user.
         */powerLevel: Int64) {
        self.userId = userId
        self.powerLevel = powerLevel
    }
}



extension UserPowerLevelUpdate: Equatable, Hashable {
    public static func ==(lhs: UserPowerLevelUpdate, rhs: UserPowerLevelUpdate) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.powerLevel != rhs.powerLevel {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(powerLevel)
    }
}


public struct FfiConverterTypeUserPowerLevelUpdate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserPowerLevelUpdate {
        return
            try UserPowerLevelUpdate(
                userId: FfiConverterString.read(from: &buf), 
                powerLevel: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: UserPowerLevelUpdate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterInt64.write(value.powerLevel, into: &buf)
    }
}


public func FfiConverterTypeUserPowerLevelUpdate_lift(_ buf: RustBuffer) throws -> UserPowerLevelUpdate {
    return try FfiConverterTypeUserPowerLevelUpdate.lift(buf)
}

public func FfiConverterTypeUserPowerLevelUpdate_lower(_ value: UserPowerLevelUpdate) -> RustBuffer {
    return FfiConverterTypeUserPowerLevelUpdate.lower(value)
}


public struct UserProfile {
    public var userId: String
    public var displayName: String?
    public var avatarUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, displayName: String?, avatarUrl: String?) {
        self.userId = userId
        self.displayName = displayName
        self.avatarUrl = avatarUrl
    }
}



extension UserProfile: Equatable, Hashable {
    public static func ==(lhs: UserProfile, rhs: UserProfile) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.avatarUrl != rhs.avatarUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(displayName)
        hasher.combine(avatarUrl)
    }
}


public struct FfiConverterTypeUserProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserProfile {
        return
            try UserProfile(
                userId: FfiConverterString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserProfile, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
    }
}


public func FfiConverterTypeUserProfile_lift(_ buf: RustBuffer) throws -> UserProfile {
    return try FfiConverterTypeUserProfile.lift(buf)
}

public func FfiConverterTypeUserProfile_lower(_ value: UserProfile) -> RustBuffer {
    return FfiConverterTypeUserProfile.lower(value)
}


public struct VideoInfo {
    public var duration: TimeInterval?
    public var height: UInt64?
    public var width: UInt64?
    public var mimetype: String?
    public var size: UInt64?
    public var thumbnailInfo: ThumbnailInfo?
    public var thumbnailSource: MediaSource?
    public var blurhash: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: TimeInterval?, height: UInt64?, width: UInt64?, mimetype: String?, size: UInt64?, thumbnailInfo: ThumbnailInfo?, thumbnailSource: MediaSource?, blurhash: String?) {
        self.duration = duration
        self.height = height
        self.width = width
        self.mimetype = mimetype
        self.size = size
        self.thumbnailInfo = thumbnailInfo
        self.thumbnailSource = thumbnailSource
        self.blurhash = blurhash
    }
}



public struct FfiConverterTypeVideoInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoInfo {
        return
            try VideoInfo(
                duration: FfiConverterOptionDuration.read(from: &buf), 
                height: FfiConverterOptionUInt64.read(from: &buf), 
                width: FfiConverterOptionUInt64.read(from: &buf), 
                mimetype: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf), 
                thumbnailInfo: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
                thumbnailSource: FfiConverterOptionTypeMediaSource.read(from: &buf), 
                blurhash: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: VideoInfo, into buf: inout [UInt8]) {
        FfiConverterOptionDuration.write(value.duration, into: &buf)
        FfiConverterOptionUInt64.write(value.height, into: &buf)
        FfiConverterOptionUInt64.write(value.width, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.thumbnailInfo, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.thumbnailSource, into: &buf)
        FfiConverterOptionString.write(value.blurhash, into: &buf)
    }
}


public func FfiConverterTypeVideoInfo_lift(_ buf: RustBuffer) throws -> VideoInfo {
    return try FfiConverterTypeVideoInfo.lift(buf)
}

public func FfiConverterTypeVideoInfo_lower(_ value: VideoInfo) -> RustBuffer {
    return FfiConverterTypeVideoInfo.lower(value)
}


public struct VideoMessageContent {
    /**
     * The computed filename, for use in a client.
     */
    public var filename: String
    public var caption: String?
    public var formattedCaption: FormattedBody?
    public var source: MediaSource
    public var info: VideoInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The computed filename, for use in a client.
         */filename: String, caption: String?, formattedCaption: FormattedBody?, source: MediaSource, info: VideoInfo?) {
        self.filename = filename
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.source = source
        self.info = info
    }
}



public struct FfiConverterTypeVideoMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoMessageContent {
        return
            try VideoMessageContent(
                filename: FfiConverterString.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                source: FfiConverterTypeMediaSource.read(from: &buf), 
                info: FfiConverterOptionTypeVideoInfo.read(from: &buf)
        )
    }

    public static func write(_ value: VideoMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeVideoInfo.write(value.info, into: &buf)
    }
}


public func FfiConverterTypeVideoMessageContent_lift(_ buf: RustBuffer) throws -> VideoMessageContent {
    return try FfiConverterTypeVideoMessageContent.lift(buf)
}

public func FfiConverterTypeVideoMessageContent_lower(_ value: VideoMessageContent) -> RustBuffer {
    return FfiConverterTypeVideoMessageContent.lower(value)
}


/**
 * Properties to create a new virtual Element Call widget.
 */
public struct VirtualElementCallWidgetOptions {
    /**
     * The url to the app.
     *
     * E.g. <https://call.element.io>, <https://call.element.dev>
     */
    public var elementCallUrl: String
    /**
     * The widget id.
     */
    public var widgetId: String
    /**
     * The url that is used as the target for the PostMessages sent
     * by the widget (to the client).
     *
     * For a web app client this is the client url. In case of using other
     * platforms the client most likely is setup up to listen to
     * postmessages in the same webview the widget is hosted. In this case
     * the `parent_url` is set to the url of the webview with the widget. Be
     * aware that this means that the widget will receive its own postmessage
     * messages. The `matrix-widget-api` (js) ignores those so this works but
     * it might break custom implementations.
     *
     * Defaults to `element_call_url` for the non-iframe (dedicated webview)
     * usecase.
     */
    public var parentUrl: String?
    /**
     * Whether the branding header of Element call should be hidden.
     *
     * Default: `true`
     */
    public var hideHeader: Bool?
    /**
     * If set, the lobby will be skipped and the widget will join the
     * call on the `io.element.join` action.
     *
     * Default: `false`
     */
    public var preload: Bool?
    /**
     * The font scale which will be used inside element call.
     *
     * Default: `1`
     */
    public var fontScale: Double?
    /**
     * Whether element call should prompt the user to open in the browser or
     * the app.
     *
     * Default: `false`
     */
    public var appPrompt: Bool?
    /**
     * Don't show the lobby and join the call immediately.
     *
     * Default: `false`
     */
    public var skipLobby: Bool?
    /**
     * Make it not possible to get to the calls list in the webview.
     *
     * Default: `true`
     */
    public var confineToRoom: Bool?
    /**
     * The font to use, to adapt to the system font.
     */
    public var font: String?
    /**
     * Can be used to pass a PostHog id to element call.
     */
    public var analyticsId: String?
    /**
     * The encryption system to use.
     *
     * Use `EncryptionSystem::Unencrypted` to disable encryption.
     */
    public var encryption: EncryptionSystem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The url to the app.
         *
         * E.g. <https://call.element.io>, <https://call.element.dev>
         */elementCallUrl: String, 
        /**
         * The widget id.
         */widgetId: String, 
        /**
         * The url that is used as the target for the PostMessages sent
         * by the widget (to the client).
         *
         * For a web app client this is the client url. In case of using other
         * platforms the client most likely is setup up to listen to
         * postmessages in the same webview the widget is hosted. In this case
         * the `parent_url` is set to the url of the webview with the widget. Be
         * aware that this means that the widget will receive its own postmessage
         * messages. The `matrix-widget-api` (js) ignores those so this works but
         * it might break custom implementations.
         *
         * Defaults to `element_call_url` for the non-iframe (dedicated webview)
         * usecase.
         */parentUrl: String?, 
        /**
         * Whether the branding header of Element call should be hidden.
         *
         * Default: `true`
         */hideHeader: Bool?, 
        /**
         * If set, the lobby will be skipped and the widget will join the
         * call on the `io.element.join` action.
         *
         * Default: `false`
         */preload: Bool?, 
        /**
         * The font scale which will be used inside element call.
         *
         * Default: `1`
         */fontScale: Double?, 
        /**
         * Whether element call should prompt the user to open in the browser or
         * the app.
         *
         * Default: `false`
         */appPrompt: Bool?, 
        /**
         * Don't show the lobby and join the call immediately.
         *
         * Default: `false`
         */skipLobby: Bool?, 
        /**
         * Make it not possible to get to the calls list in the webview.
         *
         * Default: `true`
         */confineToRoom: Bool?, 
        /**
         * The font to use, to adapt to the system font.
         */font: String?, 
        /**
         * Can be used to pass a PostHog id to element call.
         */analyticsId: String?, 
        /**
         * The encryption system to use.
         *
         * Use `EncryptionSystem::Unencrypted` to disable encryption.
         */encryption: EncryptionSystem) {
        self.elementCallUrl = elementCallUrl
        self.widgetId = widgetId
        self.parentUrl = parentUrl
        self.hideHeader = hideHeader
        self.preload = preload
        self.fontScale = fontScale
        self.appPrompt = appPrompt
        self.skipLobby = skipLobby
        self.confineToRoom = confineToRoom
        self.font = font
        self.analyticsId = analyticsId
        self.encryption = encryption
    }
}



extension VirtualElementCallWidgetOptions: Equatable, Hashable {
    public static func ==(lhs: VirtualElementCallWidgetOptions, rhs: VirtualElementCallWidgetOptions) -> Bool {
        if lhs.elementCallUrl != rhs.elementCallUrl {
            return false
        }
        if lhs.widgetId != rhs.widgetId {
            return false
        }
        if lhs.parentUrl != rhs.parentUrl {
            return false
        }
        if lhs.hideHeader != rhs.hideHeader {
            return false
        }
        if lhs.preload != rhs.preload {
            return false
        }
        if lhs.fontScale != rhs.fontScale {
            return false
        }
        if lhs.appPrompt != rhs.appPrompt {
            return false
        }
        if lhs.skipLobby != rhs.skipLobby {
            return false
        }
        if lhs.confineToRoom != rhs.confineToRoom {
            return false
        }
        if lhs.font != rhs.font {
            return false
        }
        if lhs.analyticsId != rhs.analyticsId {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(elementCallUrl)
        hasher.combine(widgetId)
        hasher.combine(parentUrl)
        hasher.combine(hideHeader)
        hasher.combine(preload)
        hasher.combine(fontScale)
        hasher.combine(appPrompt)
        hasher.combine(skipLobby)
        hasher.combine(confineToRoom)
        hasher.combine(font)
        hasher.combine(analyticsId)
        hasher.combine(encryption)
    }
}


public struct FfiConverterTypeVirtualElementCallWidgetOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VirtualElementCallWidgetOptions {
        return
            try VirtualElementCallWidgetOptions(
                elementCallUrl: FfiConverterString.read(from: &buf), 
                widgetId: FfiConverterString.read(from: &buf), 
                parentUrl: FfiConverterOptionString.read(from: &buf), 
                hideHeader: FfiConverterOptionBool.read(from: &buf), 
                preload: FfiConverterOptionBool.read(from: &buf), 
                fontScale: FfiConverterOptionDouble.read(from: &buf), 
                appPrompt: FfiConverterOptionBool.read(from: &buf), 
                skipLobby: FfiConverterOptionBool.read(from: &buf), 
                confineToRoom: FfiConverterOptionBool.read(from: &buf), 
                font: FfiConverterOptionString.read(from: &buf), 
                analyticsId: FfiConverterOptionString.read(from: &buf), 
                encryption: FfiConverterTypeEncryptionSystem.read(from: &buf)
        )
    }

    public static func write(_ value: VirtualElementCallWidgetOptions, into buf: inout [UInt8]) {
        FfiConverterString.write(value.elementCallUrl, into: &buf)
        FfiConverterString.write(value.widgetId, into: &buf)
        FfiConverterOptionString.write(value.parentUrl, into: &buf)
        FfiConverterOptionBool.write(value.hideHeader, into: &buf)
        FfiConverterOptionBool.write(value.preload, into: &buf)
        FfiConverterOptionDouble.write(value.fontScale, into: &buf)
        FfiConverterOptionBool.write(value.appPrompt, into: &buf)
        FfiConverterOptionBool.write(value.skipLobby, into: &buf)
        FfiConverterOptionBool.write(value.confineToRoom, into: &buf)
        FfiConverterOptionString.write(value.font, into: &buf)
        FfiConverterOptionString.write(value.analyticsId, into: &buf)
        FfiConverterTypeEncryptionSystem.write(value.encryption, into: &buf)
    }
}


public func FfiConverterTypeVirtualElementCallWidgetOptions_lift(_ buf: RustBuffer) throws -> VirtualElementCallWidgetOptions {
    return try FfiConverterTypeVirtualElementCallWidgetOptions.lift(buf)
}

public func FfiConverterTypeVirtualElementCallWidgetOptions_lower(_ value: VirtualElementCallWidgetOptions) -> RustBuffer {
    return FfiConverterTypeVirtualElementCallWidgetOptions.lower(value)
}


/**
 * Capabilities that a widget can request from a client.
 */
public struct WidgetCapabilities {
    /**
     * Types of the messages that a widget wants to be able to fetch.
     */
    public var read: [WidgetEventFilter]
    /**
     * Types of the messages that a widget wants to be able to send.
     */
    public var send: [WidgetEventFilter]
    /**
     * If this capability is requested by the widget, it can not operate
     * separately from the matrix client.
     *
     * This means clients should not offer to open the widget in a separate
     * browser/tab/webview that is not connected to the postmessage widget-api.
     */
    public var requiresClient: Bool
    /**
     * This allows the widget to ask the client to update delayed events.
     */
    public var updateDelayedEvent: Bool
    /**
     * This allows the widget to send events with a delay.
     */
    public var sendDelayedEvent: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Types of the messages that a widget wants to be able to fetch.
         */read: [WidgetEventFilter], 
        /**
         * Types of the messages that a widget wants to be able to send.
         */send: [WidgetEventFilter], 
        /**
         * If this capability is requested by the widget, it can not operate
         * separately from the matrix client.
         *
         * This means clients should not offer to open the widget in a separate
         * browser/tab/webview that is not connected to the postmessage widget-api.
         */requiresClient: Bool, 
        /**
         * This allows the widget to ask the client to update delayed events.
         */updateDelayedEvent: Bool, 
        /**
         * This allows the widget to send events with a delay.
         */sendDelayedEvent: Bool) {
        self.read = read
        self.send = send
        self.requiresClient = requiresClient
        self.updateDelayedEvent = updateDelayedEvent
        self.sendDelayedEvent = sendDelayedEvent
    }
}



extension WidgetCapabilities: Equatable, Hashable {
    public static func ==(lhs: WidgetCapabilities, rhs: WidgetCapabilities) -> Bool {
        if lhs.read != rhs.read {
            return false
        }
        if lhs.send != rhs.send {
            return false
        }
        if lhs.requiresClient != rhs.requiresClient {
            return false
        }
        if lhs.updateDelayedEvent != rhs.updateDelayedEvent {
            return false
        }
        if lhs.sendDelayedEvent != rhs.sendDelayedEvent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(read)
        hasher.combine(send)
        hasher.combine(requiresClient)
        hasher.combine(updateDelayedEvent)
        hasher.combine(sendDelayedEvent)
    }
}


public struct FfiConverterTypeWidgetCapabilities: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetCapabilities {
        return
            try WidgetCapabilities(
                read: FfiConverterSequenceTypeWidgetEventFilter.read(from: &buf), 
                send: FfiConverterSequenceTypeWidgetEventFilter.read(from: &buf), 
                requiresClient: FfiConverterBool.read(from: &buf), 
                updateDelayedEvent: FfiConverterBool.read(from: &buf), 
                sendDelayedEvent: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: WidgetCapabilities, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeWidgetEventFilter.write(value.read, into: &buf)
        FfiConverterSequenceTypeWidgetEventFilter.write(value.send, into: &buf)
        FfiConverterBool.write(value.requiresClient, into: &buf)
        FfiConverterBool.write(value.updateDelayedEvent, into: &buf)
        FfiConverterBool.write(value.sendDelayedEvent, into: &buf)
    }
}


public func FfiConverterTypeWidgetCapabilities_lift(_ buf: RustBuffer) throws -> WidgetCapabilities {
    return try FfiConverterTypeWidgetCapabilities.lift(buf)
}

public func FfiConverterTypeWidgetCapabilities_lower(_ value: WidgetCapabilities) -> RustBuffer {
    return FfiConverterTypeWidgetCapabilities.lower(value)
}


public struct WidgetDriverAndHandle {
    public var driver: WidgetDriver
    public var handle: WidgetDriverHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(driver: WidgetDriver, handle: WidgetDriverHandle) {
        self.driver = driver
        self.handle = handle
    }
}



public struct FfiConverterTypeWidgetDriverAndHandle: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetDriverAndHandle {
        return
            try WidgetDriverAndHandle(
                driver: FfiConverterTypeWidgetDriver.read(from: &buf), 
                handle: FfiConverterTypeWidgetDriverHandle.read(from: &buf)
        )
    }

    public static func write(_ value: WidgetDriverAndHandle, into buf: inout [UInt8]) {
        FfiConverterTypeWidgetDriver.write(value.driver, into: &buf)
        FfiConverterTypeWidgetDriverHandle.write(value.handle, into: &buf)
    }
}


public func FfiConverterTypeWidgetDriverAndHandle_lift(_ buf: RustBuffer) throws -> WidgetDriverAndHandle {
    return try FfiConverterTypeWidgetDriverAndHandle.lift(buf)
}

public func FfiConverterTypeWidgetDriverAndHandle_lower(_ value: WidgetDriverAndHandle) -> RustBuffer {
    return FfiConverterTypeWidgetDriverAndHandle.lower(value)
}


/**
 * Information about a widget.
 */
public struct WidgetSettings {
    /**
     * Widget's unique identifier.
     */
    public var widgetId: String
    /**
     * Whether or not the widget should be initialized on load message
     * (`ContentLoad` message), or upon creation/attaching of the widget to
     * the SDK's state machine that drives the API.
     */
    public var initAfterContentLoad: Bool
    /**
     * This contains the url from the widget state event.
     * In this url placeholders can be used to pass information from the client
     * to the widget. Possible values are: `$widgetId`, `$parentUrl`,
     * `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
     *
     * # Examples
     *
     * e.g `http://widget.domain?username=$userId`
     * will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
     */
    public var rawUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Widget's unique identifier.
         */widgetId: String, 
        /**
         * Whether or not the widget should be initialized on load message
         * (`ContentLoad` message), or upon creation/attaching of the widget to
         * the SDK's state machine that drives the API.
         */initAfterContentLoad: Bool, 
        /**
         * This contains the url from the widget state event.
         * In this url placeholders can be used to pass information from the client
         * to the widget. Possible values are: `$widgetId`, `$parentUrl`,
         * `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
         *
         * # Examples
         *
         * e.g `http://widget.domain?username=$userId`
         * will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
         */rawUrl: String) {
        self.widgetId = widgetId
        self.initAfterContentLoad = initAfterContentLoad
        self.rawUrl = rawUrl
    }
}



extension WidgetSettings: Equatable, Hashable {
    public static func ==(lhs: WidgetSettings, rhs: WidgetSettings) -> Bool {
        if lhs.widgetId != rhs.widgetId {
            return false
        }
        if lhs.initAfterContentLoad != rhs.initAfterContentLoad {
            return false
        }
        if lhs.rawUrl != rhs.rawUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(widgetId)
        hasher.combine(initAfterContentLoad)
        hasher.combine(rawUrl)
    }
}


public struct FfiConverterTypeWidgetSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetSettings {
        return
            try WidgetSettings(
                widgetId: FfiConverterString.read(from: &buf), 
                initAfterContentLoad: FfiConverterBool.read(from: &buf), 
                rawUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WidgetSettings, into buf: inout [UInt8]) {
        FfiConverterString.write(value.widgetId, into: &buf)
        FfiConverterBool.write(value.initAfterContentLoad, into: &buf)
        FfiConverterString.write(value.rawUrl, into: &buf)
    }
}


public func FfiConverterTypeWidgetSettings_lift(_ buf: RustBuffer) throws -> WidgetSettings {
    return try FfiConverterTypeWidgetSettings.lift(buf)
}

public func FfiConverterTypeWidgetSettings_lower(_ value: WidgetSettings) -> RustBuffer {
    return FfiConverterTypeWidgetSettings.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AccountManagementAction {
    
    case profile
    case sessionsList
    case sessionView(deviceId: String
    )
    case sessionEnd(deviceId: String
    )
    case accountDeactivate
    case crossSigningReset
}


public struct FfiConverterTypeAccountManagementAction: FfiConverterRustBuffer {
    typealias SwiftType = AccountManagementAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountManagementAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .profile
        
        case 2: return .sessionsList
        
        case 3: return .sessionView(deviceId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .sessionEnd(deviceId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .accountDeactivate
        
        case 6: return .crossSigningReset
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountManagementAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .profile:
            writeInt(&buf, Int32(1))
        
        
        case .sessionsList:
            writeInt(&buf, Int32(2))
        
        
        case let .sessionView(deviceId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(deviceId, into: &buf)
            
        
        case let .sessionEnd(deviceId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(deviceId, into: &buf)
            
        
        case .accountDeactivate:
            writeInt(&buf, Int32(5))
        
        
        case .crossSigningReset:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeAccountManagementAction_lift(_ buf: RustBuffer) throws -> AccountManagementAction {
    return try FfiConverterTypeAccountManagementAction.lift(buf)
}

public func FfiConverterTypeAccountManagementAction_lower(_ value: AccountManagementAction) -> RustBuffer {
    return FfiConverterTypeAccountManagementAction.lower(value)
}



extension AccountManagementAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An allow rule which defines a condition that allows joining a room.
 */

public enum AllowRule {
    
    /**
     * Only a member of the `room_id` Room can join the one this rule is used
     * in.
     */
    case roomMembership(roomId: String
    )
    /**
     * A custom allow rule implementation, containing its JSON representation
     * as a `String`.
     */
    case custom(json: String
    )
}


public struct FfiConverterTypeAllowRule: FfiConverterRustBuffer {
    typealias SwiftType = AllowRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AllowRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .roomMembership(roomId: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .custom(json: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AllowRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .roomMembership(roomId):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(roomId, into: &buf)
            
        
        case let .custom(json):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(json, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAllowRule_lift(_ buf: RustBuffer) throws -> AllowRule {
    return try FfiConverterTypeAllowRule.lift(buf)
}

public func FfiConverterTypeAllowRule_lower(_ value: AllowRule) -> RustBuffer {
    return FfiConverterTypeAllowRule.lower(value)
}



extension AllowRule: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AssetType {
    
    case sender
    case pin
}


public struct FfiConverterTypeAssetType: FfiConverterRustBuffer {
    typealias SwiftType = AssetType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sender
        
        case 2: return .pin
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sender:
            writeInt(&buf, Int32(1))
        
        
        case .pin:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeAssetType_lift(_ buf: RustBuffer) throws -> AssetType {
    return try FfiConverterTypeAssetType.lift(buf)
}

public func FfiConverterTypeAssetType_lower(_ value: AssetType) -> RustBuffer {
    return FfiConverterTypeAssetType.lower(value)
}



extension AssetType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AuthData {
    
    /**
     * Password-based authentication (`m.login.password`).
     */
    case password(passwordDetails: AuthDataPasswordDetails
    )
}


public struct FfiConverterTypeAuthData: FfiConverterRustBuffer {
    typealias SwiftType = AuthData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .password(passwordDetails: try FfiConverterTypeAuthDataPasswordDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .password(passwordDetails):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAuthDataPasswordDetails.write(passwordDetails, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAuthData_lift(_ buf: RustBuffer) throws -> AuthData {
    return try FfiConverterTypeAuthData.lift(buf)
}

public func FfiConverterTypeAuthData_lower(_ value: AuthData) -> RustBuffer {
    return FfiConverterTypeAuthData.lower(value)
}



extension AuthData: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BackupState {
    
    case unknown
    case creating
    case enabling
    case resuming
    case enabled
    case downloading
    case disabling
}


public struct FfiConverterTypeBackupState: FfiConverterRustBuffer {
    typealias SwiftType = BackupState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .creating
        
        case 3: return .enabling
        
        case 4: return .resuming
        
        case 5: return .enabled
        
        case 6: return .downloading
        
        case 7: return .disabling
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BackupState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .creating:
            writeInt(&buf, Int32(2))
        
        
        case .enabling:
            writeInt(&buf, Int32(3))
        
        
        case .resuming:
            writeInt(&buf, Int32(4))
        
        
        case .enabled:
            writeInt(&buf, Int32(5))
        
        
        case .downloading:
            writeInt(&buf, Int32(6))
        
        
        case .disabling:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeBackupState_lift(_ buf: RustBuffer) throws -> BackupState {
    return try FfiConverterTypeBackupState.lift(buf)
}

public func FfiConverterTypeBackupState_lower(_ value: BackupState) -> RustBuffer {
    return FfiConverterTypeBackupState.lower(value)
}



extension BackupState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BackupUploadState {
    
    case waiting
    case uploading(backedUpCount: UInt32, totalCount: UInt32
    )
    case error
    case done
}


public struct FfiConverterTypeBackupUploadState: FfiConverterRustBuffer {
    typealias SwiftType = BackupUploadState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupUploadState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .waiting
        
        case 2: return .uploading(backedUpCount: try FfiConverterUInt32.read(from: &buf), totalCount: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .error
        
        case 4: return .done
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BackupUploadState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .waiting:
            writeInt(&buf, Int32(1))
        
        
        case let .uploading(backedUpCount,totalCount):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(backedUpCount, into: &buf)
            FfiConverterUInt32.write(totalCount, into: &buf)
            
        
        case .error:
            writeInt(&buf, Int32(3))
        
        
        case .done:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeBackupUploadState_lift(_ buf: RustBuffer) throws -> BackupUploadState {
    return try FfiConverterTypeBackupUploadState.lift(buf)
}

public func FfiConverterTypeBackupUploadState_lower(_ value: BackupUploadState) -> RustBuffer {
    return FfiConverterTypeBackupUploadState.lower(value)
}



extension BackupUploadState: Equatable, Hashable {}




public enum ClientBuildError {

    
    
    case InvalidServerName(message: String)
    
    case ServerUnreachable(message: String)
    
    case WellKnownLookupFailed(message: String)
    
    case WellKnownDeserializationError(message: String)
    
    case SlidingSync(message: String)
    
    case SlidingSyncVersion(message: String)
    
    case Sdk(message: String)
    
    case EventCache(message: String)
    
    case Generic(message: String)
    
}


public struct FfiConverterTypeClientBuildError: FfiConverterRustBuffer {
    typealias SwiftType = ClientBuildError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuildError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidServerName(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .ServerUnreachable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .WellKnownLookupFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .WellKnownDeserializationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .SlidingSync(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .SlidingSyncVersion(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .Sdk(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .EventCache(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientBuildError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidServerName(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .ServerUnreachable(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .WellKnownLookupFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .WellKnownDeserializationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .SlidingSync(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .SlidingSyncVersion(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .Sdk(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .EventCache(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))

        
        }
    }
}


extension ClientBuildError: Equatable, Hashable {}

extension ClientBuildError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum ClientError {

    
    
    case Generic(msg: String
    )
}


public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension ClientError: Equatable, Hashable {}

extension ClientError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of draft of the composer.
 */

public enum ComposerDraftType {
    
    /**
     * The draft is a new message.
     */
    case newMessage
    /**
     * The draft is a reply to an event.
     */
    case reply(
        /**
         * The ID of the event being replied to.
         */eventId: String
    )
    /**
     * The draft is an edit of an event.
     */
    case edit(
        /**
         * The ID of the event being edited.
         */eventId: String
    )
}


public struct FfiConverterTypeComposerDraftType: FfiConverterRustBuffer {
    typealias SwiftType = ComposerDraftType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComposerDraftType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .newMessage
        
        case 2: return .reply(eventId: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .edit(eventId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ComposerDraftType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .newMessage:
            writeInt(&buf, Int32(1))
        
        
        case let .reply(eventId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .edit(eventId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(eventId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeComposerDraftType_lift(_ buf: RustBuffer) throws -> ComposerDraftType {
    return try FfiConverterTypeComposerDraftType.lift(buf)
}

public func FfiConverterTypeComposerDraftType_lower(_ value: ComposerDraftType) -> RustBuffer {
    return FfiConverterTypeComposerDraftType.lower(value)
}



extension ComposerDraftType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CrossSigningResetAuthType {
    
    /**
     * The homeserver requires user-interactive authentication.
     */
    case uiaa
    case oidc(info: OidcCrossSigningResetInfo
    )
}


public struct FfiConverterTypeCrossSigningResetAuthType: FfiConverterRustBuffer {
    typealias SwiftType = CrossSigningResetAuthType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CrossSigningResetAuthType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .uiaa
        
        case 2: return .oidc(info: try FfiConverterTypeOidcCrossSigningResetInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CrossSigningResetAuthType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .uiaa:
            writeInt(&buf, Int32(1))
        
        
        case let .oidc(info):
            writeInt(&buf, Int32(2))
            FfiConverterTypeOidcCrossSigningResetInfo.write(info, into: &buf)
            
        }
    }
}


public func FfiConverterTypeCrossSigningResetAuthType_lift(_ buf: RustBuffer) throws -> CrossSigningResetAuthType {
    return try FfiConverterTypeCrossSigningResetAuthType.lift(buf)
}

public func FfiConverterTypeCrossSigningResetAuthType_lower(_ value: CrossSigningResetAuthType) -> RustBuffer {
    return FfiConverterTypeCrossSigningResetAuthType.lower(value)
}



extension CrossSigningResetAuthType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Changes how date dividers get inserted, either in between each day or in
 * between each month
 */

public enum DateDividerMode {
    
    case daily
    case monthly
}


public struct FfiConverterTypeDateDividerMode: FfiConverterRustBuffer {
    typealias SwiftType = DateDividerMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DateDividerMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .daily
        
        case 2: return .monthly
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DateDividerMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .daily:
            writeInt(&buf, Int32(1))
        
        
        case .monthly:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeDateDividerMode_lift(_ buf: RustBuffer) throws -> DateDividerMode {
    return try FfiConverterTypeDateDividerMode.lift(buf)
}

public func FfiConverterTypeDateDividerMode_lower(_ value: DateDividerMode) -> RustBuffer {
    return FfiConverterTypeDateDividerMode.lower(value)
}



extension DateDividerMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EditedContent {
    
    case roomMessage(content: RoomMessageEventContentWithoutRelation
    )
    case mediaCaption(caption: String?, formattedCaption: FormattedBody?
    )
    case pollStart(pollData: PollData
    )
}


public struct FfiConverterTypeEditedContent: FfiConverterRustBuffer {
    typealias SwiftType = EditedContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EditedContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .roomMessage(content: try FfiConverterTypeRoomMessageEventContentWithoutRelation.read(from: &buf)
        )
        
        case 2: return .mediaCaption(caption: try FfiConverterOptionString.read(from: &buf), formattedCaption: try FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
        
        case 3: return .pollStart(pollData: try FfiConverterTypePollData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EditedContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .roomMessage(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRoomMessageEventContentWithoutRelation.write(content, into: &buf)
            
        
        case let .mediaCaption(caption,formattedCaption):
            writeInt(&buf, Int32(2))
            FfiConverterOptionString.write(caption, into: &buf)
            FfiConverterOptionTypeFormattedBody.write(formattedCaption, into: &buf)
            
        
        case let .pollStart(pollData):
            writeInt(&buf, Int32(3))
            FfiConverterTypePollData.write(pollData, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEditedContent_lift(_ buf: RustBuffer) throws -> EditedContent {
    return try FfiConverterTypeEditedContent.lift(buf)
}

public func FfiConverterTypeEditedContent_lower(_ value: EditedContent) -> RustBuffer {
    return FfiConverterTypeEditedContent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EnableRecoveryProgress {
    
    case starting
    case creatingBackup
    case creatingRecoveryKey
    case backingUp(backedUpCount: UInt32, totalCount: UInt32
    )
    case roomKeyUploadError
    case done(recoveryKey: String
    )
}


public struct FfiConverterTypeEnableRecoveryProgress: FfiConverterRustBuffer {
    typealias SwiftType = EnableRecoveryProgress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnableRecoveryProgress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .starting
        
        case 2: return .creatingBackup
        
        case 3: return .creatingRecoveryKey
        
        case 4: return .backingUp(backedUpCount: try FfiConverterUInt32.read(from: &buf), totalCount: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 5: return .roomKeyUploadError
        
        case 6: return .done(recoveryKey: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnableRecoveryProgress, into buf: inout [UInt8]) {
        switch value {
        
        
        case .starting:
            writeInt(&buf, Int32(1))
        
        
        case .creatingBackup:
            writeInt(&buf, Int32(2))
        
        
        case .creatingRecoveryKey:
            writeInt(&buf, Int32(3))
        
        
        case let .backingUp(backedUpCount,totalCount):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(backedUpCount, into: &buf)
            FfiConverterUInt32.write(totalCount, into: &buf)
            
        
        case .roomKeyUploadError:
            writeInt(&buf, Int32(5))
        
        
        case let .done(recoveryKey):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(recoveryKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEnableRecoveryProgress_lift(_ buf: RustBuffer) throws -> EnableRecoveryProgress {
    return try FfiConverterTypeEnableRecoveryProgress.lift(buf)
}

public func FfiConverterTypeEnableRecoveryProgress_lower(_ value: EnableRecoveryProgress) -> RustBuffer {
    return FfiConverterTypeEnableRecoveryProgress.lower(value)
}



extension EnableRecoveryProgress: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EncryptedMessage {
    
    case olmV1Curve25519AesSha2(
        /**
         * The Curve25519 key of the sender.
         */senderKey: String
    )
    case megolmV1AesSha2(
        /**
         * The ID of the session used to encrypt the message.
         */sessionId: String, 
        /**
         * What we know about what caused this UTD. E.g. was this event sent
         * when we were not a member of this room?
         */cause: UtdCause
    )
    case unknown
}


public struct FfiConverterTypeEncryptedMessage: FfiConverterRustBuffer {
    typealias SwiftType = EncryptedMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .olmV1Curve25519AesSha2(senderKey: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .megolmV1AesSha2(sessionId: try FfiConverterString.read(from: &buf), cause: try FfiConverterTypeUtdCause.read(from: &buf)
        )
        
        case 3: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptedMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .olmV1Curve25519AesSha2(senderKey):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(senderKey, into: &buf)
            
        
        case let .megolmV1AesSha2(sessionId,cause):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(sessionId, into: &buf)
            FfiConverterTypeUtdCause.write(cause, into: &buf)
            
        
        case .unknown:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeEncryptedMessage_lift(_ buf: RustBuffer) throws -> EncryptedMessage {
    return try FfiConverterTypeEncryptedMessage.lift(buf)
}

public func FfiConverterTypeEncryptedMessage_lower(_ value: EncryptedMessage) -> RustBuffer {
    return FfiConverterTypeEncryptedMessage.lower(value)
}



extension EncryptedMessage: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Defines if a call is encrypted and which encryption system should be used.
 *
 * This controls the url parameters: `perParticipantE2EE`, `password`.
 */

public enum EncryptionSystem {
    
    /**
     * Equivalent to the element call url parameter: `enableE2EE=false`
     */
    case unencrypted
    /**
     * Equivalent to the element call url parameter:
     * `perParticipantE2EE=true`
     */
    case perParticipantKeys
    /**
     * Equivalent to the element call url parameter:
     * `password={secret}`
     */
    case sharedSecret(
        /**
         * The secret/password which is used in the url.
         */secret: String
    )
}


public struct FfiConverterTypeEncryptionSystem: FfiConverterRustBuffer {
    typealias SwiftType = EncryptionSystem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionSystem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unencrypted
        
        case 2: return .perParticipantKeys
        
        case 3: return .sharedSecret(secret: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptionSystem, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unencrypted:
            writeInt(&buf, Int32(1))
        
        
        case .perParticipantKeys:
            writeInt(&buf, Int32(2))
        
        
        case let .sharedSecret(secret):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(secret, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEncryptionSystem_lift(_ buf: RustBuffer) throws -> EncryptionSystem {
    return try FfiConverterTypeEncryptionSystem.lift(buf)
}

public func FfiConverterTypeEncryptionSystem_lower(_ value: EncryptionSystem) -> RustBuffer {
    return FfiConverterTypeEncryptionSystem.lower(value)
}



extension EncryptionSystem: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Contains the 2 possible identifiers of an event, either it has a remote
 * event id or a local transaction id, never both or none.
 */

public enum EventOrTransactionId {
    
    case eventId(eventId: String
    )
    case transactionId(transactionId: String
    )
}


public struct FfiConverterTypeEventOrTransactionId: FfiConverterRustBuffer {
    typealias SwiftType = EventOrTransactionId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventOrTransactionId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventId(eventId: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .transactionId(transactionId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventOrTransactionId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventId(eventId):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .transactionId(transactionId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(transactionId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEventOrTransactionId_lift(_ buf: RustBuffer) throws -> EventOrTransactionId {
    return try FfiConverterTypeEventOrTransactionId.lift(buf)
}

public func FfiConverterTypeEventOrTransactionId_lower(_ value: EventOrTransactionId) -> RustBuffer {
    return FfiConverterTypeEventOrTransactionId.lower(value)
}



extension EventOrTransactionId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * This type represents the “send state” of a local event timeline item.
 */

public enum EventSendState {
    
    /**
     * The local event has not been sent yet.
     */
    case notSentYet
    /**
     * The local event has been sent to the server, but unsuccessfully: The
     * sending has failed.
     */
    case sendingFailed(
        /**
         * The error reason, with information for the user.
         */error: QueueWedgeError, 
        /**
         * Whether the error is considered recoverable or not.
         *
         * An error that's recoverable will disable the room's send queue,
         * while an unrecoverable error will be parked, until the user
         * decides to cancel sending it.
         */isRecoverable: Bool
    )
    /**
     * The local event has been sent successfully to the server.
     */
    case sent(eventId: String
    )
}


public struct FfiConverterTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventSendState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notSentYet
        
        case 2: return .sendingFailed(error: try FfiConverterTypeQueueWedgeError.read(from: &buf), isRecoverable: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .sent(eventId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventSendState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notSentYet:
            writeInt(&buf, Int32(1))
        
        
        case let .sendingFailed(error,isRecoverable):
            writeInt(&buf, Int32(2))
            FfiConverterTypeQueueWedgeError.write(error, into: &buf)
            FfiConverterBool.write(isRecoverable, into: &buf)
            
        
        case let .sent(eventId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(eventId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEventSendState_lift(_ buf: RustBuffer) throws -> EventSendState {
    return try FfiConverterTypeEventSendState.lift(buf)
}

public func FfiConverterTypeEventSendState_lower(_ value: EventSendState) -> RustBuffer {
    return FfiConverterTypeEventSendState.lower(value)
}



extension EventSendState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FilterTimelineEventType {
    
    case messageLike(eventType: MessageLikeEventType
    )
    case state(eventType: StateEventType
    )
}


public struct FfiConverterTypeFilterTimelineEventType: FfiConverterRustBuffer {
    typealias SwiftType = FilterTimelineEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilterTimelineEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messageLike(eventType: try FfiConverterTypeMessageLikeEventType.read(from: &buf)
        )
        
        case 2: return .state(eventType: try FfiConverterTypeStateEventType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FilterTimelineEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messageLike(eventType):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageLikeEventType.write(eventType, into: &buf)
            
        
        case let .state(eventType):
            writeInt(&buf, Int32(2))
            FfiConverterTypeStateEventType.write(eventType, into: &buf)
            
        }
    }
}


public func FfiConverterTypeFilterTimelineEventType_lift(_ buf: RustBuffer) throws -> FilterTimelineEventType {
    return try FfiConverterTypeFilterTimelineEventType.lift(buf)
}

public func FfiConverterTypeFilterTimelineEventType_lower(_ value: FilterTimelineEventType) -> RustBuffer {
    return FfiConverterTypeFilterTimelineEventType.lower(value)
}



extension FilterTimelineEventType: Equatable, Hashable {}




public enum FocusEventError {

    
    
    case InvalidEventId(eventId: String, err: String
    )
    case EventNotFound(eventId: String
    )
    case Other(msg: String
    )
}


public struct FfiConverterTypeFocusEventError: FfiConverterRustBuffer {
    typealias SwiftType = FocusEventError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FocusEventError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidEventId(
            eventId: try FfiConverterString.read(from: &buf), 
            err: try FfiConverterString.read(from: &buf)
            )
        case 2: return .EventNotFound(
            eventId: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Other(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FocusEventError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidEventId(eventId,err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(eventId, into: &buf)
            FfiConverterString.write(err, into: &buf)
            
        
        case let .EventNotFound(eventId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .Other(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension FocusEventError: Equatable, Hashable {}

extension FocusEventError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum HumanQrLoginError {

    
    
    case LinkingNotSupported
    case Cancelled
    case Expired
    case ConnectionInsecure
    case Declined
    case Unknown
    case SlidingSyncNotAvailable
    case OidcMetadataInvalid
    case OtherDeviceNotSignedIn
}


public struct FfiConverterTypeHumanQrLoginError: FfiConverterRustBuffer {
    typealias SwiftType = HumanQrLoginError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HumanQrLoginError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .LinkingNotSupported
        case 2: return .Cancelled
        case 3: return .Expired
        case 4: return .ConnectionInsecure
        case 5: return .Declined
        case 6: return .Unknown
        case 7: return .SlidingSyncNotAvailable
        case 8: return .OidcMetadataInvalid
        case 9: return .OtherDeviceNotSignedIn

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HumanQrLoginError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .LinkingNotSupported:
            writeInt(&buf, Int32(1))
        
        
        case .Cancelled:
            writeInt(&buf, Int32(2))
        
        
        case .Expired:
            writeInt(&buf, Int32(3))
        
        
        case .ConnectionInsecure:
            writeInt(&buf, Int32(4))
        
        
        case .Declined:
            writeInt(&buf, Int32(5))
        
        
        case .Unknown:
            writeInt(&buf, Int32(6))
        
        
        case .SlidingSyncNotAvailable:
            writeInt(&buf, Int32(7))
        
        
        case .OidcMetadataInvalid:
            writeInt(&buf, Int32(8))
        
        
        case .OtherDeviceNotSignedIn:
            writeInt(&buf, Int32(9))
        
        }
    }
}


extension HumanQrLoginError: Equatable, Hashable {}

extension HumanQrLoginError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The rule used for users wishing to join this room.
 */

public enum JoinRule {
    
    /**
     * Anyone can join the room without any prior action.
     */
    case `public`
    /**
     * A user who wishes to join the room must first receive an invite to the
     * room from someone already inside of the room.
     */
    case invite
    /**
     * Users can join the room if they are invited, or they can request an
     * invite to the room.
     *
     * They can be allowed (invited) or denied (kicked/banned) access.
     */
    case knock
    /**
     * Reserved but not yet implemented by the Matrix specification.
     */
    case `private`
    /**
     * Users can join the room if they are invited, or if they meet any of the
     * conditions described in a set of [`AllowRule`]s.
     */
    case restricted(rules: [AllowRule]
    )
    /**
     * Users can join the room if they are invited, or if they meet any of the
     * conditions described in a set of [`AllowRule`]s, or they can request
     * an invite to the room.
     */
    case knockRestricted(rules: [AllowRule]
    )
    /**
     * A custom join rule, up for interpretation by the consumer.
     */
    case custom(
        /**
         * The string representation for this custom rule.
         */repr: String
    )
}


public struct FfiConverterTypeJoinRule: FfiConverterRustBuffer {
    typealias SwiftType = JoinRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JoinRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`public`
        
        case 2: return .invite
        
        case 3: return .knock
        
        case 4: return .`private`
        
        case 5: return .restricted(rules: try FfiConverterSequenceTypeAllowRule.read(from: &buf)
        )
        
        case 6: return .knockRestricted(rules: try FfiConverterSequenceTypeAllowRule.read(from: &buf)
        )
        
        case 7: return .custom(repr: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JoinRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`public`:
            writeInt(&buf, Int32(1))
        
        
        case .invite:
            writeInt(&buf, Int32(2))
        
        
        case .knock:
            writeInt(&buf, Int32(3))
        
        
        case .`private`:
            writeInt(&buf, Int32(4))
        
        
        case let .restricted(rules):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeAllowRule.write(rules, into: &buf)
            
        
        case let .knockRestricted(rules):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeAllowRule.write(rules, into: &buf)
            
        
        case let .custom(repr):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(repr, into: &buf)
            
        }
    }
}


public func FfiConverterTypeJoinRule_lift(_ buf: RustBuffer) throws -> JoinRule {
    return try FfiConverterTypeJoinRule.lift(buf)
}

public func FfiConverterTypeJoinRule_lower(_ value: JoinRule) -> RustBuffer {
    return FfiConverterTypeJoinRule.lower(value)
}



extension JoinRule: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel {
    
    case error
    case warn
    case info
    case debug
    case trace
}


public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}



extension LogLevel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A Matrix ID that can be a room, room alias, user, or event.
 */

public enum MatrixId {
    
    case room(id: String
    )
    case roomAlias(alias: String
    )
    case user(id: String
    )
    case eventOnRoomId(roomId: String, eventId: String
    )
    case eventOnRoomAlias(alias: String, eventId: String
    )
}


public struct FfiConverterTypeMatrixId: FfiConverterRustBuffer {
    typealias SwiftType = MatrixId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .room(id: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .roomAlias(alias: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .user(id: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .eventOnRoomId(roomId: try FfiConverterString.read(from: &buf), eventId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .eventOnRoomAlias(alias: try FfiConverterString.read(from: &buf), eventId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MatrixId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .room(id):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(id, into: &buf)
            
        
        case let .roomAlias(alias):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(alias, into: &buf)
            
        
        case let .user(id):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(id, into: &buf)
            
        
        case let .eventOnRoomId(roomId,eventId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(roomId, into: &buf)
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .eventOnRoomAlias(alias,eventId):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(alias, into: &buf)
            FfiConverterString.write(eventId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMatrixId_lift(_ buf: RustBuffer) throws -> MatrixId {
    return try FfiConverterTypeMatrixId.lift(buf)
}

public func FfiConverterTypeMatrixId_lower(_ value: MatrixId) -> RustBuffer {
    return FfiConverterTypeMatrixId.lower(value)
}



extension MatrixId: Equatable, Hashable {}




public enum MediaInfoError {

    
    
    case MissingField(message: String)
    
    case InvalidField(message: String)
    
}


public struct FfiConverterTypeMediaInfoError: FfiConverterRustBuffer {
    typealias SwiftType = MediaInfoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaInfoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingField(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidField(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MediaInfoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .MissingField(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidField(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


extension MediaInfoError: Equatable, Hashable {}

extension MediaInfoError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Membership {
    
    case invited
    case joined
    case left
    case knocked
    case banned
}


public struct FfiConverterTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = Membership

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Membership {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invited
        
        case 2: return .joined
        
        case 3: return .left
        
        case 4: return .knocked
        
        case 5: return .banned
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Membership, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invited:
            writeInt(&buf, Int32(1))
        
        
        case .joined:
            writeInt(&buf, Int32(2))
        
        
        case .left:
            writeInt(&buf, Int32(3))
        
        
        case .knocked:
            writeInt(&buf, Int32(4))
        
        
        case .banned:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeMembership_lift(_ buf: RustBuffer) throws -> Membership {
    return try FfiConverterTypeMembership.lift(buf)
}

public func FfiConverterTypeMembership_lower(_ value: Membership) -> RustBuffer {
    return FfiConverterTypeMembership.lower(value)
}



extension Membership: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MembershipChange {
    
    case none
    case error
    case joined
    case left
    case banned
    case unbanned
    case kicked
    case invited
    case kickedAndBanned
    case invitationAccepted
    case invitationRejected
    case invitationRevoked
    case knocked
    case knockAccepted
    case knockRetracted
    case knockDenied
    case notImplemented
}


public struct FfiConverterTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .error
        
        case 3: return .joined
        
        case 4: return .left
        
        case 5: return .banned
        
        case 6: return .unbanned
        
        case 7: return .kicked
        
        case 8: return .invited
        
        case 9: return .kickedAndBanned
        
        case 10: return .invitationAccepted
        
        case 11: return .invitationRejected
        
        case 12: return .invitationRevoked
        
        case 13: return .knocked
        
        case 14: return .knockAccepted
        
        case 15: return .knockRetracted
        
        case 16: return .knockDenied
        
        case 17: return .notImplemented
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipChange, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .error:
            writeInt(&buf, Int32(2))
        
        
        case .joined:
            writeInt(&buf, Int32(3))
        
        
        case .left:
            writeInt(&buf, Int32(4))
        
        
        case .banned:
            writeInt(&buf, Int32(5))
        
        
        case .unbanned:
            writeInt(&buf, Int32(6))
        
        
        case .kicked:
            writeInt(&buf, Int32(7))
        
        
        case .invited:
            writeInt(&buf, Int32(8))
        
        
        case .kickedAndBanned:
            writeInt(&buf, Int32(9))
        
        
        case .invitationAccepted:
            writeInt(&buf, Int32(10))
        
        
        case .invitationRejected:
            writeInt(&buf, Int32(11))
        
        
        case .invitationRevoked:
            writeInt(&buf, Int32(12))
        
        
        case .knocked:
            writeInt(&buf, Int32(13))
        
        
        case .knockAccepted:
            writeInt(&buf, Int32(14))
        
        
        case .knockRetracted:
            writeInt(&buf, Int32(15))
        
        
        case .knockDenied:
            writeInt(&buf, Int32(16))
        
        
        case .notImplemented:
            writeInt(&buf, Int32(17))
        
        }
    }
}


public func FfiConverterTypeMembershipChange_lift(_ buf: RustBuffer) throws -> MembershipChange {
    return try FfiConverterTypeMembershipChange.lift(buf)
}

public func FfiConverterTypeMembershipChange_lower(_ value: MembershipChange) -> RustBuffer {
    return FfiConverterTypeMembershipChange.lower(value)
}



extension MembershipChange: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MembershipState {
    
    /**
     * The user is banned.
     */
    case ban
    /**
     * The user has been invited.
     */
    case invite
    /**
     * The user has joined.
     */
    case join
    /**
     * The user has requested to join.
     */
    case knock
    /**
     * The user has left.
     */
    case leave
    /**
     * A custom membership state value.
     */
    case custom(value: String
    )
}


public struct FfiConverterTypeMembershipState: FfiConverterRustBuffer {
    typealias SwiftType = MembershipState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ban
        
        case 2: return .invite
        
        case 3: return .join
        
        case 4: return .knock
        
        case 5: return .leave
        
        case 6: return .custom(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ban:
            writeInt(&buf, Int32(1))
        
        
        case .invite:
            writeInt(&buf, Int32(2))
        
        
        case .join:
            writeInt(&buf, Int32(3))
        
        
        case .knock:
            writeInt(&buf, Int32(4))
        
        
        case .leave:
            writeInt(&buf, Int32(5))
        
        
        case let .custom(value):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMembershipState_lift(_ buf: RustBuffer) throws -> MembershipState {
    return try FfiConverterTypeMembershipState.lift(buf)
}

public func FfiConverterTypeMembershipState_lower(_ value: MembershipState) -> RustBuffer {
    return FfiConverterTypeMembershipState.lower(value)
}



extension MembershipState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageFormat {
    
    case html
    case unknown(format: String
    )
}


public struct FfiConverterTypeMessageFormat: FfiConverterRustBuffer {
    typealias SwiftType = MessageFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .html
        
        case 2: return .unknown(format: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .html:
            writeInt(&buf, Int32(1))
        
        
        case let .unknown(format):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(format, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageFormat_lift(_ buf: RustBuffer) throws -> MessageFormat {
    return try FfiConverterTypeMessageFormat.lift(buf)
}

public func FfiConverterTypeMessageFormat_lower(_ value: MessageFormat) -> RustBuffer {
    return FfiConverterTypeMessageFormat.lower(value)
}



extension MessageFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageLikeEventContent {
    
    case callAnswer
    case callInvite
    case callNotify(notifyType: NotifyType
    )
    case callHangup
    case callCandidates
    case keyVerificationReady
    case keyVerificationStart
    case keyVerificationCancel
    case keyVerificationAccept
    case keyVerificationKey
    case keyVerificationMac
    case keyVerificationDone
    case poll(question: String
    )
    case reactionContent(relatedEventId: String
    )
    case roomEncrypted
    case roomMessage(messageType: MessageType, inReplyToEventId: String?
    )
    case roomRedaction(redactedEventId: String?, reason: String?
    )
    case sticker
}


public struct FfiConverterTypeMessageLikeEventContent: FfiConverterRustBuffer {
    typealias SwiftType = MessageLikeEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageLikeEventContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .callAnswer
        
        case 2: return .callInvite
        
        case 3: return .callNotify(notifyType: try FfiConverterTypeNotifyType.read(from: &buf)
        )
        
        case 4: return .callHangup
        
        case 5: return .callCandidates
        
        case 6: return .keyVerificationReady
        
        case 7: return .keyVerificationStart
        
        case 8: return .keyVerificationCancel
        
        case 9: return .keyVerificationAccept
        
        case 10: return .keyVerificationKey
        
        case 11: return .keyVerificationMac
        
        case 12: return .keyVerificationDone
        
        case 13: return .poll(question: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .reactionContent(relatedEventId: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .roomEncrypted
        
        case 16: return .roomMessage(messageType: try FfiConverterTypeMessageType.read(from: &buf), inReplyToEventId: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 17: return .roomRedaction(redactedEventId: try FfiConverterOptionString.read(from: &buf), reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 18: return .sticker
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageLikeEventContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .callAnswer:
            writeInt(&buf, Int32(1))
        
        
        case .callInvite:
            writeInt(&buf, Int32(2))
        
        
        case let .callNotify(notifyType):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNotifyType.write(notifyType, into: &buf)
            
        
        case .callHangup:
            writeInt(&buf, Int32(4))
        
        
        case .callCandidates:
            writeInt(&buf, Int32(5))
        
        
        case .keyVerificationReady:
            writeInt(&buf, Int32(6))
        
        
        case .keyVerificationStart:
            writeInt(&buf, Int32(7))
        
        
        case .keyVerificationCancel:
            writeInt(&buf, Int32(8))
        
        
        case .keyVerificationAccept:
            writeInt(&buf, Int32(9))
        
        
        case .keyVerificationKey:
            writeInt(&buf, Int32(10))
        
        
        case .keyVerificationMac:
            writeInt(&buf, Int32(11))
        
        
        case .keyVerificationDone:
            writeInt(&buf, Int32(12))
        
        
        case let .poll(question):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(question, into: &buf)
            
        
        case let .reactionContent(relatedEventId):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(relatedEventId, into: &buf)
            
        
        case .roomEncrypted:
            writeInt(&buf, Int32(15))
        
        
        case let .roomMessage(messageType,inReplyToEventId):
            writeInt(&buf, Int32(16))
            FfiConverterTypeMessageType.write(messageType, into: &buf)
            FfiConverterOptionString.write(inReplyToEventId, into: &buf)
            
        
        case let .roomRedaction(redactedEventId,reason):
            writeInt(&buf, Int32(17))
            FfiConverterOptionString.write(redactedEventId, into: &buf)
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case .sticker:
            writeInt(&buf, Int32(18))
        
        }
    }
}


public func FfiConverterTypeMessageLikeEventContent_lift(_ buf: RustBuffer) throws -> MessageLikeEventContent {
    return try FfiConverterTypeMessageLikeEventContent.lift(buf)
}

public func FfiConverterTypeMessageLikeEventContent_lower(_ value: MessageLikeEventContent) -> RustBuffer {
    return FfiConverterTypeMessageLikeEventContent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageLikeEventType {
    
    case callAnswer
    case callCandidates
    case callHangup
    case callInvite
    case callNotify
    case keyVerificationAccept
    case keyVerificationCancel
    case keyVerificationDone
    case keyVerificationKey
    case keyVerificationMac
    case keyVerificationReady
    case keyVerificationStart
    case pollEnd
    case pollResponse
    case pollStart
    case reaction
    case roomEncrypted
    case roomMessage
    case roomRedaction
    case sticker
    case unstablePollEnd
    case unstablePollResponse
    case unstablePollStart
}


public struct FfiConverterTypeMessageLikeEventType: FfiConverterRustBuffer {
    typealias SwiftType = MessageLikeEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageLikeEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .callAnswer
        
        case 2: return .callCandidates
        
        case 3: return .callHangup
        
        case 4: return .callInvite
        
        case 5: return .callNotify
        
        case 6: return .keyVerificationAccept
        
        case 7: return .keyVerificationCancel
        
        case 8: return .keyVerificationDone
        
        case 9: return .keyVerificationKey
        
        case 10: return .keyVerificationMac
        
        case 11: return .keyVerificationReady
        
        case 12: return .keyVerificationStart
        
        case 13: return .pollEnd
        
        case 14: return .pollResponse
        
        case 15: return .pollStart
        
        case 16: return .reaction
        
        case 17: return .roomEncrypted
        
        case 18: return .roomMessage
        
        case 19: return .roomRedaction
        
        case 20: return .sticker
        
        case 21: return .unstablePollEnd
        
        case 22: return .unstablePollResponse
        
        case 23: return .unstablePollStart
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageLikeEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .callAnswer:
            writeInt(&buf, Int32(1))
        
        
        case .callCandidates:
            writeInt(&buf, Int32(2))
        
        
        case .callHangup:
            writeInt(&buf, Int32(3))
        
        
        case .callInvite:
            writeInt(&buf, Int32(4))
        
        
        case .callNotify:
            writeInt(&buf, Int32(5))
        
        
        case .keyVerificationAccept:
            writeInt(&buf, Int32(6))
        
        
        case .keyVerificationCancel:
            writeInt(&buf, Int32(7))
        
        
        case .keyVerificationDone:
            writeInt(&buf, Int32(8))
        
        
        case .keyVerificationKey:
            writeInt(&buf, Int32(9))
        
        
        case .keyVerificationMac:
            writeInt(&buf, Int32(10))
        
        
        case .keyVerificationReady:
            writeInt(&buf, Int32(11))
        
        
        case .keyVerificationStart:
            writeInt(&buf, Int32(12))
        
        
        case .pollEnd:
            writeInt(&buf, Int32(13))
        
        
        case .pollResponse:
            writeInt(&buf, Int32(14))
        
        
        case .pollStart:
            writeInt(&buf, Int32(15))
        
        
        case .reaction:
            writeInt(&buf, Int32(16))
        
        
        case .roomEncrypted:
            writeInt(&buf, Int32(17))
        
        
        case .roomMessage:
            writeInt(&buf, Int32(18))
        
        
        case .roomRedaction:
            writeInt(&buf, Int32(19))
        
        
        case .sticker:
            writeInt(&buf, Int32(20))
        
        
        case .unstablePollEnd:
            writeInt(&buf, Int32(21))
        
        
        case .unstablePollResponse:
            writeInt(&buf, Int32(22))
        
        
        case .unstablePollStart:
            writeInt(&buf, Int32(23))
        
        }
    }
}


public func FfiConverterTypeMessageLikeEventType_lift(_ buf: RustBuffer) throws -> MessageLikeEventType {
    return try FfiConverterTypeMessageLikeEventType.lift(buf)
}

public func FfiConverterTypeMessageLikeEventType_lower(_ value: MessageLikeEventType) -> RustBuffer {
    return FfiConverterTypeMessageLikeEventType.lower(value)
}



extension MessageLikeEventType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageType {
    
    case emote(content: EmoteMessageContent
    )
    case image(content: ImageMessageContent
    )
    case audio(content: AudioMessageContent
    )
    case video(content: VideoMessageContent
    )
    case file(content: FileMessageContent
    )
    case notice(content: NoticeMessageContent
    )
    case text(content: TextMessageContent
    )
    case location(content: LocationContent
    )
    case other(msgtype: String, body: String
    )
}


public struct FfiConverterTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .emote(content: try FfiConverterTypeEmoteMessageContent.read(from: &buf)
        )
        
        case 2: return .image(content: try FfiConverterTypeImageMessageContent.read(from: &buf)
        )
        
        case 3: return .audio(content: try FfiConverterTypeAudioMessageContent.read(from: &buf)
        )
        
        case 4: return .video(content: try FfiConverterTypeVideoMessageContent.read(from: &buf)
        )
        
        case 5: return .file(content: try FfiConverterTypeFileMessageContent.read(from: &buf)
        )
        
        case 6: return .notice(content: try FfiConverterTypeNoticeMessageContent.read(from: &buf)
        )
        
        case 7: return .text(content: try FfiConverterTypeTextMessageContent.read(from: &buf)
        )
        
        case 8: return .location(content: try FfiConverterTypeLocationContent.read(from: &buf)
        )
        
        case 9: return .other(msgtype: try FfiConverterString.read(from: &buf), body: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .emote(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEmoteMessageContent.write(content, into: &buf)
            
        
        case let .image(content):
            writeInt(&buf, Int32(2))
            FfiConverterTypeImageMessageContent.write(content, into: &buf)
            
        
        case let .audio(content):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAudioMessageContent.write(content, into: &buf)
            
        
        case let .video(content):
            writeInt(&buf, Int32(4))
            FfiConverterTypeVideoMessageContent.write(content, into: &buf)
            
        
        case let .file(content):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFileMessageContent.write(content, into: &buf)
            
        
        case let .notice(content):
            writeInt(&buf, Int32(6))
            FfiConverterTypeNoticeMessageContent.write(content, into: &buf)
            
        
        case let .text(content):
            writeInt(&buf, Int32(7))
            FfiConverterTypeTextMessageContent.write(content, into: &buf)
            
        
        case let .location(content):
            writeInt(&buf, Int32(8))
            FfiConverterTypeLocationContent.write(content, into: &buf)
            
        
        case let .other(msgtype,body):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(msgtype, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMessageType_lift(_ buf: RustBuffer) throws -> MessageType {
    return try FfiConverterTypeMessageType.lift(buf)
}

public func FfiConverterTypeMessageType_lower(_ value: MessageType) -> RustBuffer {
    return FfiConverterTypeMessageType.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NotificationEvent {
    
    case timeline(event: TimelineEvent
    )
    case invite(sender: String
    )
}


public struct FfiConverterTypeNotificationEvent: FfiConverterRustBuffer {
    typealias SwiftType = NotificationEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .timeline(event: try FfiConverterTypeTimelineEvent.read(from: &buf)
        )
        
        case 2: return .invite(sender: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .timeline(event):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTimelineEvent.write(event, into: &buf)
            
        
        case let .invite(sender):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(sender, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNotificationEvent_lift(_ buf: RustBuffer) throws -> NotificationEvent {
    return try FfiConverterTypeNotificationEvent.lift(buf)
}

public func FfiConverterTypeNotificationEvent_lower(_ value: NotificationEvent) -> RustBuffer {
    return FfiConverterTypeNotificationEvent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NotificationProcessSetup {
    
    case multipleProcesses
    case singleProcess(syncService: SyncService
    )
}


public struct FfiConverterTypeNotificationProcessSetup: FfiConverterRustBuffer {
    typealias SwiftType = NotificationProcessSetup

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationProcessSetup {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .multipleProcesses
        
        case 2: return .singleProcess(syncService: try FfiConverterTypeSyncService.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationProcessSetup, into buf: inout [UInt8]) {
        switch value {
        
        
        case .multipleProcesses:
            writeInt(&buf, Int32(1))
        
        
        case let .singleProcess(syncService):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSyncService.write(syncService, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNotificationProcessSetup_lift(_ buf: RustBuffer) throws -> NotificationProcessSetup {
    return try FfiConverterTypeNotificationProcessSetup.lift(buf)
}

public func FfiConverterTypeNotificationProcessSetup_lower(_ value: NotificationProcessSetup) -> RustBuffer {
    return FfiConverterTypeNotificationProcessSetup.lower(value)
}





public enum NotificationSettingsError {

    
    
    case Generic(msg: String
    )
    /**
     * Invalid parameter.
     */
    case InvalidParameter(msg: String
    )
    /**
     * Invalid room id.
     */
    case InvalidRoomId(roomId: String
    )
    /**
     * Rule not found
     */
    case RuleNotFound(ruleId: String
    )
    /**
     * Unable to add push rule.
     */
    case UnableToAddPushRule
    /**
     * Unable to remove push rule.
     */
    case UnableToRemovePushRule
    /**
     * Unable to save the push rules
     */
    case UnableToSavePushRules
    /**
     * Unable to update push rule.
     */
    case UnableToUpdatePushRule
}


public struct FfiConverterTypeNotificationSettingsError: FfiConverterRustBuffer {
    typealias SwiftType = NotificationSettingsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationSettingsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidParameter(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidRoomId(
            roomId: try FfiConverterString.read(from: &buf)
            )
        case 4: return .RuleNotFound(
            ruleId: try FfiConverterString.read(from: &buf)
            )
        case 5: return .UnableToAddPushRule
        case 6: return .UnableToRemovePushRule
        case 7: return .UnableToSavePushRules
        case 8: return .UnableToUpdatePushRule

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationSettingsError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .InvalidParameter(msg):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .InvalidRoomId(roomId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(roomId, into: &buf)
            
        
        case let .RuleNotFound(ruleId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(ruleId, into: &buf)
            
        
        case .UnableToAddPushRule:
            writeInt(&buf, Int32(5))
        
        
        case .UnableToRemovePushRule:
            writeInt(&buf, Int32(6))
        
        
        case .UnableToSavePushRules:
            writeInt(&buf, Int32(7))
        
        
        case .UnableToUpdatePushRule:
            writeInt(&buf, Int32(8))
        
        }
    }
}


extension NotificationSettingsError: Equatable, Hashable {}

extension NotificationSettingsError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NotifyType {
    
    case ring
    case notify
}


public struct FfiConverterTypeNotifyType: FfiConverterRustBuffer {
    typealias SwiftType = NotifyType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotifyType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ring
        
        case 2: return .notify
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotifyType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ring:
            writeInt(&buf, Int32(1))
        
        
        case .notify:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeNotifyType_lift(_ buf: RustBuffer) throws -> NotifyType {
    return try FfiConverterTypeNotifyType.lift(buf)
}

public func FfiConverterTypeNotifyType_lower(_ value: NotifyType) -> RustBuffer {
    return FfiConverterTypeNotifyType.lower(value)
}



extension NotifyType: Equatable, Hashable {}




public enum OidcError {

    
    
    case NotSupported(message: String)
    
    case MetadataInvalid(message: String)
    
    case RegistrationsPathInvalid(message: String)
    
    case CallbackUrlInvalid(message: String)
    
    case Cancelled(message: String)
    
    case Generic(message: String)
    
}


public struct FfiConverterTypeOidcError: FfiConverterRustBuffer {
    typealias SwiftType = OidcError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NotSupported(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .MetadataInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .RegistrationsPathInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .CallbackUrlInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .Cancelled(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OidcError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .NotSupported(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .MetadataInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .RegistrationsPathInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .CallbackUrlInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .Cancelled(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))

        
        }
    }
}


extension OidcError: Equatable, Hashable {}

extension OidcError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OidcPrompt {
    
    /**
     * The Authorization Server must not display any authentication or consent
     * user interface pages.
     */
    case none
    /**
     * The Authorization Server should prompt the End-User for
     * reauthentication.
     */
    case login
    /**
     * The Authorization Server should prompt the End-User for consent before
     * returning information to the Client.
     */
    case consent
    /**
     * The Authorization Server should prompt the End-User to select a user
     * account.
     *
     * This enables an End-User who has multiple accounts at the Authorization
     * Server to select amongst the multiple accounts that they might have
     * current sessions for.
     */
    case selectAccount
    /**
     * The Authorization Server should prompt the End-User to create a user
     * account.
     *
     * Defined in [Initiating User Registration via OpenID Connect](https://openid.net/specs/openid-connect-prompt-create-1_0.html).
     */
    case create
    /**
     * An unknown value.
     */
    case unknown(value: String
    )
}


public struct FfiConverterTypeOidcPrompt: FfiConverterRustBuffer {
    typealias SwiftType = OidcPrompt

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcPrompt {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .login
        
        case 3: return .consent
        
        case 4: return .selectAccount
        
        case 5: return .create
        
        case 6: return .unknown(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OidcPrompt, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .login:
            writeInt(&buf, Int32(2))
        
        
        case .consent:
            writeInt(&buf, Int32(3))
        
        
        case .selectAccount:
            writeInt(&buf, Int32(4))
        
        
        case .create:
            writeInt(&buf, Int32(5))
        
        
        case let .unknown(value):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOidcPrompt_lift(_ buf: RustBuffer) throws -> OidcPrompt {
    return try FfiConverterTypeOidcPrompt.lift(buf)
}

public func FfiConverterTypeOidcPrompt_lower(_ value: OidcPrompt) -> RustBuffer {
    return FfiConverterTypeOidcPrompt.lower(value)
}



extension OidcPrompt: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OtherState {
    
    case policyRuleRoom
    case policyRuleServer
    case policyRuleUser
    case roomAliases
    case roomAvatar(url: String?
    )
    case roomCanonicalAlias
    case roomCreate
    case roomEncryption
    case roomGuestAccess
    case roomHistoryVisibility
    case roomJoinRules
    case roomName(name: String?
    )
    case roomPinnedEvents(change: RoomPinnedEventsChange
    )
    case roomPowerLevels(users: [String: Int64], previous: [String: Int64]?
    )
    case roomServerAcl
    case roomThirdPartyInvite(displayName: String?
    )
    case roomTombstone
    case roomTopic(topic: String?
    )
    case spaceChild
    case spaceParent
    case custom(eventType: String
    )
}


public struct FfiConverterTypeOtherState: FfiConverterRustBuffer {
    typealias SwiftType = OtherState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OtherState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .policyRuleRoom
        
        case 2: return .policyRuleServer
        
        case 3: return .policyRuleUser
        
        case 4: return .roomAliases
        
        case 5: return .roomAvatar(url: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 6: return .roomCanonicalAlias
        
        case 7: return .roomCreate
        
        case 8: return .roomEncryption
        
        case 9: return .roomGuestAccess
        
        case 10: return .roomHistoryVisibility
        
        case 11: return .roomJoinRules
        
        case 12: return .roomName(name: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 13: return .roomPinnedEvents(change: try FfiConverterTypeRoomPinnedEventsChange.read(from: &buf)
        )
        
        case 14: return .roomPowerLevels(users: try FfiConverterDictionaryStringInt64.read(from: &buf), previous: try FfiConverterOptionDictionaryStringInt64.read(from: &buf)
        )
        
        case 15: return .roomServerAcl
        
        case 16: return .roomThirdPartyInvite(displayName: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 17: return .roomTombstone
        
        case 18: return .roomTopic(topic: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 19: return .spaceChild
        
        case 20: return .spaceParent
        
        case 21: return .custom(eventType: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OtherState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .policyRuleRoom:
            writeInt(&buf, Int32(1))
        
        
        case .policyRuleServer:
            writeInt(&buf, Int32(2))
        
        
        case .policyRuleUser:
            writeInt(&buf, Int32(3))
        
        
        case .roomAliases:
            writeInt(&buf, Int32(4))
        
        
        case let .roomAvatar(url):
            writeInt(&buf, Int32(5))
            FfiConverterOptionString.write(url, into: &buf)
            
        
        case .roomCanonicalAlias:
            writeInt(&buf, Int32(6))
        
        
        case .roomCreate:
            writeInt(&buf, Int32(7))
        
        
        case .roomEncryption:
            writeInt(&buf, Int32(8))
        
        
        case .roomGuestAccess:
            writeInt(&buf, Int32(9))
        
        
        case .roomHistoryVisibility:
            writeInt(&buf, Int32(10))
        
        
        case .roomJoinRules:
            writeInt(&buf, Int32(11))
        
        
        case let .roomName(name):
            writeInt(&buf, Int32(12))
            FfiConverterOptionString.write(name, into: &buf)
            
        
        case let .roomPinnedEvents(change):
            writeInt(&buf, Int32(13))
            FfiConverterTypeRoomPinnedEventsChange.write(change, into: &buf)
            
        
        case let .roomPowerLevels(users,previous):
            writeInt(&buf, Int32(14))
            FfiConverterDictionaryStringInt64.write(users, into: &buf)
            FfiConverterOptionDictionaryStringInt64.write(previous, into: &buf)
            
        
        case .roomServerAcl:
            writeInt(&buf, Int32(15))
        
        
        case let .roomThirdPartyInvite(displayName):
            writeInt(&buf, Int32(16))
            FfiConverterOptionString.write(displayName, into: &buf)
            
        
        case .roomTombstone:
            writeInt(&buf, Int32(17))
        
        
        case let .roomTopic(topic):
            writeInt(&buf, Int32(18))
            FfiConverterOptionString.write(topic, into: &buf)
            
        
        case .spaceChild:
            writeInt(&buf, Int32(19))
        
        
        case .spaceParent:
            writeInt(&buf, Int32(20))
        
        
        case let .custom(eventType):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(eventType, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOtherState_lift(_ buf: RustBuffer) throws -> OtherState {
    return try FfiConverterTypeOtherState.lift(buf)
}

public func FfiConverterTypeOtherState_lower(_ value: OtherState) -> RustBuffer {
    return FfiConverterTypeOtherState.lower(value)
}



extension OtherState: Equatable, Hashable {}




public enum ParseError {

    
    
    case EmptyHost(message: String)
    
    case IdnaError(message: String)
    
    case InvalidPort(message: String)
    
    case InvalidIpv4Address(message: String)
    
    case InvalidIpv6Address(message: String)
    
    case InvalidDomainCharacter(message: String)
    
    case RelativeUrlWithoutBase(message: String)
    
    case RelativeUrlWithCannotBeABaseBase(message: String)
    
    case SetHostOnCannotBeABaseUrl(message: String)
    
    case Overflow(message: String)
    
    case Other(message: String)
    
}


public struct FfiConverterTypeParseError: FfiConverterRustBuffer {
    typealias SwiftType = ParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .EmptyHost(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .IdnaError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidPort(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidIpv4Address(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidIpv6Address(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidDomainCharacter(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .RelativeUrlWithoutBase(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .RelativeUrlWithCannotBeABaseBase(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .SetHostOnCannotBeABaseUrl(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .Overflow(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .Other(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .EmptyHost(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .IdnaError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .InvalidPort(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidIpv4Address(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidIpv6Address(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvalidDomainCharacter(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .RelativeUrlWithoutBase(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .RelativeUrlWithCannotBeABaseBase(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .SetHostOnCannotBeABaseUrl(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .Overflow(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .Other(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))

        
        }
    }
}


extension ParseError: Equatable, Hashable {}

extension ParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PollKind {
    
    case disclosed
    case undisclosed
}


public struct FfiConverterTypePollKind: FfiConverterRustBuffer {
    typealias SwiftType = PollKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disclosed
        
        case 2: return .undisclosed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PollKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disclosed:
            writeInt(&buf, Int32(1))
        
        
        case .undisclosed:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePollKind_lift(_ buf: RustBuffer) throws -> PollKind {
    return try FfiConverterTypePollKind.lift(buf)
}

public func FfiConverterTypePollKind_lower(_ value: PollKind) -> RustBuffer {
    return FfiConverterTypePollKind.lower(value)
}



extension PollKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProfileDetails {
    
    case unavailable
    case pending
    case ready(displayName: String?, displayNameAmbiguous: Bool, avatarUrl: String?
    )
    case error(message: String
    )
}


public struct FfiConverterTypeProfileDetails: FfiConverterRustBuffer {
    typealias SwiftType = ProfileDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unavailable
        
        case 2: return .pending
        
        case 3: return .ready(displayName: try FfiConverterOptionString.read(from: &buf), displayNameAmbiguous: try FfiConverterBool.read(from: &buf), avatarUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .error(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unavailable:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case let .ready(displayName,displayNameAmbiguous,avatarUrl):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(displayName, into: &buf)
            FfiConverterBool.write(displayNameAmbiguous, into: &buf)
            FfiConverterOptionString.write(avatarUrl, into: &buf)
            
        
        case let .error(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


public func FfiConverterTypeProfileDetails_lift(_ buf: RustBuffer) throws -> ProfileDetails {
    return try FfiConverterTypeProfileDetails.lift(buf)
}

public func FfiConverterTypeProfileDetails_lower(_ value: ProfileDetails) -> RustBuffer {
    return FfiConverterTypeProfileDetails.lower(value)
}



extension ProfileDetails: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PublicRoomJoinRule {
    
    case `public`
    case knock
}


public struct FfiConverterTypePublicRoomJoinRule: FfiConverterRustBuffer {
    typealias SwiftType = PublicRoomJoinRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicRoomJoinRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`public`
        
        case 2: return .knock
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicRoomJoinRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`public`:
            writeInt(&buf, Int32(1))
        
        
        case .knock:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePublicRoomJoinRule_lift(_ buf: RustBuffer) throws -> PublicRoomJoinRule {
    return try FfiConverterTypePublicRoomJoinRule.lift(buf)
}

public func FfiConverterTypePublicRoomJoinRule_lower(_ value: PublicRoomJoinRule) -> RustBuffer {
    return FfiConverterTypePublicRoomJoinRule.lower(value)
}



extension PublicRoomJoinRule: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PushFormat {
    
    case eventIdOnly
}


public struct FfiConverterTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PushFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventIdOnly
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PushFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .eventIdOnly:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypePushFormat_lift(_ buf: RustBuffer) throws -> PushFormat {
    return try FfiConverterTypePushFormat.lift(buf)
}

public func FfiConverterTypePushFormat_lower(_ value: PushFormat) -> RustBuffer {
    return FfiConverterTypePushFormat.lower(value)
}



extension PushFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PusherKind {
    
    case http(data: HttpPusherData
    )
    case email
}


public struct FfiConverterTypePusherKind: FfiConverterRustBuffer {
    typealias SwiftType = PusherKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .http(data: try FfiConverterTypeHttpPusherData.read(from: &buf)
        )
        
        case 2: return .email
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PusherKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .http(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHttpPusherData.write(data, into: &buf)
            
        
        case .email:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePusherKind_lift(_ buf: RustBuffer) throws -> PusherKind {
    return try FfiConverterTypePusherKind.lift(buf)
}

public func FfiConverterTypePusherKind_lower(_ value: PusherKind) -> RustBuffer {
    return FfiConverterTypePusherKind.lower(value)
}



extension PusherKind: Equatable, Hashable {}




/**
 * Error type for the decoding of the [`QrCodeData`].
 */
public enum QrCodeDecodeError {

    
    
    case Crypto(message: String)
    
}


public struct FfiConverterTypeQrCodeDecodeError: FfiConverterRustBuffer {
    typealias SwiftType = QrCodeDecodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCodeDecodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Crypto(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrCodeDecodeError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Crypto(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension QrCodeDecodeError: Equatable, Hashable {}

extension QrCodeDecodeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum describing the progress of the QR-code login.
 */

public enum QrLoginProgress {
    
    /**
     * The login process is starting.
     */
    case starting
    /**
     * We established a secure channel with the other device.
     */
    case establishingSecureChannel(
        /**
         * The check code that the device should display so the other device
         * can confirm that the channel is secure as well.
         */checkCode: UInt8, 
        /**
         * The string representation of the check code, will be guaranteed to
         * be 2 characters long, preserving the leading zero if the
         * first digit is a zero.
         */checkCodeString: String
    )
    /**
     * We are waiting for the login and for the OIDC provider to give us an
     * access token.
     */
    case waitingForToken(userCode: String
    )
    /**
     * The login has successfully finished.
     */
    case done
}


public struct FfiConverterTypeQrLoginProgress: FfiConverterRustBuffer {
    typealias SwiftType = QrLoginProgress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrLoginProgress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .starting
        
        case 2: return .establishingSecureChannel(checkCode: try FfiConverterUInt8.read(from: &buf), checkCodeString: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .waitingForToken(userCode: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .done
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrLoginProgress, into buf: inout [UInt8]) {
        switch value {
        
        
        case .starting:
            writeInt(&buf, Int32(1))
        
        
        case let .establishingSecureChannel(checkCode,checkCodeString):
            writeInt(&buf, Int32(2))
            FfiConverterUInt8.write(checkCode, into: &buf)
            FfiConverterString.write(checkCodeString, into: &buf)
            
        
        case let .waitingForToken(userCode):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(userCode, into: &buf)
            
        
        case .done:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeQrLoginProgress_lift(_ buf: RustBuffer) throws -> QrLoginProgress {
    return try FfiConverterTypeQrLoginProgress.lift(buf)
}

public func FfiConverterTypeQrLoginProgress_lower(_ value: QrLoginProgress) -> RustBuffer {
    return FfiConverterTypeQrLoginProgress.lower(value)
}



extension QrLoginProgress: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
 * String.
 *
 * Represent a failed to send unrecoverable error of an event sent via the
 * send_queue. It is a serializable representation of a client error, see
 * `From` implementation for more details. These errors can not be
 * automatically retried, but yet some manual action can be taken before retry
 * sending. If not the only solution is to delete the local event.
 */

public enum QueueWedgeError {
    
    /**
     * This error occurs when there are some insecure devices in the room, and
     * the current encryption setting prohibit sharing with them.
     */
    case insecureDevices(
        /**
         * The insecure devices as a Map of userID to deviceID.
         */userDeviceMap: [String: [String]]
    )
    /**
     * This error occurs when a previously verified user is not anymore, and
     * the current encryption setting prohibit sharing when it happens.
     */
    case identityViolations(
        /**
         * The users that are expected to be verified but are not.
         */users: [String]
    )
    /**
     * It is required to set up cross-signing and properly erify the current
     * session before sending.
     */
    case crossVerificationRequired
    /**
     * Some media content to be sent has disappeared from the cache.
     */
    case missingMediaContent
    /**
     * Some mime type couldn't be parsed.
     */
    case invalidMimeType(mimeType: String
    )
    /**
     * Other errors.
     */
    case genericApiError(msg: String
    )
}


public struct FfiConverterTypeQueueWedgeError: FfiConverterRustBuffer {
    typealias SwiftType = QueueWedgeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QueueWedgeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .insecureDevices(userDeviceMap: try FfiConverterDictionaryStringSequenceString.read(from: &buf)
        )
        
        case 2: return .identityViolations(users: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 3: return .crossVerificationRequired
        
        case 4: return .missingMediaContent
        
        case 5: return .invalidMimeType(mimeType: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .genericApiError(msg: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QueueWedgeError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .insecureDevices(userDeviceMap):
            writeInt(&buf, Int32(1))
            FfiConverterDictionaryStringSequenceString.write(userDeviceMap, into: &buf)
            
        
        case let .identityViolations(users):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceString.write(users, into: &buf)
            
        
        case .crossVerificationRequired:
            writeInt(&buf, Int32(3))
        
        
        case .missingMediaContent:
            writeInt(&buf, Int32(4))
        
        
        case let .invalidMimeType(mimeType):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(mimeType, into: &buf)
            
        
        case let .genericApiError(msg):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


public func FfiConverterTypeQueueWedgeError_lift(_ buf: RustBuffer) throws -> QueueWedgeError {
    return try FfiConverterTypeQueueWedgeError.lift(buf)
}

public func FfiConverterTypeQueueWedgeError_lower(_ value: QueueWedgeError) -> RustBuffer {
    return FfiConverterTypeQueueWedgeError.lower(value)
}



extension QueueWedgeError: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */

public enum ReceiptType {
    
    case read
    case readPrivate
    case fullyRead
}


public struct FfiConverterTypeReceiptType: FfiConverterRustBuffer {
    typealias SwiftType = ReceiptType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiptType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .read
        
        case 2: return .readPrivate
        
        case 3: return .fullyRead
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReceiptType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .read:
            writeInt(&buf, Int32(1))
        
        
        case .readPrivate:
            writeInt(&buf, Int32(2))
        
        
        case .fullyRead:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeReceiptType_lift(_ buf: RustBuffer) throws -> ReceiptType {
    return try FfiConverterTypeReceiptType.lift(buf)
}

public func FfiConverterTypeReceiptType_lower(_ value: ReceiptType) -> RustBuffer {
    return FfiConverterTypeReceiptType.lower(value)
}



extension ReceiptType: Equatable, Hashable {}




public enum RecoveryError {

    
    
    /**
     * A backup already exists on the homeserver, the recovery subsystem does
     * not allow backups to be overwritten, disable recovery first.
     */
    case BackupExistsOnServer
    /**
     * A typical SDK error.
     */
    case Client(source: ClientError
    )
    /**
     * Error in the secret storage subsystem.
     */
    case SecretStorage(errorMessage: String
    )
}


public struct FfiConverterTypeRecoveryError: FfiConverterRustBuffer {
    typealias SwiftType = RecoveryError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BackupExistsOnServer
        case 2: return .Client(
            source: try FfiConverterTypeClientError.read(from: &buf)
            )
        case 3: return .SecretStorage(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RecoveryError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .BackupExistsOnServer:
            writeInt(&buf, Int32(1))
        
        
        case let .Client(source):
            writeInt(&buf, Int32(2))
            FfiConverterTypeClientError.write(source, into: &buf)
            
        
        case let .SecretStorage(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


extension RecoveryError: Equatable, Hashable {}

extension RecoveryError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RecoveryState {
    
    case unknown
    case enabled
    case disabled
    case incomplete
}


public struct FfiConverterTypeRecoveryState: FfiConverterRustBuffer {
    typealias SwiftType = RecoveryState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .enabled
        
        case 3: return .disabled
        
        case 4: return .incomplete
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RecoveryState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .enabled:
            writeInt(&buf, Int32(2))
        
        
        case .disabled:
            writeInt(&buf, Int32(3))
        
        
        case .incomplete:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeRecoveryState_lift(_ buf: RustBuffer) throws -> RecoveryState {
    return try FfiConverterTypeRecoveryState.lift(buf)
}

public func FfiConverterTypeRecoveryState_lower(_ value: RecoveryState) -> RustBuffer {
    return FfiConverterTypeRecoveryState.lower(value)
}



extension RecoveryState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RepliedToEventDetails {
    
    case unavailable
    case pending
    case ready(content: TimelineItemContent, sender: String, senderProfile: ProfileDetails
    )
    case error(message: String
    )
}


public struct FfiConverterTypeRepliedToEventDetails: FfiConverterRustBuffer {
    typealias SwiftType = RepliedToEventDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RepliedToEventDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unavailable
        
        case 2: return .pending
        
        case 3: return .ready(content: try FfiConverterTypeTimelineItemContent.read(from: &buf), sender: try FfiConverterString.read(from: &buf), senderProfile: try FfiConverterTypeProfileDetails.read(from: &buf)
        )
        
        case 4: return .error(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RepliedToEventDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unavailable:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case let .ready(content,sender,senderProfile):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTimelineItemContent.write(content, into: &buf)
            FfiConverterString.write(sender, into: &buf)
            FfiConverterTypeProfileDetails.write(senderProfile, into: &buf)
            
        
        case let .error(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRepliedToEventDetails_lift(_ buf: RustBuffer) throws -> RepliedToEventDetails {
    return try FfiConverterTypeRepliedToEventDetails.lift(buf)
}

public func FfiConverterTypeRepliedToEventDetails_lower(_ value: RepliedToEventDetails) -> RustBuffer {
    return FfiConverterTypeRepliedToEventDetails.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomDirectorySearchEntryUpdate {
    
    case append(values: [RoomDescription]
    )
    case clear
    case pushFront(value: RoomDescription
    )
    case pushBack(value: RoomDescription
    )
    case popFront
    case popBack
    case insert(index: UInt32, value: RoomDescription
    )
    case set(index: UInt32, value: RoomDescription
    )
    case remove(index: UInt32
    )
    case truncate(length: UInt32
    )
    case reset(values: [RoomDescription]
    )
}


public struct FfiConverterTypeRoomDirectorySearchEntryUpdate: FfiConverterRustBuffer {
    typealias SwiftType = RoomDirectorySearchEntryUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomDirectorySearchEntryUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .append(values: try FfiConverterSequenceTypeRoomDescription.read(from: &buf)
        )
        
        case 2: return .clear
        
        case 3: return .pushFront(value: try FfiConverterTypeRoomDescription.read(from: &buf)
        )
        
        case 4: return .pushBack(value: try FfiConverterTypeRoomDescription.read(from: &buf)
        )
        
        case 5: return .popFront
        
        case 6: return .popBack
        
        case 7: return .insert(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeRoomDescription.read(from: &buf)
        )
        
        case 8: return .set(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeRoomDescription.read(from: &buf)
        )
        
        case 9: return .remove(index: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .truncate(length: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 11: return .reset(values: try FfiConverterSequenceTypeRoomDescription.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomDirectorySearchEntryUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .append(values):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomDescription.write(values, into: &buf)
            
        
        case .clear:
            writeInt(&buf, Int32(2))
        
        
        case let .pushFront(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRoomDescription.write(value, into: &buf)
            
        
        case let .pushBack(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeRoomDescription.write(value, into: &buf)
            
        
        case .popFront:
            writeInt(&buf, Int32(5))
        
        
        case .popBack:
            writeInt(&buf, Int32(6))
        
        
        case let .insert(index,value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoomDescription.write(value, into: &buf)
            
        
        case let .set(index,value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoomDescription.write(value, into: &buf)
            
        
        case let .remove(index):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .truncate(length):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .reset(values):
            writeInt(&buf, Int32(11))
            FfiConverterSequenceTypeRoomDescription.write(values, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomDirectorySearchEntryUpdate_lift(_ buf: RustBuffer) throws -> RoomDirectorySearchEntryUpdate {
    return try FfiConverterTypeRoomDirectorySearchEntryUpdate.lift(buf)
}

public func FfiConverterTypeRoomDirectorySearchEntryUpdate_lower(_ value: RoomDirectorySearchEntryUpdate) -> RustBuffer {
    return FfiConverterTypeRoomDirectorySearchEntryUpdate.lower(value)
}



extension RoomDirectorySearchEntryUpdate: Equatable, Hashable {}




public enum RoomError {

    
    
    case InvalidAttachmentData(message: String)
    
    case InvalidAttachmentMimeType(message: String)
    
    case InvalidMediaInfo(message: String)
    
    case TimelineUnavailable(message: String)
    
    case InvalidThumbnailData(message: String)
    
    case FailedSendingAttachment(message: String)
    
}


public struct FfiConverterTypeRoomError: FfiConverterRustBuffer {
    typealias SwiftType = RoomError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidAttachmentData(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidAttachmentMimeType(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidMediaInfo(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .TimelineUnavailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidThumbnailData(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .FailedSendingAttachment(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidAttachmentData(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidAttachmentMimeType(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .InvalidMediaInfo(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .TimelineUnavailable(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidThumbnailData(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .FailedSendingAttachment(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))

        
        }
    }
}


extension RoomError: Equatable, Hashable {}

extension RoomError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListEntriesDynamicFilterKind {
    
    case all(filters: [RoomListEntriesDynamicFilterKind]
    )
    case any(filters: [RoomListEntriesDynamicFilterKind]
    )
    case nonLeft
    case joined
    case unread
    case favourite
    case invite
    case category(expect: RoomListFilterCategory
    )
    case none
    case normalizedMatchRoomName(pattern: String
    )
    case fuzzyMatchRoomName(pattern: String
    )
}


public struct FfiConverterTypeRoomListEntriesDynamicFilterKind: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntriesDynamicFilterKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesDynamicFilterKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all(filters: try FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.read(from: &buf)
        )
        
        case 2: return .any(filters: try FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.read(from: &buf)
        )
        
        case 3: return .nonLeft
        
        case 4: return .joined
        
        case 5: return .unread
        
        case 6: return .favourite
        
        case 7: return .invite
        
        case 8: return .category(expect: try FfiConverterTypeRoomListFilterCategory.read(from: &buf)
        )
        
        case 9: return .none
        
        case 10: return .normalizedMatchRoomName(pattern: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .fuzzyMatchRoomName(pattern: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntriesDynamicFilterKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .all(filters):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.write(filters, into: &buf)
            
        
        case let .any(filters):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.write(filters, into: &buf)
            
        
        case .nonLeft:
            writeInt(&buf, Int32(3))
        
        
        case .joined:
            writeInt(&buf, Int32(4))
        
        
        case .unread:
            writeInt(&buf, Int32(5))
        
        
        case .favourite:
            writeInt(&buf, Int32(6))
        
        
        case .invite:
            writeInt(&buf, Int32(7))
        
        
        case let .category(expect):
            writeInt(&buf, Int32(8))
            FfiConverterTypeRoomListFilterCategory.write(expect, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(9))
        
        
        case let .normalizedMatchRoomName(pattern):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(pattern, into: &buf)
            
        
        case let .fuzzyMatchRoomName(pattern):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(pattern, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListEntriesDynamicFilterKind_lift(_ buf: RustBuffer) throws -> RoomListEntriesDynamicFilterKind {
    return try FfiConverterTypeRoomListEntriesDynamicFilterKind.lift(buf)
}

public func FfiConverterTypeRoomListEntriesDynamicFilterKind_lower(_ value: RoomListEntriesDynamicFilterKind) -> RustBuffer {
    return FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(value)
}



extension RoomListEntriesDynamicFilterKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListEntriesUpdate {
    
    case append(values: [RoomListItem]
    )
    case clear
    case pushFront(value: RoomListItem
    )
    case pushBack(value: RoomListItem
    )
    case popFront
    case popBack
    case insert(index: UInt32, value: RoomListItem
    )
    case set(index: UInt32, value: RoomListItem
    )
    case remove(index: UInt32
    )
    case truncate(length: UInt32
    )
    case reset(values: [RoomListItem]
    )
}


public struct FfiConverterTypeRoomListEntriesUpdate: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntriesUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .append(values: try FfiConverterSequenceTypeRoomListItem.read(from: &buf)
        )
        
        case 2: return .clear
        
        case 3: return .pushFront(value: try FfiConverterTypeRoomListItem.read(from: &buf)
        )
        
        case 4: return .pushBack(value: try FfiConverterTypeRoomListItem.read(from: &buf)
        )
        
        case 5: return .popFront
        
        case 6: return .popBack
        
        case 7: return .insert(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeRoomListItem.read(from: &buf)
        )
        
        case 8: return .set(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeRoomListItem.read(from: &buf)
        )
        
        case 9: return .remove(index: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .truncate(length: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 11: return .reset(values: try FfiConverterSequenceTypeRoomListItem.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntriesUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .append(values):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomListItem.write(values, into: &buf)
            
        
        case .clear:
            writeInt(&buf, Int32(2))
        
        
        case let .pushFront(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRoomListItem.write(value, into: &buf)
            
        
        case let .pushBack(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeRoomListItem.write(value, into: &buf)
            
        
        case .popFront:
            writeInt(&buf, Int32(5))
        
        
        case .popBack:
            writeInt(&buf, Int32(6))
        
        
        case let .insert(index,value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoomListItem.write(value, into: &buf)
            
        
        case let .set(index,value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoomListItem.write(value, into: &buf)
            
        
        case let .remove(index):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .truncate(length):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .reset(values):
            writeInt(&buf, Int32(11))
            FfiConverterSequenceTypeRoomListItem.write(values, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListEntriesUpdate_lift(_ buf: RustBuffer) throws -> RoomListEntriesUpdate {
    return try FfiConverterTypeRoomListEntriesUpdate.lift(buf)
}

public func FfiConverterTypeRoomListEntriesUpdate_lower(_ value: RoomListEntriesUpdate) -> RustBuffer {
    return FfiConverterTypeRoomListEntriesUpdate.lower(value)
}





public enum RoomListError {

    
    
    case SlidingSync(error: String
    )
    case UnknownList(listName: String
    )
    case InputCannotBeApplied
    case RoomNotFound(roomName: String
    )
    case InvalidRoomId(error: String
    )
    case TimelineAlreadyExists(roomName: String
    )
    case TimelineNotInitialized(roomName: String
    )
    case InitializingTimeline(error: String
    )
    case EventCache(error: String
    )
    case IncorrectRoomMembership(expected: [Membership], actual: Membership
    )
}


public struct FfiConverterTypeRoomListError: FfiConverterRustBuffer {
    typealias SwiftType = RoomListError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SlidingSync(
            error: try FfiConverterString.read(from: &buf)
            )
        case 2: return .UnknownList(
            listName: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InputCannotBeApplied
        case 4: return .RoomNotFound(
            roomName: try FfiConverterString.read(from: &buf)
            )
        case 5: return .InvalidRoomId(
            error: try FfiConverterString.read(from: &buf)
            )
        case 6: return .TimelineAlreadyExists(
            roomName: try FfiConverterString.read(from: &buf)
            )
        case 7: return .TimelineNotInitialized(
            roomName: try FfiConverterString.read(from: &buf)
            )
        case 8: return .InitializingTimeline(
            error: try FfiConverterString.read(from: &buf)
            )
        case 9: return .EventCache(
            error: try FfiConverterString.read(from: &buf)
            )
        case 10: return .IncorrectRoomMembership(
            expected: try FfiConverterSequenceTypeMembership.read(from: &buf), 
            actual: try FfiConverterTypeMembership.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SlidingSync(error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .UnknownList(listName):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(listName, into: &buf)
            
        
        case .InputCannotBeApplied:
            writeInt(&buf, Int32(3))
        
        
        case let .RoomNotFound(roomName):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(roomName, into: &buf)
            
        
        case let .InvalidRoomId(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .TimelineAlreadyExists(roomName):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(roomName, into: &buf)
            
        
        case let .TimelineNotInitialized(roomName):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(roomName, into: &buf)
            
        
        case let .InitializingTimeline(error):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .EventCache(error):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .IncorrectRoomMembership(expected,actual):
            writeInt(&buf, Int32(10))
            FfiConverterSequenceTypeMembership.write(expected, into: &buf)
            FfiConverterTypeMembership.write(actual, into: &buf)
            
        }
    }
}


extension RoomListError: Equatable, Hashable {}

extension RoomListError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListFilterCategory {
    
    case group
    case people
}


public struct FfiConverterTypeRoomListFilterCategory: FfiConverterRustBuffer {
    typealias SwiftType = RoomListFilterCategory

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListFilterCategory {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .group
        
        case 2: return .people
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListFilterCategory, into buf: inout [UInt8]) {
        switch value {
        
        
        case .group:
            writeInt(&buf, Int32(1))
        
        
        case .people:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRoomListFilterCategory_lift(_ buf: RustBuffer) throws -> RoomListFilterCategory {
    return try FfiConverterTypeRoomListFilterCategory.lift(buf)
}

public func FfiConverterTypeRoomListFilterCategory_lower(_ value: RoomListFilterCategory) -> RustBuffer {
    return FfiConverterTypeRoomListFilterCategory.lower(value)
}



extension RoomListFilterCategory: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListLoadingState {
    
    case notLoaded
    case loaded(maximumNumberOfRooms: UInt32?
    )
}


public struct FfiConverterTypeRoomListLoadingState: FfiConverterRustBuffer {
    typealias SwiftType = RoomListLoadingState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListLoadingState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notLoaded
        
        case 2: return .loaded(maximumNumberOfRooms: try FfiConverterOptionUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListLoadingState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notLoaded:
            writeInt(&buf, Int32(1))
        
        
        case let .loaded(maximumNumberOfRooms):
            writeInt(&buf, Int32(2))
            FfiConverterOptionUInt32.write(maximumNumberOfRooms, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomListLoadingState_lift(_ buf: RustBuffer) throws -> RoomListLoadingState {
    return try FfiConverterTypeRoomListLoadingState.lift(buf)
}

public func FfiConverterTypeRoomListLoadingState_lower(_ value: RoomListLoadingState) -> RustBuffer {
    return FfiConverterTypeRoomListLoadingState.lower(value)
}



extension RoomListLoadingState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListServiceState {
    
    case initial
    case settingUp
    case recovering
    case running
    case error
    case terminated
}


public struct FfiConverterTypeRoomListServiceState: FfiConverterRustBuffer {
    typealias SwiftType = RoomListServiceState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListServiceState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initial
        
        case 2: return .settingUp
        
        case 3: return .recovering
        
        case 4: return .running
        
        case 5: return .error
        
        case 6: return .terminated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListServiceState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initial:
            writeInt(&buf, Int32(1))
        
        
        case .settingUp:
            writeInt(&buf, Int32(2))
        
        
        case .recovering:
            writeInt(&buf, Int32(3))
        
        
        case .running:
            writeInt(&buf, Int32(4))
        
        
        case .error:
            writeInt(&buf, Int32(5))
        
        
        case .terminated:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeRoomListServiceState_lift(_ buf: RustBuffer) throws -> RoomListServiceState {
    return try FfiConverterTypeRoomListServiceState.lift(buf)
}

public func FfiConverterTypeRoomListServiceState_lower(_ value: RoomListServiceState) -> RustBuffer {
    return FfiConverterTypeRoomListServiceState.lower(value)
}



extension RoomListServiceState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListServiceSyncIndicator {
    
    case show
    case hide
}


public struct FfiConverterTypeRoomListServiceSyncIndicator: FfiConverterRustBuffer {
    typealias SwiftType = RoomListServiceSyncIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListServiceSyncIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .show
        
        case 2: return .hide
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListServiceSyncIndicator, into buf: inout [UInt8]) {
        switch value {
        
        
        case .show:
            writeInt(&buf, Int32(1))
        
        
        case .hide:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRoomListServiceSyncIndicator_lift(_ buf: RustBuffer) throws -> RoomListServiceSyncIndicator {
    return try FfiConverterTypeRoomListServiceSyncIndicator.lift(buf)
}

public func FfiConverterTypeRoomListServiceSyncIndicator_lower(_ value: RoomListServiceSyncIndicator) -> RustBuffer {
    return FfiConverterTypeRoomListServiceSyncIndicator.lower(value)
}



extension RoomListServiceSyncIndicator: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomMessageEventMessageType {
    
    case audio
    case emote
    case file
    case image
    case location
    case notice
    case serverNotice
    case text
    case video
    case verificationRequest
    case other
}


public struct FfiConverterTypeRoomMessageEventMessageType: FfiConverterRustBuffer {
    typealias SwiftType = RoomMessageEventMessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMessageEventMessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .audio
        
        case 2: return .emote
        
        case 3: return .file
        
        case 4: return .image
        
        case 5: return .location
        
        case 6: return .notice
        
        case 7: return .serverNotice
        
        case 8: return .text
        
        case 9: return .video
        
        case 10: return .verificationRequest
        
        case 11: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomMessageEventMessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .audio:
            writeInt(&buf, Int32(1))
        
        
        case .emote:
            writeInt(&buf, Int32(2))
        
        
        case .file:
            writeInt(&buf, Int32(3))
        
        
        case .image:
            writeInt(&buf, Int32(4))
        
        
        case .location:
            writeInt(&buf, Int32(5))
        
        
        case .notice:
            writeInt(&buf, Int32(6))
        
        
        case .serverNotice:
            writeInt(&buf, Int32(7))
        
        
        case .text:
            writeInt(&buf, Int32(8))
        
        
        case .video:
            writeInt(&buf, Int32(9))
        
        
        case .verificationRequest:
            writeInt(&buf, Int32(10))
        
        
        case .other:
            writeInt(&buf, Int32(11))
        
        }
    }
}


public func FfiConverterTypeRoomMessageEventMessageType_lift(_ buf: RustBuffer) throws -> RoomMessageEventMessageType {
    return try FfiConverterTypeRoomMessageEventMessageType.lift(buf)
}

public func FfiConverterTypeRoomMessageEventMessageType_lower(_ value: RoomMessageEventMessageType) -> RustBuffer {
    return FfiConverterTypeRoomMessageEventMessageType.lower(value)
}



extension RoomMessageEventMessageType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing the push notification modes for a room.
 */

public enum RoomNotificationMode {
    
    /**
     * Receive notifications for all messages.
     */
    case allMessages
    /**
     * Receive notifications for mentions and keywords only.
     */
    case mentionsAndKeywordsOnly
    /**
     * Do not receive any notifications.
     */
    case mute
}


public struct FfiConverterTypeRoomNotificationMode: FfiConverterRustBuffer {
    typealias SwiftType = RoomNotificationMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomNotificationMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allMessages
        
        case 2: return .mentionsAndKeywordsOnly
        
        case 3: return .mute
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomNotificationMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allMessages:
            writeInt(&buf, Int32(1))
        
        
        case .mentionsAndKeywordsOnly:
            writeInt(&buf, Int32(2))
        
        
        case .mute:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeRoomNotificationMode_lift(_ buf: RustBuffer) throws -> RoomNotificationMode {
    return try FfiConverterTypeRoomNotificationMode.lift(buf)
}

public func FfiConverterTypeRoomNotificationMode_lower(_ value: RoomNotificationMode) -> RustBuffer {
    return FfiConverterTypeRoomNotificationMode.lower(value)
}



extension RoomNotificationMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomPreset {
    
    /**
     * `join_rules` is set to `invite` and `history_visibility` is set to
     * `shared`.
     */
    case privateChat
    /**
     * `join_rules` is set to `public` and `history_visibility` is set to
     * `shared`.
     */
    case publicChat
    /**
     * Same as `PrivateChat`, but all initial invitees get the same power level
     * as the creator.
     */
    case trustedPrivateChat
}


public struct FfiConverterTypeRoomPreset: FfiConverterRustBuffer {
    typealias SwiftType = RoomPreset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPreset {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .privateChat
        
        case 2: return .publicChat
        
        case 3: return .trustedPrivateChat
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomPreset, into buf: inout [UInt8]) {
        switch value {
        
        
        case .privateChat:
            writeInt(&buf, Int32(1))
        
        
        case .publicChat:
            writeInt(&buf, Int32(2))
        
        
        case .trustedPrivateChat:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeRoomPreset_lift(_ buf: RustBuffer) throws -> RoomPreset {
    return try FfiConverterTypeRoomPreset.lift(buf)
}

public func FfiConverterTypeRoomPreset_lower(_ value: RoomPreset) -> RustBuffer {
    return FfiConverterTypeRoomPreset.lower(value)
}



extension RoomPreset: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of room for a [`RoomPreviewInfo`].
 */

public enum RoomType {
    
    /**
     * It's a plain chat room.
     */
    case room
    /**
     * It's a space that can group several rooms.
     */
    case space
    /**
     * It's a custom implementation.
     */
    case custom(value: String
    )
}


public struct FfiConverterTypeRoomType: FfiConverterRustBuffer {
    typealias SwiftType = RoomType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .room
        
        case 2: return .space
        
        case 3: return .custom(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .room:
            writeInt(&buf, Int32(1))
        
        
        case .space:
            writeInt(&buf, Int32(2))
        
        
        case let .custom(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRoomType_lift(_ buf: RustBuffer) throws -> RoomType {
    return try FfiConverterTypeRoomType.lift(buf)
}

public func FfiConverterTypeRoomType_lower(_ value: RoomType) -> RustBuffer {
    return FfiConverterTypeRoomType.lower(value)
}



extension RoomType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomVisibility {
    
    /**
     * Indicates that the room will be shown in the published room list.
     */
    case `public`
    /**
     * Indicates that the room will not be shown in the published room list.
     */
    case `private`
}


public struct FfiConverterTypeRoomVisibility: FfiConverterRustBuffer {
    typealias SwiftType = RoomVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`public`
        
        case 2: return .`private`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`public`:
            writeInt(&buf, Int32(1))
        
        
        case .`private`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRoomVisibility_lift(_ buf: RustBuffer) throws -> RoomVisibility {
    return try FfiConverterTypeRoomVisibility.lift(buf)
}

public func FfiConverterTypeRoomVisibility_lower(_ value: RoomVisibility) -> RustBuffer {
    return FfiConverterTypeRoomVisibility.lower(value)
}



extension RoomVisibility: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RtcApplicationType {
    
    case call
}


public struct FfiConverterTypeRtcApplicationType: FfiConverterRustBuffer {
    typealias SwiftType = RtcApplicationType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RtcApplicationType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .call
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RtcApplicationType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .call:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeRtcApplicationType_lift(_ buf: RustBuffer) throws -> RtcApplicationType {
    return try FfiConverterTypeRtcApplicationType.lift(buf)
}

public func FfiConverterTypeRtcApplicationType_lower(_ value: RtcApplicationType) -> RustBuffer {
    return FfiConverterTypeRtcApplicationType.lower(value)
}



extension RtcApplicationType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SessionVerificationData {
    
    case emojis(emojis: [SessionVerificationEmoji], indices: Data
    )
    case decimals(values: [UInt16]
    )
}


public struct FfiConverterTypeSessionVerificationData: FfiConverterRustBuffer {
    typealias SwiftType = SessionVerificationData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .emojis(emojis: try FfiConverterSequenceTypeSessionVerificationEmoji.read(from: &buf), indices: try FfiConverterData.read(from: &buf)
        )
        
        case 2: return .decimals(values: try FfiConverterSequenceUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionVerificationData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .emojis(emojis,indices):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeSessionVerificationEmoji.write(emojis, into: &buf)
            FfiConverterData.write(indices, into: &buf)
            
        
        case let .decimals(values):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt16.write(values, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSessionVerificationData_lift(_ buf: RustBuffer) throws -> SessionVerificationData {
    return try FfiConverterTypeSessionVerificationData.lift(buf)
}

public func FfiConverterTypeSessionVerificationData_lower(_ value: SessionVerificationData) -> RustBuffer {
    return FfiConverterTypeSessionVerificationData.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Recommended decorations for decrypted messages, representing the message's
 * authenticity properties.
 */

public enum ShieldState {
    
    /**
     * A red shield with a tooltip containing the associated message should be
     * presented.
     */
    case red(code: ShieldStateCode, message: String
    )
    /**
     * A grey shield with a tooltip containing the associated message should be
     * presented.
     */
    case grey(code: ShieldStateCode, message: String
    )
    /**
     * No shield should be presented.
     */
    case none
}


public struct FfiConverterTypeShieldState: FfiConverterRustBuffer {
    typealias SwiftType = ShieldState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .red(code: try FfiConverterTypeShieldStateCode.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .grey(code: try FfiConverterTypeShieldStateCode.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShieldState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .red(code,message):
            writeInt(&buf, Int32(1))
            FfiConverterTypeShieldStateCode.write(code, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .grey(code,message):
            writeInt(&buf, Int32(2))
            FfiConverterTypeShieldStateCode.write(code, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeShieldState_lift(_ buf: RustBuffer) throws -> ShieldState {
    return try FfiConverterTypeShieldState.lift(buf)
}

public func FfiConverterTypeShieldState_lower(_ value: ShieldState) -> RustBuffer {
    return FfiConverterTypeShieldState.lower(value)
}



extension ShieldState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SlidingSyncVersion {
    
    case none
    case proxy(url: String
    )
    case native
}


public struct FfiConverterTypeSlidingSyncVersion: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .proxy(url: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .native
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .proxy(url):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(url, into: &buf)
            
        
        case .native:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeSlidingSyncVersion_lift(_ buf: RustBuffer) throws -> SlidingSyncVersion {
    return try FfiConverterTypeSlidingSyncVersion.lift(buf)
}

public func FfiConverterTypeSlidingSyncVersion_lower(_ value: SlidingSyncVersion) -> RustBuffer {
    return FfiConverterTypeSlidingSyncVersion.lower(value)
}



extension SlidingSyncVersion: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SlidingSyncVersionBuilder {
    
    case none
    case proxy(url: String
    )
    case native
    case discoverProxy
    case discoverNative
}


public struct FfiConverterTypeSlidingSyncVersionBuilder: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncVersionBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncVersionBuilder {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .proxy(url: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .native
        
        case 4: return .discoverProxy
        
        case 5: return .discoverNative
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncVersionBuilder, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .proxy(url):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(url, into: &buf)
            
        
        case .native:
            writeInt(&buf, Int32(3))
        
        
        case .discoverProxy:
            writeInt(&buf, Int32(4))
        
        
        case .discoverNative:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeSlidingSyncVersionBuilder_lift(_ buf: RustBuffer) throws -> SlidingSyncVersionBuilder {
    return try FfiConverterTypeSlidingSyncVersionBuilder.lift(buf)
}

public func FfiConverterTypeSlidingSyncVersionBuilder_lower(_ value: SlidingSyncVersionBuilder) -> RustBuffer {
    return FfiConverterTypeSlidingSyncVersionBuilder.lower(value)
}



extension SlidingSyncVersionBuilder: Equatable, Hashable {}




public enum SsoError {

    
    
    case CallbackUrlInvalid(message: String)
    
    case LoginWithTokenFailed(message: String)
    
    case Generic(message: String)
    
}


public struct FfiConverterTypeSsoError: FfiConverterRustBuffer {
    typealias SwiftType = SsoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SsoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CallbackUrlInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .LoginWithTokenFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SsoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .CallbackUrlInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .LoginWithTokenFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


extension SsoError: Equatable, Hashable {}

extension SsoError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum StateEventContent {
    
    case policyRuleRoom
    case policyRuleServer
    case policyRuleUser
    case roomAliases
    case roomAvatar
    case roomCanonicalAlias
    case roomCreate
    case roomEncryption
    case roomGuestAccess
    case roomHistoryVisibility
    case roomJoinRules
    case roomMemberContent(userId: String, membershipState: MembershipState
    )
    case roomName
    case roomPinnedEvents
    case roomPowerLevels
    case roomServerAcl
    case roomThirdPartyInvite
    case roomTombstone
    case roomTopic
    case spaceChild
    case spaceParent
}


public struct FfiConverterTypeStateEventContent: FfiConverterRustBuffer {
    typealias SwiftType = StateEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEventContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .policyRuleRoom
        
        case 2: return .policyRuleServer
        
        case 3: return .policyRuleUser
        
        case 4: return .roomAliases
        
        case 5: return .roomAvatar
        
        case 6: return .roomCanonicalAlias
        
        case 7: return .roomCreate
        
        case 8: return .roomEncryption
        
        case 9: return .roomGuestAccess
        
        case 10: return .roomHistoryVisibility
        
        case 11: return .roomJoinRules
        
        case 12: return .roomMemberContent(userId: try FfiConverterString.read(from: &buf), membershipState: try FfiConverterTypeMembershipState.read(from: &buf)
        )
        
        case 13: return .roomName
        
        case 14: return .roomPinnedEvents
        
        case 15: return .roomPowerLevels
        
        case 16: return .roomServerAcl
        
        case 17: return .roomThirdPartyInvite
        
        case 18: return .roomTombstone
        
        case 19: return .roomTopic
        
        case 20: return .spaceChild
        
        case 21: return .spaceParent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StateEventContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .policyRuleRoom:
            writeInt(&buf, Int32(1))
        
        
        case .policyRuleServer:
            writeInt(&buf, Int32(2))
        
        
        case .policyRuleUser:
            writeInt(&buf, Int32(3))
        
        
        case .roomAliases:
            writeInt(&buf, Int32(4))
        
        
        case .roomAvatar:
            writeInt(&buf, Int32(5))
        
        
        case .roomCanonicalAlias:
            writeInt(&buf, Int32(6))
        
        
        case .roomCreate:
            writeInt(&buf, Int32(7))
        
        
        case .roomEncryption:
            writeInt(&buf, Int32(8))
        
        
        case .roomGuestAccess:
            writeInt(&buf, Int32(9))
        
        
        case .roomHistoryVisibility:
            writeInt(&buf, Int32(10))
        
        
        case .roomJoinRules:
            writeInt(&buf, Int32(11))
        
        
        case let .roomMemberContent(userId,membershipState):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterTypeMembershipState.write(membershipState, into: &buf)
            
        
        case .roomName:
            writeInt(&buf, Int32(13))
        
        
        case .roomPinnedEvents:
            writeInt(&buf, Int32(14))
        
        
        case .roomPowerLevels:
            writeInt(&buf, Int32(15))
        
        
        case .roomServerAcl:
            writeInt(&buf, Int32(16))
        
        
        case .roomThirdPartyInvite:
            writeInt(&buf, Int32(17))
        
        
        case .roomTombstone:
            writeInt(&buf, Int32(18))
        
        
        case .roomTopic:
            writeInt(&buf, Int32(19))
        
        
        case .spaceChild:
            writeInt(&buf, Int32(20))
        
        
        case .spaceParent:
            writeInt(&buf, Int32(21))
        
        }
    }
}


public func FfiConverterTypeStateEventContent_lift(_ buf: RustBuffer) throws -> StateEventContent {
    return try FfiConverterTypeStateEventContent.lift(buf)
}

public func FfiConverterTypeStateEventContent_lower(_ value: StateEventContent) -> RustBuffer {
    return FfiConverterTypeStateEventContent.lower(value)
}



extension StateEventContent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum StateEventType {
    
    case callMember
    case policyRuleRoom
    case policyRuleServer
    case policyRuleUser
    case roomAliases
    case roomAvatar
    case roomCanonicalAlias
    case roomCreate
    case roomEncryption
    case roomGuestAccess
    case roomHistoryVisibility
    case roomJoinRules
    case roomMemberEvent
    case roomName
    case roomPinnedEvents
    case roomPowerLevels
    case roomServerAcl
    case roomThirdPartyInvite
    case roomTombstone
    case roomTopic
    case spaceChild
    case spaceParent
}


public struct FfiConverterTypeStateEventType: FfiConverterRustBuffer {
    typealias SwiftType = StateEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .callMember
        
        case 2: return .policyRuleRoom
        
        case 3: return .policyRuleServer
        
        case 4: return .policyRuleUser
        
        case 5: return .roomAliases
        
        case 6: return .roomAvatar
        
        case 7: return .roomCanonicalAlias
        
        case 8: return .roomCreate
        
        case 9: return .roomEncryption
        
        case 10: return .roomGuestAccess
        
        case 11: return .roomHistoryVisibility
        
        case 12: return .roomJoinRules
        
        case 13: return .roomMemberEvent
        
        case 14: return .roomName
        
        case 15: return .roomPinnedEvents
        
        case 16: return .roomPowerLevels
        
        case 17: return .roomServerAcl
        
        case 18: return .roomThirdPartyInvite
        
        case 19: return .roomTombstone
        
        case 20: return .roomTopic
        
        case 21: return .spaceChild
        
        case 22: return .spaceParent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StateEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .callMember:
            writeInt(&buf, Int32(1))
        
        
        case .policyRuleRoom:
            writeInt(&buf, Int32(2))
        
        
        case .policyRuleServer:
            writeInt(&buf, Int32(3))
        
        
        case .policyRuleUser:
            writeInt(&buf, Int32(4))
        
        
        case .roomAliases:
            writeInt(&buf, Int32(5))
        
        
        case .roomAvatar:
            writeInt(&buf, Int32(6))
        
        
        case .roomCanonicalAlias:
            writeInt(&buf, Int32(7))
        
        
        case .roomCreate:
            writeInt(&buf, Int32(8))
        
        
        case .roomEncryption:
            writeInt(&buf, Int32(9))
        
        
        case .roomGuestAccess:
            writeInt(&buf, Int32(10))
        
        
        case .roomHistoryVisibility:
            writeInt(&buf, Int32(11))
        
        
        case .roomJoinRules:
            writeInt(&buf, Int32(12))
        
        
        case .roomMemberEvent:
            writeInt(&buf, Int32(13))
        
        
        case .roomName:
            writeInt(&buf, Int32(14))
        
        
        case .roomPinnedEvents:
            writeInt(&buf, Int32(15))
        
        
        case .roomPowerLevels:
            writeInt(&buf, Int32(16))
        
        
        case .roomServerAcl:
            writeInt(&buf, Int32(17))
        
        
        case .roomThirdPartyInvite:
            writeInt(&buf, Int32(18))
        
        
        case .roomTombstone:
            writeInt(&buf, Int32(19))
        
        
        case .roomTopic:
            writeInt(&buf, Int32(20))
        
        
        case .spaceChild:
            writeInt(&buf, Int32(21))
        
        
        case .spaceParent:
            writeInt(&buf, Int32(22))
        
        }
    }
}


public func FfiConverterTypeStateEventType_lift(_ buf: RustBuffer) throws -> StateEventType {
    return try FfiConverterTypeStateEventType.lift(buf)
}

public func FfiConverterTypeStateEventType_lower(_ value: StateEventType) -> RustBuffer {
    return FfiConverterTypeStateEventType.lower(value)
}



extension StateEventType: Equatable, Hashable {}




public enum SteadyStateError {

    
    
    case BackupDisabled(message: String)
    
    case Connection(message: String)
    
    case Lagged(message: String)
    
}


public struct FfiConverterTypeSteadyStateError: FfiConverterRustBuffer {
    typealias SwiftType = SteadyStateError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SteadyStateError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BackupDisabled(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Connection(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Lagged(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SteadyStateError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .BackupDisabled(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Connection(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Lagged(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


extension SteadyStateError: Equatable, Hashable {}

extension SteadyStateError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SyncServiceState {
    
    case idle
    case running
    case terminated
    case error
}


public struct FfiConverterTypeSyncServiceState: FfiConverterRustBuffer {
    typealias SwiftType = SyncServiceState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncServiceState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .idle
        
        case 2: return .running
        
        case 3: return .terminated
        
        case 4: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SyncServiceState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .idle:
            writeInt(&buf, Int32(1))
        
        
        case .running:
            writeInt(&buf, Int32(2))
        
        
        case .terminated:
            writeInt(&buf, Int32(3))
        
        
        case .error:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeSyncServiceState_lift(_ buf: RustBuffer) throws -> SyncServiceState {
    return try FfiConverterTypeSyncServiceState.lift(buf)
}

public func FfiConverterTypeSyncServiceState_lower(_ value: SyncServiceState) -> RustBuffer {
    return FfiConverterTypeSyncServiceState.lower(value)
}



extension SyncServiceState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TimelineChange {
    
    case append
    case clear
    case insert
    case set
    case remove
    case pushBack
    case pushFront
    case popBack
    case popFront
    case truncate
    case reset
}


public struct FfiConverterTypeTimelineChange: FfiConverterRustBuffer {
    typealias SwiftType = TimelineChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .append
        
        case 2: return .clear
        
        case 3: return .insert
        
        case 4: return .set
        
        case 5: return .remove
        
        case 6: return .pushBack
        
        case 7: return .pushFront
        
        case 8: return .popBack
        
        case 9: return .popFront
        
        case 10: return .truncate
        
        case 11: return .reset
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineChange, into buf: inout [UInt8]) {
        switch value {
        
        
        case .append:
            writeInt(&buf, Int32(1))
        
        
        case .clear:
            writeInt(&buf, Int32(2))
        
        
        case .insert:
            writeInt(&buf, Int32(3))
        
        
        case .set:
            writeInt(&buf, Int32(4))
        
        
        case .remove:
            writeInt(&buf, Int32(5))
        
        
        case .pushBack:
            writeInt(&buf, Int32(6))
        
        
        case .pushFront:
            writeInt(&buf, Int32(7))
        
        
        case .popBack:
            writeInt(&buf, Int32(8))
        
        
        case .popFront:
            writeInt(&buf, Int32(9))
        
        
        case .truncate:
            writeInt(&buf, Int32(10))
        
        
        case .reset:
            writeInt(&buf, Int32(11))
        
        }
    }
}


public func FfiConverterTypeTimelineChange_lift(_ buf: RustBuffer) throws -> TimelineChange {
    return try FfiConverterTypeTimelineChange.lift(buf)
}

public func FfiConverterTypeTimelineChange_lower(_ value: TimelineChange) -> RustBuffer {
    return FfiConverterTypeTimelineChange.lower(value)
}



extension TimelineChange: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TimelineEventType {
    
    case messageLike(content: MessageLikeEventContent
    )
    case state(content: StateEventContent
    )
}


public struct FfiConverterTypeTimelineEventType: FfiConverterRustBuffer {
    typealias SwiftType = TimelineEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messageLike(content: try FfiConverterTypeMessageLikeEventContent.read(from: &buf)
        )
        
        case 2: return .state(content: try FfiConverterTypeStateEventContent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messageLike(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageLikeEventContent.write(content, into: &buf)
            
        
        case let .state(content):
            writeInt(&buf, Int32(2))
            FfiConverterTypeStateEventContent.write(content, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTimelineEventType_lift(_ buf: RustBuffer) throws -> TimelineEventType {
    return try FfiConverterTypeTimelineEventType.lift(buf)
}

public func FfiConverterTypeTimelineEventType_lower(_ value: TimelineEventType) -> RustBuffer {
    return FfiConverterTypeTimelineEventType.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TimelineItemContent {
    
    case message(content: MessageContent
    )
    case redactedMessage
    case sticker(body: String, info: ImageInfo, source: MediaSource
    )
    case poll(question: String, kind: PollKind, maxSelections: UInt64, answers: [PollAnswer], votes: [String: [String]], endTime: UInt64?, hasBeenEdited: Bool
    )
    case callInvite
    case callNotify
    case unableToDecrypt(msg: EncryptedMessage
    )
    case roomMembership(userId: String, userDisplayName: String?, change: MembershipChange?, reason: String?
    )
    case profileChange(displayName: String?, prevDisplayName: String?, avatarUrl: String?, prevAvatarUrl: String?
    )
    case state(stateKey: String, content: OtherState
    )
    case failedToParseMessageLike(eventType: String, error: String
    )
    case failedToParseState(eventType: String, stateKey: String, error: String
    )
}


public struct FfiConverterTypeTimelineItemContent: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItemContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .message(content: try FfiConverterTypeMessageContent.read(from: &buf)
        )
        
        case 2: return .redactedMessage
        
        case 3: return .sticker(body: try FfiConverterString.read(from: &buf), info: try FfiConverterTypeImageInfo.read(from: &buf), source: try FfiConverterTypeMediaSource.read(from: &buf)
        )
        
        case 4: return .poll(question: try FfiConverterString.read(from: &buf), kind: try FfiConverterTypePollKind.read(from: &buf), maxSelections: try FfiConverterUInt64.read(from: &buf), answers: try FfiConverterSequenceTypePollAnswer.read(from: &buf), votes: try FfiConverterDictionaryStringSequenceString.read(from: &buf), endTime: try FfiConverterOptionUInt64.read(from: &buf), hasBeenEdited: try FfiConverterBool.read(from: &buf)
        )
        
        case 5: return .callInvite
        
        case 6: return .callNotify
        
        case 7: return .unableToDecrypt(msg: try FfiConverterTypeEncryptedMessage.read(from: &buf)
        )
        
        case 8: return .roomMembership(userId: try FfiConverterString.read(from: &buf), userDisplayName: try FfiConverterOptionString.read(from: &buf), change: try FfiConverterOptionTypeMembershipChange.read(from: &buf), reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 9: return .profileChange(displayName: try FfiConverterOptionString.read(from: &buf), prevDisplayName: try FfiConverterOptionString.read(from: &buf), avatarUrl: try FfiConverterOptionString.read(from: &buf), prevAvatarUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 10: return .state(stateKey: try FfiConverterString.read(from: &buf), content: try FfiConverterTypeOtherState.read(from: &buf)
        )
        
        case 11: return .failedToParseMessageLike(eventType: try FfiConverterString.read(from: &buf), error: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .failedToParseState(eventType: try FfiConverterString.read(from: &buf), stateKey: try FfiConverterString.read(from: &buf), error: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineItemContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .message(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageContent.write(content, into: &buf)
            
        
        case .redactedMessage:
            writeInt(&buf, Int32(2))
        
        
        case let .sticker(body,info,source):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(body, into: &buf)
            FfiConverterTypeImageInfo.write(info, into: &buf)
            FfiConverterTypeMediaSource.write(source, into: &buf)
            
        
        case let .poll(question,kind,maxSelections,answers,votes,endTime,hasBeenEdited):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(question, into: &buf)
            FfiConverterTypePollKind.write(kind, into: &buf)
            FfiConverterUInt64.write(maxSelections, into: &buf)
            FfiConverterSequenceTypePollAnswer.write(answers, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(votes, into: &buf)
            FfiConverterOptionUInt64.write(endTime, into: &buf)
            FfiConverterBool.write(hasBeenEdited, into: &buf)
            
        
        case .callInvite:
            writeInt(&buf, Int32(5))
        
        
        case .callNotify:
            writeInt(&buf, Int32(6))
        
        
        case let .unableToDecrypt(msg):
            writeInt(&buf, Int32(7))
            FfiConverterTypeEncryptedMessage.write(msg, into: &buf)
            
        
        case let .roomMembership(userId,userDisplayName,change,reason):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterOptionString.write(userDisplayName, into: &buf)
            FfiConverterOptionTypeMembershipChange.write(change, into: &buf)
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case let .profileChange(displayName,prevDisplayName,avatarUrl,prevAvatarUrl):
            writeInt(&buf, Int32(9))
            FfiConverterOptionString.write(displayName, into: &buf)
            FfiConverterOptionString.write(prevDisplayName, into: &buf)
            FfiConverterOptionString.write(avatarUrl, into: &buf)
            FfiConverterOptionString.write(prevAvatarUrl, into: &buf)
            
        
        case let .state(stateKey,content):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(stateKey, into: &buf)
            FfiConverterTypeOtherState.write(content, into: &buf)
            
        
        case let .failedToParseMessageLike(eventType,error):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        
        case let .failedToParseState(eventType,stateKey,error):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(stateKey, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTimelineItemContent_lift(_ buf: RustBuffer) throws -> TimelineItemContent {
    return try FfiConverterTypeTimelineItemContent.lift(buf)
}

public func FfiConverterTypeTimelineItemContent_lower(_ value: TimelineItemContent) -> RustBuffer {
    return FfiConverterTypeTimelineItemContent.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VerificationState {
    
    case unknown
    case verified
    case unverified
}


public struct FfiConverterTypeVerificationState: FfiConverterRustBuffer {
    typealias SwiftType = VerificationState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .verified
        
        case 3: return .unverified
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerificationState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .verified:
            writeInt(&buf, Int32(2))
        
        
        case .unverified:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeVerificationState_lift(_ buf: RustBuffer) throws -> VerificationState {
    return try FfiConverterTypeVerificationState.lift(buf)
}

public func FfiConverterTypeVerificationState_lower(_ value: VerificationState) -> RustBuffer {
    return FfiConverterTypeVerificationState.lower(value)
}



extension VerificationState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */

public enum VirtualTimelineItem {
    
    /**
     * A divider between messages of different day or month depending on
     * timeline settings.
     */
    case dateDivider(
        /**
         * A timestamp in milliseconds since Unix Epoch on that day in local
         * time.
         */ts: UInt64
    )
    /**
     * The user's own read marker.
     */
    case readMarker
}


public struct FfiConverterTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VirtualTimelineItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .dateDivider(ts: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .readMarker
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VirtualTimelineItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .dateDivider(ts):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(ts, into: &buf)
            
        
        case .readMarker:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeVirtualTimelineItem_lift(_ buf: RustBuffer) throws -> VirtualTimelineItem {
    return try FfiConverterTypeVirtualTimelineItem.lift(buf)
}

public func FfiConverterTypeVirtualTimelineItem_lower(_ value: VirtualTimelineItem) -> RustBuffer {
    return FfiConverterTypeVirtualTimelineItem.lower(value)
}



extension VirtualTimelineItem: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Different kinds of filters that could be applied to the timeline events.
 */

public enum WidgetEventFilter {
    
    /**
     * Matches message-like events with the given `type`.
     */
    case messageLikeWithType(eventType: String
    )
    /**
     * Matches `m.room.message` events with the given `msgtype`.
     */
    case roomMessageWithMsgtype(msgtype: String
    )
    /**
     * Matches state events with the given `type`, regardless of `state_key`.
     */
    case stateWithType(eventType: String
    )
    /**
     * Matches state events with the given `type` and `state_key`.
     */
    case stateWithTypeAndStateKey(eventType: String, stateKey: String
    )
}


public struct FfiConverterTypeWidgetEventFilter: FfiConverterRustBuffer {
    typealias SwiftType = WidgetEventFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetEventFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messageLikeWithType(eventType: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .roomMessageWithMsgtype(msgtype: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .stateWithType(eventType: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .stateWithTypeAndStateKey(eventType: try FfiConverterString.read(from: &buf), stateKey: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WidgetEventFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messageLikeWithType(eventType):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(eventType, into: &buf)
            
        
        case let .roomMessageWithMsgtype(msgtype):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(msgtype, into: &buf)
            
        
        case let .stateWithType(eventType):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(eventType, into: &buf)
            
        
        case let .stateWithTypeAndStateKey(eventType,stateKey):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(stateKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeWidgetEventFilter_lift(_ buf: RustBuffer) throws -> WidgetEventFilter {
    return try FfiConverterTypeWidgetEventFilter.lift(buf)
}

public func FfiConverterTypeWidgetEventFilter_lower(_ value: WidgetEventFilter) -> RustBuffer {
    return FfiConverterTypeWidgetEventFilter.lower(value)
}



extension WidgetEventFilter: Equatable, Hashable {}






public protocol BackupStateListener : AnyObject {
    
    func onUpdate(status: BackupState) 
    
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBackupStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceBackupStateListener = UniffiVTableCallbackInterfaceBackupStateListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceBackupStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeBackupState.lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceBackupStateListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BackupStateListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitBackupStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(&UniffiCallbackInterfaceBackupStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceBackupStateListener {
    fileprivate static var handleMap = UniffiHandleMap<BackupStateListener>()
}

extension FfiConverterCallbackInterfaceBackupStateListener : FfiConverter {
    typealias SwiftType = BackupStateListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol BackupSteadyStateListener : AnyObject {
    
    func onUpdate(status: BackupUploadState) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBackupSteadyStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceBackupSteadyStateListener = UniffiVTableCallbackInterfaceBackupSteadyStateListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceBackupSteadyStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeBackupUploadState.lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceBackupSteadyStateListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BackupSteadyStateListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitBackupSteadyStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(&UniffiCallbackInterfaceBackupSteadyStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceBackupSteadyStateListener {
    fileprivate static var handleMap = UniffiHandleMap<BackupSteadyStateListener>()
}

extension FfiConverterCallbackInterfaceBackupSteadyStateListener : FfiConverter {
    typealias SwiftType = BackupSteadyStateListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol ClientDelegate : AnyObject {
    
    func didReceiveAuthError(isSoftLogout: Bool) 
    
    func didRefreshTokens() 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceClientDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceClientDelegate = UniffiVTableCallbackInterfaceClientDelegate(
        didReceiveAuthError: { (
            uniffiHandle: UInt64,
            isSoftLogout: Int8,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceClientDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didReceiveAuthError(
                     isSoftLogout: try FfiConverterBool.lift(isSoftLogout)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didRefreshTokens: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceClientDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didRefreshTokens(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceClientDelegate.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ClientDelegate: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitClientDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(&UniffiCallbackInterfaceClientDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceClientDelegate {
    fileprivate static var handleMap = UniffiHandleMap<ClientDelegate>()
}

extension FfiConverterCallbackInterfaceClientDelegate : FfiConverter {
    typealias SwiftType = ClientDelegate
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol ClientSessionDelegate : AnyObject {
    
    func retrieveSessionFromKeychain(userId: String) throws  -> Session
    
    func saveSessionInKeychain(session: Session) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceClientSessionDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceClientSessionDelegate = UniffiVTableCallbackInterfaceClientSessionDelegate(
        retrieveSessionFromKeychain: { (
            uniffiHandle: UInt64,
            userId: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Session in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceClientSessionDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.retrieveSessionFromKeychain(
                     userId: try FfiConverterString.lift(userId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeSession.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeClientError.lower
            )
        },
        saveSessionInKeychain: { (
            uniffiHandle: UInt64,
            session: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceClientSessionDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.saveSessionInKeychain(
                     session: try FfiConverterTypeSession.lift(session)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceClientSessionDelegate.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ClientSessionDelegate: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitClientSessionDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(&UniffiCallbackInterfaceClientSessionDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceClientSessionDelegate {
    fileprivate static var handleMap = UniffiHandleMap<ClientSessionDelegate>()
}

extension FfiConverterCallbackInterfaceClientSessionDelegate : FfiConverter {
    typealias SwiftType = ClientSessionDelegate
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol EnableRecoveryProgressListener : AnyObject {
    
    func onUpdate(status: EnableRecoveryProgress) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEnableRecoveryProgressListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEnableRecoveryProgressListener = UniffiVTableCallbackInterfaceEnableRecoveryProgressListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEnableRecoveryProgressListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeEnableRecoveryProgress.lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceEnableRecoveryProgressListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EnableRecoveryProgressListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEnableRecoveryProgressListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(&UniffiCallbackInterfaceEnableRecoveryProgressListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceEnableRecoveryProgressListener {
    fileprivate static var handleMap = UniffiHandleMap<EnableRecoveryProgressListener>()
}

extension FfiConverterCallbackInterfaceEnableRecoveryProgressListener : FfiConverter {
    typealias SwiftType = EnableRecoveryProgressListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol IdentityStatusChangeListener : AnyObject {
    
    func call(identityStatusChange: [IdentityStatusChange]) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceIdentityStatusChangeListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceIdentityStatusChangeListener = UniffiVTableCallbackInterfaceIdentityStatusChangeListener(
        call: { (
            uniffiHandle: UInt64,
            identityStatusChange: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceIdentityStatusChangeListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     identityStatusChange: try FfiConverterSequenceTypeIdentityStatusChange.lift(identityStatusChange)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceIdentityStatusChangeListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface IdentityStatusChangeListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitIdentityStatusChangeListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(&UniffiCallbackInterfaceIdentityStatusChangeListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceIdentityStatusChangeListener {
    fileprivate static var handleMap = UniffiHandleMap<IdentityStatusChangeListener>()
}

extension FfiConverterCallbackInterfaceIdentityStatusChangeListener : FfiConverter {
    typealias SwiftType = IdentityStatusChangeListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol IgnoredUsersListener : AnyObject {
    
    func call(ignoredUserIds: [String]) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceIgnoredUsersListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceIgnoredUsersListener = UniffiVTableCallbackInterfaceIgnoredUsersListener(
        call: { (
            uniffiHandle: UInt64,
            ignoredUserIds: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceIgnoredUsersListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     ignoredUserIds: try FfiConverterSequenceString.lift(ignoredUserIds)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceIgnoredUsersListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface IgnoredUsersListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitIgnoredUsersListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(&UniffiCallbackInterfaceIgnoredUsersListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceIgnoredUsersListener {
    fileprivate static var handleMap = UniffiHandleMap<IgnoredUsersListener>()
}

extension FfiConverterCallbackInterfaceIgnoredUsersListener : FfiConverter {
    typealias SwiftType = IgnoredUsersListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




/**
 * A listener for receiving new requests to a join a room.
 */
public protocol KnockRequestsListener : AnyObject {
    
    func call(joinRequests: [KnockRequest]) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceKnockRequestsListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceKnockRequestsListener = UniffiVTableCallbackInterfaceKnockRequestsListener(
        call: { (
            uniffiHandle: UInt64,
            joinRequests: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceKnockRequestsListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     joinRequests: try FfiConverterSequenceTypeKnockRequest.lift(joinRequests)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceKnockRequestsListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface KnockRequestsListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitKnockRequestsListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(&UniffiCallbackInterfaceKnockRequestsListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceKnockRequestsListener {
    fileprivate static var handleMap = UniffiHandleMap<KnockRequestsListener>()
}

extension FfiConverterCallbackInterfaceKnockRequestsListener : FfiConverter {
    typealias SwiftType = KnockRequestsListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




/**
 * Delegate to notify of changes in push rules
 */
public protocol NotificationSettingsDelegate : AnyObject {
    
    func settingsDidChange() 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceNotificationSettingsDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNotificationSettingsDelegate = UniffiVTableCallbackInterfaceNotificationSettingsDelegate(
        settingsDidChange: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceNotificationSettingsDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.settingsDidChange(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceNotificationSettingsDelegate.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NotificationSettingsDelegate: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNotificationSettingsDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(&UniffiCallbackInterfaceNotificationSettingsDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceNotificationSettingsDelegate {
    fileprivate static var handleMap = UniffiHandleMap<NotificationSettingsDelegate>()
}

extension FfiConverterCallbackInterfaceNotificationSettingsDelegate : FfiConverter {
    typealias SwiftType = NotificationSettingsDelegate
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol PaginationStatusListener : AnyObject {
    
    func onUpdate(status: LiveBackPaginationStatus) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePaginationStatusListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfacePaginationStatusListener = UniffiVTableCallbackInterfacePaginationStatusListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePaginationStatusListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeLiveBackPaginationStatus_lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfacePaginationStatusListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PaginationStatusListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitPaginationStatusListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(&UniffiCallbackInterfacePaginationStatusListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfacePaginationStatusListener {
    fileprivate static var handleMap = UniffiHandleMap<PaginationStatusListener>()
}

extension FfiConverterCallbackInterfacePaginationStatusListener : FfiConverter {
    typealias SwiftType = PaginationStatusListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol ProgressWatcher : AnyObject {
    
    func transmissionProgress(progress: TransmissionProgress) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceProgressWatcher {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceProgressWatcher = UniffiVTableCallbackInterfaceProgressWatcher(
        transmissionProgress: { (
            uniffiHandle: UInt64,
            progress: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceProgressWatcher.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.transmissionProgress(
                     progress: try FfiConverterTypeTransmissionProgress.lift(progress)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceProgressWatcher.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ProgressWatcher: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitProgressWatcher() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(&UniffiCallbackInterfaceProgressWatcher.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceProgressWatcher {
    fileprivate static var handleMap = UniffiHandleMap<ProgressWatcher>()
}

extension FfiConverterCallbackInterfaceProgressWatcher : FfiConverter {
    typealias SwiftType = ProgressWatcher
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol QrLoginProgressListener : AnyObject {
    
    func onUpdate(state: QrLoginProgress) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceQrLoginProgressListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceQrLoginProgressListener = UniffiVTableCallbackInterfaceQrLoginProgressListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceQrLoginProgressListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeQrLoginProgress.lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceQrLoginProgressListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface QrLoginProgressListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitQrLoginProgressListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(&UniffiCallbackInterfaceQrLoginProgressListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceQrLoginProgressListener {
    fileprivate static var handleMap = UniffiHandleMap<QrLoginProgressListener>()
}

extension FfiConverterCallbackInterfaceQrLoginProgressListener : FfiConverter {
    typealias SwiftType = QrLoginProgressListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol RecoveryStateListener : AnyObject {
    
    func onUpdate(status: RecoveryState) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRecoveryStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRecoveryStateListener = UniffiVTableCallbackInterfaceRecoveryStateListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRecoveryStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeRecoveryState.lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceRecoveryStateListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RecoveryStateListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRecoveryStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(&UniffiCallbackInterfaceRecoveryStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRecoveryStateListener {
    fileprivate static var handleMap = UniffiHandleMap<RecoveryStateListener>()
}

extension FfiConverterCallbackInterfaceRecoveryStateListener : FfiConverter {
    typealias SwiftType = RecoveryStateListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol RoomDirectorySearchEntriesListener : AnyObject {
    
    func onUpdate(roomEntriesUpdate: [RoomDirectorySearchEntryUpdate]) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomDirectorySearchEntriesListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener = UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            roomEntriesUpdate: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     roomEntriesUpdate: try FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate.lift(roomEntriesUpdate)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RoomDirectorySearchEntriesListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRoomDirectorySearchEntriesListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(&UniffiCallbackInterfaceRoomDirectorySearchEntriesListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener {
    fileprivate static var handleMap = UniffiHandleMap<RoomDirectorySearchEntriesListener>()
}

extension FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener : FfiConverter {
    typealias SwiftType = RoomDirectorySearchEntriesListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol RoomInfoListener : AnyObject {
    
    func call(roomInfo: RoomInfo) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomInfoListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRoomInfoListener = UniffiVTableCallbackInterfaceRoomInfoListener(
        call: { (
            uniffiHandle: UInt64,
            roomInfo: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomInfoListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     roomInfo: try FfiConverterTypeRoomInfo.lift(roomInfo)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceRoomInfoListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RoomInfoListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRoomInfoListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(&UniffiCallbackInterfaceRoomInfoListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomInfoListener {
    fileprivate static var handleMap = UniffiHandleMap<RoomInfoListener>()
}

extension FfiConverterCallbackInterfaceRoomInfoListener : FfiConverter {
    typealias SwiftType = RoomInfoListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol RoomListEntriesListener : AnyObject {
    
    func onUpdate(roomEntriesUpdate: [RoomListEntriesUpdate]) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomListEntriesListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRoomListEntriesListener = UniffiVTableCallbackInterfaceRoomListEntriesListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            roomEntriesUpdate: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomListEntriesListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     roomEntriesUpdate: try FfiConverterSequenceTypeRoomListEntriesUpdate.lift(roomEntriesUpdate)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceRoomListEntriesListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RoomListEntriesListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRoomListEntriesListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(&UniffiCallbackInterfaceRoomListEntriesListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomListEntriesListener {
    fileprivate static var handleMap = UniffiHandleMap<RoomListEntriesListener>()
}

extension FfiConverterCallbackInterfaceRoomListEntriesListener : FfiConverter {
    typealias SwiftType = RoomListEntriesListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol RoomListLoadingStateListener : AnyObject {
    
    func onUpdate(state: RoomListLoadingState) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomListLoadingStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRoomListLoadingStateListener = UniffiVTableCallbackInterfaceRoomListLoadingStateListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomListLoadingStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeRoomListLoadingState.lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceRoomListLoadingStateListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RoomListLoadingStateListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRoomListLoadingStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(&UniffiCallbackInterfaceRoomListLoadingStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomListLoadingStateListener {
    fileprivate static var handleMap = UniffiHandleMap<RoomListLoadingStateListener>()
}

extension FfiConverterCallbackInterfaceRoomListLoadingStateListener : FfiConverter {
    typealias SwiftType = RoomListLoadingStateListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol RoomListServiceStateListener : AnyObject {
    
    func onUpdate(state: RoomListServiceState) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomListServiceStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRoomListServiceStateListener = UniffiVTableCallbackInterfaceRoomListServiceStateListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomListServiceStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeRoomListServiceState.lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceRoomListServiceStateListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RoomListServiceStateListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRoomListServiceStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(&UniffiCallbackInterfaceRoomListServiceStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomListServiceStateListener {
    fileprivate static var handleMap = UniffiHandleMap<RoomListServiceStateListener>()
}

extension FfiConverterCallbackInterfaceRoomListServiceStateListener : FfiConverter {
    typealias SwiftType = RoomListServiceStateListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol RoomListServiceSyncIndicatorListener : AnyObject {
    
    func onUpdate(syncIndicator: RoomListServiceSyncIndicator) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomListServiceSyncIndicatorListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener = UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            syncIndicator: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     syncIndicator: try FfiConverterTypeRoomListServiceSyncIndicator.lift(syncIndicator)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RoomListServiceSyncIndicatorListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRoomListServiceSyncIndicatorListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(&UniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener {
    fileprivate static var handleMap = UniffiHandleMap<RoomListServiceSyncIndicatorListener>()
}

extension FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener : FfiConverter {
    typealias SwiftType = RoomListServiceSyncIndicatorListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




/**
 * A listener to the global (client-wide) error reporter of the send queue.
 */
public protocol SendQueueRoomErrorListener : AnyObject {
    
    /**
     * Called every time the send queue has ran into an error for a given room,
     * which will disable the send queue for that particular room.
     */
    func onError(roomId: String, error: ClientError) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSendQueueRoomErrorListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSendQueueRoomErrorListener = UniffiVTableCallbackInterfaceSendQueueRoomErrorListener(
        onError: { (
            uniffiHandle: UInt64,
            roomId: RustBuffer,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSendQueueRoomErrorListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     roomId: try FfiConverterString.lift(roomId),
                     error: try FfiConverterTypeClientError.lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceSendQueueRoomErrorListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SendQueueRoomErrorListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSendQueueRoomErrorListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(&UniffiCallbackInterfaceSendQueueRoomErrorListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSendQueueRoomErrorListener {
    fileprivate static var handleMap = UniffiHandleMap<SendQueueRoomErrorListener>()
}

extension FfiConverterCallbackInterfaceSendQueueRoomErrorListener : FfiConverter {
    typealias SwiftType = SendQueueRoomErrorListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol SessionVerificationControllerDelegate : AnyObject {
    
    func didReceiveVerificationRequest(details: SessionVerificationRequestDetails) 
    
    func didAcceptVerificationRequest() 
    
    func didStartSasVerification() 
    
    func didReceiveVerificationData(data: SessionVerificationData) 
    
    func didFail() 
    
    func didCancel() 
    
    func didFinish() 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSessionVerificationControllerDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate = UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate(
        didReceiveVerificationRequest: { (
            uniffiHandle: UInt64,
            details: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didReceiveVerificationRequest(
                     details: try FfiConverterTypeSessionVerificationRequestDetails.lift(details)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didAcceptVerificationRequest: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didAcceptVerificationRequest(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didStartSasVerification: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didStartSasVerification(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didReceiveVerificationData: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didReceiveVerificationData(
                     data: try FfiConverterTypeSessionVerificationData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didFail: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didFail(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didCancel: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didCancel(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didFinish: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didFinish(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SessionVerificationControllerDelegate: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSessionVerificationControllerDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(&UniffiCallbackInterfaceSessionVerificationControllerDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSessionVerificationControllerDelegate {
    fileprivate static var handleMap = UniffiHandleMap<SessionVerificationControllerDelegate>()
}

extension FfiConverterCallbackInterfaceSessionVerificationControllerDelegate : FfiConverter {
    typealias SwiftType = SessionVerificationControllerDelegate
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol SyncServiceStateObserver : AnyObject {
    
    func onUpdate(state: SyncServiceState) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncServiceStateObserver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSyncServiceStateObserver = UniffiVTableCallbackInterfaceSyncServiceStateObserver(
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSyncServiceStateObserver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeSyncServiceState.lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceSyncServiceStateObserver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SyncServiceStateObserver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSyncServiceStateObserver() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(&UniffiCallbackInterfaceSyncServiceStateObserver.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSyncServiceStateObserver {
    fileprivate static var handleMap = UniffiHandleMap<SyncServiceStateObserver>()
}

extension FfiConverterCallbackInterfaceSyncServiceStateObserver : FfiConverter {
    typealias SwiftType = SyncServiceStateObserver
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol TimelineListener : AnyObject {
    
    func onUpdate(diff: [TimelineDiff]) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceTimelineListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceTimelineListener = UniffiVTableCallbackInterfaceTimelineListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            diff: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTimelineListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     diff: try FfiConverterSequenceTypeTimelineDiff.lift(diff)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceTimelineListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface TimelineListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitTimelineListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(&UniffiCallbackInterfaceTimelineListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceTimelineListener {
    fileprivate static var handleMap = UniffiHandleMap<TimelineListener>()
}

extension FfiConverterCallbackInterfaceTimelineListener : FfiConverter {
    typealias SwiftType = TimelineListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol TypingNotificationsListener : AnyObject {
    
    func call(typingUserIds: [String]) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceTypingNotificationsListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceTypingNotificationsListener = UniffiVTableCallbackInterfaceTypingNotificationsListener(
        call: { (
            uniffiHandle: UInt64,
            typingUserIds: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTypingNotificationsListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     typingUserIds: try FfiConverterSequenceString.lift(typingUserIds)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceTypingNotificationsListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface TypingNotificationsListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitTypingNotificationsListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(&UniffiCallbackInterfaceTypingNotificationsListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceTypingNotificationsListener {
    fileprivate static var handleMap = UniffiHandleMap<TypingNotificationsListener>()
}

extension FfiConverterCallbackInterfaceTypingNotificationsListener : FfiConverter {
    typealias SwiftType = TypingNotificationsListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol UnableToDecryptDelegate : AnyObject {
    
    func onUtd(info: UnableToDecryptInfo) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceUnableToDecryptDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceUnableToDecryptDelegate = UniffiVTableCallbackInterfaceUnableToDecryptDelegate(
        onUtd: { (
            uniffiHandle: UInt64,
            info: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceUnableToDecryptDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUtd(
                     info: try FfiConverterTypeUnableToDecryptInfo.lift(info)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceUnableToDecryptDelegate.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface UnableToDecryptDelegate: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitUnableToDecryptDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(&UniffiCallbackInterfaceUnableToDecryptDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceUnableToDecryptDelegate {
    fileprivate static var handleMap = UniffiHandleMap<UnableToDecryptDelegate>()
}

extension FfiConverterCallbackInterfaceUnableToDecryptDelegate : FfiConverter {
    typealias SwiftType = UnableToDecryptDelegate
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol VerificationStateListener : AnyObject {
    
    func onUpdate(status: VerificationState) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceVerificationStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceVerificationStateListener = UniffiVTableCallbackInterfaceVerificationStateListener(
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVerificationStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeVerificationState.lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceVerificationStateListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface VerificationStateListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitVerificationStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(&UniffiCallbackInterfaceVerificationStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceVerificationStateListener {
    fileprivate static var handleMap = UniffiHandleMap<VerificationStateListener>()
}

extension FfiConverterCallbackInterfaceVerificationStateListener : FfiConverter {
    typealias SwiftType = VerificationStateListener
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol WidgetCapabilitiesProvider : AnyObject {
    
    func acquireCapabilities(capabilities: WidgetCapabilities)  -> WidgetCapabilities
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceWidgetCapabilitiesProvider {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider = UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider(
        acquireCapabilities: { (
            uniffiHandle: UInt64,
            capabilities: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> WidgetCapabilities in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceWidgetCapabilitiesProvider.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.acquireCapabilities(
                     capabilities: try FfiConverterTypeWidgetCapabilities.lift(capabilities)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeWidgetCapabilities.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceWidgetCapabilitiesProvider.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface WidgetCapabilitiesProvider: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitWidgetCapabilitiesProvider() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(&UniffiCallbackInterfaceWidgetCapabilitiesProvider.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceWidgetCapabilitiesProvider {
    fileprivate static var handleMap = UniffiHandleMap<WidgetCapabilitiesProvider>()
}

extension FfiConverterCallbackInterfaceWidgetCapabilitiesProvider : FfiConverter {
    typealias SwiftType = WidgetCapabilitiesProvider
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDouble: FfiConverterRustBuffer {
    typealias SwiftType = Double?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIdentityResetHandle: FfiConverterRustBuffer {
    typealias SwiftType = IdentityResetHandle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentityResetHandle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentityResetHandle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeInReplyToDetails: FfiConverterRustBuffer {
    typealias SwiftType = InReplyToDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInReplyToDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInReplyToDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMediaSource: FfiConverterRustBuffer {
    typealias SwiftType = MediaSource?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMediaSource.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMediaSource.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = Room?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomMessageEventContentWithoutRelation: FfiConverterRustBuffer {
    typealias SwiftType = RoomMessageEventContentWithoutRelation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomMessageEventContentWithoutRelation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomMessageEventContentWithoutRelation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendHandle: FfiConverterRustBuffer {
    typealias SwiftType = SendHandle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendHandle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendHandle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTaskHandle: FfiConverterRustBuffer {
    typealias SwiftType = TaskHandle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTaskHandle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTaskHandle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimelineEventTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = TimelineEventTypeFilter?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimelineEventTypeFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimelineEventTypeFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserIdentity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserIdentity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAudioInfo: FfiConverterRustBuffer {
    typealias SwiftType = AudioInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAudioInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAudioInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeComposerDraft: FfiConverterRustBuffer {
    typealias SwiftType = ComposerDraft?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeComposerDraft.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeComposerDraft.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeElementCallWellKnown: FfiConverterRustBuffer {
    typealias SwiftType = ElementCallWellKnown?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeElementCallWellKnown.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeElementCallWellKnown.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = EventTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFileInfo: FfiConverterRustBuffer {
    typealias SwiftType = FileInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFileInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFileInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFormattedBody: FfiConverterRustBuffer {
    typealias SwiftType = FormattedBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFormattedBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFormattedBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeImageInfo: FfiConverterRustBuffer {
    typealias SwiftType = ImageInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeInsertData: FfiConverterRustBuffer {
    typealias SwiftType = InsertData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInsertData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInsertData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMatrixEntity: FfiConverterRustBuffer {
    typealias SwiftType = MatrixEntity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMatrixEntity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMatrixEntity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMentions: FfiConverterRustBuffer {
    typealias SwiftType = Mentions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMentions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMentions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNotificationItem: FfiConverterRustBuffer {
    typealias SwiftType = NotificationItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNotificationItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNotificationItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNotificationPowerLevels: FfiConverterRustBuffer {
    typealias SwiftType = NotificationPowerLevels?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNotificationPowerLevels.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNotificationPowerLevels.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePowerLevels: FfiConverterRustBuffer {
    typealias SwiftType = PowerLevels?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePowerLevels.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePowerLevels.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeResolvedRoomAlias: FfiConverterRustBuffer {
    typealias SwiftType = ResolvedRoomAlias?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeResolvedRoomAlias.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeResolvedRoomAlias.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = RoomMember?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomMember.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomMember.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSetData: FfiConverterRustBuffer {
    typealias SwiftType = SetData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSetData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSetData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeThumbnailInfo: FfiConverterRustBuffer {
    typealias SwiftType = ThumbnailInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeThumbnailInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeThumbnailInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTracingFileConfiguration: FfiConverterRustBuffer {
    typealias SwiftType = TracingFileConfiguration?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTracingFileConfiguration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTracingFileConfiguration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUnstableAudioDetailsContent: FfiConverterRustBuffer {
    typealias SwiftType = UnstableAudioDetailsContent?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUnstableAudioDetailsContent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUnstableAudioDetailsContent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUnstableVoiceContent: FfiConverterRustBuffer {
    typealias SwiftType = UnstableVoiceContent?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUnstableVoiceContent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUnstableVoiceContent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVideoInfo: FfiConverterRustBuffer {
    typealias SwiftType = VideoInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVideoInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVideoInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAccountManagementAction: FfiConverterRustBuffer {
    typealias SwiftType = AccountManagementAction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAccountManagementAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAccountManagementAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAssetType: FfiConverterRustBuffer {
    typealias SwiftType = AssetType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAssetType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAssetType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAuthData: FfiConverterRustBuffer {
    typealias SwiftType = AuthData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAuthData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAuthData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventSendState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventSendState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeJoinRule: FfiConverterRustBuffer {
    typealias SwiftType = JoinRule?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJoinRule.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJoinRule.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = Membership?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMembership.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMembership.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMembershipChange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMembershipChange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePublicRoomJoinRule: FfiConverterRustBuffer {
    typealias SwiftType = PublicRoomJoinRule?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublicRoomJoinRule.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublicRoomJoinRule.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePushFormat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePushFormat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomNotificationMode: FfiConverterRustBuffer {
    typealias SwiftType = RoomNotificationMode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomNotificationMode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomNotificationMode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeShieldState: FfiConverterRustBuffer {
    typealias SwiftType = ShieldState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeShieldState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeShieldState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVirtualTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVirtualTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceBackupSteadyStateListener: FfiConverterRustBuffer {
    typealias SwiftType = BackupSteadyStateListener?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceBackupSteadyStateListener.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceBackupSteadyStateListener.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceClientDelegate: FfiConverterRustBuffer {
    typealias SwiftType = ClientDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceClientDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceClientDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceNotificationSettingsDelegate: FfiConverterRustBuffer {
    typealias SwiftType = NotificationSettingsDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceNotificationSettingsDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceNotificationSettingsDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceProgressWatcher: FfiConverterRustBuffer {
    typealias SwiftType = ProgressWatcher?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceProgressWatcher.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceProgressWatcher.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate: FfiConverterRustBuffer {
    typealias SwiftType = SessionVerificationControllerDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeRoomHero: FfiConverterRustBuffer {
    typealias SwiftType = [RoomHero]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRoomHero.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRoomHero.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMember]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRoomMember.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRoomMember.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringInt64: FfiConverterRustBuffer {
    typealias SwiftType = [String: Int64]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventItemOrigin: FfiConverterRustBuffer {
    typealias SwiftType = EventItemOrigin?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventItemOrigin.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventItemOrigin.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]

    public static func write(_ value: [UInt16], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt16.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt16]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt16.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = [Room]

    public static func write(_ value: [Room], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Room] {
        let len: Int32 = try readInt(&buf)
        var seq = [Room]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoom.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomListItem: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListItem]

    public static func write(_ value: [RoomListItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSessionVerificationEmoji: FfiConverterRustBuffer {
    typealias SwiftType = [SessionVerificationEmoji]

    public static func write(_ value: [SessionVerificationEmoji], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSessionVerificationEmoji.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SessionVerificationEmoji] {
        let len: Int32 = try readInt(&buf)
        var seq = [SessionVerificationEmoji]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSessionVerificationEmoji.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTimelineDiff: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineDiff]

    public static func write(_ value: [TimelineDiff], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTimelineDiff.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineDiff] {
        let len: Int32 = try readInt(&buf)
        var seq = [TimelineDiff]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTimelineDiff.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]

    public static func write(_ value: [TimelineItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTimelineItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [TimelineItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTimelineItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeIdentityStatusChange: FfiConverterRustBuffer {
    typealias SwiftType = [IdentityStatusChange]

    public static func write(_ value: [IdentityStatusChange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentityStatusChange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentityStatusChange] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentityStatusChange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIdentityStatusChange.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeKnockRequest: FfiConverterRustBuffer {
    typealias SwiftType = [KnockRequest]

    public static func write(_ value: [KnockRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKnockRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [KnockRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [KnockRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKnockRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePollAnswer: FfiConverterRustBuffer {
    typealias SwiftType = [PollAnswer]

    public static func write(_ value: [PollAnswer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePollAnswer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PollAnswer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PollAnswer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePollAnswer.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]

    public static func write(_ value: [Reaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Reaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Reaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReaction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReactionSenderData: FfiConverterRustBuffer {
    typealias SwiftType = [ReactionSenderData]

    public static func write(_ value: [ReactionSenderData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReactionSenderData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReactionSenderData] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReactionSenderData]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReactionSenderData.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomDescription: FfiConverterRustBuffer {
    typealias SwiftType = [RoomDescription]

    public static func write(_ value: [RoomDescription], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomDescription.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomDescription] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomDescription]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomDescription.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomHero: FfiConverterRustBuffer {
    typealias SwiftType = [RoomHero]

    public static func write(_ value: [RoomHero], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomHero.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomHero] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomHero]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomHero.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMember]

    public static func write(_ value: [RoomMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomMember.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserPowerLevelUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [UserPowerLevelUpdate]

    public static func write(_ value: [UserPowerLevelUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserPowerLevelUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserPowerLevelUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserPowerLevelUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserPowerLevelUpdate.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserProfile: FfiConverterRustBuffer {
    typealias SwiftType = [UserProfile]

    public static func write(_ value: [UserProfile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserProfile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserProfile] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserProfile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserProfile.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAllowRule: FfiConverterRustBuffer {
    typealias SwiftType = [AllowRule]

    public static func write(_ value: [AllowRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAllowRule.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AllowRule] {
        let len: Int32 = try readInt(&buf)
        var seq = [AllowRule]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAllowRule.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFilterTimelineEventType: FfiConverterRustBuffer {
    typealias SwiftType = [FilterTimelineEventType]

    public static func write(_ value: [FilterTimelineEventType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFilterTimelineEventType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FilterTimelineEventType] {
        let len: Int32 = try readInt(&buf)
        var seq = [FilterTimelineEventType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFilterTimelineEventType.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = [Membership]

    public static func write(_ value: [Membership], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMembership.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Membership] {
        let len: Int32 = try readInt(&buf)
        var seq = [Membership]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMembership.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOidcPrompt: FfiConverterRustBuffer {
    typealias SwiftType = [OidcPrompt]

    public static func write(_ value: [OidcPrompt], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOidcPrompt.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OidcPrompt] {
        let len: Int32 = try readInt(&buf)
        var seq = [OidcPrompt]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOidcPrompt.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [RoomDirectorySearchEntryUpdate]

    public static func write(_ value: [RoomDirectorySearchEntryUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomDirectorySearchEntryUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomDirectorySearchEntryUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomDirectorySearchEntryUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomDirectorySearchEntryUpdate.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListEntriesDynamicFilterKind]

    public static func write(_ value: [RoomListEntriesDynamicFilterKind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListEntriesDynamicFilterKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListEntriesDynamicFilterKind] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListEntriesDynamicFilterKind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListEntriesDynamicFilterKind.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomListEntriesUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListEntriesUpdate]

    public static func write(_ value: [RoomListEntriesUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListEntriesUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListEntriesUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListEntriesUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListEntriesUpdate.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomMessageEventMessageType: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMessageEventMessageType]

    public static func write(_ value: [RoomMessageEventMessageType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomMessageEventMessageType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomMessageEventMessageType] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomMessageEventMessageType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomMessageEventMessageType.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSlidingSyncVersion: FfiConverterRustBuffer {
    typealias SwiftType = [SlidingSyncVersion]

    public static func write(_ value: [SlidingSyncVersion], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSlidingSyncVersion.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SlidingSyncVersion] {
        let len: Int32 = try readInt(&buf)
        var seq = [SlidingSyncVersion]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSlidingSyncVersion.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeWidgetEventFilter: FfiConverterRustBuffer {
    typealias SwiftType = [WidgetEventFilter]

    public static func write(_ value: [WidgetEventFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWidgetEventFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WidgetEventFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [WidgetEventFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWidgetEventFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringInt32: FfiConverterRustBuffer {
    public static func write(_ value: [String: Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterInt32.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Int32] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Int32]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterInt32.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringInt64: FfiConverterRustBuffer {
    public static func write(_ value: [String: Int64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Int64] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Int64]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeReceipt: FfiConverterRustBuffer {
    public static func write(_ value: [String: Receipt], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeReceipt.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Receipt] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Receipt]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeReceipt.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
























private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
/**
 * Creates a [`RoomMessageEventContentWithoutRelation`] given a
 * [`MessageContent`] value.
 */
public func contentWithoutRelationFromMessage(message: MessageContent)throws  -> RoomMessageEventContentWithoutRelation {
    return try  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(
        FfiConverterTypeMessageContent.lower(message),$0
    )
})
}
/**
 * Create a caption edit.
 *
 * If no `formatted_caption` is provided, then it's assumed the `caption`
 * represents valid Markdown that can be used as the formatted caption.
 */
public func createCaptionEdit(caption: String?, formattedCaption: FormattedBody?) -> EditedContent {
    return try!  FfiConverterTypeEditedContent.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(
        FfiConverterOptionString.lower(caption),
        FfiConverterOptionTypeFormattedBody.lower(formattedCaption),$0
    )
})
}
public func genTransactionId() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id($0
    )
})
}
/**
 * Create the actual url that can be used to setup the WebView or IFrame
 * that contains the widget.
 *
 * # Arguments
 * * `widget_settings` - The widget settings to generate the url for.
 * * `room` - A matrix room which is used to query the logged in username
 * * `props` - Properties from the client that can be used by a widget to adapt
 * to the client. e.g. language, font-scale...
 */
public func generateWebviewUrl(widgetSettings: WidgetSettings, room: Room, props: ClientProperties)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(FfiConverterTypeWidgetSettings.lower(widgetSettings),FfiConverterTypeRoom.lower(room),FfiConverterTypeClientProperties.lower(props)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeParseError.lift
        )
}
/**
 * The Capabilities required to run a element call widget.
 *
 * This is intended to be used in combination with: `acquire_capabilities` of
 * the `CapabilitiesProvider`.
 *
 * `acquire_capabilities` can simply return the `WidgetCapabilities` from this
 * function. Even if there are non intersecting permissions to what the widget
 * requested.
 *
 * Editing and extending the capabilities from this function is also possible,
 * but should only be done as temporal workarounds until this function is
 * adjusted
 */
public func getElementCallRequiredPermissions(ownUserId: String, ownDeviceId: String) -> WidgetCapabilities {
    return try!  FfiConverterTypeWidgetCapabilities.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(
        FfiConverterString.lower(ownUserId),
        FfiConverterString.lower(ownDeviceId),$0
    )
})
}
/**
 * Verifies the passed `String` matches the expected room alias format:
 *
 * This means it's lowercase, with no whitespace chars, has a single leading
 * `#` char and a single `:` separator between the local and domain parts, and
 * the local part only contains characters that can't be percent encoded.
 */
public func isRoomAliasFormatValid(alias: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(
        FfiConverterString.lower(alias),$0
    )
})
}
/**
 * Log an event.
 *
 * The target should be something like a module path, and can be referenced in
 * the filter string given to `setup_tracing`. `level` and `target` for a
 * callsite are fixed at the first `log_event` call for that callsite and can
 * not be changed afterwards, i.e. the level and target passed for second and
 * following `log_event`s with the same callsite will be ignored.
 *
 * This function leaks a little bit of memory for each unique (file + line +
 * level + target) it is called with. Please make sure that the number of
 * different combinations of those parameters this can be called with is
 * constant in the final executable.
 */
public func logEvent(file: String, line: UInt32?, level: LogLevel, target: String, message: String) {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_log_event(
        FfiConverterString.lower(file),
        FfiConverterOptionUInt32.lower(line),
        FfiConverterTypeLogLevel.lower(level),
        FfiConverterString.lower(target),
        FfiConverterString.lower(message),$0
    )
}
}
/**
 * Helper function to parse a string into a ElementWellKnown struct
 */
public func makeElementWellKnown(string: String)throws  -> ElementWellKnown {
    return try  FfiConverterTypeElementWellKnown.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_func_make_element_well_known(
        FfiConverterString.lower(string),$0
    )
})
}
public func makeWidgetDriver(settings: WidgetSettings)throws  -> WidgetDriverAndHandle {
    return try  FfiConverterTypeWidgetDriverAndHandle.lift(try rustCallWithError(FfiConverterTypeParseError.lift) {
    uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(
        FfiConverterTypeWidgetSettings.lower(settings),$0
    )
})
}
/**
 * Generates a `matrix.to` permalink to the given room alias.
 */
public func matrixToRoomAliasPermalink(roomAlias: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(
        FfiConverterString.lower(roomAlias),$0
    )
})
}
/**
 * Generates a `matrix.to` permalink to the given userID.
 */
public func matrixToUserPermalink(userId: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(
        FfiConverterString.lower(userId),$0
    )
})
}
public func messageEventContentFromHtml(body: String, htmlBody: String) -> RoomMessageEventContentWithoutRelation {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(
        FfiConverterString.lower(body),
        FfiConverterString.lower(htmlBody),$0
    )
})
}
public func messageEventContentFromHtmlAsEmote(body: String, htmlBody: String) -> RoomMessageEventContentWithoutRelation {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(
        FfiConverterString.lower(body),
        FfiConverterString.lower(htmlBody),$0
    )
})
}
public func messageEventContentFromMarkdown(md: String) -> RoomMessageEventContentWithoutRelation {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
        FfiConverterString.lower(md),$0
    )
})
}
public func messageEventContentFromMarkdownAsEmote(md: String) -> RoomMessageEventContentWithoutRelation {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(
        FfiConverterString.lower(md),$0
    )
})
}
public func messageEventContentNew(msgtype: MessageType)throws  -> RoomMessageEventContentWithoutRelation {
    return try  FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(
        FfiConverterTypeMessageType.lower(msgtype),$0
    )
})
}
/**
 * `WidgetSettings` are usually created from a state event.
 * (currently unimplemented)
 *
 * In some cases the client wants to create custom `WidgetSettings`
 * for specific rooms based on other conditions.
 * This function returns a `WidgetSettings` object which can be used
 * to setup a widget using `run_client_widget_api`
 * and to generate the correct url for the widget.
 *
 * # Arguments
 *
 * * `props` - A struct containing the configuration parameters for a element
 * call widget.
 */
public func newVirtualElementCallWidget(props: VirtualElementCallWidgetOptions)throws  -> WidgetSettings {
    return try  FfiConverterTypeWidgetSettings.lift(try rustCallWithError(FfiConverterTypeParseError.lift) {
    uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(
        FfiConverterTypeVirtualElementCallWidgetOptions.lower(props),$0
    )
})
}
/**
 * Parse a matrix entity from a given URI, be it either
 * a `matrix.to` link or a `matrix:` URI
 */
public func parseMatrixEntityFrom(uri: String) -> MatrixEntity? {
    return try!  FfiConverterOptionTypeMatrixEntity.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(
        FfiConverterString.lower(uri),$0
    )
})
}
/**
 * Transforms a Room's display name into a valid room alias name.
 */
public func roomAliasNameFromRoomDisplayName(roomName: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(
        FfiConverterString.lower(roomName),$0
    )
})
}
public func sdkGitSha() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha($0
    )
})
}
public func setupTracing(config: TracingConfiguration) {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_setup_tracing(
        FfiConverterTypeTracingConfiguration.lower(config),$0
    )
}
}
public func suggestedPowerLevelForRole(role: RoomMemberRole) -> Int64 {
    return try!  FfiConverterInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(
        FfiConverterTypeRoomMemberRole_lower(role),$0
    )
})
}
public func suggestedRoleForPowerLevel(powerLevel: Int64) -> RoomMemberRole {
    return try!  FfiConverterTypeRoomMemberRole_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(
        FfiConverterInt64.lower(powerLevel),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_matrix_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message() != 1366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit() != 49747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id() != 15808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url() != 6844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions() != 30181) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid() != 54845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_log_event() != 62286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known() != 21379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver() != 34206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink() != 13776) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink() != 46473) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html() != 37203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote() != 8938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown() != 58385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote() != 20152) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new() != 57839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget() != 4988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from() != 49710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name() != 65010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha() != 4038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_setup_tracing() != 45018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role() != 61777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level() != 48532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions() != 8867) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth() != 6754) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_account_data() != 50433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_account_url() != 42373) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions() != 35296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url() != 27867) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo() != 18126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url() != 58990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account() != 39890) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_create_room() != 52700) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_create_room_alias() != 54261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt() != 19710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account() != 20658) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher() != 45990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_device_id() != 44340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_display_name() != 56259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues() != 30834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_encryption() != 9657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room() != 5137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content() != 40308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file() != 52604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail() != 52601) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings() != 6359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_profile() != 60062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms() != 22399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias() != 7674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id() != 36348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller() != 55934) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_url() != 50489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_homeserver() != 26427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details() != 63487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user() != 14588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users() != 49620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available() != 23322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id() != 64032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias() != 18521) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_knock() != 48652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_login() != 33276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email() != 11789) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback() != 35005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_logout() != 7576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_notification_client() != 37308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar() != 29033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities() != 39651) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias() != 3551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_restore_session() != 40455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists() != 20359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search() != 39855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_rooms() != 29558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_search_users() != 42927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_server() != 63276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_session() != 8085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data() != 18256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate() != 59796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name() != 15292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher() != 41975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version() != 4957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login() != 34571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users() != 23285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status() != 57403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_sync_service() != 52812) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room() != 56986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user() != 8489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar() != 64486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_upload_media() != 51195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc() != 30079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_user_id() != 40531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name() != 57725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates() != 14763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups() != 44502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing() != 37167) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy() != 11959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build() != 56018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code() != 51905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name() != 46627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh() != 43839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates() != 47525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification() != 2334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock() != 42214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url() != 28347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_passphrase() != 14286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy() != 5659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config() != 58783) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement() != 2776) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy() != 41183) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name() != 29096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url() != 30022) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths() != 54230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate() != 8576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder() != 39381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_use_event_cache_persistent_storage() != 58836) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent() != 13719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username() != 45302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server() != 45490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state() != 51049) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener() != 14246) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key() != 58425) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery() != 18699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key() != 11864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups() != 55446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery() != 64351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device() != 27955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_recover() != 33712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset() != 12902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state() != 54051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener() != 36612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity() != 13780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key() != 20380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity() != 20644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state() != 29114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener() != 59806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state() != 37503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks() != 41585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version() != 36573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts() != 63396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login() != 46090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login() != 33501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url() != 61326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type() != 43501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel() != 57622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset() != 11997) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event() != 51792) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id() != 5876) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept() != 25656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline() != 65054) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban() != 26242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen() != 36036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info() != 55450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle() != 46057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields() != 12518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path() != 16357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist() != 12883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json() != 23306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediasource_url() != 62692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification() != 2524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device() != 37323) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device() != 21251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules() != 60025) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode() != 36211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings() != 55295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules() != 19849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode() != 18228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled() != 12210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled() != 533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled() != 13304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled() != 49857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode() != 35399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled() != 16823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode() != 9426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate() != 57636) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled() != 11988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled() != 31650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode() != 4135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled() != 56594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room() != 47580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count() != 61905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants() != 41533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases() != 28555) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes() != 44206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url() != 34637) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_ban_user() != 35046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban() != 64711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite() != 62459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick() != 12773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin() != 8341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other() != 13274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own() != 57442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message() != 36743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state() != 19062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification() != 18832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias() != 19786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft() != 39667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage() != 13838) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key() != 18081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_display_name() != 64194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_edit() != 61956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue() != 23914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels() != 54094) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call() != 33588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_heroes() != 22313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_id() != 61990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend() != 39984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user() != 62239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id() != 41133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count() != 1023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_inviter() != 49874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_direct() != 16947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted() != 55158) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_public() != 7336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled() != 36591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_space() != 16919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned() != 49186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_join() != 9240) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count() != 55835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_kick_user() != 28600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_leave() != 63688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft() != 38115) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read() != 16004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink() != 36705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink() != 47781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member() != 48980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url() != 29492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name() != 33206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_members() != 42691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync() != 3255) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_membership() != 26065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_message_filtered_timeline() != 32258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id() != 39510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_pinned_events_timeline() != 29596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_raw_name() != 15453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_redact() != 45810) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar() != 7230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_report_content() != 16529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels() != 63622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string() != 37832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_room_info() != 41146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft() != 62232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification() != 43366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed() != 53551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_raw() != 20486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite() != 64403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority() != 48070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_name() != 52127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_topic() != 5576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag() != 2381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes() != 14290) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests() != 30649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates() != 48209) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications() != 38524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user() != 47787) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_timeline() != 701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_timeline_focused_on_event() != 27319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_topic() != 59745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice() != 28642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_unban_user() != 1803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users() != 52057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar() != 19069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend() != 33485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page() != 34221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages() != 2923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page() != 29305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results() != 30207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search() != 24438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters() != 36097) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state() != 21585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_room() != 8801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page() != 47748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page() != 61352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter() != 61202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller() != 36258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream() != 56632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_avatar_url() != 39097) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_canonical_alias() != 63300) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_display_name() != 8651) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_full_room() != 17298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_id() != 41176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_init_timeline() != 61817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_invited_room() != 44344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_direct() != 46873) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_encrypted() != 65150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_is_timeline_initialized() != 46855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_latest_event() != 38259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_membership() != 1596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_preview_room() != 32277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistitem_room_info() != 32985) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms() != 49704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room() != 5185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state() != 64650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms() != 59765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator() != 16821) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len() != 39835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk() != 23186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompreview_info() != 9145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter() != 1297) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave() != 5096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel() != 62384) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join() != 1903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort() != 11570) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend() != 28691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request() != 53466) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request() != 37982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification() != 27140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification() != 32994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification() != 64345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_verification() != 17229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate() != 42324) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification() != 16328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description() != 21346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol() != 46075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_enter() != 8900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_exit() != 47924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_is_none() != 33327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish() != 64706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url() != 10889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service() != 26426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_start() != 16010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_state() != 61806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop() != 23138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish() != 22814) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock() != 56326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_utd_hook() != 9029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel() != 9124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished() != 29008) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener() != 18746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content() != 21811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll() != 37925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_edit() != 42189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll() != 61329) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event() != 54068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members() != 37994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_focused_paginate_forwards() != 51003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id() != 33999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details() != 54225) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read() != 16621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards() != 65175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event() != 41687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event() != 48707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption() != 21112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send() != 9553) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio() != 43163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file() != 37925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image() != 45681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location() != 47400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response() != 7453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt() != 37532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply() != 64747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video() != 22670) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message() != 58509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status() != 46161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction() != 29303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event() != 52414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append() != 8453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change() != 4562) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert() != 26630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back() != 53464) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front() != 42084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove() != 74) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset() != 34118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set() != 13334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate() != 34040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id() != 11088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type() != 12922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id() != 18142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp() != 58123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event() != 6106) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual() != 50960) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug() != 38094) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id() != 39945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications() != 33024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count() != 35997) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count() != 35655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified() != 61954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key() != 4041) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin() != 62925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run() != 7519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv() != 2662) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send() != 18689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new() != 27991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json() != 10564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url() != 11983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes() != 32675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_span_current() != 53698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_span_new() != 14105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude() != 53805) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include() != 25498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update() != 12849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update() != 41052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error() != 26350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_refresh_tokens() != 16325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain() != 43954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain() != 53223) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update() != 13538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call() != 57311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call() != 47519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call() != 10077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change() != 51708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update() != 29884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress() != 41133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update() != 9758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update() != 64575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update() != 41968) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call() != 44934) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update() != 12576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update() != 23169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update() != 24823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update() != 36937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error() != 38224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request() != 3417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request() != 3733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification() != 56833) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data() != 30840) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail() != 32164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel() != 3367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish() != 37905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update() != 62231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update() != 30147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call() != 64299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd() != 61791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update() != 38998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities() != 12846) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitBackupStateListener()
    uniffiCallbackInitBackupSteadyStateListener()
    uniffiCallbackInitClientDelegate()
    uniffiCallbackInitClientSessionDelegate()
    uniffiCallbackInitEnableRecoveryProgressListener()
    uniffiCallbackInitIdentityStatusChangeListener()
    uniffiCallbackInitIgnoredUsersListener()
    uniffiCallbackInitKnockRequestsListener()
    uniffiCallbackInitNotificationSettingsDelegate()
    uniffiCallbackInitPaginationStatusListener()
    uniffiCallbackInitProgressWatcher()
    uniffiCallbackInitQrLoginProgressListener()
    uniffiCallbackInitRecoveryStateListener()
    uniffiCallbackInitRoomDirectorySearchEntriesListener()
    uniffiCallbackInitRoomInfoListener()
    uniffiCallbackInitRoomListEntriesListener()
    uniffiCallbackInitRoomListLoadingStateListener()
    uniffiCallbackInitRoomListServiceStateListener()
    uniffiCallbackInitRoomListServiceSyncIndicatorListener()
    uniffiCallbackInitSendQueueRoomErrorListener()
    uniffiCallbackInitSessionVerificationControllerDelegate()
    uniffiCallbackInitSyncServiceStateObserver()
    uniffiCallbackInitTimelineListener()
    uniffiCallbackInitTypingNotificationsListener()
    uniffiCallbackInitUnableToDecryptDelegate()
    uniffiCallbackInitVerificationStateListener()
    uniffiCallbackInitWidgetCapabilitiesProvider()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all